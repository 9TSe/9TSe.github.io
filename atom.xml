<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>9TSe</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-10-28T01:30:56.601Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>9TSe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git</title>
    <link href="http://example.com/2023/10/27/Git/"/>
    <id>http://example.com/2023/10/27/Git/</id>
    <published>2023-10-27T10:46:57.000Z</published>
    <updated>2023-10-28T01:30:56.601Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-1-Git-简易指南"><a href="#1-1-Git-简易指南" class="headerlink" title="1.1 Git 简易指南"></a>1.1 Git 简易指南</h1><p><img src="/img/git1.png"></p><h2 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h2><p>创建新文件夹，打开，然后执行 <code>git init</code> 以创建新的 git 仓库。</p><blockquote><p>下面每一步中，你都可以通过 <code>git status</code> 来查看你的git仓库状态。</p></blockquote><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>你的本地仓库由 Git 维护的三棵「树」组成。<br>第一个是你的 <code>工作目录</code>，它持有实际文件；<br>第二个是 <code>缓存区（Index）</code>，它像个缓存区域，临时保存你的改动；<br>最后是 <code>HEAD</code>，指向你最近一次提交后的结果。</p><blockquote><p>事实上，第三个阶段是 commit history 的图。HEAD 一般是指向最新一次 commit 的引用。现在暂时不必究其细节。</p></blockquote><h2 id="添加与提交"><a href="#添加与提交" class="headerlink" title="添加与提交"></a>添加与提交</h2><p>你可以计划改动（把它们添加到缓存区），使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt; filename &gt;</span><br><span class="line">git add *</span><br></pre></td></tr></table></figure><p>这是 Git 基本工作流程的第一步。使用如下命令以实际提交改动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;代码提交信息&quot;</span><br></pre></td></tr></table></figure><p>现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。</p><blockquote><p>在开发时，良好的习惯是根据工作进度及时 commit，并务必注意附上有意义的 commit message。创建完项目目录后，第一次提交的 commit message 一般为「Initial commit」。</p></blockquote><h2 id="推送改动"><a href="#推送改动" class="headerlink" title="推送改动"></a>推送改动</h2><p>你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>可以把 master 换成你想要推送的任何分支。</p><p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;server&gt;</span><br></pre></td></tr></table></figure><p>如此你就能够将你的改动推送到所添加的服务器上去了。</p><blockquote><p>这里 origin 是 &lt;server&gt; 的别名，取什么名字都可以，也可以在 push 时将 &lt;jserver&gt; 替换为 origin。但为了以后 push 方便，我们第一次一般都会先 remote add。<br>如果你还没有 Git 仓库，可以在 Github 等代码托管平台上创建一个空（不要自动生成 README.md）的仓库，然后将代码 push 到远端仓库。</p></blockquote><hr><h1 id="1-2-创建代码仓库"><a href="#1-2-创建代码仓库" class="headerlink" title="1.2 创建代码仓库"></a>1.2 创建代码仓库</h1><p>这一章简要地带你了解一些最重要的 Git 命令。在这节中，介绍开始一个新的版本控制项目需要的所有工具，后面的包含了每天都会用到的Git操作。</p><p>在这节之后，你应该能够创建一个新的 Git 仓库，缓存你的项目以免丢失，以及查看你项目的历史。</p><h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p><code>git init</code> 命令创建一个新的 Git 仓库。它用来将已存在但还没有版本控制的项目转换成一个 Git 仓库，或者创建一个空的新仓库。大多数Git命令在未初始化的仓库中都是无法使用的，所以这就是你运行新项目的第一个命令了。</p><p>运行 <code>git init</code> 命令会在你项目的根目录下创建一个新的 <code>.git</code> 目录，其中包含了你项目必需的所有元数据。除了 <code>.git</code> 目录之外，已经存在的项目不会被改变（就像 SVN 一样，Git 不强制每个子目录中都有一个 <code>.git</code> 目录）。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>将当前的目录转换成一个 Git 仓库。它在当前的目录下增加了一个 <code>.git</code> 目录，于是就可以开始记录项目版本了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init &lt;directory&gt;</span><br></pre></td></tr></table></figure><p>在指定目录创建一个空的 Git 仓库。运行这个命令会创建一个名为 <code>directory</code>，只包含 <code>.git</code> 子目录的空目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init --bare &lt;directory&gt;</span><br></pre></td></tr></table></figure><p>初始化一个裸的 Git 仓库，但是忽略工作目录。共享的仓库应该总是用 <code>--bare</code> 标记创建（见下面的讨论）。一般来说，用 <code>—bare</code> 标记初始化的仓库以 <code>.git</code> 结尾。比如，一个叫<code>my-project</code>的仓库，它的空版本应该保存在 <code>my-project.git</code> 目录下。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>和 SVN 相比，<code>git init</code> 命令是一个创建新的版本控制项目非常简单的途径。Git 不需要你创建仓库，导入文件，检查正在修改的拷贝。你只需要 <code>cd</code> 到你的项目目录下，运行 <code>git init</code>，你就有了一个功能强大的 Git 仓库。</p><p>但是，对大多数项目来说，<code>git init</code> 只需要在创建中央仓库时执行一次——开发者通常不会使用 <code>git init</code> 来创建他们的本地仓库。他们往往使用 <code>git clone</code> 来将已存在的仓库拷贝到他们的机器中去。</p><h4 id="裸仓库"><a href="#裸仓库" class="headerlink" title="裸仓库"></a>裸仓库</h4><p><code>-—bare</code> 标记创建了一个没有工作目录的仓库，这样我们在仓库中更改文件并且提交了。中央仓库应该总是创建成裸仓库，因为向非裸仓库推送分支有可能会覆盖已有的代码变动。将<code>-—bare</code>看成是用来将仓库标记为储存设施，而不是一个开发环境。也就是说，对于所有的 Git 工作流，中央仓库是裸仓库，开发者的本地仓库是非裸仓库。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>因为 <code>git clone</code> 创建项目的本地拷贝更为方便，<code>git init</code> 最常见的使用情景就是用于创建中央仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh &lt;user&gt;@&lt;host&gt;</span><br><span class="line"></span><br><span class="line">cd path/above/repo</span><br><span class="line"></span><br><span class="line">git init --bare my-project.git</span><br></pre></td></tr></table></figure><p>首先，你用SSH连入存放中央仓库的服务器。然后，来到任何你想存放项目的地方，最后，使用 <code>-—bare</code> 标记来创建一个中央存储仓库。开发者会将 <code>my-project.git</code> 克隆到本地的开发环境中。</p><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p><code>git clone</code> 命令拷贝整个 Git 仓库。这个命令就像 <code>svn checkout</code> 一样，除了「工作副本」是一个完备的Git仓库——它包含自己的历史，管理自己的文件，以及环境和原仓库完全隔离。</p><p>为了方便起见，<code>clone</code> 自动创建了一个名为 <code>origin</code> 的远程连接，指向原有仓库。这让和中央仓库之间的交互更加简单。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt;</span><br></pre></td></tr></table></figure><p>将位于 <code>&lt;repo&gt;</code> 的仓库克隆到本地机器。原仓库可以在本地文件系统中，或是通过 HTTP 或 SSH 连接的远程机器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure><p>将位于 <code>&lt;repo&gt;</code> 的仓库克隆到本地机器上的 <code>&lt;directory&gt;</code> 目录。</p><h3 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h3><p>如果项目在远程仓库已经设置完毕，<code>git clone</code> 是用户获取开发副本最常见的方式。和  <code>git init</code>相似，<code>clone</code> 通常也是一次性的操作——只要开发者获得了一份工作副本，所有版本控制操作和协作管理都是在本地仓库中完成的。</p><h4 id="仓库间协作"><a href="#仓库间协作" class="headerlink" title="仓库间协作"></a>仓库间协作</h4><p>这一点很重要，你要理解 Git 中「工作副本」的概念和 SVN 仓库 check out 下来的「工作副本」是很不一样的。和 SVN 不同的是，Git 不会区分工作副本和中央仓库——它们都是功能完备的 Git 仓库。</p><p>这就使得 Git 的协作和 SVN 截然不同。SVN 依赖于中央仓库和工作副本之间的关系，而 Git 协作模型是基于仓库和仓库之间的交互的。相对于 SVN 的提交流程，你可以在 Git 仓库之间 <code>push</code> 或 <code>pull</code> 提交。</p><p>当然，你也完全可以给予某个特定的仓库一些特殊的含义。比如，指定某个 Git 仓库为中央仓库，你就可以用 Git 进行中央化的工作流。重点是，这是通过约定实现的，而不是写死在版本控制系统本身。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>下面这个例子演示用 SSH 用户名 john 连接到 example.com，获取远程服务器上中央仓库的本地副本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone ssh://john@example.com/path/to/my-project.git</span><br><span class="line"></span><br><span class="line">cd my-project</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始工作</span></span><br></pre></td></tr></table></figure><p>第一行命令在本地机器的 <code>my-project</code> 目录下初始化了一个新的 Git 仓库，并且导入了中央仓库中的文件。接下来，你 <code>cd</code> 到项目目录，开始编辑文件、缓存提交、和其它仓库交互。同时注意 <code>.git</code> 拓展名克隆时会被去除。它表明了本地副本的非裸状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config</span><br></pre></td></tr></table></figure><p><code>git config</code> 命令允许你在命令行中配置你的 Git 安装（或是一个独立仓库）。这个命令定义了所有配置，从用户信息到仓库行为等等。一些常见的配置命令如下所列。</p><h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &lt;name&gt;</span><br></pre></td></tr></table></figure><p>定义当前仓库所有提交使用的作者姓名。通常来说，你希望使用 <code>--global</code> 标记设置当前用户的配置项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &lt;name&gt;</span><br></pre></td></tr></table></figure><p>定义当前用户所有提交使用的作者姓名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &lt;email&gt;</span><br></pre></td></tr></table></figure><p>定义当前用户所有提交使用的作者邮箱。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.&lt;alias-name&gt; &lt;git-command&gt;</span><br></pre></td></tr></table></figure><p>为Git命令创建一个快捷方式（别名）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system core.editor &lt;editor&gt;</span><br></pre></td></tr></table></figure><p>定义当前机器所有用户使用命令时用到的文本编辑器，如 <code>git commit</code>。<code>&lt;editor&gt;</code> 参数用编辑器的启动命令（如 vi）替代。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --edit</span><br></pre></td></tr></table></figure><p>用文本编辑器打开全局配置文件，手动编辑。</p><h3 id="讨论-2"><a href="#讨论-2" class="headerlink" title="讨论"></a>讨论</h3><p>所有配置项都储存在纯文本文件中，所以 <code>git config</code> 命令其实只是一个提供便捷的命令行接口。通常，你只需要在新机器上配置一次 Git 安装，以及，你通常会想要使用 <code>--global</code> 标记。</p><p>Git 将配置项保存在三个单独的文件中，允许你分别对单个仓库、用户和整个系统设置。</p><ul><li><p><repo>&#x2F;.git&#x2F;config – 特定仓库的设置。</p></li><li><p>~&#x2F;.gitconfig – 特定用户的设置。这也是 <code>--global</code> 标记的设置项存放的位置。</p></li><li><p>$(prefix)&#x2F;etc&#x2F;gitconfig – 系统层面的设置。</p></li></ul><p>当这些文件中的配置项冲突时，本地仓库设置覆盖用户设置，用户设置覆盖系统设置。如果你打开期中一份文件，你会看到下面这些：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line"></span><br><span class="line">name = John Smith</span><br><span class="line"></span><br><span class="line">email = john@example.com</span><br><span class="line"></span><br><span class="line">[alias]</span><br><span class="line"></span><br><span class="line">st = status</span><br><span class="line"></span><br><span class="line">co = checkout</span><br><span class="line"></span><br><span class="line">br = branch</span><br><span class="line"></span><br><span class="line">up = rebase</span><br><span class="line"></span><br><span class="line">ci = commit</span><br><span class="line"></span><br><span class="line">[core]</span><br><span class="line"></span><br><span class="line">editor = vim</span><br></pre></td></tr></table></figure><p>你可以用 <code>git config</code> 手动编辑这些值。</p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><p>你在安装 Git 之后想要做的第一件事是告诉它你的名字和邮箱，个性化一些默认设置。一般初始的设置过程看上去是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">告诉Git你是谁</span></span><br><span class="line"></span><br><span class="line">git config --global user.name &quot;John Smith&quot;</span><br><span class="line"></span><br><span class="line">git config --global user.email john@example.com</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选择你喜欢的文本编辑器</span></span><br><span class="line"></span><br><span class="line">git config --global core.editor vim</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加一些快捷方式(别名)</span></span><br><span class="line"></span><br><span class="line">git config --global alias.st status</span><br><span class="line"></span><br><span class="line">git config --global alias.co checkout</span><br><span class="line"></span><br><span class="line">git config --global alias.br branch</span><br><span class="line"></span><br><span class="line">git config --global alias.up rebase</span><br><span class="line"></span><br><span class="line">git config --global alias.ci commit</span><br></pre></td></tr></table></figure><p>它会生成上一节中所说的 <code>~/.gitconfig</code> 文件。</p><hr><h1 id="1-3-保存你的更改"><a href="#1-3-保存你的更改" class="headerlink" title="1.3 保存你的更改"></a>1.3 保存你的更改</h1><p>“保存”这个概念在 Git 等版本控制系统和 Word 等文本编辑应用中不太一样。传统软件里的“保存”在 Git 里被叫做“提交”（commit）。 我们常说的的保存可以理解成在文件系统中覆盖一个已有的文件或者创建一个新的文件。而在 Git 中，提交这个操作作用于若干个文件和目录。</p><p>在 Git 和 SVN 里保存更改也不一样。SVN 提交或检入（check-in）将会推送到远端的中央服务器。也就是说 SVN 的提交需要联网才能完全“保存”项目更改。Git 提交可以在本地完成，然后再使用<code>git push -u origin master</code>命令推送到远端服务器。这两种方法的区别体现了两种架构设计的本质区别。Git 是一个分布式的应用，而 SVN 是一个中心化的应用。分布式应用一般来说更可靠，因为它们不存在中央服务器这样的单点故障。</p><p><code>git add</code>、<code>git status</code>和<code>git commit</code>这三个命令通常一起使用，将 Git 项目当前的状态保存成一份快照。</p><p>Git 还有另一个保存机制：“储藏”（stash）。储藏是一个临时的储存区域，保存还没准备好提交的更改。储藏操作作用于工作目录，三个文件树中的第一棵。它有很多用法，访问 git stash 页面了解更多。</p><p>Git 仓库可以通过设置忽略一些文件或目录。Git 将不会保存这些文件的任何更改。Git 有多种方式管理忽略文件列表。访问 git ignore 页面了解更多 Git 忽略文件设置。</p><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p><code>git add</code> 命令将工作目录中的变化添加到暂存区。它告诉 Git 你想要在下一次提交时包含这个文件的更新。但是，<code>git add</code> 不会实质上地影响你的仓库——在你运行 <code>git commit</code> 前更改都还没有真正被记录。</p><p>使用这些命令的同时，你还需要 <code>git status</code> 来查看工作目录和暂存区的状态。</p><h3 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure><p>将 <code>&lt;file&gt;</code> 中的更改加入下次提交的缓存。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;directory&gt;</span><br></pre></td></tr></table></figure><p>将 <code>&lt;directory&gt;</code> 下的更改加入下次提交的缓存。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -i</span><br></pre></td></tr></table></figure><p>开始交互式的缓存，你可以选择文件的一部分加入到下次提交缓存。它会向你展示一堆更改，等待你输入一个命令。<code>y</code> 将这块更改加入缓存，<code>n</code> 忽略这块更改，<code>s</code> 将它分割成更小的块，<code>e</code> 手动编辑这块更改，以及 <code>q</code> 退出。</p><h3 id="讨论-3"><a href="#讨论-3" class="headerlink" title="讨论"></a>讨论</h3><p><code>git add</code> 和 <code>git commit</code> 这两个命令组成了最基本的 Git 工作流。每一个 Git 用户都需要理解这两个命令，不管他们团队的协作模型是如何的。我有一千种方式可以将项目版本记录在仓库的历史中。</p><p>在一个只有编辑、缓存、提交这样基本流程的项目上开发。首先，你要在工作目录中编辑你的文件。当你准备备份项目的当前状态时，你通过 <code>git add</code> 来缓存更改。当你对缓存的快照满意之后，你通过 <code>git commit</code> 将它提交到你的项目历史中去。</p><p><code>git add</code> 命令不能和 <code>svn add</code> 混在一起理解，后者将文件添加到仓库中。而 <code>git add</code> 发生于更抽象的 <em>更改</em> 层面。也就是说，<code>git add</code> 在每次你修改一个文件时都需要被调用，而 <code>svn add</code> 只需要每个文件调用一次。这听上去很多余，但这样的工作流使得一个项目更容易组织。</p><h4 id="缓存区"><a href="#缓存区" class="headerlink" title="缓存区"></a>缓存区</h4><p>缓存区是 Git 更为独特的地方之一，如果你是从 SVN（甚至是 Mercurial）迁移而来，那你可得花点时间理解了。你可以简单地把它想成是工作目录和项目历史之间的缓冲区。</p><p>缓存允许你在实际提交到项目历史之前，将相关的更改组合成一份高度专注的快照，而不是将你上次提交以后产生的所有更改一并提交。也就是说你可以更改各种不相关的文件，然后回过去将它们按逻辑切分，将相关的更改添加到缓存，一份一份提交。在任何修改控制系统中，很重要的一点是提交必须是原子性的，以便于追踪 bug，并用最小的代价回滚更改。</p><h3 id="栗子-1"><a href="#栗子-1" class="headerlink" title="栗子"></a>栗子</h3><p>当你开始新项目的时候，<code>git add</code> 和 <code>svn import</code> 类似。为了创建当前目录的初始提交，使用下面两个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>当你项目设置好之后，新的文件可以通过路径传递给 <code>git add</code> 来添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add hello.py</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>上面的命令同样可以用于记录已有文件的更改。重复一次，Git 不会区分缓存的更改来自新文件，还是仓库中已有的文件。</p><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p><code>git commit</code>命令将缓存的快照提交到项目历史。提交的快照可以认为是项目安全的版本，Git 永远不会改变它们，除非你这么要求。和 <code>git add</code> 一样，这是最重要的 Git 命令之一。</p><p>尽管和它和 <code>svn commit</code> 名字一样，但实际上它们毫无关联。快照被提交到本地仓库，不会和其他 Git 仓库有任何交互。</p><h3 id="用法-4"><a href="#用法-4" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><p>提交已经缓存的快照。它会运行文本编辑器，等待你输入提交信息。当你输入信息之后，保存文件，关闭编辑器，创建实际的提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;&lt;message&gt;&quot;</span><br></pre></td></tr></table></figure><p>提交已经缓存的快照。但将 <code>&lt;message&gt;</code> 作为提交信息，而不是运行文本编辑器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure><p>提交一份包含工作目录所有更改的快照。它只包含跟踪过的文件的更改（那些之前已经通过 <code>git add</code> 添加过的文件）。</p><h3 id="讨论-4"><a href="#讨论-4" class="headerlink" title="讨论"></a>讨论</h3><p>快照总是提交到 <em>本地</em> 仓库。这一点和 SVN 截然不同，后者的工作拷贝提交到中央仓库。而 Git 不会强制你和中央仓库进行交互，直到你准备好了。就像缓存区是工作目录和项目历史之间的缓冲地带，每个开发者的本地仓库是他们贡献的代码和中央仓库之间的缓冲地带。</p><p>这一点改变了 Git 用户基本的开发模型。Git 开发者可以在本地仓库中积累一些提交，而不是一发生更改就直接提交到中央仓库。这对于 SVN 风格的协作有着诸多优点：更容易将功能切分成原子性的提交，让相关的提交组合在一起，发布到中央仓库之前整理好本地的历史。开发者得以在一个隔离的环境中工作，直到他们方便的时候再整合代码。</p><h4 id="记录快照，而不是记录差异"><a href="#记录快照，而不是记录差异" class="headerlink" title="记录快照，而不是记录差异"></a>记录快照，而不是记录差异</h4><p>SVN 和 Git 除了使用上存在巨大差异，它们底层的实现同样遵循截然不同的设计哲学。SVN 追踪文件的 <em>变化</em> ，而 Git 的版本控制模型基于 <em>快照</em> 。比如说，一个 SVN 提交由仓库中原文件相比的差异（diff）组成。而 Git 在每次提交中记录文件的 <em>完整内容</em> 。</p><p>这让很多 Git 操作比 SVN 来的快得多，因为文件的某个版本不需要通过版本间的差异组装得到——每个文件完整的修改能立刻从 Git 的内部数据库中得到。</p><p>Git 的快照模型对它版本控制模型的方方面面都有着深远的影响，从分支到合并工具，再到协作工作流，以至于影响了所有特性。</p><h3 id="栗子-2"><a href="#栗子-2" class="headerlink" title="栗子"></a>栗子</h3><p>下面这个栗子假设你编辑了 <code>hello.py</code> 文件的一些内容，并且准备好将它提交到项目历史。首先，你需要用 <code>git add</code> 缓存文件，然后提交缓存的快照。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add hello.py</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>它会打开一个文件编辑器（可以通过 <code>git config</code> 设置) 询问提交信息，同时列出将被提交的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please enter the commit message <span class="keyword">for</span> your changes. Lines starting</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">with <span class="string">&#x27;#&#x27;</span> will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On branch master</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Changes to be committed:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#modified: hello.py</span></span></span><br></pre></td></tr></table></figure><p>Git 对提交信息没有特定的格式限制，但约定俗成的格式是：在第一行用 50 个以内的字符总结这个提交，留一空行，然后详细阐述具体的更改。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Change the message displayed by hello.py</span><br><span class="line"></span><br><span class="line">- Update the sayHello() function to output the user&#x27;s name</span><br><span class="line">- Change the sayGoodbye() function to a friendlier message</span><br></pre></td></tr></table></figure><p>注意，很多开发者倾向于在提交信息中使用一般现在时态。这样看起来更像是对仓库进行的操作，让很多改写历史的操作更加符合直觉。</p><hr><h1 id="1-4-检查仓库状态"><a href="#1-4-检查仓库状态" class="headerlink" title="1.4 检查仓库状态"></a>1.4 检查仓库状态</h1><h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><p><code>git status</code> 命令显示工作目录和缓存区的状态。你可以看到哪些更改被缓存了，哪些还没有，以及哪些还未被 Git 追踪。status 的输出 <em>不会</em> 告诉你任何已提交到项目历史的信息。如果你想看的话，应该使用 <code>git log</code> 命令。</p><h3 id="用法-5"><a href="#用法-5" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>列出已缓存、未缓存、未追踪的文件。</p><h3 id="讨论-5"><a href="#讨论-5" class="headerlink" title="讨论"></a>讨论</h3><p><code>git status</code> 是一个相对简单的命令。 它告诉你 <code>git add</code> 和 <code>git commit</code> 的进展。status 信息还包括了添加缓存和移除缓存的相关指令。样例输出显示了三类主要的 <code>git status</code> 输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On branch master</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Changes to be committed:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#modified: hello.py</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Changes not staged for commit:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#modified: main.py</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Untracked files:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#hello.pyc</span></span></span><br></pre></td></tr></table></figure><h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>未追踪的文件通常有两类。它们要么是项目新增但还未提交的文件，要么是像 <code>.pyc</code>、<code>.obj</code>、<code>.exe</code> 等编译后的二进制文件。显然前者应该出现在 <code>git status</code> 的输出中，而后者会让我们困惑究竟发生了什么。</p><p>因此，Git 允许你完全忽略这些文件，只需要将路径放在一个特定的 <code>.gitignore</code> 文件中。所有想要忽略的文件应该分别写在单独一行，<code>*</code> 字符用作通配符。比如，将下面这行加入项目根目录的<code>.gitignore</code>文件可以避免编译后的Python模块出现在<code>git status</code>中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.pyc</span><br></pre></td></tr></table></figure><h3 id="栗子-3"><a href="#栗子-3" class="headerlink" title="栗子"></a>栗子</h3><p>在提交更改前检查仓库状态是一个良好的实践，这样你就不会不小心提交什么奇怪的东西。这个例子显示了缓存和提交快照前后的仓库状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Edit hello.py</span></span><br><span class="line">git status</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hello.py is listed under <span class="string">&quot;Changes not staged for commit&quot;</span></span></span><br><span class="line">git add hello.py</span><br><span class="line">git status</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hello.py is listed under <span class="string">&quot;Changes to be committed&quot;</span></span></span><br><span class="line">git commit</span><br><span class="line">git status</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nothing to commit (working directory clean)</span></span><br></pre></td></tr></table></figure><p>第一个 status 的输出显示文件还未缓存。<code>git add</code> 操作会影响第二个 <code>git status</code>，最后的 status 输出告诉你已经没有可以提交的东西了——工作目录和最近的提交一致。一些 Git 命令（比如 <code>git merge</code>）需要工作目录整洁，以免意外覆盖更改。</p><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p><code>git log</code> 命令显示已提交的快照。你可以列出项目历史，筛选，以及搜索特定更改。<code>git status</code> 允许你查看工作目录和缓存区，而 <code>git log</code> 只作用于提交的项目历史。</p><p>log 输出可以有很多种自定义的方式，从简单地筛选提交，到用完全自定义的格式显示。其中一些最常用的 <code>git log</code> 配置如下所示。</p><h3 id="用法-6"><a href="#用法-6" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>使用默认格式显示完整地项目历史。如果输出超过一屏，你可以用 <code>空格键</code> 来滚动，按 <code>q</code> 退出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -n &lt;limit&gt;</span><br></pre></td></tr></table></figure><p>用 <code>&lt;limit&gt;</code> 限制提交的数量。比如 <code>git log -n 3</code> 只会显示 3 个提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure><p>将每个提交压缩到一行。当你需要查看项目历史的上层情况时这会很有用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure><p>除了 <code>git log</code> 信息之外，包含哪些文件被更改了，以及每个文件相对的增删行数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p</span><br></pre></td></tr></table></figure><p>显示代表每个提交的一堆信息。显示每个提交全部的差异（diff），这也是项目历史中最详细的视图。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=&quot;&lt;pattern&gt;&quot;</span><br></pre></td></tr></table></figure><p>搜索特定作者的提交。<code>&lt;pattern&gt;</code> 可以是字符串或正则表达式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --grep=&quot;&lt;pattern&gt;&quot;</span><br></pre></td></tr></table></figure><p>搜索提交信息匹配特定 <code>&lt;pattern&gt;</code> 的提交。<code>&lt;pattern&gt;</code> 可以是字符串或正则表达式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log &lt;since&gt;..&lt;until&gt;</span><br></pre></td></tr></table></figure><p>只显示发生在 <code>&lt;since&gt;</code> 和 <code>&lt;until&gt;</code> 之间的提交。两个参数可以是提交 ID、分支名、<code>HEAD</code> 或是任何一种引用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log &lt;file&gt;</span><br></pre></td></tr></table></figure><p>只显示包含特定文件的提交。查找特定文件的历史这样做会很方便。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --decorate --oneline</span><br></pre></td></tr></table></figure><p>还有一些有用的选项。<code>--graph</code> 标记会绘制一幅字符组成的图形，左边是提交，右边是提交信息。<code>--decorate</code> 标记会加上提交所在的分支名称和标签。<code>--oneline</code> 标记将提交信息显示在同一行，一目了然。</p><h3 id="讨论-6"><a href="#讨论-6" class="headerlink" title="讨论"></a>讨论</h3><p><code>git log</code> 命令是 Git 查看项目历史的基本工具。当你要寻找项目特定的一个版本或者弄明白合并功能分支时引入了哪些变化，你就会用到这个命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commit 3157ee3718e180a9476bf2e5cab8e3f1e78a73b7</span><br><span class="line">Author: John Smith</span><br></pre></td></tr></table></figure><p>大多数时候都很简单直接。但是，第一行需要解释下。<code>commit</code> 后面 40 个字的字符串是提交内容的 SHA-1 校验总和（checksum）。它有两个作用。一是保证提交的正确性——如果它被损坏了，提交会生成一个不同的校验总和。第二，它是提交唯一的标识 ID。</p><p>这个 ID 可以用于 <code>git log</code> 这样的命令中来引用具体的提交。比如，<code>git log 3157e..5ab91</code> 会显示所有ID在 <code>3157e</code> 和 <code>5ab91</code> 之间的提交。除了校验总和之外，分支名、HEAD 关键字也是常用的引用提交的方法。<code>HEAD</code> 总是指向当前的提交，无论是分支还是特定提交也好。</p><p><del>字符用于表示提交的父节点的相对引用。比如，&#96;3157e</del>1<code>指向</code>3157e<code> 前一个提交,</code>HEAD~3&#96; 是当前提交的回溯3个节点的提交。</p><p>所有这些标识方法的背后都是为了让你对特定提交进行操作。<code>git log</code> 命令一般是这些交互的起点，因为它让你找到你想要的提交。</p><h3 id="栗子-4"><a href="#栗子-4" class="headerlink" title="栗子"></a>栗子</h3><p><em>用法</em> 一节提供了 <code>git log</code> 很多的栗子，但请记住，你可以将很多选项用在同一个命令中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=&quot;John Smith&quot; -p hello.py</span><br></pre></td></tr></table></figure><p>这个命令会显示 <code>John Smith</code> 作者对 <code>hello.py</code> 文件所做的所有更改的差异比较（diff）。</p><p>..句法是比较分支很有用的工具。下面的栗子显示了在 <code>some-feature</code> 分支而不在 <code>master</code> 分支的所有提交的概览。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline master..some-feature</span><br></pre></td></tr></table></figure><hr><h1 id="1-5-检出之前的提交"><a href="#1-5-检出之前的提交" class="headerlink" title="1.5 检出之前的提交"></a>1.5 检出之前的提交</h1><h2 id="检出之前的提交"><a href="#检出之前的提交" class="headerlink" title="检出之前的提交"></a>检出之前的提交</h2><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p><code>git checkout</code> 这个命令有三个不同的作用：检出文件、检出提交和检出分支。在这一章中，我们只关心前两种用法。</p><p>检出提交会使工作目录和这个提交完全匹配。你可以用它来查看项目之前的状态，而不改变当前的状态。检出文件使你能够查看某个特定文件的旧版本，而工作目录中剩下的文件不变。</p><h3 id="用法-7"><a href="#用法-7" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>回到 master 分支。分支会在下一节中讲到，而现在，你只需要将它视为回到项目「当前」状态的一种方式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;commit&gt; &lt;file&gt;</span><br></pre></td></tr></table></figure><p>查看文件之前的版本。它将工作目录中的 <code>&lt;file&gt;</code> 文件变成 <code>&lt;commit&gt;</code> 中那个文件的拷贝，并将它加入缓存区。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>更新工作目录中的所有文件，使得和某个特定提交中的文件一致。你可以将提交的哈希字串，或是标签作为 <code>&lt;commit&gt;</code> 参数。这会使你处在分离 HEAD 的状态。</p><h3 id="讨论-7"><a href="#讨论-7" class="headerlink" title="讨论"></a>讨论</h3><p>版本控制系统背后的思想就是「安全」地储存项目的拷贝，这样你永远不用担心什么时候不可复原地破坏了你的代码库。当你建立了项目历史之后，<code>git checkout</code> 是一种便捷的方式，来将保存的快照「加载」到你的开发机器上去。</p><p>检出之前的提交是一个只读操作。在查看旧版本的时候绝不会损坏你的仓库。你项目「当前」的状态在<code>master</code> 上不会变化。在开发的正常阶段，<code>HEAD</code> 一般指向 master 或是其他的本地分支，但当你检出之前提交的时候，<code>HEAD</code> 就不再指向一个分支了——它直接指向一个提交。这被称为「分离 <code>HEAD</code>」状态</p><p>在另一方面，检出旧文件不影响你仓库的当前状态。你可以在新的快照中像其他文件一样重新提交旧版本。所以，在效果上，<code>git checkout</code> 的这个用法可以用来将单个文件回滚到旧版本 。</p><h3 id="栗子-5"><a href="#栗子-5" class="headerlink" title="栗子"></a>栗子</h3><h4 id="查看之前的版本"><a href="#查看之前的版本" class="headerlink" title="查看之前的版本"></a>查看之前的版本</h4><p>这个栗子假定你开始了一个疯狂的实验，但你不确定你是否想要保留它。为了帮助你决定，你想看一看你开始实验之前的项目状态。首先，你需要找到你想要看的那个版本的 ID。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure><p>假设你的项目历史看上去和下面一样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b7119f2 继续做些丧心病狂的事</span><br><span class="line">872fa7e 做些丧心病狂的事</span><br><span class="line">a1e8fb5 对 hello.py 做了一些修改</span><br><span class="line">435b61d 创建 hello.py</span><br><span class="line">9773e52 初始导入</span><br></pre></td></tr></table></figure><p>你可以这样使用 <code>git checkout</code> 来查看「对 hello.py 做了一些修改」这个提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout a1e8fb5</span><br></pre></td></tr></table></figure><p>这让你的工作目录和 <code>a1e8fb5</code> 提交所处的状态完全一致。你可以查看文件，编译项目，运行测试，甚至编辑文件而不需要考虑是否会影响项目的当前状态。你所做的一切 <em>都不会</em> 被保存到仓库中。为了继续开发，你需要回到你项目的「当前」状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>这里假定了你默认在 master 分支上开发，我们会在以后的分支模型中详细讨论。</p><p>一旦你回到 master 分支之后，你可以使用 <code>git revert</code> 或 <code>git reset</code> 来回滚任何不想要的更改。</p><h4 id="检出文件"><a href="#检出文件" class="headerlink" title="检出文件"></a>检出文件</h4><p>如果你只对某个文件感兴趣，你也可以用 <code>git checkout</code> 来获取它的一个旧版本。比如说，如果你只想从之前的提交中查看 <code>hello.py</code> 文件，你可以使用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout a1e8fb5 hello.py</span><br></pre></td></tr></table></figure><p>记住，和检出提交不同，这里 <em>确实</em> 会影响你项目的当前状态。旧的文件版本会显示为「需要提交的更改」，允许你回滚到文件之前的版本。如果你不想保留旧的版本，你可以用下面的命令检出到最近的版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD hello.py</span><br></pre></td></tr></table></figure><hr><h1 id="1-6-回滚错误的修改"><a href="#1-6-回滚错误的修改" class="headerlink" title="1.6 回滚错误的修改"></a>1.6 回滚错误的修改</h1><h2 id="回滚错误的修改"><a href="#回滚错误的修改" class="headerlink" title="回滚错误的修改"></a>回滚错误的修改</h2><p>这章教程提供了和项目旧版本打交道所需要的所有技巧。首先，你会知道如何浏览旧的提交，然后了解回滚项目历史中的公有提交和回滚本地机器上的私有更改之间的区别。</p><h2 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h2><p><code>git revert</code> 命令用来撤销一个已经提交的快照。但是，它是通过搞清楚如何撤销这个提交引入的更改，然后在最后加上一个撤销了更改的 <em>新</em> 提交，而不是从项目历史中移除这个提交。这避免了Git丢失项目历史，这一点对于你的版本历史和协作的可靠性来说是很重要的。</p><h3 id="用法-8"><a href="#用法-8" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>生成一个撤消了 <code>&lt;commit&gt;</code> 引入的修改的新提交，然后应用到当前分支。</p><h3 id="讨论-8"><a href="#讨论-8" class="headerlink" title="讨论"></a>讨论</h3><p>撤销（revert）应该用在你想要在项目历史中移除一整个提交的时候。比如说，你在追踪一个 bug，然后你发现它是由一个提交造成的，这时候撤销就很有用。与其说自己去修复它，然后提交一个新的快照，不如用 <code>git revert</code>，它帮你做了所有的事情。</p><h4 id="撤销（revert）和重设（reset）对比"><a href="#撤销（revert）和重设（reset）对比" class="headerlink" title="撤销（revert）和重设（reset）对比"></a>撤销（revert）和重设（reset）对比</h4><p>理解这一点很重要。<code>git revert</code> 回滚了「单独一个提交」，它没有移除后面的提交，然后回到项目之前的状态。在 Git 中，后者实际上被称为 <code>reset</code>，而不是 <code>revert</code>。</p><p>撤销和重设相比有两个重要的优点。首先，它不会改变项目历史，对那些已经发布到共享仓库的提交来说这是一个安全的操作。至于为什么改变共享的历史是危险的，请参阅 <code>git reset</code> 一节。</p><p>其次，<code>git revert</code> 可以针对历史中任何一个提交，而 <code>git reset</code> 只能从当前提交向前回溯。比如，你想用 <code>git reset</code> 重设一个旧的提交，你不得不移除那个提交后的所有提交，再移除那个提交，然后重新提交后面的所有提交。不用说，这并不是一个优雅的回滚方案。</p><h3 id="栗子-6"><a href="#栗子-6" class="headerlink" title="栗子"></a>栗子</h3><p>下面的这个栗子是 <code>git revert</code> 一个简单的演示。它提交了一个快照，然后立即撤销这个操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑一些跟踪的文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交一份快照</span></span><br><span class="line">git commit -m &quot;Make some changes that will be undone&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">撤销刚刚的提交</span></span><br><span class="line">git revert HEAD</span><br></pre></td></tr></table></figure><p>注意第四个提交在撤销后依然在项目历史中。<code>git revert</code> 在后面增加了一个提交来撤销修改，而不是删除它。 因此，第三和第五个提交表示同样的代码，而第四个提交依然在历史中，以备以后我们想要回到这个提交。</p><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p>如果说 <code>git revert</code> 是一个撤销更改安全的方式，你可以将 <code>git reset</code> 看做一个 <em>危险</em> 的方式。当你用 <code>git reset</code> 来重设更改时(提交不再被任何引用或引用日志所引用)，我们无法获得原来的样子——这个撤销是永远的。使用这个工具的时候务必要小心，因为这是少数几个可能会造成工作丢失的命令之一。</p><p>和 <code>git checkout</code> 一样，<code>git reset</code> 有很多种用法。它可以被用来移除提交快照，尽管它通常被用来撤销缓存区和工作目录的修改。不管是哪种情况，它应该只被用于 <em>本地</em> 修改——你永远不应该重设和其他开发者共享的快照。</p><h3 id="用法-9"><a href="#用法-9" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;file&gt;</span><br></pre></td></tr></table></figure><p>从缓存区移除特定文件，但不改变工作目录。它会取消这个文件的缓存，而不覆盖任何更改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset</span><br></pre></td></tr></table></figure><p>重设缓冲区，匹配最近的一次提交，但工作目录不变。它会取消 <em>所有</em> 文件的缓存，而不会覆盖任何修改，给你了一个重设缓存快照的机会。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure><p>重设缓冲区和工作目录，匹配最近的一次提交。除了取消缓存之外，<code>--hard</code> 标记告诉 Git 还要重写所有工作目录中的更改。换句话说：它清除了所有未提交的更改，所以在使用前确定你想扔掉你所有本地的开发。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>将当前分支的末端移到 <code>&lt;commit&gt;</code>，将缓存区重设到这个提交，但不改变工作目录。所有 <code>&lt;commit&gt;</code> 之后的更改会保留在工作目录中，这允许你用更干净、原子性的快照重新提交项目历史。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>将当前分支的末端移到 <code>&lt;commit&gt;</code>，将缓存区和工作目录都重设到这个提交。它不仅清除了未提交的更改，同时还清除了 <code>&lt;commit&gt;</code> 之后的所有提交。</p><h3 id="讨论-9"><a href="#讨论-9" class="headerlink" title="讨论"></a>讨论</h3><p>上面所有的调用都是用来移除仓库中的修改。没有 <code>--hard</code> 标记时 <code>git reset</code> 通过取消缓存或取消一系列的提交，然后重新构建提交来清理仓库。而加上 <code>--hard</code> 标记对于作了大死之后想要重头再来尤其方便。</p><p>撤销(revert)被设计为撤销 <em>公开</em> 的提交的安全方式，<code>git reset</code>被设计为重设 <em>本地</em> 更改。因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销。</p><h4 id="不要重设公共历史"><a href="#不要重设公共历史" class="headerlink" title="不要重设公共历史"></a>不要重设公共历史</h4><p>当有 <code>&lt;commit&gt;</code> 之后的提交被推送到公共仓库后，你绝不应该使用 <code>git reset</code>。发布一个提交之后，你必须假设其他开发者会依赖于它。</p><p>移除一个其他团队成员在上面继续开发的提交在协作时会引发严重的问题。当他们试着和你的仓库同步时，他们会发现项目历史的一部分突然消失了。下面的序列展示了如果你尝试重设公共提交时会发生什么。<code>origin/master</code> 是你本地 <code>master</code> 分支对应的中央仓库中的分支。</p><p>一旦你在重设之后又增加了新的提交，Git 会认为你的本地历史已经和 <code>origin/master</code> 分叉了，同步你的仓库时的合并提交（merge commit）会使你的同事困惑。</p><p>重点是，确保你只对本地的修改使用 <code>git reset</code>，而不是公共更改。如果你需要修复一个公共提交，<code>git revert</code> 命令正是被设计来做这个的。</p><h3 id="栗子-7"><a href="#栗子-7" class="headerlink" title="栗子"></a>栗子</h3><h4 id="取消文件缓存"><a href="#取消文件缓存" class="headerlink" title="取消文件缓存"></a>取消文件缓存</h4><p><code>git reset</code> 命令在准备缓存快照时经常被用到。下面的例子假设你有两个文件，<code>hello.py</code> 和 <code>main.py</code>它们已经被加入了仓库中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑了hello.py和main.py</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缓存了目录下所有文件</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">意识到hello.py和main.py中的修改</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">应该在不同的快照中提交</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取消main.py缓存</span></span><br><span class="line">git reset main.py</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只提交hello.py</span></span><br><span class="line">git commit -m &quot;Make some changes to hello.py&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在另一份快照中提交main.py</span></span><br><span class="line">git add main.py</span><br><span class="line">git commit -m &quot;Edit main.py&quot;</span><br></pre></td></tr></table></figure><p>如你所见，<code>git reset</code> 帮助你取消和这次提交无关的修改，让提交能够专注于某一特定的范围。</p><h4 id="移除本地修改"><a href="#移除本地修改" class="headerlink" title="移除本地修改"></a>移除本地修改</h4><p>下面的这个栗子显示了一个更高端的用法。它展示了你作了大死之后应该如何扔掉那几个更新。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个叫`foo.py`的新文件，增加代码</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交到项目历史</span></span><br><span class="line">git add foo.py</span><br><span class="line">git commit -m &quot;Start developing a crazy feature&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再次编辑`foo.py`，修改其他文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交另一份快照</span></span><br><span class="line">git commit -a -m &quot;Continue my crazy feature&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">决定废弃这个功能，并删除相关的更改</span></span><br><span class="line">git reset --hard HEAD~2</span><br></pre></td></tr></table></figure><p><code>git reset HEAD~2</code> 命令将当前分支向前倒退两个提交，相当于在项目历史中移除刚创建的这两个提交。记住，这种重设只能用在 <em>非公开</em> 的提交中。绝不要在将提交推送到共享仓库之后执行上面的操作。</p><h2 id="git-clean"><a href="#git-clean" class="headerlink" title="git clean"></a>git clean</h2><p><code>git clean</code> 命令将未跟踪的文件从你的工作目录中移除。它只是提供了一条捷径，因为用 <code>git status</code> 查看哪些文件还未跟踪然后手动移除它们也很方便。和一般的 <code>rm</code> 命令一样，<code>git clean</code> 是无法撤消的，所以在删除未跟踪的文件之前想清楚，你是否真的要这么做。</p><p><code>git clean</code> 命令经常和 <code>git reset --hard</code> 一起使用。记住，reset 只影响被跟踪的文件，所以还需要一个单独的命令来清理未被跟踪的文件。这个两个命令相结合，你就可以将工作目录回到之前特定提交时的状态。</p><h3 id="用法-10"><a href="#用法-10" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -n</span><br></pre></td></tr></table></figure><p>执行一次git clean的『演习』。它会告诉你那些文件在命令执行后会被移除，而不是真的删除它。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -f</span><br></pre></td></tr></table></figure><p>移除当前目录下未被跟踪的文件。<code>-f</code>（强制）标记是必需的，除非 <code>clean.requireForce</code> 配置项被设为了 <code>false</code>（默认为 <code>true</code>）。它 <em>不会</em> 删除 <code>.gitignore</code> 中指定的未跟踪的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -f &lt;path&gt;</span><br></pre></td></tr></table></figure><p>移除未跟踪的文件，但限制在某个路径下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -df</span><br></pre></td></tr></table></figure><p>移除未跟踪的文件，以及目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -xf</span><br></pre></td></tr></table></figure><p>移除当前目录下未跟踪的文件，以及 Git 一般忽略的文件。</p><h3 id="讨论-10"><a href="#讨论-10" class="headerlink" title="讨论"></a>讨论</h3><p>如果你在本地仓库中作死之后想要毁尸灭迹，<code>git reset --hard</code> 和 <code>git clean -f</code> 是你最好的选择。运行这两个命令使工作目录和最近的提交相匹配，让你在干净的状态下继续工作。</p><p><code>git clean</code> 命令对于 build 后清理工作目录十分有用。比如，它可以轻易地删除 C 编译器生成的 <code>.o</code> 和 <code>.exe</code> 二进制文件。这通常是打包发布前需要的一步。<code>-x</code> 命令在这种情况下特别方便。</p><p>请牢记，和 <code>git reset</code> 一样， <code>git clean</code> 是仅有的几个可以永久删除提交的命令之一，所以要小心使用。事实上，它太容易丢掉重要的修改了，以至于 Git 厂商 <em>强制</em> 你用 <code>-f</code> 标志来进行最基本的操作。这可以避免你用一个 <code>git clean</code> 就不小心删除了所有东西。</p><h3 id="栗子-8"><a href="#栗子-8" class="headerlink" title="栗子"></a>栗子</h3><p>下面的栗子清除了工作目录中的所有更改，包括新建还没加入缓存的文件。它假设你已经提交了一些快照，准备开始一些新的实验。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑了一些文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新增了一些文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">『糟糕』</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将跟踪的文件回滚回去</span></span><br><span class="line">git reset --hard</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除未跟踪的文件</span></span><br><span class="line">git clean -df</span><br></pre></td></tr></table></figure><p>在执行了 reset&#x2F;clean 的流程之后，工作目录和缓存区和最近一次提交看上去一模一样，而  <code>git status</code>会认为这是一个干净的工作目录。你可以重新来过了。</p><p>注意，不像 <code>git reset</code> 的第二个栗子，新的文件没有被加入到仓库中。因此，它们不会受到 <code>git reset --hard</code> 的影响，需要 <code>git clean</code> 来删除它们。</p><hr><h1 id="1-7-重写项目历史"><a href="#1-7-重写项目历史" class="headerlink" title="1.7 重写项目历史"></a>1.7 重写项目历史</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Git 的主要职责是保证你不会丢失提交的修改。但是，它同样被设计成让你完全掌控开发工作流。这包括了让你自定义你的项目历史，而这也创造了丢失提交的可能性。Git 提供了可以重写项目历史的命令，但也警告你这些命令可能会让你丢失内容。</p><p>这份教程讨论了重写提交快照的一些常见原因，并告诉你如何避免不好的影响。</p><h2 id="git-commit-–amend"><a href="#git-commit-–amend" class="headerlink" title="git commit –amend"></a>git commit –amend</h2><p><code>git commit --amend</code> 命令是修复最新提交的便捷方式。它允许你将缓存的修改和之前的提交合并到一起，而不是提交一个全新的快照。它还可以用来简单地编辑上一次提交的信息而不改变快照。</p><p>但是，amend 不只是修改了最新的提交——它进行了一次替换。对于 Git 来说，这看上去像一个全新的提交</p><h3 id="用法-11"><a href="#用法-11" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>合并缓存的修改和上一次的提交，用新的快照替换上一个提交。缓存区没有文件时运行这个命令可以用来编辑上次提交的提交信息，而不会更改快照。</p><h3 id="讨论-11"><a href="#讨论-11" class="headerlink" title="讨论"></a>讨论</h3><p>仓促的提交在你日常开发过程中时常会发生。很容易就忘记了缓存一个文件或者弄错了提交信息的格式。<code>--amend</code> 标记是修复这些小意外的便捷方式。</p><h4 id="不要修复公共提交"><a href="#不要修复公共提交" class="headerlink" title="不要修复公共提交"></a>不要修复公共提交</h4><p>在<code>git reset</code>这节中，我们说过永远不要重设和其他开发者共享的提交。对于修复也是一样：永远不要修复一个已经推送到公共仓库中的提交。</p><p>修复过的提交事实上是全新的提交，之前的提交会被移除出项目历史。这和重设公共快照的后果是一样的。如果你修复了其他开发者在之后继续开发的一个提交，看上去他们的工作基础从项目历史中消失了一样。对于在这上面的开发者来说这是很困惑的，而且很难恢复。</p><h3 id="栗子-9"><a href="#栗子-9" class="headerlink" title="栗子"></a>栗子</h3><p>下面这个🌰展示了 Git 开发工作流中的一个常见情形。我们编辑了一些希望在同一个快照中提交的文件，但我们忘记添加了其中的一个。修复错误只需要缓存那个文件并且用 <code>--amend</code> 标记提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑 hello.py 和 main.py</span></span><br><span class="line">git add hello.py</span><br><span class="line">git commit</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">意识到你忘记添加 main.py 的更改</span></span><br><span class="line">git add main.py</span><br><span class="line">git commit --amend --no-edit</span><br></pre></td></tr></table></figure><p>编辑器会弹出上一次提交的信息，加入 <code>--no-edit</code> 标记会修复提交但不修改提交信息。需要的话你可以修改，不然的话就像往常一样保存并关闭文件。完整的提交会替换之前不完整的提交，看上去就像我们在同一个快照中提交了 <code>hello.py</code> 和 <code>main.py</code>。</p><h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><p>变基（rebase, 事实上这个名字十分诡异, 所以在大多数时候直接用英文术语）是将分支移到一个新的基提交的过程。过程一般如下所示：</p><p>从内容的角度来看，rebase 只不过是将分支从一个提交移到了另一个。但从内部机制来看，Git 是通过在选定的基上创建新提交来完成这件事的——它事实上重写了你的项目历史。理解这一点很重要，尽管分支看上去是一样的，但它包含了全新的提交。</p><h3 id="用法-12"><a href="#用法-12" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;base&gt;</span><br></pre></td></tr></table></figure><p>将当前分支 rebase 到 <code>&lt;base&gt;</code>，这里可以是任何类型的提交引用（ID、分支名、标签，或是 <code>HEAD</code> 的相对引用）。</p><h3 id="讨论-12"><a href="#讨论-12" class="headerlink" title="讨论"></a>讨论</h3><p>rebase 的主要目的是为了保持一个线性的项目历史。比如说，当你在 feature 分支工作时 master 分支取得了一些进展：</p><p>要将你的 feature 分支整合进 <code>master</code> 分支，你有两个选择：直接 merge，或者先 rebase 后 merge。前者会产生一个三路合并（3-way merge）和一个合并提交，而后者产生的是一个快速向前的合并以及完美的线性历史。</p><p>rebase 是将上游更改合并进本地仓库的通常方法。你每次想查看上游进展时，用 <code>git merge</code> 拉取上游更新会导致一个多余的合并提交。在另一方面，rebase 就好像是说「我想将我的更改建立在其他人的进展之上」。</p><h4 id="不要-rebase-公共历史"><a href="#不要-rebase-公共历史" class="headerlink" title="不要 rebase 公共历史"></a>不要 rebase 公共历史</h4><p>和我们讨论过的 <code>git commit --amend</code> 和 <code>git reset</code> 一样，你永远不应该 rebase 那些已经推送到公共仓库的提交。rebase 会用新的提交替换旧的提交，你的项目历史会像突然消失了一样。</p><h3 id="栗子-10"><a href="#栗子-10" class="headerlink" title="栗子"></a>栗子</h3><p>下面这个例子同时使用 git rebase 和 git merge 来保持线性的项目历史。这是一个确认你的合并都是快速向前的方法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始新的功能分支</span></span><br><span class="line">git checkout -b new-feature master</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑文件</span></span><br><span class="line">git commit -a -m &quot;Start developing a feature&quot;</span><br></pre></td></tr></table></figure><p>在 feature 分支开发了一半的时候，我们意识到项目中有一个安全漏洞:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基于master分支创建一个快速修复分支</span></span><br><span class="line">git checkout -b hotfix master</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑文件</span></span><br><span class="line">git commit -a -m &quot;Fix security hole&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并回master</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge hotfix</span><br><span class="line">git branch -d hotfix</span><br></pre></td></tr></table></figure><p>将 hotfix 分支并回之后 master，我们有了一个分叉的项目历史。我们用 rebase 整合 feature 分支以获得线性的历史，而不是使用普通的 git merge。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout new-feature</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure><p>它将 new-feature 分支移到了 master 分支的末端，现在我们可以在 master 上进行标准的快速向前合并了:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge new-feature</span><br></pre></td></tr></table></figure><h2 id="git-rebase-i"><a href="#git-rebase-i" class="headerlink" title="git rebase -i"></a>git rebase -i</h2><p>用 <code>-i</code> 标记运行 <code>git rebase</code> 开始交互式 rebase。交互式 rebase 给你在过程中修改单个提交的机会，而不是盲目地将所有提交都移到新的基上。你可以移除、分割提交，更改提交的顺序。它就像是打了鸡血的 <code>git commit --amend</code> 一样。</p><h3 id="用法-13"><a href="#用法-13" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i &lt;base&gt;</span><br></pre></td></tr></table></figure><p>将当前分支 rebase 到 <code>base</code>，但使用可交互的形式。它会打开一个编辑器，你可以为每个将要 rebase 的提交输入命令（见后文）。这些命令决定了每个提交将会怎样被转移到新的基上去。你还可以对这些提交进行排序。</p><h3 id="讨论-13"><a href="#讨论-13" class="headerlink" title="讨论"></a>讨论</h3><p>交互式 rebase 给你了控制项目历史的完全掌控。它给了开发人员很大的自由，因为他们可以提交一个「混乱」的历史而只需专注于写代码，然后回去恢复干净。</p><p>大多数开发者喜欢在并入主代码库之前用交互式 rebase 来完善他们的 feature 分支。他们可以将不重要的提交合在一起，删除不需要的，确保所有东西在提交到「正式」的项目历史前都是整齐的。对其他人来说，这个功能的开发看上去是由一系列精心安排的提交组成的。</p><h3 id="栗子-11"><a href="#栗子-11" class="headerlink" title="栗子"></a>栗子</h3><p>下面这个🌰是 <code>非交互式rebase</code> 一节中🌰的可交互升级版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始新的功能分支</span></span><br><span class="line">git checkout -b new-feature master</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑文件</span></span><br><span class="line">git commit -a -m &quot;Start developing a feature&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑更多文件</span></span><br><span class="line">git commit -a -m &quot;Fix something from the previous commit&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接在 master 上添加文件</span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑文件</span></span><br><span class="line">git commit -a -m &quot;Fix security hole&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始交互式 rebase</span></span><br><span class="line">git checkout new-feature</span><br><span class="line">git rebase -i master</span><br></pre></td></tr></table></figure><p>最后的那个命令会打开一个编辑器，包含 new-feature 的两个提交，和一些指示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick 32618c4 Start developing a feature</span><br><span class="line">pick 62eed47 Fix something from the previous commit</span><br></pre></td></tr></table></figure><p>你可以更改每个提交前的 pick 命令来决定在 rebase 时提交移动的方式。在我们的例子中，我们只需要用 squash 命令把两个提交并在一起就可以了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick 32618c4 Start developing a feature</span><br><span class="line">squash 62eed47 Fix something from the previous commit</span><br></pre></td></tr></table></figure><p>保存并关闭编辑器以开始 rebase。另一个编辑器会打开，询问你合并后的快照的提交信息。在定义了提交信息之后，rebase 就完成了，你可以在 <code>git log</code> 输出中看到那个提交。</p><p>注意缩并的提交和原来的两个提交的 ID 都不一样，告诉我们这确实是个新的提交。</p><p>最后，你可以执行一个快速向前的合并，来将完善的 feature 分支整合进主代码库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge new-feature</span><br></pre></td></tr></table></figure><p>交互式 rebase 强大的能力可以从整合后的 master 分支看出——额外的 <code>62eed47</code> 提交找不到了。对其他人来说，你就像是一个天才，用完美数量的提交完成了 <code>new-feature</code>。这就是交互式提交如何保持项目历史干净和合意。</p><h2 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h2><p>Git 用引用日志这种机制来记录分支顶端的更新。它允许你回到那些不被任何分支或标签引用的更改。在重写历史后，引用日志包含了分支旧状态的信息，有需要的话你可以回到这个状态。</p><h3 id="用法-14"><a href="#用法-14" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>显示本地仓库的引用日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog --relative-date</span><br></pre></td></tr></table></figure><p>用相对的日期显示引用日志。(如 2 周前）。</p><h3 id="讨论-14"><a href="#讨论-14" class="headerlink" title="讨论"></a>讨论</h3><p>每次当前的 HEAD 更新时（如切换分支、拉取新更改、重写历史或只是添加新的提交），引用日志都会添加一个新条目。</p><h3 id="栗子-12"><a href="#栗子-12" class="headerlink" title="栗子"></a>栗子</h3><p>为了理解 <code>git reflog</code>，我们来看一个🌰。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0a2e358 HEAD@&#123;0&#125;: reset: moving to HEAD~2</span><br><span class="line">0254ea7 HEAD@&#123;1&#125;: checkout: moving from 2.2 to master</span><br><span class="line">c10f740 HEAD@&#123;2&#125;: checkout: moving from master to 2.2</span><br></pre></td></tr></table></figure><p>上面的引用日志显示了 master 和 2.2 的 branch 之间的相互切换。还有对一个更老的提交的强制重设。最近的活动用 <code>HEAD@&#123;0&#125;</code> 标记在上方显示。</p><p>如果事实上你是不小心切换回去的，引用日志包含了你意外地丢掉两个提交之前 master 指向的提交 0254ea7。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 0254ea7</span><br></pre></td></tr></table></figure><p>使用 <code>git reset</code>，就有可能能将master变回之前的那个提交。它提供了一张安全网，以防历史发生意外更改。</p><p>务必记住，引用日志提供的安全网只对提交到本地仓库的更改有效，而且只有移动操作会被记录。</p><hr><h1 id="2-1-保持代码同步"><a href="#2-1-保持代码同步" class="headerlink" title="2.1 保持代码同步"></a>2.1 保持代码同步</h1><p>SVN 使用唯一的中央仓库作为开发者之间沟通的桥梁，在开发者的工作拷贝和中央仓库之间传递变更集合（changeset），协作得以发生。这和Git的协作模型有所不同，Git 给予每个开发者一份自己的仓库拷贝，拥有自己完整的本地历史和分支结构。用户通常共享一系列的提交而不是单个变更集合。Git 允许你在仓库间共享整个分支，而不是从工作副本提交一个差异集合到中央仓库。</p><p>下面的命令让你管理仓库之间的连接，将分支「推送」到其他仓库来发布本地历史，或是将分支「拉取」到本地仓库来查看其它开发者的贡献。</p><h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><p><code>git remote</code> 命令允许你创建、查看和删除和其它仓库之间的连接。远程连接更像是书签，而不是直接跳转到其他仓库的链接。它用方便记住的别名引用不那么方便记住的 URL，而不是提供其他仓库的实时连接。</p><p>你可以向 Git 命令传递 origin 和 john 的别名来引用这些仓库，替代完整的 URL。</p><h3 id="用法-15"><a href="#用法-15" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><p>列出你和其他仓库之间的远程连接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>和上个命令相同，但同时显示每个连接的 URL。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;name&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure><p>创建一个新的远程仓库连接。在添加之后，你可以将 <code>&lt;name&gt;</code> 作为 <code>&lt;url&gt;</code> 便捷的别名在其他 Git 命令中使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm &lt;name&gt;</span><br></pre></td></tr></table></figure><p>移除名为<name>的远程仓库的连接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename &lt;old-name&gt; &lt;new-name&gt;</span><br></pre></td></tr></table></figure><p>将远程连接从 <code>&lt;old-name&gt;</code> 重命名为 <code>&lt;new-name&gt;</code>。</p><h3 id="讨论-15"><a href="#讨论-15" class="headerlink" title="讨论"></a>讨论</h3><p>Git 被设计为给每个开发者提供完全隔离的开发环境。也就是说信息并不是自动地在仓库之间传递。开发者需要手动将上游提交拉取到本地，或手动将本地提交推送到中央仓库中去。<code>git remote</code> 命令正是将 URL 传递给这些「共享」命令的快捷方式。</p><h4 id="名为-origin-的远程连接"><a href="#名为-origin-的远程连接" class="headerlink" title="名为 origin 的远程连接"></a>名为 origin 的远程连接</h4><p>当你用 <code>git clone</code> 克隆仓库时，它自动创建了一个名为 origin 的远程连接，指向被克隆的仓库。当开发者创建中央仓库的本地副本时非常有用，因为它提供了拉取上游更改和发布本地提交的快捷方式。这也是为什么大多数基于 Git 的项目将它们的中央仓库取名为 origin。</p><h4 id="仓库的-URL"><a href="#仓库的-URL" class="headerlink" title="仓库的 URL"></a>仓库的 URL</h4><p>Git 支持多种方式来引用一个远程仓库。其中两种最简单的方式便是 HTTP 和 SSH 协议。HTTP 是允许匿名、只读访问仓库的简易方式。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://host/path/to/repo.git</span><br></pre></td></tr></table></figure><p>但是，直接将提交推送到一个 HTTP 地址一般是不可行的（你不太可能希望匿名用户也能随意推送）。如果希望对仓库进行读写，你需要使用 SSH 协议：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh://user@host/path/to/repo.git</span><br></pre></td></tr></table></figure><p>你需要在托管的服务器上有一个有效的 SSH 账户，但不用麻烦了，Git 支持开箱即用的 SSH 认证连接。</p><h3 id="栗子-13"><a href="#栗子-13" class="headerlink" title="栗子"></a>栗子</h3><p>除了 origin 之外，添加你同事的仓库连接通常会带来一些便利。比如，如果你的同事 John 在 <code>dev.example.com/john.git</code> 上维护了一个公开的仓库，你可以这样添加连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add john http://dev.example.com/john.git</span><br></pre></td></tr></table></figure><p>通过这种方式访问每个开发者的仓库，中央仓库之外的协作变得可能。这给维护大项目的小团队带来了极大的便利。</p><h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><p><code>git fetch</code> 命令将提交从远程仓库导入到你的本地仓库。拉取下来的提交储存为远程分支，而不是我们一直使用的普通的本地分支。你因此可以在整合进你的项目副本之前查看更改。</p><h3 id="用法-16"><a href="#用法-16" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;remote&gt;</span><br></pre></td></tr></table></figure><p>拉取仓库中所有的分支。同时会从另一个仓库中下载所有需要的提交和文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>和上一个命令相同，但只拉取指定的分支。</p><h3 id="讨论-16"><a href="#讨论-16" class="headerlink" title="讨论"></a>讨论</h3><p>当你希望查看其他人的工作进展时，你需要 fetch。fetch 下来的内容表示为一个远程分支，因此不会影响你的本地开发。这是一个安全的方式，在整合进你的本地仓库之前，检查那些提交。类似于 svn update，你可以看到中央仓库的历史进展如何，但它不会强制你将这些进展合并入你的仓库。</p><h4 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h4><p>远程分支和本地分支一样，只不过它们代表这些提交来自于其他人的仓库。你可以像查看本地分支一样查看远程分支，但你会处于分离 HEAD 状态（就像查看旧的提交时一样）。你可以把它们视作只读的分支。如果想要查看远程分支，只需要向 <code>git branch</code> 命令传入 <code>-r</code> 参数。远程分支拥有 remote 的前缀，所以你不会将它们和本地分支混起来。比如，下面的代码片段显示了从 origin 拉取之后，你可能想要查看的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">origin/master</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">origin/develop</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">origin/some-feature</span></span><br></pre></td></tr></table></figure><p>同样，你可以用寻常的 <code>git checkout</code> 和 <code>git log</code> 命令来查看这些分支。如果你接受远程分支包含的更改，你可以使用 <code>git merge</code> 将它并入本地分支。所以，不像 SVN，同步你的本地仓库和远程仓库事实上是一个分两步的操作：先 fetch，然后 merge。<code>git pull</code> 命令是这个过程的快捷方式。</p><h3 id="栗子-14"><a href="#栗子-14" class="headerlink" title="栗子"></a>栗子</h3><p>这个例子回顾了同步本地和远程仓库 <code>master</code> 分支的常见工作流：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure><p>它会显示会被下载的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a1e8fb5..45e66a4 master -&gt; origin/master</span><br><span class="line">a1e8fb5..9e8ab1c develop -&gt; origin/develop</span><br><span class="line">* [new branch] some-feature -&gt; origin/some-feature</span><br></pre></td></tr></table></figure><p>远程分支中的提交显示为方块，而不是圆圈。正如你所见，<code>git fetch</code> 让你看到了另一个仓库完整的分支结构。</p><p>若想查看添加到上游 master 上的提交，你可以运行 <code>git log</code>，用 <code>origin/master</code> 过滤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline master..origin/master</span><br></pre></td></tr></table></figure><p>用下面这些命令接受更改并并入你的本地 <code>master</code> 分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git log origin/master</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>git merge origin/master</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure><p>origin&#x2F;master 和 master 分支现在指向了同一个提交，你已经和上游的更新保持了同步。</p><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p>在基于 Git 的协作工作流中，将上游更改合并到你的本地仓库是一个常见的工作。我们已经知道应该使用 <code>git fetch</code>，然后是 <code>git merge</code>，但是 <code>git pull</code> 将这两个命令合二为一。</p><h3 id="用法-17"><a href="#用法-17" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;remote&gt;</span><br></pre></td></tr></table></figure><p>拉取当前分支对应的远程副本中的更改，并立即并入本地副本。效果和 <code>git fetch</code> 后接 <code>git merge origin/.</code> 一致。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase &lt;remote&gt;</span><br></pre></td></tr></table></figure><p>和上一个命令相同，但使用 <code>git rebase</code> 合并远程分支和本地分支，而不是使用 <code>git merge</code>。</p><h3 id="讨论-17"><a href="#讨论-17" class="headerlink" title="讨论"></a>讨论</h3><p>你可以将 <code>git pull</code> 当做 Git 中对应 <code>svn update</code> 的命令。这是同步你本地仓库和上游更改的简单方式。</p><p>你认为你的仓库已经同步了，但 <code>git fetch</code> 发现 origin 中 <code>master</code> 的版本在上次检查后已经有了新进展。 接着 <code>git merge</code> 立即将 <code>remote master</code> 并入本地的分支。</p><h4 id="基于-Rebase-的-Pull"><a href="#基于-Rebase-的-Pull" class="headerlink" title="基于 Rebase 的 Pull"></a>基于 Rebase 的 Pull</h4><p><code>--rebase</code> 标记可以用来保证线性的项目历史，防止合并提交（merge commits）的产生。很多开发者倾向于使用 rebase 而不是 merge，因为「我想要把我的更改放在其他人完成的工作之后」。在这种情况下，与普通的 <code>git pull</code> 相比而言，使用带有 <code>--rebase</code> 标记的 <code>git pull</code> 甚至更像 svn update。</p><p>事实上，使用 <code>--rebase</code> 的 pull 的工作流是如此普遍，以致于你可以直接在配置项中设置它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global branch.autosetuprebase always # In git &lt; 1.7.9</span><br><span class="line">git config --global pull.rebase true              # In git &gt;= 1.7.9</span><br></pre></td></tr></table></figure><p>在运行这个命令之后，所有的 <code>git pull</code> 命令将使用 <code>git rebase</code> 而不是 <code>git merge</code>。</p><h3 id="栗子-15"><a href="#栗子-15" class="headerlink" title="栗子"></a>栗子</h3><p>下面的栗子演示了如何和一个中央仓库的 <code>master branch</code> 同步：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull --rebase origin</span><br></pre></td></tr></table></figure><p>简单地将你本地的更改放到其他人已经提交的更改之后。</p><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>Push 是你将本地仓库中的提交转移到远程仓库中时要做的事。它和 <code>git fetch</code> 正好相反，fetch 将提交导入到本地分支，而 push 将提交导出到远程分支。它可以覆盖已有的更改，所以你需要小心使用。这些情况请见下面的讨论。</p><h3 id="用法-18"><a href="#用法-18" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>将指定的分支推送到 <code>&lt;remote&gt;</code> 上，包括所有需要的提交和提交对象。它会在目标仓库中创建一个本地分支。为了防止你覆盖已有的提交，如果会导致目标仓库非快速向前合并时，Git 不允许你 push。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; --force</span><br></pre></td></tr></table></figure><p>和上一个命令相同，但即使会导致非快速向前合并也强制推送。除非你确定你所做的事，否则不要使用 <code>--force</code> 标记。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; --all</span><br></pre></td></tr></table></figure><p>将所有本地分支推送到指定的远程仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; --tags</span><br></pre></td></tr></table></figure><p>当你推送一个分支或是使用 <code>--all</code> 选项时，标签不会被自动推送上去。<code>--tags</code> 将你所有的本地标签推送到远程仓库中去。</p><h3 id="讨论-18"><a href="#讨论-18" class="headerlink" title="讨论"></a>讨论</h3><p><code>git push</code> 最常见的用法是将你的本地更改发布到中央仓库。在你积累了一些本地提交，准备和同事们共享时，你（可以）用交互式 rebase 来清理你的提交，然后推送到中央仓库去。</p><p>当你本地的 master 分支进展超过了中央仓库的 <code>master</code> 分支，当你运行 <code>git push origin master</code> 发布更改时发生的事情。注意，<code>git push</code> 和在远程仓库内部运行 <code>git merge master</code> 事实上是一样的。</p><h4 id="强制推送"><a href="#强制推送" class="headerlink" title="强制推送"></a>强制推送</h4><p>Git 为了防止你覆盖中央仓库的历史，会拒绝你会导致非快速向前合并的推送请求。所以，如果远程历史和你本地历史已经分叉，你需要将远程分支 pull 下来，在本地合并后再尝试推送。这和 SVN 让你在提交更改集合之前要和中央仓库同步是类似的。</p><p><code>--force</code> 这个标记覆盖了这个行为，让远程仓库的分支符合你的本地分支，删除你上次 pull 之后可能的上游更改。只有当你意识到你刚刚共享的提交不正确，并用 <code>git commit --amend</code> 或者交互式 rebase 修复之后，你才需要用到强制推送。但是，你必须绝对确定在你使用 <code>--force</code> 标记前你的同事们都没有 pull 这些提交。</p><h4 id="只推送到裸仓库"><a href="#只推送到裸仓库" class="headerlink" title="只推送到裸仓库"></a>只推送到裸仓库</h4><p>此外，你只应该推送到那些用 <code>--bare</code> 标记初始化的仓库。因为推送会弄乱远程分支结构，很重要的一点是，永远不要推送到其他开发者的仓库。但因为裸仓库没有工作目录，不会发生打断别人的开发之类的事情。</p><h3 id="栗子-16"><a href="#栗子-16" class="headerlink" title="栗子"></a>栗子</h3><p>下面的栗子描述了将本地提交推送到中央仓库的一些标准做法。首先，确保你本地的 <code>master</code> 和中央仓库的副本是一致的，提前 fetch 中央仓库的副本并在上面 rebase。交互式 rebase 同样是共享之前清理提交的好机会。接下来，<code>git push</code> 命令将你本地 <code>master</code> 分支上的所有提交发送给中央仓库.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git fetch origin master</span><br><span class="line">git rebase -i origin/master</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Squash commits, fix up commit messages etc.</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>因为我们已经确信本地的 <code>master</code> 分支是最新的，它应该导致快速向前的合并，<code>git push</code> 不应该抛出非快速向前之类的问题。</p><hr><h1 id="2-2-创建Pull-Request"><a href="#2-2-创建Pull-Request" class="headerlink" title="2.2 创建Pull Request"></a>2.2 创建Pull Request</h1><p>Pull Request 是开发者使用 GitHub 进行协作的利器。这个功能为用户提供了友好的页面，让提议的更改在并入官方项目之前，可以得到充分的讨论。</p><p>最简单地来说，Pull Request 是一种机制，让开发者告诉项目成员一个功能已经完成。一旦 feature 分支开发完毕，开发者使用 GitHub 账号提交一个 Pull Request。它告诉所有参与者，他们需要审查代码，并将代码并入 <code>master</code> 分支。</p><p>但是，Pull Request 不只是一个通知，还是一个专注于某个提议功能的讨论版。 如果更改导致了任何问题，团队成员可以在 Pull Request 下发布反馈，甚至推送后续提交来修改这个 Pull Request。所有的活动都在这个 Pull Request里之间追踪。</p><p>和其他协作模型相比，这种共享提交的解决方案形成了更加线性的工作流。SVN 和 Git 都能通过一个简单的脚本发送通知邮件；但是，如果要讨论更改，开发者不得不在邮件里回复。这会变得愈发杂乱无章，尤其是后续提交出现时。Pull Request 将所有这些功能放入了一个友好的网页，在每个 GitHub 仓库上方都能找到。</p><h3 id="剖析一个-Pull-Request"><a href="#剖析一个-Pull-Request" class="headerlink" title="剖析一个 Pull Request"></a>剖析一个 Pull Request</h3><p>当你提交一个 Pull Request 的时候，你做的事情是 <em>请求（request）</em> 另一个开发者（比如项目维护者）来 <em>拉取（pull）</em> 你仓库中的一个分支到他们的仓库。也就是说你需要提供 4 个信息来完成一个 Pull Request：源仓库、源分支、目标仓库、目标分支。</p><p>GitHub 会机智地帮你将一些值设为默认值。但是，取决于你的协作工作流，你的团队可能需要设置不同的值。一个请求从 feature 分支合并到官方  master分支的一个 Pull Request，但除此之外还有好多种使用 Pull Request 的方式。</p><h3 id="Pull-Request是如何工作的"><a href="#Pull-Request是如何工作的" class="headerlink" title="Pull Request是如何工作的"></a>Pull Request是如何工作的</h3><p>Pull Request 可以和 feature 分支工作流、GitFlow 工作流或者 Fork 工作流一起使用。但 Pull Request 需要两个不同的分支或是两个不同的仓库，因此它们不能和中心化的工作流一起使用。在不同的工作流中使用 Pull Request 有些不同，但大致的流程如下：</p><ol><li>开发者在他们的本地仓库中为某个功能创建一个专门的分支。</li><li>开发者将分支推送到公共的 GitHub 仓库。</li><li>开发者用 GitHub 发起一个 Pull Request。</li><li>其余的团队成员审查代码，讨论并且做出修改。</li><li>项目维护者将这个功能并入官方的仓库，然后关闭这个 Pull Request。</li></ol><p>下面的章节讨论 Pull Request 在不同的协作工作流中有哪些不同。</p><h3 id="Feature-分支工作流中的-Pull-Request"><a href="#Feature-分支工作流中的-Pull-Request" class="headerlink" title="Feature 分支工作流中的 Pull Request"></a>Feature 分支工作流中的 Pull Request</h3><p>Feature 分支工作流使用共享的 GitHub 仓库来管理协作，开发者在单独的 feature 分支中添加功能。开发者在将代码并入主代码库之前，应该发起一个 Pull Request 来启动这个功能的讨论，而不是直接将它们合并到 <code>master</code>。</p><p>在 Feature 分支工作流中只有一个公共的仓库，因此 Pull Request 的目标和源仓库永远是同一个。一般来说，开发者会将他们的  feature分支作为源分支，<code>master</code> 作为目标分支。</p><p>在收到 Pull Request 之后，项目维护者将会做出决定。如果这个功能可以立即发布，他们只需要将代码合并进 <code>master</code>，然后关闭 Pull Request 即可。但是，如果提议的更改有一些问题，他们可以在 Pull Request 下发布反馈。后续提交将会显示在相关评论的下方。</p><p>你也可以发布一个未完成功能的 Pull Request。例如，如果开发者在实现一个特殊的需求时遇到了问题，同样可以发布一个包含工作进展的 Pull Request。其他开发者可以在这个 Pull Request 后面提供建议，甚至自己发布后续的提交来解决这个问题。</p><h3 id="GitFlow-工作流中的-Pull-Request"><a href="#GitFlow-工作流中的-Pull-Request" class="headerlink" title="GitFlow 工作流中的 Pull Request"></a>GitFlow 工作流中的 Pull Request</h3><p>GitFlow 工作流和 Feature 分支工作流类似，但定义了围绕项目发布的一个严格的分支模型。在 GitFlow 工作流之上添加 Pull Request 使得开发者方便地讨论发布分支或是所在的维护分支。</p><p>在 GitFlow 工作流中的 Pull Request 和上一节中的完全一致：开发者只需在功能、发布或是快速修复分支需要审查时发布一个 Pull Request，GitHub 会通知到其余的团队成员。</p><p>功能一般都会合并到 <code>develop</code> 分支，而发布和快速修复分支会被同时合并到 <code>develop</code> 和 <code>master</code> 当中。 Pull Request 可以用来妥善管理这些合并。</p><h3 id="Fork-工作流中的-Pull-Request"><a href="#Fork-工作流中的-Pull-Request" class="headerlink" title="Fork 工作流中的 Pull Request"></a>Fork 工作流中的 Pull Request</h3><p>在 Fork 工作流中，开发者将一个完成的功能推送到 <em>他们自己的</em> 仓库，而不是公共的仓库。在这之后，他们发布一个 Pull Request，告诉项目维护者代码需要审查了。</p><p>在这个工作流中，Pull Request 的通知作用显得非常有用，因为项目维护者无法获知其他开发者什么时候向他们自己的 GitHub 仓库中添加了提交。</p><p>因为每个开发者都有他们自己的公共仓库，Pull Request 的源仓库和目标仓库不是同一个。源仓库是开发者的公开仓库，源分支是包含提议更改的那一个。如果开发者想要将功能合并到主代码库，目标仓库便是官方的项目仓库，目标分支为 <code>master</code>。</p><p>Pull Request 还可以用来和官方项目之外的开发者进行协作。比如说，一个开发者正在和同事一起开发一个功能，他们可以向 <em>同事的</em> GitHub 仓库发起一个 Pull Request，而不是官方仓库。他们将 feature 分支同时作为源分支和目标分支。</p><p>两个开发者可以在 Pull Request 中讨论和开发分支。当功能完成时，其中一位可以发起另一个 Pull Request，请求将功能合并到官方的 master 分支中去。这种灵活性使得 Pull Request 成为了 Fork 工作流中尤为强大的协作工具。</p><h3 id="栗子-17"><a href="#栗子-17" class="headerlink" title="栗子"></a>栗子</h3><p>下面的🌰演示了如何将 Pull Request 用在 Fork 工作流中。小团队中的开发和向一个开源项目贡献代码都可以这样做。</p><p>在这个栗子中，Mary 是一位开发者，John 是项目的维护者。他们都有自己公开的 GitHub 仓库，John 的仓库之一便是下面的官方项目。</p><h4 id="Mary-fork了官方项目"><a href="#Mary-fork了官方项目" class="headerlink" title="Mary fork了官方项目"></a>Mary fork了官方项目</h4><p>为了参与这个项目，Mary 首先要做的是 fork 属于 John 的 GitHub 仓库。她需要注册登录 GitHub，找到 John 的仓库，点击 Fork 按钮。</p><p>选好 fork 的目标位置之后，她在服务端就有了一个项目的副本。</p><h4 id="Mary-克隆了她的-GitHub-仓库"><a href="#Mary-克隆了她的-GitHub-仓库" class="headerlink" title="Mary 克隆了她的 GitHub 仓库"></a>Mary 克隆了她的 GitHub 仓库</h4><p>接下来，Mary 需要将她刚刚 fork 的 GitHub 仓库克隆下来。她在本地会有一份项目的副本。她需要运行下面这个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/user/repo.git</span><br></pre></td></tr></table></figure><p>请记住，<code>git clone</code> 自动创建了一个名为 <code>origin</code> 的远端连接，指向 Mary 所 fork 的仓库。</p><h4 id="Mary-开发了一个新功能"><a href="#Mary-开发了一个新功能" class="headerlink" title="Mary 开发了一个新功能"></a>Mary 开发了一个新功能</h4><p>在她写任何代码之前，Mary 需要为这个功能创建一个新的分支。这个分支将是她随后发起 Pull Request 时要用到的源分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b some-feature</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑一些代码</span></span><br><span class="line">git commit -a -m &quot;新功能的一些草稿&quot;</span><br></pre></td></tr></table></figure><p>为了完成这个新功能，Mary 想创建多少个提交都可以。如果 feature 分支的历史有些乱，她可以使用交互式的 rebase 来移除或者拼接不必要的提交。对于大项目来说，清理 feature 的项目历史使得项目维护者更容易看清楚 Pull Request 的所处的进展。</p><h4 id="Mary-将-feature-分支推送到了她的-GitHub-仓库"><a href="#Mary-将-feature-分支推送到了她的-GitHub-仓库" class="headerlink" title="Mary 将 feature 分支推送到了她的 GitHub 仓库"></a>Mary 将 feature 分支推送到了她的 GitHub 仓库</h4><p>在功能完成后，Mary 使用简单的 <code>git push</code> 将 feature 分支推送到了她自己的 GitHub 仓库上（不是官方的仓库）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin some-branch</span><br></pre></td></tr></table></figure><p>这样她的更改就可以被项目维护者看到了（或者任何有权限的协作者）。</p><h4 id="Mary-创建了一个-Pull-Request"><a href="#Mary-创建了一个-Pull-Request" class="headerlink" title="Mary 创建了一个 Pull Request"></a>Mary 创建了一个 Pull Request</h4><p>GitHub 上已经有了她的 feature 分支之后，Mary 可以找到被她 fork 的仓库，点击项目简介下的 <em>New Pull Request</em> 按钮，用她的 GitHub 账号创建一个 Pull Request。Mary 的仓库会被默认设置为源仓库（head fork），询问她指定源分支（compare）、目标仓库（base fork）和目标分支（base）。</p><p>Mary 想要将她的功能并入主代码库，所以源分支就是她的 feature 分支，目标仓库就是 John 的公开仓库，目标分支为 <code>master</code>。她还需要提供一个 Pull Request 的标题和简介。</p><p>在她创建了 Pull Request 之后，GitHub 会给 John 发送一条通知。</p><h4 id="John-审查了这个-Pull-Request"><a href="#John-审查了这个-Pull-Request" class="headerlink" title="John 审查了这个 Pull Request"></a>John 审查了这个 Pull Request</h4><p>John 可以在他自己的 GitHub 仓库下的 <em>Pull Request</em> 选项卡中看到所有的 Pull Request。点击 Mary 的 Pull Request 会显示这个 Pull Request 的简介、feature 分支的提交历史，以及包含的更改。</p><p>如果他认为 feature 分支已经可以合并了，他只需点击 <em>Merge Pull Request</em> 按钮来通过这个 Pull Request，将 Mary 的  feature分支并入他的 <code>master</code> 分支。</p><p>但是，在这里栗子中，假设 John 发现了 Mary 代码中的一个小 bug，需要她在合并前修复。他可以评论整个 Pull Request，也可以评论 feature 分支中某个特定的提交。</p><h4 id="Mary-添加了一个后续提交"><a href="#Mary-添加了一个后续提交" class="headerlink" title="Mary 添加了一个后续提交"></a>Mary 添加了一个后续提交</h4><p>如果 Mary 对这个反馈感到困惑，她可以在 Pull Request 后回复，把这里当做是她的功能的讨论版。</p><p>为了修复错误，Mary 在她的 feature 分支后面添加了另一个提交，并将它推送到了她的 GitHub 仓库，就像她之前做的一样。这个提交被自动添加到原来的 Pull Request 后面，John 可以在他的评论下方再次审查这些修改。</p><h4 id="John-接受了-Pull-Request"><a href="#John-接受了-Pull-Request" class="headerlink" title="John 接受了 Pull Request"></a>John 接受了 Pull Request</h4><p>最后，John 接受了这些修改，将 feature 分支并入了 master 分支，关闭了这个 Pull Request。功能现在已经整合到了项目中，其他在 master 分支上工作的开发者可以使用标准的 <code>git pull</code> 命令将这些修改拉取到自己的本地仓库。</p><h3 id="接下来怎么做？"><a href="#接下来怎么做？" class="headerlink" title="接下来怎么做？"></a>接下来怎么做？</h3><p>你现在应该已经掌握了如何将你的 Pull Request 整合到你的工作流。记住，Pull Request 不是替代任何 Git 工作流的万金油，而是一种让队员间协作锦上添花的工具。</p><hr><h1 id="2-3-使用分支"><a href="#2-3-使用分支" class="headerlink" title="2.3 使用分支"></a>2.3 使用分支</h1><p>这份教程是 Git 分支的综合介绍。首先，我们简单讲解如何创建分支，就像请求一份新的项目历史一样。然后，我们会看到 git checkout 是如何切换分支的。最后，学习一下 git merge 是如何整合独立分支的历史。</p><p>我们已经知道，Git 分支和 SVN 分支不同。SVN 分支只被用来记录偶尔大规模的开发效果，而 Git 分支是你日常工作流中不可缺失的一部分。</p><h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><p>分支代表了一条独立的开发流水线。分支是我们在第二篇中讨论过的「编辑&#x2F;缓存&#x2F;提交」流程的抽象。你可以把它看作请求全新「工作目录、缓存区、项目历史」的一种方式。新的提交被存放在当前分支的历史中，导致了项目历史被 fork 了一份。</p><p><code>git branch</code> 命令允许你创建、列出、重命名和删除分支。它不允许你切换分支或是将被 fork 的历史放回去。因此，<code>git branch</code> 和 <code>git checkout</code>、<code>git merge</code> 这两个命令通常紧密地结合在一起使用。</p><h3 id="用法-19"><a href="#用法-19" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>列出仓库中所有分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>创建一个名为 <code>&lt;branch&gt;</code> 的分支。<em>不会</em> 自动切换到那个分支去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>删除指定分支。这是一个安全的操作，Git 会阻止你删除包含未合并更改的分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>强制删除指定分支，即使包含未合并更改。如果你希望永远删除某条开发线的所有提交，你应该用这个命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>将当前分支命名为 <code>&lt;branch&gt;</code>。</p><h3 id="讨论-19"><a href="#讨论-19" class="headerlink" title="讨论"></a>讨论</h3><p>在 Git 中，分支是你日常开发流程中的一部分。当你想要添加一个新的功能或是修复一个 bug 时——不管 bug 是大是小——你都应该新建一个分支来封装你的修改。这确保了不稳定的代码永远不会被提交到主代码库中，它同时给了你机会，在并入主分支前清理你 feature 分支的历史。</p><p>比如，将一个拥有两条独立开发线的仓库可视化，其中一条是一个不起眼的功能，另一条是长期运行的功能。使用分支开发时，不仅可以同时在两条线上工作，还可以保持主要的 <code>master branch</code> 不混入奇怪的代码。</p><h4 id="分支的顶端"><a href="#分支的顶端" class="headerlink" title="分支的顶端"></a>分支的顶端</h4><p>Git 分支背后的实现远比 SVN 的模型要轻量。与其在目录之间复制文件，Git 将分支存为指向提交的引用。换句话说，分支代表了一系列提交的 <em>顶端</em> ——而不是提交的 <em>容器</em> 。分支历史通过提交之间的关系来推断。</p><p>这使得 Git 的合并模型变成了动态的。SVN 中的合并是基于文件的，而Git 让你在更抽象的提交层面操作。事实上，你可以看到项目历史中的合并其实是将两个独立的提交历史连接起来。</p><h3 id="栗子-18"><a href="#栗子-18" class="headerlink" title="栗子"></a>栗子</h3><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>分支只是指向提交的 <em>指针</em> ，理解这一点很重要。当你创建一个分支是，Git 只需要创建一个新的指针——仓库不会受到任何影响。因此，如果你最开始有这样一个仓库：</p><p>接下来你用下面的命令创建了一个分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch crazy-experiment</span><br></pre></td></tr></table></figure><p>仓库历史保持不变。你得到的是一个指向当前提交的新的指针：</p><p>注意，这只会 <em>创建</em> 一个新的分支。要开始在上面添加提交，你需要用 <code>git checkout</code> 来选中这个分支，然后使用标准的 <code>git add</code> 和 <code>git commit</code> 命令。</p><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><p>一旦你完成了分支上的工作，准备将它并入主代码库，你可以自由地删除这个分支，而不丢失项目历史：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d crazy-experiment</span><br></pre></td></tr></table></figure><p>然后，如果分支还没有合并，下面的命令会产生一个错误信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: The branch &#x27;crazy-experiment&#x27; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#x27;git branch -D crazy-experiment&#x27;.</span><br></pre></td></tr></table></figure><p>Git 保护你不会丢失这些提交的引用，或者说丢失访问整条开发线的入口。如果你 <em>真的</em> 想要删除这个分支（比如说这是一个失败的实验），你可以用大写的 <code>-D</code> 标记：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D crazy-experiment</span><br></pre></td></tr></table></figure><p>它会删除这个分支，无视它的状态和警告，因此需谨慎使用。</p><h2 id="git-checkout-1"><a href="#git-checkout-1" class="headerlink" title="git checkout"></a>git checkout</h2><p><code>git checkout</code> 命令允许你切换用 <code>git branch</code> 创建的分支。查看一个分支会更新工作目录中的文件，以符合分支中的版本，它还告诉 Git 记录那个分支上的新提交。将它看作一个选中你正在进行的开发的一种方式。</p><p>在上一篇中，我们看到了如何用 <code>git checkout</code> 来查看旧的提交。「查看分支」和「将工作目录更新到选中的版本&#x2F;修改」很类似；但是，新的更改 <em>会</em> 保存在项目历史中——这不是一个只读的操作。</p><h3 id="用法-20"><a href="#用法-20" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;existing-branch&gt;</span><br></pre></td></tr></table></figure><p>查看特定分支，分支应该已经通过 <code>git branch</code> 创建。这使得 <code>&lt;existing-branch&gt;</code> 成为当前的分支，并更新工作目录的版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;new-branch&gt;</span><br></pre></td></tr></table></figure><p>创建并查看 <code>&lt;new-branch&gt;</code>，<code>-b</code> 选项是一个方便的标记，告诉Git在运行 <code>git checkout &lt;new-branch&gt;</code> 之前运行 <code>git branch &lt;new-branch&gt;</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;new-branch&gt; &lt;existing-branch&gt;</span><br></pre></td></tr></table></figure><p>和上一条相同，但将 <code>&lt;existing-branch&gt;</code> 作为新分支的基，而不是当前分支。</p><h3 id="讨论-20"><a href="#讨论-20" class="headerlink" title="讨论"></a>讨论</h3><p><code>git checkout</code> 和 <code>git branch</code> 是一对好基友。当你想要创建一个新功能时，你用 <code>git branch</code> 创建分支，然后用 <code>git checkout</code> 查看。你可以在一个仓库中用 <code>git checkout</code> 切换分支，同时开发几个功能。</p><p>每个功能专门一个分支对于传统 SVN 工作流来说是一个巨大的转变。这使得尝试新的实验超乎想象的简单，不用担心毁坏已有的功能，并且可以同时开发几个不相关的功能。另外，分支可以促进了不同的协作工作流。</p><h4 id="分离的-HEAD"><a href="#分离的-HEAD" class="headerlink" title="分离的 HEAD"></a>分离的 <code>HEAD</code></h4><p>现在我们已经看到了 <code>git checkout</code> 最主要的三种用法，我们可以讨论上一篇中提到的「分离 <code>HEAD</code>」状态了。</p><p>记住，<code>HEAD</code> 是 Git 指向当前快照的引用。<code>git checkout</code> 命令内部只是更新 <code>HEAD</code>，指向特定分支或提交。当它指向分支时，Git 不会报错，但当你 check out 提交时，它会进入「分离 <code>HEAD</code>」状态。</p><p>有个警告会告诉你所做的更改和项目的其余历史处于「分离」的状态。如果你在分离 <code>HEAD</code> 状态开始开发新功能，没有分支可以让你回到之前的状态。当你不可避免地 checkout 到了另一个分支（比如你的更改并入了这个分支），你将不再能够引用你的 feature 分支：</p><p>重点是，你应该永远在分支上开发——而绝不在分离的 <code>HEAD</code> 上。这样确保你一直可以引用到你的新提交。不过，如果你只是想查看旧的提交，那么是否处于分离 <code>HEAD</code> 状态并不重要。</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>下面的例子演示了基本的 Git 分支流程。当你想要开发新功能时，你创建一个专门的分支，切换过去：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch new-feature</span><br><span class="line">git checkout new-feature</span><br></pre></td></tr></table></figure><p>接下来，你可以和以往一样提交新的快照：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑文件</span></span><br><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m &quot;Started work on a new feature&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">周而复始…</span></span><br></pre></td></tr></table></figure><p>这些操作都被记录在 <code>new-feature</code> 上，和 <code>master</code> 完全独立。你想添加多少提交就可以添加多少，不用关心你其它分支的修改。当你想要回到「主」代码库时，只要 check out 到 <code>master</code> 分支即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>这个命令在你开始新的分支之前，告诉你仓库的状态。在这里，你可以选择并入完成的新功能，或者在你项目稳定的版本上继续工作。</p><h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p>合并是 Git 将被 fork 的历史放回到一起的方式。<code>git merge</code> 命令允许你将 <code>git branch</code> 创建的多条分支合并成一个。</p><p>注意，下面所有命令将更改 <em>并入</em> 当前分支。当前分支会被更新，以响应合并操作，但目标分支完全不受影响。也就是说 <code>git merge</code> 经常和 <code>git checkout</code> 一起使用，选择当前分支，然后用 <code>git branch -d</code> 删除废弃的目标分支。</p><h3 id="用法-21"><a href="#用法-21" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>将指定分支并入当前分支。Git 会决定使用哪种合并算法（下文讨论）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>将指定分支并入当前分支，但 <em>总是</em> 生成一个合并提交（即使是快速向前合并）。这可以用来记录仓库中发生的所有合并。</p><h3 id="讨论-21"><a href="#讨论-21" class="headerlink" title="讨论"></a>讨论</h3><p>一旦你在单独的分支上完成了功能的开发，重要的是将它放回主代码库。取决于你的仓库结构，Git 有几种不同的算法来完成合并：快速向前合并或者三路合并。</p><p>当当前分支顶端到目标分支路径是线性之时，我们可以采取 <strong>快速向前合并</strong> 。Git 只需要将当前分支顶端（快速向前地）移动到目标分支顶端，即可整合两个分支的历史，而不需要“真正”合并分支。它在效果上合并了历史，因为目标分支上的提交现在在当前分支可以访问到。比如，<code>some-feature</code> 到 <code>master</code> 分支的快速向前合并会是这样的：</p><p>但是，如果分支已经分叉了，那么就无法进行快速向前合并。当和目标分支之间的路径不是线性之时，Git 只能执行 <strong>三路合并</strong> 。三路合并使用一个专门的提交来合并两个分支的历史。这个术语取自这样一个事实，Git 使用 <em>三个</em> 提交来生成合并提交：两个分支顶端和它们共同的祖先。</p><p>但你可以选择使用哪一种合并策略时，很多开发者喜欢使用快速向前合并（搭配 rebase 使用）来合并微小的功能或者修复 bug，使用三路合并来整合长期运行的功能。后者导致的合并提交作为两个分支的连接标志。</p><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>如果你尝试合并的两个分支同一个文件的同一个部分，Git 将无法决定使用哪个版本。当这种情况发生时，它会停在合并提交，让你手动解决这些冲突。</p><p>Git 的合并流程令人称赞的一点是，它使用我们熟悉的「编辑&#x2F;缓存&#x2F;提交」工作流来解决冲突。当你遇到合并冲突时，运行 <code>git status</code> 命令来查看哪些文件存在需要解决的冲突。比如，如果两个分支都修改了 <code>hello.py</code> 的同一处，你会看到下面的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On branch master</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Unmerged paths:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(use <span class="string">&quot;git add/rm ...&quot;</span> as appropriate to mark resolution)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># both modified: hello.py</span></span></span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure><p>接下来，你可以自己修复这个合并。当你准备结束合并时，你只需对冲突的文件运行 <code>git add</code> 告诉 Git 冲突已解决。然后，运行 <code>git commit</code> 生成一个合并提交。这和提交一个普通的快照有着完全相同的流程，也就是说，开发者能够轻而易举地管理他们的合并。</p><p>注意，提交冲突只会出现在三路合并中。在快速向前合并中，我们不可能出现冲突的更改。</p><h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><h4 id="快速向前合并"><a href="#快速向前合并" class="headerlink" title="快速向前合并"></a>快速向前合并</h4><p>我们第一个例子演示了快速向前合并。下面的代码创建了一个分支，在后面添加了两个提交，然后使用快速向前合并将它并入主分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始新功能</span></span><br><span class="line">git checkout -b new-feature master</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑文件</span></span><br><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m &quot;开始新功能&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑文件</span></span><br><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m &quot;完成功能&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并new-feature分支</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge new-feature</span><br><span class="line">git branch -d new-feature</span><br></pre></td></tr></table></figure><p>对于临时存在、用作独立开发环境而不是组织长期运行功能的工具的分支来说，这是一种常见的工作流。</p><p>同时注意，运行 <code>git branch -d</code> 时 Git 不应该产生错误提示，因为 <code>new-feature</code> 现在可以在主分支上访问了。</p><h4 id="三路合并"><a href="#三路合并" class="headerlink" title="三路合并"></a>三路合并</h4><p>下一个例子很相似，但需要进行三路合并，因为 <code>master</code> 在这个功能开发时取得了新进展。这是复杂功能和多个开发者同时工作时常见的情形。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始新功能</span></span><br><span class="line">git checkout -b new-feature master</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑文件</span></span><br><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m &quot;开始新功能&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑文件</span></span><br><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m &quot;完成功能&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在master分支上开发</span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑文件</span></span><br><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m &quot;在master上添加了一些极其稳定的功能&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并new-feature分支</span></span><br><span class="line">git merge new-feature</span><br><span class="line">git branch -d new-feature</span><br></pre></td></tr></table></figure><p>注意，Git 现在无法进行快速向前合并，因为无法将 <code>master</code> 直接移动到 <code>new-feature</code>。</p><p>对大多数工作流来说，<code>new-feature</code> 会是一个需要一段时间来开发的复杂功能，这也是为什么同时 <code>master</code> 会有新的提交出现。如果你的分支上的功能像上面的一样简单，你会更想将它 rebase 到 <code>master</code>，使用快速向前合并。它会通过整理项目历史来避免多余的合并提交。</p><hr><h1 id="2-4-常见工作流比较"><a href="#2-4-常见工作流比较" class="headerlink" title="2.4 常见工作流比较"></a>2.4 常见工作流比较</h1><p>多种多样的工作流使得在项目中实施 Git 时变得难以选择。这份教程提供了一个出发点，调查企业团队最常见的 Git 工作流。</p><p>阅读的时候，请记住工作流应该是一种规范而不是金科玉律。我们希望向你展示所有工作流，让你融会贯通，因地制宜。</p><p>这份教程讨论了下面四种工作流：</p><ul><li>中心化的工作流</li><li>基于功能分支的工作流</li><li>Gitflow工作流</li><li>Fork工作流</li></ul><h2 id="中心化的工作流"><a href="#中心化的工作流" class="headerlink" title="中心化的工作流"></a>中心化的工作流</h2><p>过渡到分布式分版本控制系统看起来是个令人恐惧的任务，但你不必为了利用 Git 的优点而改变你现有的工作流。你的团队仍然可以用以前SVN的方式开发项目。</p><p>然而，使用 Git 来驱动你的开发工作流显示出了一些SVN没有的优点。首先，它让每个开发者都有了自己 <em>本地</em> 的完整项目副本。隔离的环境使得每个开发者的工作独立于项目的其它修改——他们可以在自己的本地仓库中添加提交，完全无视上游的开发，直到需要的时候。</p><p>第二，它让你接触到了 Git 鲁棒的分支和合并模型。和 SVN 不同，Git 分支被设计为一种故障安全的机制，用来在仓库之间整合代码和共享更改。</p><h2 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h2><p>和 Subversion 一样，中心化的工作流将中央仓库作为项目中所有修改的唯一入口。和 <code>trunk</code>  不同，默认的开发分支叫做<code>master</code>，所有更改都被提交到这个分支。这种工作流不需要 <code>master</code> 之外的其它分支。</p><p>开发者将中央仓库克隆到本地后开始工作。在他们的本地项目副本中，他们可以像SVN一样修改文件和提交更改；不过，这些新的提交被保存在 <em>本地</em> ——它们和中央仓库完全隔离。这使得开发者可以将和上游的同步推迟到他们方便的时候。</p><p>为了向官方项目发布修改，开发者将他们的本地 <code>master</code> 分支「推送」到中央仓库。这一步等同于 <code>svn commit</code>，除了Git添加的是所有不在中央 <code>master</code> 分支上的本地提交。</p><h3 id="管理冲突"><a href="#管理冲突" class="headerlink" title="管理冲突"></a>管理冲突</h3><p>中央仓库代表官方项目，因此它的提交历史应该被视作神圣不可更改的。如果开发者的本地提交和中央仓库分叉了，Git 会拒绝将他们的修改推送上去，因为这会覆盖官方提交。</p><p>在开发者发布他们的功能之前，他们需要 fetch 更新的中央提交，在它们之上 rebase 自己的更改。这就像是「我想要在其他人的工作进展之上添加我的修改」，它会产生完美的线性历史，就像和传统的 SVN 工作流一样。</p><p>如果本地修改和上游提交冲突时，Git 会暂停 rebase 流程，给你机会手动解决这些冲突。Git 很赞的一点是，它将 <code>git status</code> 和 <code>git add</code>命令同时用来生成提交和解决合并冲突。这使得开发者能够轻而易举地管理他们的合并。另外，如果他们改错了什么，Git 让他们轻易地退出 rebase 过程，然后重试（或者找人帮忙）。</p><h2 id="栗子-19"><a href="#栗子-19" class="headerlink" title="栗子"></a>栗子</h2><p>让我们一步步观察一个普通的小团队是如何使用这种工作流协作的。我们有两位开发者，John 和 Mary，分别在开发两个功能，他们通过中心化的仓库共享代码。</p><h3 id="一人初始化了中央仓库"><a href="#一人初始化了中央仓库" class="headerlink" title="一人初始化了中央仓库"></a>一人初始化了中央仓库</h3><p>首先，需要有人在服务器上创建中央仓库。如果这是一个新项目，你可以初始化一个空的仓库。不然，你需要导入一个已经存在的 Git 或 SVN 项目。</p><p>中央仓库应该永远是裸仓库（没有工作目录），可以这样创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@host git init --bare /path/to/repo.git</span><br></pre></td></tr></table></figure><p>但确保你使用的 SSH 用户名 <code>user</code>、服务器 <code>host</code> 的域名或 IP 地址、储存仓库的地址 <code>/path/to/repo.git</code> 是有效的。注意 <code>.git</code> 约定俗成地出现在仓库名的后面，表明这是一个裸仓库。</p><h3 id="所有人将仓库克隆到本地"><a href="#所有人将仓库克隆到本地" class="headerlink" title="所有人将仓库克隆到本地"></a>所有人将仓库克隆到本地</h3><p>接下来，每个开发者在本地创建一份完整项目的副本。使用 <a href="https://github.com/geeeeeeeeek/git-recipes/wiki/2.2-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93#git-clone"><code>git clone</code></a> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone ssh://user@host/path/to/repo.git</span><br></pre></td></tr></table></figure><p>当你克隆仓库时，Git 自动添加了一个名为 <code>origin</code> 的远程连接，指向「父」仓库，以便你以后和这个仓库交换数据。</p><h3 id="John-在开发他的功能"><a href="#John-在开发他的功能" class="headerlink" title="John 在开发他的功能"></a>John 在开发他的功能</h3><p>在他的本地仓库中，John 可以用标准的 Git 提交流程开发功能：编辑、缓存、提交。如果你对缓存区还不熟悉，你也可以不用记录工作目录中每次的变化。于是你创建了一个高度集中的提交，即使你已经在本地做了很多修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status # 查看仓库状态</span><br><span class="line">git add &lt;some-file&gt; # 缓存一个文件</span><br><span class="line">git commit # 提交一个文件&lt;/some-file&gt;</span><br></pre></td></tr></table></figure><p>记住，这些命令创建的是本地提交，John 可以周而复始地重复这个过程，而不用考虑中央仓库。对于庞大的功能，需要切成更简单、原子化的片段时，这个特性就很有用。</p><h3 id="Mary-在开发她的功能"><a href="#Mary-在开发她的功能" class="headerlink" title="Mary 在开发她的功能"></a>Mary 在开发她的功能</h3><p>同时，Mary 在她自己的本地仓库用相同的编辑&#x2F;缓存&#x2F;提交流程开发她的功能。和 John 一样，她不需要关心中央仓库的进展，她也 <em>完全</em> 不关心 John 在他自己仓库中做的事，因为所有本地仓库都是私有的。</p><h3 id="John-发布了他的功能"><a href="#John-发布了他的功能" class="headerlink" title="John 发布了他的功能"></a>John 发布了他的功能</h3><p>一旦 John 完成了他的功能，他应该将本地提交发布到中央仓库，这样其他项目成员就可以访问了。他可以使用<a href="https://github.com/geeeeeeeeek/git-recipes/wiki/3.2-%E4%BF%9D%E6%8C%81%E5%90%8C%E6%AD%A5#git-push"><code>git push</code></a>命令，就像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>记住，<code>origin</code> 是 John 克隆中央仓库时指向它的远程连接。<code>master</code> 参数告诉 Git 试着将 <code>origin</code> 的 <code>master</code> 分支变得和他本地的 <code>master</code> 分支一样。中央仓库在 John 克隆之后还没有进展，因此这个推送如他所愿，没有产生冲突。</p><h3 id="Mary-as试图发布她的功能"><a href="#Mary-as试图发布她的功能" class="headerlink" title="Mary as试图发布她的功能"></a>Mary as试图发布她的功能</h3><p>John 已经成功地将他的更改发布到了中央仓库上，看看当 Mary 试着将她的功能推送到上面时会发生什么。她可以使用同一个推送命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>但是，她的本地历史和中央仓库已经分叉了，Git 会拒绝这个请求，并显示一段冗长的错误信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to &#x27;/path/to/repo.git&#x27;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Merge the remote changes (e.g. &#x27;git pull&#x27;)</span><br><span class="line">hint: before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br></pre></td></tr></table></figure><p>Git 防止 Mary 覆盖官方的修改。她需要将 John 的更新拉取到她的仓库，和她的本地修改整合后，然后重试。</p><h3 id="Mary在John的提交之上rebase"><a href="#Mary在John的提交之上rebase" class="headerlink" title="Mary在John的提交之上rebase"></a>Mary在John的提交之上rebase</h3><p>Mary 可以使用 <code>git pull</code> 来将上游修改并入她的仓库。这个命令和 <code>svn update</code> 很像——它拉取整个上游提交历史到Mary的本地仓库，并和她的本地提交一起整合：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master</span><br></pre></td></tr></table></figure><p><code>--rebase</code> 选项告诉 Git，在同步了中央仓库的修改之后，将 Mary 所有的提交移到 <code>master</code> 分支的顶端</p><p>如果你忽略这个选项拉取同样会成功，只不过你每次和中央仓库同步时都会多出一个「合并提交」。在这种工作流中，rebase 和生成一个合并提交相比，总是一个更好的选择。</p><h3 id="Mary-解决了合并冲突"><a href="#Mary-解决了合并冲突" class="headerlink" title="Mary 解决了合并冲突"></a>Mary 解决了合并冲突</h3><p>Rebase 的工作是将每个本地提交一个个转移到更新后的 <code>master</code> 分支。也就是说，你可以一个个提交分别解决合并冲突，而不是在一个庞大的合并提交中解决。它会让你的每个提交保持专注，并获得一个干净的项目历史。另一方面，你更容易发现bug是在哪引入的，如果有必要的话，用最小的代价回滚这些修改。</p><p>如果 Mary 和 John 开发的功能没有关联，rebase的过程不太可能出现冲突。但如果出现冲突时，Git 在当前提交会暂停 rebase，输出下面的信息，和一些相关的指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFLICT (content): Merge conflict in &lt;some-file&gt;</span><br></pre></td></tr></table></figure><p>Git 的优点在于 <em>每个人</em> 都能解决他们自己的合并冲突。在这个例子中，Mary 只需运行一下 <a href="https://github.com/geeeeeeeeek/git-recipes/wiki/2.4-%E6%A3%80%E6%9F%A5%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81#git-status"><code>git status</code></a> 就可以发现问题是什么。冲突的文件会出现在未合并路径中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Unmerged paths:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(use <span class="string">&quot;git reset HEAD &lt;some-file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(use <span class="string">&quot;git add/rm &lt;some-file&gt;...&quot;</span> as appropriate to mark resolution)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># both modified: &lt;some-file&gt;</span></span></span><br></pre></td></tr></table></figure><p>接下来，修改这些文件。如果她对结果满意了，和往常一样缓存这些文件，然后让 <a href="https://github.com/geeeeeeeeek/git-recipes/wiki/2.7-%E9%87%8D%E5%86%99%E9%A1%B9%E7%9B%AE%E5%8E%86%E5%8F%B2#git-rebase"><code>git rebase</code></a> 完成接下来的工作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;some-file&gt;</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><p>就是这样。Git 会继续检查下个提交，对冲突的提交重复这个流程。</p><p>如果你这时候发现不知道自己做了什么，不要惊慌。只要运行下面的命令，你就会回到开始之前的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure><h3 id="Mary-成功发布了她的分支"><a href="#Mary-成功发布了她的分支" class="headerlink" title="Mary 成功发布了她的分支"></a>Mary 成功发布了她的分支</h3><p>在她和中央仓库同步之后，Mary 可以成功地发布她的修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h2 id="接下来该怎么做"><a href="#接下来该怎么做" class="headerlink" title="接下来该怎么做"></a>接下来该怎么做</h2><p>正如你所见，使用一丢丢 Git 命令来复制一套传统的 Subversion 开发环境也是可行的。这对于从 SVN 转变而来的团队来说很棒，但这样没有利用到 Git 分布式的本质。</p><p>如果你的团队已经习惯了中心化的工作流，但希望提高协作效率，那么探索 <code>Feature 分支工作流</code> 的好处是完全值当的。每个功能在专门的独立分支上进行，在代码并入官方项目之前就可以启动围绕新修改的深度讨论。</p><h2 id="Feature-分支的工作流"><a href="#Feature-分支的工作流" class="headerlink" title="Feature 分支的工作流"></a>Feature 分支的工作流</h2><p>一旦你掌握了 <code>中心化工作流的使用方法</code>，在你的开发流程中添加功能分支是一个简单的方式，来促进协作和开发者之间的交流。这种封装使得多个开发者专注自己的功能而不会打扰主代码库。它还保证 <code>master</code> 分支永远不会包含损坏的代码，给持续集成环境带来了是很大的好处。</p><p>封装功能的开发使得 <code>Pull Request</code> 的使用成为可能，用来启动围绕一个分支的讨论。它给了其他开发者在功能并入主项目之前参与决策的机会。或者，如果你开发功能时卡在一半，你可以发起一个 Pull Request，向同事寻求建议。重点是，Pull Request 使得你的团队在评论其他人的工作时变得非常简单。</p><h2 id="如何工作-1"><a href="#如何工作-1" class="headerlink" title="如何工作"></a>如何工作</h2><p>Feature 分支工作流同样使用中央仓库，<code>master</code> 同样代表官方的项目历史。但是，与其直接提交在本地的 <code>master</code> 分支，开发者每次进行新的工作时创建一个新的分支。Feature 分支应该包含描述性的名称，比如 <code>animated-menu-items</code>（菜单项动画）或 <code>issue-#1061</code>。每个分支都应该有一个清晰、高度集中的目的。</p><p>Git 在技术上无法区别 <code>master</code> 和功能分支，所以开发者可以在 feature 分支上编辑、缓存、提交，就和中心化工作流中一样。</p><p>此外，feature 分支可以（也应该）被推送到中央仓库。这使得你和其他开发者共享这个功能，而又不改变官方代码。既然 <code>master</code> 只是一个“特殊”的分支，在中央仓库中储存多个 feature 分支不会引出什么问题。当然了，这也是备份每个开发者本地提交的好办法。</p><h3 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h3><p>除了隔离功能开发之外，分支使得通过 <code>Pull Request</code> 讨论修改成为可能。一旦有人完成了一个功能，他们不会立即将它并入<code>master</code>。他们将 feature 分支推送到中央服务器上，发布一个 Pull Request，请求将他们的修改并入 <code>master</code>。这给了其他开发者在修改并入主代码库之前审查的机会。</p><p>代码审查是 Pull Request 的主要好处，但他们事实上被设计为成为讨论代码的一般场所。你可以把 Pull Request 看作是专注某个分支的讨论版。也就是说他们可以用于开发流程之前。比如，一个开发者在某个功能上需要帮助，他只需发起一个 Pull Request。感兴趣的小伙伴会自动收到通知，看到相关提交中的问题。</p><p>一旦 Pull Request 被接受了，发布功能的行为和中心化的工作流是一样的。首先，确定你本地的 <code>master</code> 和上游的 <code>master</code> 已经同步。然后，将  feature分支并入 <code>master</code>，将更新的 <code>master</code> 推送回中央仓库。</p><h2 id="栗子-20"><a href="#栗子-20" class="headerlink" title="栗子"></a>栗子</h2><p>下面这🌰演示了代码审查使用到的 Pull Request，但记住 Pull Request 有多种用途。</p><h3 id="Mary-开始了一个新功能"><a href="#Mary-开始了一个新功能" class="headerlink" title="Mary 开始了一个新功能"></a>Mary 开始了一个新功能</h3><p>在她开始开发一个功能之前，Mary 需要一个独立的分支。她可以用下面的命令<code>创建新分支</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b marys-feature master</span><br></pre></td></tr></table></figure><p>一个基于 <code>master</code>、名为 <code>marys-feature</code> 的分支将会被checkout，<code>-b</code> 标记告诉Git在分支不存在时创建它。在这个分支上，Mary和往常一样编辑、缓存、提交更改，用足够多的提交来构建这个功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git add &lt;some-file&gt;</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><h3 id="Mary-去吃饭了"><a href="#Mary-去吃饭了" class="headerlink" title="Mary 去吃饭了"></a>Mary 去吃饭了</h3><p>Mary 在早上给她的功能添加了一些提交。在她去吃午饭前，<code>将她的分支推送到中央仓库</code>是个不错的想法。这是一种方便的备份，但如果Mary和其他开发者一起协作，他们也可以看到她的初始提交了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin marys-feature</span><br></pre></td></tr></table></figure><p>这个命令将 <code>marys-feature</code> 推送到中央仓库（<code>origin</code>），<code>-u</code> 标记将它添加为远程跟踪的分支。在设置完跟踪的分支之后，Mary 调用不带任何参数的 <code>git push</code> 来推送她的功能。</p><h3 id="Mary-完成了她的工作"><a href="#Mary-完成了她的工作" class="headerlink" title="Mary 完成了她的工作"></a>Mary 完成了她的工作</h3><p>当 Mary 吃完午饭回来，她完成了她的功能。在 并入 <code>master</code> 之前，她需要发布一个 Pull Request，让其他的团队成员知道她所做的工作。但首先，她应该保证中央仓库包含了她最新的提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p>然后，她在她的 Git 界面上发起了一个 Pull Request，请求将 <code>marys-feature</code> 合并进 <code>master</code>，团队成员会收到自动的通知。Pull Request 的好处是，评论显示在相关的提交正下方，方便讨论特定的修改。</p><h3 id="Bill-收到了-Pull-Request"><a href="#Bill-收到了-Pull-Request" class="headerlink" title="Bill 收到了 Pull Request"></a>Bill 收到了 Pull Request</h3><p>Bill 收到了 Pull Request，并且查看了 <code>marys-feature</code>。他决定在并入官方项目之前做一些小修改，通过 Pull Request 和 Mary 进行了沟通。</p><h3 id="Mary-作了修改"><a href="#Mary-作了修改" class="headerlink" title="Mary 作了修改"></a>Mary 作了修改</h3><p>为了做这些更改，Mary 重复了之前创建功能时相同的流程，她编辑、缓存、提交、将更新推送到中央仓库。她所有的活动显示在 Pull Request 中，Bill 可以一直评论。</p><p>如果 Bill 想要的话，也可以将 <code>marys-feature</code> 分支 pull 到他自己的本地仓库，继续工作。后续的任何提交都会显示在 Pull Request 上。</p><h3 id="Mary-发布了她的功能"><a href="#Mary-发布了她的功能" class="headerlink" title="Mary 发布了她的功能"></a>Mary 发布了她的功能</h3><p>一旦 Bill 准备接受这个 Pull Request，某个人（Bill 或者 Mary 都可）需要将功能并入稳定的项目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line">git pull origin marys-feature</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>首先，不管是谁在执行合并，都要保证他们的 <code>master</code> 分支是最新的。然后，运行 <code>git pull origin marys-feature</code> 合并中央仓库的 <code>marys-feature</code> 副本。你也可以使用简单的 <code>git merge marys-feature</code>，但之前的命令保证你拉取下来的一定是功能分支最新的版本。最后，更新的 <code>master</code> 需要被推送回 <code>origin</code>。</p><p>这个过程导致了一个合并提交。一些开发者喜欢它，因为它是功能和其余代码合并的标志。但，如果你希望得到线性的历史，你可以在执行 merge 之前将功能 rebase 到 <code>master</code> 分支的顶端，产生一个快速向前的合并。</p><p>一些界面会自动化接受 Pull Request 的流程，只需点击一下「Merge Pull Request」。如果你的没有的话，它至少在合并之后应该可以自动地关闭 Pull Request。</p><h3 id="同时，John-以同样的方式工作着"><a href="#同时，John-以同样的方式工作着" class="headerlink" title="同时，John 以同样的方式工作着"></a>同时，John 以同样的方式工作着</h3><p>Mary 和 Bill 一起开发 <code>marys-feature</code>，在 Pull Request 上讨论的同时，John 还在开发他自己的  feature分支。通过将功能用不同分支隔离开来，每个人可以独立地工作，但很容易和其他开发者共享修改。</p><h2 id="接下来该怎么做-1"><a href="#接下来该怎么做-1" class="headerlink" title="接下来该怎么做"></a>接下来该怎么做</h2><p>为了彻底了解 GitHub 上的功能分支，你应该查看<code>使用分支一章</code>。现在，你应该已经看到了功能分支极大地增强了<code>中心化工作流</code>中单一 <code>master</code> 分支的作用。除此之外，功能分支还便利了 Pull Request 的使用，在版本控制界面上直接讨论特定的提交。GitFlow 工作流是管理功能开发、发布准备、维护的常见模式。</p><h2 id="GitFlow-工作流"><a href="#GitFlow-工作流" class="headerlink" title="GitFlow 工作流"></a>GitFlow 工作流</h2><p>下面的 [GitFlow 工作流]源于 <a href="http://nvie.com/">nvie</a> 网站上的作者 Vincent Driessen。</p><p>GitFlow 工作流围绕项目发布定义了一个严格的分支模型。有些地方比[功能分支工作流]更复杂，为管理大型项目提供了鲁棒的框架。</p><p>和功能分支工作流相比，这种工作流没有增加任何新的概念或命令。它给不同的分支指定了特定的角色，定义它们应该如何、什么时候交流。除了功能分支之外，它还为准备发布、维护发布、记录发布分别使用了单独的分支。当然，你还能享受到功能分支工作流带来的所有好处：Pull Request、隔离实验和更高效的协作。</p><h2 id="如何工作-2"><a href="#如何工作-2" class="headerlink" title="如何工作"></a>如何工作</h2><p>GitFlow 工作流仍然使用中央仓库作为开发者沟通的中心。和[其他工作流]一样，开发者在本地工作，将分支推送到中央仓库。唯一的区别在于项目的分支结构。</p><h3 id="历史分支"><a href="#历史分支" class="headerlink" title="历史分支"></a>历史分支</h3><p>和单独的 <code>master</code> 分支不同，这种工作流使用两个分支来记录项目历史。<code>master</code> 分支储存官方发布历史，<code>develop</code> 分支用来整合功能分支。同时，这还方便了在 <code>master</code> 分支上给所有提交打上版本号标签。</p><p>工作流剩下的部分围绕这两个分支的差别展开。</p><h3 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h3><p>每个新功能都放置在自己的分支中，可以[在备份&#x2F;协作时推送到中央仓库]。但是，与其合并到 <code>master</code>，功能分支将开发分支作为父分支。当一个功能完成时，它将被[合并回 <code>develop</code>。功能永远不应该直接在 <code>master</code> 上交互。</p><p>注意，功能分支加上 <code>develop</code> 分支就是我们之前所说的功能分支工作流。但是，GitFlow 工作流不止于此。</p><h3 id="发布分支"><a href="#发布分支" class="headerlink" title="发布分支"></a>发布分支</h3><p>一旦  <code>develop</code>分支的新功能足够发布（或者预先确定的发布日期即将到来），你可以从 <code>develop</code> 分支 fork 一个发布分支。这个分支的创建开始了下个发布周期，只有和发布相关的任务应该在这个分支进行，如修复 bug、生成文档等。一旦准备好了发布，发布分支将合并进 <code>master</code>，打上版本号的标签。另外，它也应该合并回 <code>develop</code>，后者可能在发布启动之后有了新的进展。</p><p>使用一个专门的分支来准备发布确保一个团队完善当前的发布，其他团队可以继续开发下一个发布的功能。它还建立了清晰的开发阶段（比如说，「这周我们准备 4.0 版本的发布」，而我们在仓库的结构中也能看到这个阶段）。</p><p>通常我们约定：</p><ul><li>从 <code>develop</code> 创建分支</li><li>合并进 <code>master</code> 分支</li><li>命名规范 <code>release-* or release/*</code></li></ul><h3 id="维护分支"><a href="#维护分支" class="headerlink" title="维护分支"></a>维护分支</h3><p>维护或者「紧急修复」分支用来快速给产品的发布打上补丁。这是唯一可以从 <code>master</code> 上 fork 的分支。一旦修复完成了，它应该被并入 <code>master</code> 和 <code>develop</code> 分支（或者当前的发布分支），<code>master</code> 应该打上更新的版本号的标签。</p><p>有一个专门的 bug 修复开发线使得你的团队能够处理 issues，而不打断其他工作流或是要等到下一个发布周期。你可以将维护分支看作在 <code>master</code> 分支上工作的临时发布分支。</p><h2 id="栗子-21"><a href="#栗子-21" class="headerlink" title="栗子"></a>栗子</h2><p>下面的栗子演示了这种工作流如何用来管理发布周期。假设你已经创建了中央仓库。</p><h3 id="创建一个开发分支"><a href="#创建一个开发分支" class="headerlink" title="创建一个开发分支"></a>创建一个开发分支</h3><p>你要做的第一步是为默认的 <code>master</code> 分支创建一个互补的 <code>develop</code> 分支。最简单的办法是[在本地创建一个空的 develop 分支]，将它推送到服务器上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch develop</span><br><span class="line">git push -u origin develop</span><br></pre></td></tr></table></figure><p>这个分支将会包含项目中所有的历史，而 <code>master</code> 将包含不完全的版本。其他开发者应该[将中央仓库克隆到本地]，创建一个分支来追踪 develop 分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone ssh://user@host/path/to/repo.git</span><br><span class="line">git checkout -b develop origin/develop</span><br></pre></td></tr></table></figure><p>现在所有人都有了一份历史分支的本地副本。</p><h3 id="Mary-和-John-开始了新功能"><a href="#Mary-和-John-开始了新功能" class="headerlink" title="Mary 和 John 开始了新功能"></a>Mary 和 John 开始了新功能</h3><p>我们的栗子从 John 和 Mary 在不同分支上工作开始。他们都要为自己的功能创建单独的分支。[他们的功能分支都应该基于<code>develop</code>]，而不是 <code>master</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b some-feature develop</span><br></pre></td></tr></table></figure><p>他们都使用「编辑、缓存、提交」的一般约定来向功能分支添加提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git add &lt;some-file&gt;</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><h3 id="Mary-完成了她的功能"><a href="#Mary-完成了她的功能" class="headerlink" title="Mary 完成了她的功能"></a>Mary 完成了她的功能</h3><p>在添加了一些提交之后，Mary 确信她的功能以及准备好了。如果她的团队使用 Pull Request，现在正是发起 Pull Request 的好时候，请求将她的功能并入 <code>develop</code> 分支。否则，她可以向下面一样，将它并入本地的 <code>develop</code> 分支，推送到中央仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git pull origin develop</span><br><span class="line">git checkout develop</span><br><span class="line">git merge some-feature</span><br><span class="line">git push</span><br><span class="line">git branch -d some-feature</span><br></pre></td></tr></table></figure><p>第一个命令在尝试并入功能分支之前确保 <code>develop</code> 分支已是最新。注意，功能绝不该被直接并入 <code>master</code>。冲突的处理方式和[中心化工作流]相同。</p><h3 id="Mary-开始准备发布"><a href="#Mary-开始准备发布" class="headerlink" title="Mary 开始准备发布"></a>Mary 开始准备发布</h3><p>当 John 仍然在他的功能分支上工作时，Mary s开始准备项目的第一个官方发布。和开发功能一样，她新建了一个分支来封装发布的准备工作。这也正是发布的版本号创建的一步：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b release-0.1 develop</span><br></pre></td></tr></table></figure><p>这个分支用来整理提交，充分测试，更新文档，为即将到来的发布做各种准备。它就像是一个专门用来完善发布的功能分支。</p><p>一旦 Mary 创建了这个分支，推送到中央仓库，这次发布的功能便被锁定了。不在 <code>develop</code> 分支中的功能将被推迟到下个发布周期。</p><h3 id="Mary完成了她的发布"><a href="#Mary完成了她的发布" class="headerlink" title="Mary完成了她的发布"></a>Mary完成了她的发布</h3><p>一旦发布准备稳妥，Mary 将它并入 <code>master</code> 和 <code>develop</code>，然后删除发布分支。合并回 <code>develop</code> 很重要，因为可能已经有关键的更新添加到了发布分支上，而开发新功能需要用到它们。同样的，如果 Mary 的团队重视代码审查，现在将是发起 Pull Request 的完美时机。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge release-0.1</span><br><span class="line">git push</span><br><span class="line">git checkout develop</span><br><span class="line">git merge release-0.1</span><br><span class="line">git push</span><br><span class="line">git branch -d release-0.1</span><br></pre></td></tr></table></figure><p>发布分支是功能开发（<code>develop</code>）和公开发布（<code>master</code>）之间的过渡阶段。不论什么时候将提交并入 <code>master</code> 时，你应该为提交打上方便引用的标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -a 0.1 -m &quot;Initial public release&quot; master</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p>Git 提供了许多钩子，即仓库中特定事件发生时被执行的脚本。当你向中央仓库推送 <code>master</code> 分支或者标签时，你可以配置一个钩子来自动化构建公开发布。</p><h3 id="终端用户发现了一个-bug"><a href="#终端用户发现了一个-bug" class="headerlink" title="终端用户发现了一个 bug"></a>终端用户发现了一个 bug</h3><p>正式发布之后，Mary 回过头来和 John 一起为下一个发布开发功能。这时，一个终端用户开了一个 issue 抱怨说当前发布中存在一个 bug。为了解决这个 bug，Mary（或 John）从 <code>master</code> 创建了一个维护分支，用几个提交修复这个 issue，然后直接合并回 <code>master</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b issue-#001 master</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Fix the bug</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge issue-#001</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>和发布分支一样，维护分支包含了 <code>develop</code> 中需要的重要更新，因此 Mary 同样需要执行这个合并。接下来，她可以[删除这个分支]了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line">git merge issue-#001</span><br><span class="line">git push</span><br><span class="line">git branch -d issue-#001</span><br></pre></td></tr></table></figure><h2 id="接下来该怎么做-2"><a href="#接下来该怎么做-2" class="headerlink" title="接下来该怎么做"></a>接下来该怎么做</h2><p>现在，希望你已经很熟悉[中心化的工作流]、[功能分支工作流]和 GitFlow 工作流。你应该已经可以抓住本地仓库、推送&#x2F;拉取模式，和 Git 鲁棒的分支和合并模型的无限潜力。</p><p>请记住，教程中呈现的工作流只是可行的实践——而非工作中使用 Git 的金科玉律。因此，尽情地取其精华，去其糟粕吧。不变的是要让 Git 为你所用，而不是相反。</p><h2 id="Fork-工作流"><a href="#Fork-工作流" class="headerlink" title="Fork 工作流"></a>Fork 工作流</h2><p>Fork 工作流和教程中讨论的其它工作流截然不同。与其使用唯一的服务端仓库作为「中央」代码库，它给予 <em>每个</em> 开发者一个服务端仓库。也就是说每个贡献者都有两个 Git 仓库，而不是一个：一个私有的本地仓库和一个公开的服务端仓库。</p><p>Fork 工作流的主要优点在于贡献可以轻易地整合进项目，而不需要每个人都推送到单一的中央仓库。开发者推送到他们 <em>自己的</em> 服务端仓库，只有项目管理者可以推送到官方仓库。这使得管理者可以接受任何开发者的提交，却不需要给他们中央仓库的权限。</p><p>结论是，这种分布式的工作流为大型、组织性强的团队（包括不可信的第三方）提供了安全的协作方式。它同时也是开源项目理想的工作流。</p><h2 id="如何工作-3"><a href="#如何工作-3" class="headerlink" title="如何工作"></a>如何工作</h2><p>和其它 Git 工作流一样，Fork 工作流以一个储存在服务端的官方公开项目开场。但新的开发者想参与项目时，他们不直接克隆官方项目。</p><p>取而代之地，他们 fork 一份官方项目，在服务端创建一份副本。这份新建的副本作为他们私有的公开仓库——没有其他开发者可以在上面推送，但他们可以从上面拉取修改（在后面我们会讨论为什么这一点很重要）。在他们创建了服务端副本之后，开发者执行 <code>git clone</code> 操作，在他们的本地机器上复制一份。这是他们私有的开发环境，正如其他工作流中一样。</p><p>当他们准备好发布本地提交时，他们将提交推送到自己的公开仓库——而非官方仓库。然后，他们向主仓库发起一个 Pull Request，让项目维护者知道一个更新做好了合并的准备。如果贡献的代码有什么问题的话，Pull Request 可以作为一个方便的讨论版。</p><p>我为了将功能并入官方代码库，维护者将贡献者的修改拉取到他们的本地仓库，确保修改不会破坏项目，将它[合并到本地的 master 分支，然后将 <code>master</code> 分支[推送]到服务端的官方仓库。贡献现在已是项目的一部分，其他开发者应该从官方仓库拉取并同步他们的本地仓库。</p><h3 id="中央仓库"><a href="#中央仓库" class="headerlink" title="中央仓库"></a>中央仓库</h3><p>「官方」仓库这个概念在 Fork 工作流中只是一个约定，理解这一点很重要。从技术的角度，Git 并看不出每个开发者和官方的公开仓库有什么区别。事实上，官方仓库唯一官方的原因是，它是项目维护者的仓库。</p><h3 id="Fork-工作流中的分支"><a href="#Fork-工作流中的分支" class="headerlink" title="Fork 工作流中的分支"></a>Fork 工作流中的分支</h3><p>所有这些个人的公开仓库只是一个在开发者之间共享分支的约定。每个人仍然可以使用分支来隔离功能，就像在[功能分支工作流] 和 [GitFlow 工作流中]一样。唯一的区别在于这些分支是如何开始的。在 Fork 工作流中，它们从另一个开发者的本地仓库拉取而来，而在功能分支和 GitFlow 分支它们被推送到官方仓库。</p><h2 id="栗子-22"><a href="#栗子-22" class="headerlink" title="栗子"></a>栗子</h2><h3 id="项目维护者初始化了中央仓库"><a href="#项目维护者初始化了中央仓库" class="headerlink" title="项目维护者初始化了中央仓库"></a>项目维护者初始化了中央仓库</h3><p>和任何基于 Git 的项目一样，第一步是在服务端创建一个可以被所有项目成员访问到的官方仓库。一般来说，这个仓库同时还是项目维护者的公开仓库。</p><p>[公开的仓库应该永远是裸的]，不管它们是否代表官方代码库。所以项目维护者应该运行下面这样的命令来设置官方仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh user@host</span><br><span class="line">git init --bare /path/to/repo.git</span><br></pre></td></tr></table></figure><p>GitHub 同时提供了一个图形化界面来替代上面的操作。这和教程中其它工作流设置中央仓库的流程完全一致。如果有必要的话，项目维护者应该将已有的代码库推送到这个仓库中。</p><h3 id="开发者-fork-仓库"><a href="#开发者-fork-仓库" class="headerlink" title="开发者 fork 仓库"></a>开发者 fork 仓库</h3><p>接下来，所有开发者需要 fork 官方仓库。你可以用 SSH 到服务器，运行 <code>git clone</code> 将它复制到服务器的另一个地址—— fork 其实只是服务端的 clone。但同样地，GitHub上开发者只需点一点按钮就可以 fork 仓库。</p><p>在这步之后，每个开发者应该都有了自己的服务端仓库。像官方仓库一样，所有这些仓库都应该是裸仓库。</p><h3 id="开发者将-fork-的仓库克隆到本地"><a href="#开发者将-fork-的仓库克隆到本地" class="headerlink" title="开发者将 fork 的仓库克隆到本地"></a>开发者将 fork 的仓库克隆到本地</h3><p>接下来开发者需要克隆他们自己的公开仓库。他们可以用熟悉的 <code>git clone</code> 命令来完成这一步。</p><p>我们的栗子假设使用他们使用 GitHub 来托管仓库。记住，在这种情况下，每个开发者应该有他们自己的 GitHub 账号，应该用下面的命令克隆服务端仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://user@github.com/user/repo.git</span><br></pre></td></tr></table></figure><p>而教程中的其他工作流使用单一的 <code>origin</code> 远程连接，指向中央仓库，Fork 工作流需要两个远程连接，一个是中央仓库，另一个是开发者个人的服务端仓库。你可以给这些远端取任何名字，约定的做法是将 <code>origin</code> 作为你 fork 后的仓库的远端（运行 <code>git clone</code> 是会自动创建）和 <code>upstream</code> 作为官方项目。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream https://github.com/maintainer/repo</span><br></pre></td></tr></table></figure><p>你需要使用上面的命令来创建上游仓库的远程连接。它使得你轻易地保持本地仓库和官方仓库的进展同步。注意如果你的上游仓库开启了认证（比如它没有开源），你需要提供一个用户名，就像这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream https://user@bitbucket.org/maintainer/repo.git</span><br></pre></td></tr></table></figure><p>它需要用户从官方代码库克隆或拉取之前提供有效的密码。</p><h3 id="开发者进行自己的开发"><a href="#开发者进行自己的开发" class="headerlink" title="开发者进行自己的开发"></a>开发者进行自己的开发</h3><p>在他们刚克隆的本地仓库中，开发者可以编辑代码、[提交更改]，和其它分支中一样[创建分支]：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b some-feature</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑代码</span></span><br><span class="line">git commit -a -m &quot;Add first draft of some feature&quot;</span><br></pre></td></tr></table></figure><p>他们所有的更改在推送到公开仓库之前都是完全私有的。而且，如果官方项目已经向前进展了，他们可以用 <code>git pull</code> 获取新的提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull upstream master</span><br></pre></td></tr></table></figure><p>因为开发者应该在专门的功能分支开发，这一般会[产生一个快速向前的合并]</p><h3 id="开发者发布他们的功能"><a href="#开发者发布他们的功能" class="headerlink" title="开发者发布他们的功能"></a>开发者发布他们的功能</h3><p>一旦开发者准备好共享他们的新功能，他们需要做两件事情。第一，他们必须将贡献的代码推送到自己的公开仓库，让其他开发者能够访问到。他们的 <code>origin</code> 远端应该已经设置好了，所以他们只需要：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin feature-branch</span><br></pre></td></tr></table></figure><p>这和其他工作流不同之处在于，<code>origin</code> 远端指向开发者个人的服务端仓库，而不是主代码库。</p><p>第二，他们需要通知项目维护者，他们想要将功能并入官方代码库。GitHub 提供了一个「New Pull Request」按钮，跳转到一个网页，让你指明想要并入主仓库的分支。一般来说，你希望将功能分支并入上游远端的 <code>master</code> 分支。</p><h3 id="项目维护者整合他们的功能"><a href="#项目维护者整合他们的功能" class="headerlink" title="项目维护者整合他们的功能"></a>项目维护者整合他们的功能</h3><p>当项目维护者收到 Pull Request 时，他们的工作是决定是否将它并入官方的代码库。他们可以使用下面两种方式之一：</p><ol><li>直接检查 Pull Request 中检查代码</li><li>将代码拉取到本地仓库然后手动合并</li></ol><p>第一个选项更简单，让维护者查看修改前后的差异，在上面评论，然后通过图形界面执行合并。然而，如果 Pull Request 会导致合并冲突，第二个选项就有了必要。在这个情况中，维护者需要从开发者的服务端仓库 fetch 功能分支，合并到他们本地的 <code>master</code> 分支，然后解决冲突：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch https://bitbucket.org/user/repo feature-branch</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查修改</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge FETCH_HEAD</span><br></pre></td></tr></table></figure><p>一旦修改被整合进本地的 <code>master</code>，维护者需要将它推送到服务器上的官方仓库，这样其他开发者也可以访问它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>记住，维护者的 <code>origin</code> 指向他们的公开仓库，也就是项目的官方代码库。开发者的贡献现在完全并入了项目。</p><h3 id="开发者和中央仓库保持同步"><a href="#开发者和中央仓库保持同步" class="headerlink" title="开发者和中央仓库保持同步"></a>开发者和中央仓库保持同步</h3><p>因为主代码库已经取得了新的进展，其他开发者应该和官方仓库同步：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull upstream master</span><br></pre></td></tr></table></figure><h2 id="接下来该怎么做-3"><a href="#接下来该怎么做-3" class="headerlink" title="接下来该怎么做"></a>接下来该怎么做</h2><p>如果你从 SVN 迁移而来，Fork 工作流看上去是一个比较大的转变。但不要害怕——它只是在 Feature 分支工作流之上引入了一层抽象。贡献的代码发布到开发者在服务端自己的仓库，而不是在唯一的中央仓库中直接共享分支。</p><p>这篇文章解释了一次代码贡献是如何从一个开发者流入官方的 <code>master</code> 分支的，但相同的方法可以用在将代码贡献整合进任何仓库。比如，如果你团队的一部分成员在一个特定功能上协作，他们可以用自己约定的行为共享修改——而不改变主仓库。</p><p>这使得 Fork 工作流对于松散的团队来说是个非常强大的工具。任何开发者都可以轻而易举地和其他开发者共享修改，任何分支都能高效地并入主代码库。</p><hr><h1 id="3-1-Git图解"><a href="#3-1-Git图解" class="headerlink" title="3.1 Git图解"></a>3.1 Git图解</h1><p><img src="/img/git1.png"></p><p>此页图解 git 中的最常用命令。如果你稍微理解 git 的工作原理，这篇文章能够让你理解的更透彻。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>上面的四条命令在工作目录、stage 缓存(也叫做索引)和 commit 历史之间复制文件。</p><ul><li><code>git add files</code> 把工作目录中的文件加入 stage 缓存</li><li><code>git commit</code> 把 stage 缓存生成一次 commit，并加入 commit 历史</li><li><code>git reset -- files</code> 撤销最后一次 <code>git add files</code>，你也可以用 <code>git reset</code> 撤销所有 stage 缓存文件</li><li><code>git checkout -- files</code> 把文件从 stage 缓存复制到工作目录，用来丢弃本地修改</li></ul><p>你可以用 <code>git reset -p</code>、<code>git checkout -p</code> 或 <code>git add -p</code> 进入交互模式，也可以跳过 stage 缓存直接从  commit历史取出文件或者直接提交代码。</p><ul><li><code>git commit -a </code> 相当于运行 <code>git add</code> 把所有当前目录下的文件加入 stage 缓存再运行 <code>git commit</code>。</li><li><code>git commit files</code> 进行一次包含最后一次提交加上工作目录中文件快照的提交，并且文件被添加到 stage 缓存。</li><li><code>git checkout HEAD -- files</code> 回滚到复制最后一次提交。</li></ul><h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><h3 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h3><p>有许多种方法查看两次提交之间的变动，下面是其中一些例子。</p><h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><p>提交时，Git 用 stage 缓存中的文件创建一个新的提交，并把此时的节点设为父节点。然后把当前分支指向新的提交节点。当前分支是 <code>_master_</code>。</p><p>在运行命令之前，<code>_master_</code> 指向 <code>_ed489_</code>，提交后，<code>_master_</code> 指向新的节点<code>_f0cec_</code> 并以 <code>_ed489_</code> 作为父节点。</p><p>即便当前分支是某次提交的祖父节点，Git 会同样操作。</p><p>这样，<code>_maint_ </code>分支就不再是 <code>_master_</code> 分支的祖父节点。此时，[merge] 或者 [rebase] 是必须的。</p><p>如果想更改一次提交，使用 <code>git commit --amend</code>。Git 会使用与当前提交相同的父节点进行一次新提交，旧的提交会被取消。</p><p>另一个例子是[分离HEAD提交]，在后面的章节中介绍。</p><h3 id="Checkout"><a href="#Checkout" class="headerlink" title="Checkout"></a>Checkout</h3><p><code>git checkout</code> 命令用于从历史提交（或者 stage 缓存）中拷贝文件到工作目录，也可用于切换分支。</p><p>当给定某个文件名（或者打开 <code>-p</code> 选项，或者文件名和-p选项同时打开）时，Git 会从指定的提交中拷贝文件到 stage 缓存和工作目录。比如，<code>git checkout HEAD~ foo.c</code> 会将提交节点 <code>_HEAD~_</code>（即当前提交节点的父节点）中的 <code>foo.c</code> 复制到工作目录并且加到 stage 缓存中。如果命令中没有指定提交节点，则会从 stage 缓存中拷贝内容。注意当前分支不会发生变化。</p><p>当不指定文件名，而是给出一个（本地）分支时，那么 <code>_HEAD_</code> 标识会移动到那个分支（也就是说，我们「切换」到那个分支了），然后 stage 缓存和工作目录中的内容会和 <code>_HEAD_</code> 对应的提交节点一致。新提交节点中的所有文件都会被复制（到 stage 缓存和工作目录中）；只存在于老的提交节点（<code>ed489</code>）中的文件会被删除；不属于上述两者的文件会被忽略，不受影响。</p><p>如果既没有指定文件名，也没有指定分支名，而是一个标签、远程分支、SHA-1 值或者是像 <code>_master~3_</code> 类似的东西，就得到一个匿名分支，称作 <code>_detached HEAD_</code>（被分离的 <code>_HEAD_</code> 标识）。这样可以很方便地在历史版本之间互相切换。比如说你想要编译 1.6.6.1 版本的 Git，你可以运行 <code>git checkout v1.6.6.1</code>（这是一个标签，而非分支名），编译，安装，然后切换回另一个分支，比如说 <code>git checkout master</code>。然而，当提交操作涉及到「分离的 HEAD」时，其行为会略有不同，详情见在下面。</p><h3 id="HEAD-标识处于分离状态时的提交操作"><a href="#HEAD-标识处于分离状态时的提交操作" class="headerlink" title="HEAD 标识处于分离状态时的提交操作"></a>HEAD 标识处于分离状态时的提交操作</h3><p>当 <code>_HEAD_</code> 处于分离状态（不依附于任一分支）时，提交操作可以正常进行，但是不会更新任何已命名的分支。你可以认为这是在更新一个匿名分支。</p><p>一旦此后你切换到别的分支，比如说 <code>_master_</code>，那么这个提交节点（可能）再也不会被引用到，然后就会被丢弃掉了。注意这个命令之后就不会有东西引用 <code>_2eecb_</code>。</p><p>但是，如果你想保存这个状态，可以用命令 <code>git checkout -b name</code> 来创建一个新的分支。</p><h3 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h3><p><code>git reset</code> 命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史commit历史中复制文件到索引，而不动工作目录。</p><p>如果不给选项，那么当前分支指向到那个提交。如果用 <code>--hard</code> 选项，那么工作目录也更新，如果用 <code>--soft</code> 选项，那么都不变。</p><p>如果没有给出提交点的版本号，那么默认用 <code>_HEAD_</code>。这样，分支指向不变，但是索引会回滚到最后一次提交，如果用 <code>--hard</code> 选项，工作目录也同样。</p><p>如果给了文件名(或者 <code>-p</code> 选项), 那么工作效果和带文件名的<a href="#checkout">checkout</a>差不多，除了索引被更新。</p><h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p><code>git merge</code> 命令把不同分支合并起来。合并前，索引必须和当前提交相同。如果另一个分支是当前提交的祖父节点，那么合并命令将什么也不做。</p><p>另一种情况是如果当前提交是另一个分支的祖父节点，就导致 <code>_fast-forward_</code> 合并。指向只是简单的移动，并生成一个新的提交。</p><p>否则就是一次真正的合并。默认把当前提交（<code>_ed489_</code> 如下所示）和另一个提交（<code>_33104_</code>）以及他们的共同祖父节点（<code>_b325c_</code>）进行一次<code>三方合并</code>。结果是先保存当前目录和索引，然后和父节点 <code>_33104_</code> 一起做一次新提交。</p><h3 id="Cherry-Pick"><a href="#Cherry-Pick" class="headerlink" title="Cherry Pick"></a>Cherry Pick</h3><p><code>git cherry-pick</code> 命令「复制」一个提交节点并在当前分支做一次完全一样的新提交。</p><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p><code>git rebase</code> 是合并命令的另一种选择。合并把两个父分支合并进行一次提交，提交历史不是线性的。rebase 在当前分支上重演另一个分支的历史，提交历史是线性的。</p><p>本质上，这是线性化的自动的 <a href="#cherry-pick">cherry-pick</a>。</p><p>上面的命令都在 <code>_topic_</code> 分支中进行，而不是 <code>_master_</code> 分支，在 <code>_master_</code> 分支上重演，并且把分支指向新的节点。注意旧提交没有被引用，将被回收。</p><p>要限制回滚范围，使用 <code>--onto</code> 选项。下面的命令在 <code>_master_</code> 分支上重演当前分支从 <code>_169a6_</code> 以来的最近几个提交，即 <code>_2c33a_</code>。</p><p>同样有 <code>git rebase --interactive</code> 让你更方便的完成一些复杂操作，比如丢弃、重排、修改、合并提交。</p><hr><h1 id="4-1-代码合并：Merge、Rebase-的选择"><a href="#4-1-代码合并：Merge、Rebase-的选择" class="headerlink" title="4.1 代码合并：Merge、Rebase 的选择"></a>4.1 代码合并：Merge、Rebase 的选择</h1><p><code>git rebase</code> 这个命令经常被人认为是一种 Git 巫术，初学者应该避而远之。但如果使用得当的话，它能给你的团队开发省去太多烦恼。在这篇文章中，我们会比较 <code>git rebase</code> 和类似的 <code>git merge</code> 命令，找到 Git 工作流中 rebase 的所有用法。</p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>你要知道的第一件事是，<code>git rebase</code> 和<code>git merge</code> 做的事其实是一样的。它们都被设计来将一个分支的更改并入另一个分支，只不过方式有些不同。</p><p>想象一下，你刚创建了一个专门的分支开发新功能，然后团队中另一个成员在 master 分支上添加了新的提交。这就会造成提交历史被 fork 一份，用 Git 来协作的开发者应该都很清楚。</p><p>现在，如果 master 中新的提交和你的工作是相关的。为了将新的提交并入你的分支，你有两个选择：merge 或 rebase。</p><h3 id="Merge-1"><a href="#Merge-1" class="headerlink" title="Merge"></a>Merge</h3><p>将 master 分支合并到 feature 分支最简单的办法就是用下面这些命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git merge master</span><br></pre></td></tr></table></figure><p>或者，你也可以把它们压缩在一行里。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge master feature</span><br></pre></td></tr></table></figure><p>feature 分支中新的合并提交（merge commit）将两个分支的历史连在了一起。你会得到下面这样的分支结构：</p><p>Merge 好在它是一个安全的操作。现有的分支不会被更改，避免了 rebase 潜在的缺点（后面会说）。</p><p>另一方面，这同样意味着每次合并上游更改时 feature 分支都会引入一个外来的合并提交。如果 master 非常活跃的话，这或多或少会污染你的分支历史。虽然高级的 <code>git log</code> 选项可以减轻这个问题，但对于开发者来说，还是会增加理解项目历史的难度。</p><h3 id="Rebase-1"><a href="#Rebase-1" class="headerlink" title="Rebase"></a>Rebase</h3><p>作为 merge 的替代选择，你可以像下面这样将 feature 分支并入 master 分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure><p>它会把整个 feature 分支移动到 master 分支的后面，有效地把所有 master 分支上新的提交并入过来。但是，rebase 为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。</p><p>rebase最大的好处是你的项目历史会非常整洁。首先，它不像 <code>git merge</code> 那样引入不必要的合并提交。其次，rebase 导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的 fork。这让你更容易使用 <code>git log</code>、<code>git bisect</code> 和 <code>gitk</code> 来查看项目历史。</p><p>不过，这种简单的提交历史会带来两个后果：安全性和可跟踪性。如果你违反了 rebase 黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响。此外，rebase 不会有合并提交中附带的信息——你看不到 feature 分支中并入了上游的哪些更改。</p><h3 id="交互式的-rebase"><a href="#交互式的-rebase" class="headerlink" title="交互式的 rebase"></a>交互式的 rebase</h3><p>交互式的 rebase 允许你更改并入新分支的提交。这比自动的 rebase 更加强大，因为它提供了对分支上提交历史完整的控制。一般来说，这被用于将 feature 分支并入 master 分支之前，清理混乱的历史。</p><p>把 <code>-i</code> 传入 <code>git rebase</code> 选项来开始一个交互式的rebase过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase -i master</span><br></pre></td></tr></table></figure><p>它会打开一个文本编辑器，显示所有将被移动的提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick 33d5b7a Message for commit #1</span><br><span class="line">pick 9480b3d Message for commit #2</span><br><span class="line">pick 5c67e61 Message for commit #3</span><br></pre></td></tr></table></figure><p>这个列表定义了 rebase 将被执行后分支会是什么样的。更改 <code>pick</code> 命令或者重新排序，这个分支的历史就能如你所愿了。比如说，如果第二个提交修复了第一个提交中的小问题，你可以用 <code>fixup</code> 命令把它们合到一个提交中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick 33d5b7a Message for commit #1</span><br><span class="line">fixup 9480b3d Message for commit #2</span><br><span class="line">pick 5c67e61 Message for commit #3</span><br></pre></td></tr></table></figure><p>保存后关闭文件，Git 会根据你的指令来执行 rebase，项目历史看上去会是这样：</p><p>忽略不重要的提交会让你的 feature 分支的历史更清晰易读。这是 <code>git merge</code> 做不到的。</p><h2 id="Rebase-的黄金法则"><a href="#Rebase-的黄金法则" class="headerlink" title="Rebase 的黄金法则"></a>Rebase 的黄金法则</h2><p>当你理解 rebase 是什么的时候，最重要的就是什么时候 <em>不能</em> 用 rebase。<code>git rebase</code> 的黄金法则便是，绝不要在公共的分支上使用它。</p><p>比如说，如果你把 master 分支 rebase 到你的 feature 分支上会发生什么：</p><p>这次 rebase 将 master 分支上的所有提交都移到了 feature 分支后面。问题是它只发生在你的代码仓库中，其他所有的开发者还在原来的 master 上工作。因为 rebase 引起了新的提交，Git 会认为你的 master 分支和其他人的 master 已经分叉了。</p><p>同步两个 master 分支的唯一办法是把它们 merge 到一起，导致一个额外的合并提交和两堆包含同样更改的提交。不用说，这会让人非常困惑。</p><p>所以，在你运行 <code>git rebase</code> 之前，一定要问问你自己「有没有别人正在这个分支上工作？」。如果答案是肯定的，那么把你的爪子放回去，重新找到一个无害的方式（如 <code>git revert</code>）来提交你的更改。不然的话，你可以随心所欲地重写历史。</p><h3 id="强制推送-1"><a href="#强制推送-1" class="headerlink" title="强制推送"></a>强制推送</h3><p>如果你想把 rebase 之后的 master 分支推送到远程仓库，Git 会阻止你这么做，因为两个分支包含冲突。但你可以传入 <code>--force</code> 标记来强行推送。就像下面一样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">小心使用这个命令！</span></span><br><span class="line">git push --force</span><br></pre></td></tr></table></figure><p>它会重写远程的 master 分支来匹配你仓库中 rebase 之后的 master 分支，对于团队中其他成员来说这看上去很诡异。所以，务必小心这个命令，只有当你知道你在做什么的时候再使用。</p><p>仅有的几个强制推送的使用场景之一是，当你在想向远程仓库推送了一个私有分支之后，执行了一个本地的清理（比如说为了回滚）。这就像是在说「哦，其实我并不想推送之前那个 feature 分支的。用我现在的版本替换掉吧。」同样，你要注意没有别人正在这个 feature 分支上工作。</p><h2 id="工作流-1"><a href="#工作流-1" class="headerlink" title="工作流"></a>工作流</h2><p>rebase 可以或多或少应用在你们团队的 Git 工作流中。在这一节中，我们来看看在 feature 分支开发的各个阶段中，rebase 有哪些好处。</p><p>第一步是在任何和 <code>git rebase</code> 有关的工作流中为每一个 feature 专门创建一个分支。它会给你带来安全使用 rebase 的分支结构：</p><h3 id="本地清理"><a href="#本地清理" class="headerlink" title="本地清理"></a>本地清理</h3><p>在你工作流中使用 rebase 最好的用法之一就是清理本地正在开发的分支。隔一段时间执行一次交互式 rebase，你可以保证你 feature 分支中的每一个提交都是专注和有意义的。你在写代码时不用担心造成孤立的提交——因为你后面一定能修复。</p><p>调用 <code>git rebase</code> 的时候，你有两个基（base）可以选择：上游分支（比如 master）或者你 feature 分支中早先的一个提交。我们在「交互式 rebase」一节看到了第一种的例子。后一种在当你只需要修改最新几次提交时也很有用。比如说，下面的命令对最新的 3 次提交进行了交互式 rebase：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure><p>通过指定 <code>HEAD~3</code> 作为新的基提交，你实际上没有移动分支——你只是将之后的 3 次提交重写了。注意它不会把上游分支的更改并入到 feature 分支中。</p><p>如果你想用这个方法重写整个 feature 分支，<code>git merge-base</code> 命令非常方便地找出 feature 分支开始分叉的基。下面这段命令返回基提交的 ID，你可以接下来将它传给 <code>git rebase</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge-base feature master</span><br></pre></td></tr></table></figure><p>交互式 rebase 是在你工作流中引入 <code>git rebase</code> 的的好办法，因为它只影响本地分支。其他开发者只能看到你已经完成的结果，那就是一个非常整洁、易于追踪的分支历史。</p><p>但同样的，这只能用在私有分支上。如果你在同一个 feature 分支和其他开发者合作的话，这个分支是公开的，你不能重写这个历史。</p><p>用带有交互式的 rebase 清理本地提交，这是无法用 <code>git merge</code> 命令代替的。</p><h3 id="将上游分支上的更改并入feature分支"><a href="#将上游分支上的更改并入feature分支" class="headerlink" title="将上游分支上的更改并入feature分支"></a>将上游分支上的更改并入feature分支</h3><p>在概览一节，我们看到了 feature 分支如何通过 <code>git merge</code> 或 <code>git rebase</code> 来并入上游分支。merge 是保留你完整历史的安全选择，rebase 将你的 feature 分支移动到 master 分支后面，创建一个线性的历史。</p><p><code>git rebase</code> 的用法和本地清理非常类似（而且可以同时使用），但之间并入了 master 上的上游更改。</p><p>记住，rebase 到远程分支而不是 master 也是完全合法的。当你和另一个开发者在同一个 feature 分之上协作的时候，你会用到这个用法，将他们的更改并入你的项目。</p><p>比如说，如果你和另一个开发者 John 往 feature 分支上添加了几个提交，在从 John 的仓库中 fetch 之后，你的仓库可能会像下面这样：</p><p>就和并入 master 上的上游更改一样，你可以这样解决这个 fork：要么 merge 你的本地分支和 John 的分支，要么把你的本地分支 rebase 到 John 的分支后面。</p><p>注意，这里的 rebase 没有违反 rebase 黄金法则，因为只有你的本地分支上的 commit 被移动了，之前的所有东西都没有变。这就像是在说「把我的改动加到 John 的后面去」。在大多数情况下，这比通过合并提交来同步远程分支更符合直觉。</p><p>默认情况下，<code>git pull</code> 命令会执行一次merge，但你可以传入<code>--rebase</code> 来强制它通过rebase来整合远程分支。</p><h3 id="用-Pull-Request-进行审查"><a href="#用-Pull-Request-进行审查" class="headerlink" title="用 Pull Request 进行审查"></a>用 Pull Request 进行审查</h3><p>如果你将 Pull Request 作为你代码审查过程中的一环，你需要避免在创建 Pull Request 之后使用 <code>git rebase</code>。只要你发起了 Pull Request，其他开发者能看到你的代码，也就是说这个分支变成了公共分支。重写历史会造成 Git 和你的同事难以找到这个分支接下来的任何提交。</p><p>来自其他开发者的任何更改都应该用 <code>git merge</code> 而不是 <code>git rebase</code> 来并入。</p><p>因此，在提交 Pull Request前用交互式的 rebase 进行代码清理通常是一个好的做法。</p><h3 id="并入通过的功能分支"><a href="#并入通过的功能分支" class="headerlink" title="并入通过的功能分支"></a>并入通过的功能分支</h3><p>如果某个功能被你们团队通过了，你可以选择将这个分支 rebase 到 master 分支之后，或是使用 <code>git merge</code> 来将这个功能并入主代码库中。</p><p>这和将上游改动并入 feature 分支很相似，但是你不可以在 master 分支重写提交，你最后需要用 <code>git merge</code> 来并入这个 feature。但是，在 merge 之前执行一次 rebase，你可以确保 merge 是一直向前的，最后生成的是一个完全线性的提交历史。这样你还可以加入 Pull Request 之后的提交。</p><p>如果你还没有完全熟悉 <code>git rebase</code>，你还可以在一个临时分支中执行 rebase。这样的话，如果你意外地弄乱了你 feature 分支的历史，你还可以查看原来的分支然后重试。</p><p>比如说：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git checkout -b temporary-branch</span><br><span class="line">git rebase -i master</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[清理目录]</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge temporary-branch</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你使用 rebase 之前需要知道的知识点都在这了。如果你想要一个干净的、线性的提交历史，没有不必要的合并提交，你应该使用 <code>git rebase</code> 而不是 <code>git merge</code> 来并入其他分支上的更改。</p><p>另一方面，如果你想要保存项目完整的历史，并且避免重写公共分支上的 commit， 你可以使用 <code>git merge</code>。两种选项都很好用，但至少你现在多了 <code>git rebase</code> 这个选择。</p><hr><h1 id="4-2-代码回滚：Reset、Checkout、Revert-的选择"><a href="#4-2-代码回滚：Reset、Checkout、Revert-的选择" class="headerlink" title="4.2 代码回滚：Reset、Checkout、Revert 的选择"></a>4.2 代码回滚：Reset、Checkout、Revert 的选择</h1><p><code>git reset</code>、<code>git checkout</code> 和 <code>git revert</code> 是你的 Git 工具箱中最有用的一些命令。它们都用来撤销代码仓库中的某些更改，而前两个命令不仅可以作用于提交，还可以作用于特定文件。</p><p>因为它们非常相似，所以我们经常会搞混，不知道什么场景下该用哪个命令。在这篇文章中，我们会比较 <code>git reset</code>、<code>git checkout</code> 和 <code>git revert</code> 最常见的用法。希望你在看完后能游刃有余地使用这些命令来管理你的仓库。</p><p>Git 仓库有三个主要组成——工作目录，缓存区和提交历史。这张图有助于理解每个命令到底产生了哪些影响。当你阅读的时候，牢记这张图。</p><h2 id="提交层面的操作"><a href="#提交层面的操作" class="headerlink" title="提交层面的操作"></a>提交层面的操作</h2><p>你传给 <code>git reset</code> 和 <code>git checkout</code> 的参数决定了它们的作用域。如果你没有包含文件路径，这些操作对所有提交生效。我们这一节要探讨的就是提交层面的操作。注意，<code>git revert</code> 没有文件层面的操作。</p><h3 id="Reset-1"><a href="#Reset-1" class="headerlink" title="Reset"></a>Reset</h3><p>在提交层面上，reset 将一个分支的末端指向另一个提交。这可以用来移除当前分支的一些提交。比如，下面这两条命令让 hotfix 分支向后回退了两个提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout hotfix</span><br><span class="line">git reset HEAD~2</span><br></pre></td></tr></table></figure><p>hotfix 分支末端的两个提交现在变成了悬挂提交。也就是说，下次 Git 执行垃圾回收的时候，这两个提交会被删除。</p><p>如果你的更改还没有共享给别人，<code>git reset</code> 是撤销这些更改的简单方法。当你开发一个功能的时候发现「糟糕，我做了什么？我应该重新来过！」时，reset 就像是 go-to 命令一样。</p><p>除了在当前分支上操作，你还可以通过传入这些标记来修改你的缓存区或工作目录：</p><ul><li>–soft – 缓存区和工作目录都不会被改变</li><li>–mixed – 默认选项。缓存区和你指定的提交同步，但工作目录不受影响</li><li>–hard – 缓存区和工作目录都同步到你指定的提交</li></ul><p>把这些标记想成定义 <code>git reset</code> 操作的作用域就容易理解多了。</p><p>这些标记往往和 HEAD 作为参数一起使用。比如，<code>git reset --mixed HEAD</code> 将你当前的改动从缓存区中移除，但是这些改动还留在工作目录中。另一方面，如果你想完全舍弃你没有提交的改动，你可以使用 <code>git reset --hard HEAD</code>。这是 <code>git reset</code> 最常用的两种用法。</p><p>当你传入 HEAD 以外的其他提交的时候要格外小心，因为 reset 操作会重写当前分支的历史。正如 rebase 黄金法则所说的，在公共分支上这样做可能会引起严重的后果。</p><h3 id="Checkout-1"><a href="#Checkout-1" class="headerlink" title="Checkout"></a>Checkout</h3><p>你应该已经非常熟悉提交层面的 <code>git checkout</code>。当传入分支名时，可以切换到那个分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout hotfix</span><br></pre></td></tr></table></figure><p>上面这个命令做的不过是将HEAD移到一个新的分支，然后更新工作目录。因为这可能会覆盖本地的修改，Git 强制你提交或者缓存工作目录中的所有更改，不然在 checkout 的时候这些更改都会丢失。和 <code>git reset</code> 不一样的是，<code>git checkout</code> 没有移动这些分支。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b5ad4ac9c92eb372e084162d2eb5644d.png" alt="将 HEAD 从 master 移到 hotfix"></p><p>除了分支之外，你还可以传入提交的引用来 checkout 到任意的提交。这和 checkout 到另一个分支是完全一样的：把 HEAD 移动到特定的提交。比如，下面这个命令会 checkout 到当前提交的祖父提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD~2</span><br></pre></td></tr></table></figure><p>这对于快速查看项目旧版本来说非常有用。但如果你当前的 HEAD 没有任何分支引用，那么这会造成 HEAD 分离。这是非常危险的，如果你接着添加新的提交，然后切换到别的分支之后就没办法回到之前添加的这些提交。因此，在为分离的 HEAD 添加新的提交的时候你应该创建一个新的分支。</p><h3 id="Revert"><a href="#Revert" class="headerlink" title="Revert"></a>Revert</h3><p>Revert 撤销一个提交的同时会创建一个新的提交。这是一个安全的方法，因为它不会重写提交历史。比如，下面的命令会找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout hotfix</span><br><span class="line">git revert HEAD~2</span><br></pre></td></tr></table></figure><p>相比 <code>git reset</code>，它不会改变现在的提交历史。因此，<code>git revert</code> 可以用在公共分支上，<code>git reset</code> 应该用在私有分支上。</p><p>你也可以把 <code>git revert</code> 当作撤销已经提交的更改，而 <code>git reset HEAD</code> 用来撤销没有提交的更改。</p><p>就像 <code>git checkout</code> 一样，<code>git revert</code> 也有可能会重写文件。所以，Git 会在你执行 revert 之前要求你提交或者缓存你工作目录中的更改。</p><h2 id="文件层面的操作"><a href="#文件层面的操作" class="headerlink" title="文件层面的操作"></a>文件层面的操作</h2><p><code>git reset</code> 和 <code>git checkout</code> 命令也接受文件路径作为参数。这时它的行为就大为不同了。它不会作用于整份提交，参数将它限制于特定文件。</p><h3 id="Reset-2"><a href="#Reset-2" class="headerlink" title="Reset"></a>Reset</h3><p>当检测到文件路径时，<code>git reset</code> 将缓存区同步到你指定的那个提交。比如，下面这个命令会将倒数第二个提交中的 <code>foo.py</code> 加入到缓存区中，供下一个提交使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD~2 foo.py</span><br></pre></td></tr></table></figure><p>和提交层面的 <code>git reset</code> 一样，通常我们使用HEAD而不是某个特定的提交。运行 <code>git reset HEAD foo.py</code> 会将当前的 <code>foo.py</code> 从缓存区中移除出去，而不会影响工作目录中对 <code>foo.py</code> 的更改。</p><p><code>--soft</code>、<code>--mixed</code> 和 <code>--hard</code> 对文件层面的 <code>git reset</code> 毫无作用，因为缓存区中的文件一定会变化，而工作目录中的文件一定不变。</p><h3 id="Checkout-2"><a href="#Checkout-2" class="headerlink" title="Checkout"></a>Checkout</h3><p>Checkout 一个文件和带文件路径 <code>git reset</code> 非常像，除了它更改的是工作目录而不是缓存区。不像提交层面的 checkout 命令，它不会移动  HEAD引用，也就是你不会切换到别的分支上去。</p><p>比如，下面这个命令将工作目录中的 <code>foo.py</code> 同步到了倒数第二个提交中的 <code>foo.py</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD~2 foo.py</span><br></pre></td></tr></table></figure><p>和提交层面相同的是，它可以用来检查项目的旧版本，但作用域被限制到了特定文件。</p><p>如果你缓存并且提交了 checkout 的文件，它具备将某个文件回撤到之前版本的效果。注意它撤销了这个文件后面所有的更改，而 <code>git revert</code> 命令只撤销某个特定提交的更改。</p><p>和 <code>git reset</code> 一样，这个命令通常和 HEAD 一起使用。比如 <code>git checkout HEAD foo.py</code> 等同于舍弃 <code>foo.py</code> 没有缓存的更改。这个行为和 <code>git reset HEAD --hard</code> 很像，但只影响特定文件。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>你现在已经掌握了 Git 仓库中撤销更改的所有工具。<code>git reset</code>、<code>git checkout</code> 和 <code>git revert</code> 命令比较容易混淆，但当你想起它们对工作目录、缓存区和提交历史的不同影响，就会容易判断现在应该用哪个命令。</p><p>下面这个表格总结了这些命令最常用的使用场景。记得经常对照这个表格，因为你使用 Git 时一定会经常用到。</p><table><thead><tr><th align="center">命令</th><th align="center">作用域</th><th align="left">常用情景</th></tr></thead><tbody><tr><td align="center">git reset</td><td align="center">提交层面</td><td align="left">在私有分支上舍弃一些没有提交的更改</td></tr><tr><td align="center">git reset</td><td align="center">文件层面</td><td align="left">将文件从缓存区中移除</td></tr><tr><td align="center">git checkout</td><td align="center">提交层面</td><td align="left">切换分支或查看旧版本</td></tr><tr><td align="center">git checkout</td><td align="center">文件层面</td><td align="left">舍弃工作目录中的更改</td></tr><tr><td align="center">git revert</td><td align="center">提交层面</td><td align="left">在公共分支上回滚更改</td></tr><tr><td align="center">git revert</td><td align="center">文件层面</td><td align="left">（然而并没有）</td></tr></tbody></table><hr><h1 id="4-3-Git-log-高级用法"><a href="#4-3-Git-log-高级用法" class="headerlink" title="4.3 Git log 高级用法"></a>4.3 Git log 高级用法</h1><p>每一个版本控制系统的出现都是为了让你记录代码的变化。你可以看到项目的历史记录——谁贡献了什么、bug 是什么时候引入的，还可以撤回有问题的更改。但是，首先你得知道如何使用它。这也就是为什么会有 <code>git log</code> 这个命令。</p><p>到现在为止，你应该已经知道如何用 <code>git log</code> 命令来显示最基本的提交信息。但除此之外，你还可以传入各种不同的参数来获得不一样的输出。</p><p><code>git log</code> 有两个高级用法：一是自定义提交的输出格式，二是过滤输出哪些提交。这两个用法合二为一，你就可以找到你项目中你需要的任何信息。</p><h2 id="格式化-Log-输出"><a href="#格式化-Log-输出" class="headerlink" title="格式化 Log 输出"></a>格式化 Log 输出</h2><p>首先，这篇文章会展示几种 <code>git log</code> 格式化输出的例子。大多数例子只是通过标记向 <code>git log</code> 请求或多或少的信息。</p><p>如果你不喜欢默认的 <code>git log</code> 格式，你可以用 <code>git config</code> 的别名功能来给你想要的格式创建一个快捷方式。</p><h3 id="Oneline"><a href="#Oneline" class="headerlink" title="Oneline"></a>Oneline</h3><p><code>--oneline</code> 标记把每一个提交压缩到了一行中。它默认只显示提交ID和提交信息的第一行。<code>git log --oneline</code> 的输出一般是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0e25143 Merge branch &#x27;feature&#x27;</span><br><span class="line">ad8621a Fix a bug in the feature</span><br><span class="line">16b36c6 Add a new feature</span><br><span class="line">23ad9ad Add the initial code base</span><br></pre></td></tr></table></figure><p>它对于获得项目的总体情况很有帮助。</p><h3 id="Decorate"><a href="#Decorate" class="headerlink" title="Decorate"></a>Decorate</h3><p>很多时候，知道每个提交关联的分支或者标签很有用。<code>--decorate</code> 标记让 <code>git log</code> 显示指向这个提交的所有引用（比如说分支、标签等）。</p><p>这可以和另一个配置项一起使用。比如，执行 <code>git log --oneline --decorate</code> 会将提交历史格式化成这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0e25143 (HEAD, master) Merge branch &#x27;feature&#x27;</span><br><span class="line">ad8621a (feature) Fix a bug in the feature</span><br><span class="line">16b36c6 Add a new feature</span><br><span class="line">23ad9ad (tag: v0.9) Add the initial code base</span><br></pre></td></tr></table></figure><p>在这个例子中，你（通过HEAD标记）可以看到最上面那个提交已经被 checkout 了，而且它还是 master 分支的尾端。第二个提交有另一个 feature 分支指向它，以及最后那个提交带有 v0.9 标签。</p><p>分支、标签、HEAD 还有提交历史是你 Git 仓库中包含的所有信息。因此，这个命令让你更完整地观察项目结构。</p><h3 id="Diff-1"><a href="#Diff-1" class="headerlink" title="Diff"></a>Diff</h3><p><code>git log</code> 提供了很多选项来显示两个提交之间的差异。其中最常用的两个是 <code>--stat</code> 和 <code>-p</code>。</p><p><code>--stat</code> 选项显示每次提交的文件增删数量（注意：修改一行记作增加一行且删去一行），当你想要查看提交引入的变化时这会非常有用。比如说，下面这个提交在 hello.py 文件中增加了 67 行，删去了 38 行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">commit f2a238924e89ca1d4947662928218a06d39068c3</span><br><span class="line">Author: John &lt;john@example.com&gt;</span><br><span class="line">Date:   Fri Jun 25 17:30:28 2014 -0500</span><br><span class="line"></span><br><span class="line">    Add a new feature</span><br><span class="line"></span><br><span class="line"> hello.py | 105 ++++++++++++++++++++++++-----------------</span><br><span class="line"> 1 file changed, 67 insertion(+), 38 deletions(-)</span><br></pre></td></tr></table></figure><p>文件名后面+和-的数量是这个提交造成的更改中增删的相对比例。它给你一个直观的感觉，关于这次提交有多少改动。如果你想知道每次提交删改的绝对数量，你可以将 <code>-p</code> 选项传入<code>git log</code>。这样提交所有的删改都会被输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">commit 16b36c697eb2d24302f89aa22d9170dfe609855b</span><br><span class="line">Author: Mary &lt;mary@example.com&gt;</span><br><span class="line">Date:   Fri Jun 25 17:31:57 2014 -0500</span><br><span class="line"></span><br><span class="line">    Fix a bug in the feature</span><br><span class="line"></span><br><span class="line">diff --git a/hello.py b/hello.py</span><br><span class="line">index 18ca709..c673b40 100644</span><br><span class="line">--- a/hello.py</span><br><span class="line">+++ b/hello.py</span><br><span class="line">@@ -13,14 +13,14 @@ B</span><br><span class="line">-print(&quot;Hello, World!&quot;)</span><br><span class="line">+print(&quot;Hello, Git!&quot;)</span><br></pre></td></tr></table></figure><p>对于改动很多的提交来说，这个输出会变得又长又大。一般来说，当你输出所有删改的时候，你是想要查找某一具体的改动，这时你就要用到 <code>pickaxe</code> 选项。</p><h3 id="Shortlog"><a href="#Shortlog" class="headerlink" title="Shortlog"></a>Shortlog</h3><p><code>git shortlog</code> 是一种特殊的 <code>git log</code>，它是为创建发布声明设计的。它把每个提交按作者分类，显示提交信息的第一行。这样可以容易地看到谁做了什么。</p><p>比如说，两个开发者为项目贡献了 5 个提交，那么 <code>git shortlog</code> 输出会是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Mary (2):</span><br><span class="line">      Fix a bug in the feature</span><br><span class="line">      Fix a serious security hole in our framework</span><br><span class="line"></span><br><span class="line">John (3):</span><br><span class="line">      Add the initial code base</span><br><span class="line">      Add a new feature</span><br><span class="line">      Merge branch &#x27;feature&#x27;</span><br></pre></td></tr></table></figure><p>默认情况下，<code>git shortlog</code> 把输出按作者名字排序，但你可以传入 <code>-n</code> 选项来按每个作者提交数量排序。</p><h3 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h3><p><code>--graph</code> 选项绘制一个 ASCII 图像来展示提交历史的分支结构。它经常和 <code>--oneline</code> 和 <code>--decorate</code> 两个选项一起使用，这样会更容易查看哪个提交属于哪个分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --oneline --decorate</span><br><span class="line">For a simple repository with just 2 branches, this will produce the following:</span><br><span class="line"></span><br><span class="line">*   0e25143 (HEAD, master) Merge branch &#x27;feature&#x27;</span><br><span class="line">|\  </span><br><span class="line">| * 16b36c6 Fix a bug in the new feature</span><br><span class="line">| * 23ad9ad Start a new feature</span><br><span class="line">* | ad8621a Fix a critical security issue</span><br><span class="line">|/  </span><br><span class="line">* 400e4b7 Fix typos in the documentation</span><br><span class="line">* 160e224 Add the initial code base</span><br></pre></td></tr></table></figure><p>虽然这对简单的项目来说是个很好用的选择，但你可能会更喜欢 gitk 或 SourceTree 这些更强大的可视化工具来分析大型项目。</p><h3 id="自定义格式"><a href="#自定义格式" class="headerlink" title="自定义格式"></a>自定义格式</h3><p>对于其他的 <code>git log</code> 格式需求，你都可以使用 <code>--pretty=format:&quot;&lt;string&gt;&quot;</code> 选项。它允许你使用像 printf 一样的占位符来输出提交。</p><p>比如，下面命令中的 <code>%cn</code>、<code>%h</code> 和 <code>%cd</code> 这三种占位符会被分别替换为作者名字、缩略标识和提交日期。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=format:&quot;%cn committed %h on %cd&quot;</span><br><span class="line">This results in the following format for each commit:</span><br><span class="line"></span><br><span class="line">John committed 400e4b7 on Fri Jun 24 12:30:04 2014 -0500</span><br><span class="line">John committed 89ab2cf on Thu Jun 23 17:09:42 2014 -0500</span><br><span class="line">Mary committed 180e223 on Wed Jun 22 17:21:19 2014 -0500</span><br><span class="line">John committed f12ca28 on Wed Jun 22 13:50:31 2014 -0500</span><br></pre></td></tr></table></figure><p>完整的占位符清单可以在文档中找到。</p><p>除了让你只看到关注的信息，这个 <code>--pretty=format:&quot;&lt;string&gt;&quot;</code> 选项在你想要在另一个命令中使用日志内容是尤为有用的。</p><h2 id="过滤提交历史"><a href="#过滤提交历史" class="headerlink" title="过滤提交历史"></a>过滤提交历史</h2><p>格式化提交输出只是 <code>git log</code> 其中的一个用途。另一半是理解如何浏览整个提交历史。接下来的文章会介绍如何用 <code>git log</code> 选择项目历史中的特定提交。所有的用法都可以和上面讨论过的格式化选项结合起来。</p><h3 id="按数量"><a href="#按数量" class="headerlink" title="按数量"></a>按数量</h3><p><code>git log</code> 最基础的过滤选项是限制显示的提交数量。当你只对最近几次提交感兴趣时，它可以节省你一页一页查看的时间。</p><p>你可以在后面加上 <code>-&lt;n&gt;</code> 选项。比如说，下面这个命令会显示最新的 3 次提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -3</span><br></pre></td></tr></table></figure><h3 id="按日期"><a href="#按日期" class="headerlink" title="按日期"></a>按日期</h3><p>如果你想要查看某一特定时间段内的提交，你可以使用 <code>--after</code> 或 <code>--before</code> 标记来按日期筛选。它们都接受好几种日期格式作为参数。比如说，下面的命令会显示 2014 年 7 月 1 日后（含）的提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --after=&quot;2014-7-1&quot;</span><br></pre></td></tr></table></figure><p>你也可以传入相对的日期，比如一周前（<code>&quot;1 week ago&quot;</code>）或者昨天（<code>&quot;yesterday&quot;</code>）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get log --after=&quot;yesterday&quot;</span><br></pre></td></tr></table></figure><p>你可以同时提供<code>--before</code> 和 <code>--after</code> 来检索两个日期之间的提交。比如，为了显示 2014 年 7 月 1 日到 2014 年 7 月 4 日之间的提交，你可以这么写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --after=&quot;2014-7-1&quot; --before=&quot;2014-7-4&quot;</span><br></pre></td></tr></table></figure><p>注意 <code>--since</code>、<code>--until</code> 标记和 <code>--after</code>、<code>--before</code> 标记分别是等价的。</p><h3 id="按作者"><a href="#按作者" class="headerlink" title="按作者"></a>按作者</h3><p>当你只想看某一特定作者的提交的时候，你可以使用 <code>--author</code> 标记。它接受正则表达式，返回所有作者名字满足这个规则的提交。如果你知道那个作者的确切名字你可以直接传入文本字符串：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=&quot;John&quot;</span><br></pre></td></tr></table></figure><p>它会显示所有作者叫 John 的提交。作者名不一定是全匹配，只要包含那个子串就会匹配。</p><p>你也可以用正则表达式来创建更复杂的检索。比如，下面这个命令检索名叫 Mary 或 John 的作者的提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=&quot;John\|Mary&quot;</span><br></pre></td></tr></table></figure><p>注意作者的邮箱地址也算作是作者的名字，所以你也可以用这个选项来按邮箱检索。</p><p>如果你的工作流区分提交者和作者，<code>--committer</code> 也能以相同的方式使用。</p><h3 id="按提交信息"><a href="#按提交信息" class="headerlink" title="按提交信息"></a>按提交信息</h3><p>按提交信息来过滤提交，你可以使用 <code>--grep</code> 标记。它和上面的 <code>--author</code> 标记差不多，只不过它搜索的是提交信息而不是作者。</p><p>比如说，你的团队规范要求在提交信息中包括相关的issue编号，你可以用下面这个命令来显示这个 issue 相关的所有提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --grep=&quot;JRA-224:&quot;</span><br></pre></td></tr></table></figure><p>你也可以传入 <code>-i</code> 参数来忽略大小写匹配。</p><h3 id="按文件"><a href="#按文件" class="headerlink" title="按文件"></a>按文件</h3><p>很多时候，你只对某个特定文件的更改感兴趣。为了显示某个特定文件的历史，你只需要传入文件路径。比如说，下面这个命令返回所有和 <code>foo.py</code> 和 <code>bar.py</code> 文件相关的提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -- foo.py bar.py</span><br></pre></td></tr></table></figure><p><code>--</code> 告诉 <code>git log</code> 接下来的参数是文件路径而不是分支名。如果分支名和文件名不可能冲突，你可以省略 <code>--</code>。</p><h3 id="按内容"><a href="#按内容" class="headerlink" title="按内容"></a>按内容</h3><p>我们还可以根据源代码中某一行的增加和删除来搜索提交。这被称为 pickaxe，它接受形如 <code>-S&quot;&lt;string&gt;&quot;</code> 的参数。比如说，当你想要知道 <code>Hello, World!</code> 字符串是什么时候加到项目中哪个文件中去的，你可以使用下面这个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -S &quot;Hello, World!&quot;</span><br></pre></td></tr></table></figure><p>如果你想用正则表达式而不是字符串来搜索，你可以使用 <code>-G&quot;&lt;regex&gt;&quot;</code> 标记。</p><p>这是一个非常强大的调试工具，它能让你定位到所有影响代码中特定一行的提交。它甚至可以让你看到某一行是什么时候复制或者移动到另一个文件中去的。</p><h3 id="按范围"><a href="#按范围" class="headerlink" title="按范围"></a>按范围</h3><p>你可以传入范围来筛选提交。这个范围由下面这样的格式指定，其中 <code>&lt;since&gt;</code> 和 <code>&lt;until&gt;</code> 是提交的引用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log &lt;since&gt;..&lt;until&gt;</span><br></pre></td></tr></table></figure><p>这个命令在你使用分支引用作为参数时特别有用。这是显示两个分支之间区别最简单的方式。看看下面这个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log master..feature</span><br></pre></td></tr></table></figure><p>其中的 <code>master..feature</code> 范围包含了在 feature 分支而不在 master 分支中所有的提交。换句话说，这个命令可以看出从 master 分支 fork 到 feature 分支后发生了哪些变化。它可以这样可视化：</p><p>注意如果你更改范围的前后顺序（feature..master），你会获取到 master 分支而非 feature 分支上的所有提交。如果 <code>git log</code> 输出了全部两个分支的提交，这说明你的提交历史已经分叉了。</p><h3 id="过滤合并提交"><a href="#过滤合并提交" class="headerlink" title="过滤合并提交"></a>过滤合并提交</h3><p><code>git log</code> 输出时默认包括合并提交。但是，如果你的团队采用强制合并策略（意思是 merge 你修改的上游分支而不是将你的分支 rebase 到上游分支），你的项目历史中会有很多外来的提交。</p><p>你可以通过 <code>--no-merges</code> 标记来排除这些提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --no-merges</span><br></pre></td></tr></table></figure><p>另一方面，如果你只对合并提交感兴趣，你可以使用 <code>--merges</code> 标记：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --merges</span><br></pre></td></tr></table></figure><p>它会返回所有包含两个父节点的提交。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>你现在应该对使用 <code>git log</code> 来格式化输出和选择你要显示的提交的用法比较熟悉了。它允许你查看你项目历史中任何需要的内容。</p><p>这些技巧是你 Git 工具箱中重要的部分，不过注意 <code>git log</code> 往往和其他 Git 命令连着使用。当你找到了你要的提交，你把它传给 <code>git checkout</code>、<code>git revert</code> 或是其他控制提交历史的工具。所以，请继续坚持 Git 高级用法的学习。</p><hr><h1 id="4-4-Git-钩子：自定义你的工作流"><a href="#4-4-Git-钩子：自定义你的工作流" class="headerlink" title="4.4 Git 钩子：自定义你的工作流"></a>4.4 Git 钩子：自定义你的工作流</h1><p>Git 钩子是在 Git 仓库中特定事件发生时自动运行的脚本。它可以让你自定义 Git 内部的行为，在开发周期中的关键点触发自定义的行为。</p><p>Git 钩子最常见的使用场景包括推行提交规范，根据仓库状态改变项目环境，和接入持续集成工作流。但是，因为脚本可以完全定制，你可以用 Git 钩子来自动化或者优化你开发工作流中任意部分。</p><p>在这篇文章中，我们会先简要介绍 Git 钩子是如何工作的。然后，我们会审视一些本地和远端仓库使用最流行的钩子。</p><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>Git 钩子是仓库中特定事件发生时 Git 自动运行的普通脚本。因此，Git 钩子安装和配置也非常容易。</p><p>钩子在本地或服务端仓库都可以部署，且只会在仓库中事件发生时被执行。在文章后面我们会具体地研究各种钩子。接下来所讲的配置对本地和服务端钩子都起作用。</p><h3 id="安装钩子"><a href="#安装钩子" class="headerlink" title="安装钩子"></a>安装钩子</h3><p>钩子存在于每个 Git 仓库的 <code>.git/hooks</code> 目录中。当你初始化仓库时，Git 自动生成这个目录和一些示例脚本。当你观察 <code>.git/hooks</code> 时，你会看到下面这些文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">applypatch-msg.sample       pre-push.sample</span><br><span class="line">commit-msg.sample           pre-rebase.sample</span><br><span class="line">post-update.sample          prepare-commit-msg.sample</span><br><span class="line">pre-applypatch.sample       update.sample</span><br><span class="line">pre-commit.sample</span><br></pre></td></tr></table></figure><p>这里已经包含了大部分可用的钩子了，但是 <code>.sample</code> 拓展名防止它们默认被执行。为了安装一个钩子，你只需要去掉 <code>.sample</code> 拓展名。或者你要写一个新的脚本，你只需添加一个文件名和上述匹配的新文件，去掉 <code>.sample</code> 拓展名。</p><p>比如说，试试安装一个 <code>prepare-commit-msg</code> 钩子。去掉脚本的 <code>.sample</code> 拓展名，在文件中加上下面这两行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/shell</span></span><br><span class="line"></span><br><span class="line">echo &quot;# Please include a useful commit message!&quot; &gt; $1</span><br></pre></td></tr></table></figure><p>钩子需要能被执行，所以如果你创建了一个新的脚本文件，你需要修改它的文件权限。比如说，为了确保 <code>prepare-commit-msg</code> 可执行，运行下面这个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x prepare-commit-msg</span><br></pre></td></tr></table></figure><p>接下来你每次运行 <code>git commit</code> 时，你会看到默认的提交信息都被替换了。我们会在「准备提交信息」一节中细看它是如何工作的。现在我们已经可以定制 Git 的内部功能，你只需要坐和放宽。</p><p>内置的样例脚本是非常有用的参考资料，因为每个钩子传入的参数都有非常详细的说明（不同钩子不一样）。</p><h3 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h3><p>内置的脚本大多是  shell和 PERL 语言的，但你可以使用任何脚本语言，只要它们最后能编译到可执行文件。每次脚本中的 <code>#!/bin/shell</code> 定义了你的文件将被如何解释。比如，使用其他语言时你只需要将 path 改为你的解释器的路径。</p><p>比如说，你可以在 <code>prepare-commit-msg</code> 中写一个可执行的 Python 脚本。下面这个钩子和上一节的 shell 脚本做的事完全一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"></span><br><span class="line">commit_msg_filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(commit_msg_filepath, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;# Please include a useful commit message!&quot;</span>)</span><br></pre></td></tr></table></figure><p>注意第一行改成了 Python 解释器的路径。此外，这里用 <code>sys.argv[1]</code> 而不是 <code>$1</code> 来获取第一个参数（这个也后面再讲）。</p><p>这个特性非常强大，因为你可以用任何你喜欢的语言来编写  Git 钩子。</p><h3 id="钩子的作用域"><a href="#钩子的作用域" class="headerlink" title="钩子的作用域"></a>钩子的作用域</h3><p>对于任何 Git 仓库来说钩子都是本地的，而且它不会随着 <code>git clone</code> 一起复制到新的仓库。而且，因为钩子是本地的，任何能接触得到仓库的人都可以修改。</p><p>对于开发团队来说，这有很大的影响。首先，你要确保你们成员之间的钩子都是最新的。其次，你也不能强行让其他人用你喜欢的方式提交——你只能鼓励他们这样做。</p><p>在开发团队中维护钩子是比较复杂的，因为 <code>.git/hooks</code> 目录不随你的项目一起拷贝，也不受版本控制影响。一个简单的解决办法是把你的钩子存在项目的实际目录中（在 <code>.git</code> 外）。这样你就可以像其他文件一样进行版本控制。为了安装钩子，你可以在 <code>.git/hooks</code> 中创建一个符号链接，或者简单地在更新后把它们复制到 <code>.git/hooks</code> 目录下。</p><p>作为备选方案，Git 同样提供了一个模板目录机制来更简单地自动安装钩子。每次你使用 <code>git init</code> 或 <code>git clone</code> 时，模板目录文件夹下的所有文件和目录都会被复制到 <code>.git</code> 文件夹。</p><p>所有的下面讲到的本地钩子都可以被更改或者彻底删除，只要你是项目的参与者。这完全取决于你的团队成员想不想用这个钩子。所以记住，最好把 Git 钩子当成一个方便的开发者工具而不是一个严格强制的开发规范。</p><p>也就是说，用服务端钩子来拒绝没有遵守规范的提交是完全可行的。后面我们会再讨论这个问题。</p><h2 id="本地钩子"><a href="#本地钩子" class="headerlink" title="本地钩子"></a>本地钩子</h2><p>本地钩子只影响它们所在的仓库。当你在读这一节的时候，记住开发者可以修改他们本地的钩子，所以不要用它们来推行强制的提交规范。不过，它们确实可以让开发者更易于接受这些规范。</p><p>在这一节中，我们会探讨 6 个最有用的本地钩子：</p><ul><li>pre-commit</li><li>prepare-commit-msg</li><li>commit-msg</li><li>post-commit</li><li>post-checkout</li><li>pre-rebase</li></ul><p>前四个钩子让你介入完整的提交生命周期，后两个允许你执行一些额外的操作，分别为 <code>git checkout</code> 和 <code>git rebase</code> 的安全检查。</p><p>所有带 <code>pre-</code> 的钩子允许你修改即将发生的操作，而带 <code>post-</code> 的钩子只能用于通知。</p><p>我们也会看到处理钩子的参数和用底层 Git 命令获取仓库信息的实用技巧。</p><h3 id="pre-commit"><a href="#pre-commit" class="headerlink" title="pre-commit"></a>pre-commit</h3><p><code>pre-commit</code> 脚本在每次你运行 <code>git commit</code> 命令时，Git 向你询问提交信息或者生产提交对象时被执行。你可以用这个钩子来检查即将被提交的代码快照。比如说，你可以运行一些自动化测试，保证这个提交不会破坏现有的功能。</p><p><code>pre-commit</code> 不需要任何参数，以非0状态退出时将放弃整个提交。让我们看一个简化了的（和更详细的）内置 <code>pre-commit</code> 钩子。只要检测到不一致时脚本就放弃这个提交，就像 <code>git diff-index</code> 命令定义的那样（只要词尾有空白字符、只有空白字符的行、行首一个 tab 后紧接一个空格就被认为错误）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查这是否是初始提交</span></span><br><span class="line"><span class="keyword">if</span> git rev-parse --verify HEAD &gt;/dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">then</span><br><span class="line">    echo <span class="string">&quot;pre-commit: About to create a new commit...&quot;</span></span><br><span class="line">    against=HEAD</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    echo <span class="string">&quot;pre-commit: About to create the first commit...&quot;</span></span><br><span class="line">    against=4b825dc642cb6eb9a060e54bf8d69288fbee4904</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用git diff-index来检查空白字符错误</span></span><br><span class="line">echo <span class="string">&quot;pre-commit: Testing for whitespace errors...&quot;</span></span><br><span class="line"><span class="keyword">if</span> ! git diff-index --check --cached $against</span><br><span class="line">then</span><br><span class="line">    echo <span class="string">&quot;pre-commit: Aborting commit due to whitespace errors&quot;</span></span><br><span class="line">    exit <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    echo <span class="string">&quot;pre-commit: No whitespace errors :)&quot;</span></span><br><span class="line">    exit <span class="number">0</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>使用 <code>git diff-index</code> 时我们要指出和哪次提交进行比较。一般来说是 HEAD，但 HEAD 在创建第一次提交时不存在，所以我们的第一个任务是解决这个极端情形。我们通过 <code>git rev-parse --verify</code> 来检查 HEAD 是否是一个合法的引用。<code>&gt;/dev/null 2&gt;&amp;1</code> 这部分屏蔽了 <code>git rev-parse</code> 任何输出。HEAD 或者一个新的提交对象被储存在 <code>against</code> 变量中供 <code>git diff-index</code> 使用。<code>4b825d...</code> 这个哈希字串代表一个空白提交的 ID。</p><p><code>git diff-index --cached</code> 命令将提交和缓存区比较。通过传入 <code>-check</code> 选项，我们要求它在更改引入空白字符错误时警告我们。如果它这么做了，我们返回状态1来放弃这次提交，否则返回状态 0，提交工作流正常进行。</p><p>这只是 <code>pre-commit</code> 的其中一个例子。它恰好使用了已有的 Git 命令来根据提交带来的更改进行测试，但你可以在 <code>pre-commit</code> 中做任何你想做的事，比如执行其它脚本、运行第三方测试集、用 Lint 检查代码风格。</p><h3 id="prepare-commit-msg"><a href="#prepare-commit-msg" class="headerlink" title="prepare-commit-msg"></a>prepare-commit-msg</h3><p><code>prepare-commit-msg</code> 钩子在 <code>pre-commit</code> 钩子在文本编辑器中生成提交信息之后被调用。这被用来方便地修改自动生成的 squash 或 merge 提交。</p><p><code>prepare-commit-msg</code> 脚本的参数可以是下列三个：</p><ul><li>包含提交信息的文件名。你可以在原地更改提交信息。</li><li>提交类型。可以是信息（<code>-m</code> 或 <code>-F</code> 选项），模板（<code>-t</code> 选项），merge（如果是个合并提交）或 squash（如果这个提交插入了其他提交）。</li><li>相关提交的 SHA1 哈希字串。只有当 <code>-c</code>、<code>-C</code> 或 <code>--amend</code> 选项出现时才需要。</li></ul><p>和 <code>pre-commit</code> 一样，以非0状态退出会放弃提交。</p><p>我们已经看过一个修改提交信息的简单例子，现在我们来看一个更有用的脚本。使用 issue 跟踪器时，我们通常在单独的分支上处理 issue。如果你在分支名中包含了 issue 编号，你可以使用 <code>prepare-commit-msg</code> 钩子来自动地将它包括在那个分支的每个提交信息中。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, os, re</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> check_output</span><br><span class="line"></span><br><span class="line"><span class="comment"># 收集参数</span></span><br><span class="line">commit_msg_filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">2</span>:</span><br><span class="line">    commit_type = sys.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    commit_type = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">3</span>:</span><br><span class="line">    commit_hash = sys.argv[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    commit_hash = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;prepare-commit-msg: File: %s\nType: %s\nHash: %s&quot;</span> % (commit_msg_filepath, commit_type, commit_hash)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测我们所在的分支</span></span><br><span class="line">branch = check_output([<span class="string">&#x27;git&#x27;</span>, <span class="string">&#x27;symbolic-ref&#x27;</span>, <span class="string">&#x27;--short&#x27;</span>, <span class="string">&#x27;HEAD&#x27;</span>]).strip()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;prepare-commit-msg: On branch &#x27;%s&#x27;&quot;</span> % branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用issue编号生成提交信息</span></span><br><span class="line"><span class="keyword">if</span> branch.startswith(<span class="string">&#x27;issue-&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;prepare-commit-msg: Oh hey, it&#x27;s an issue branch.&quot;</span></span><br><span class="line">    result = re.<span class="keyword">match</span>(<span class="string">&#x27;issue-(.*)&#x27;</span>, branch)</span><br><span class="line">    issue_number = result.group(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(commit_msg_filepath, <span class="string">&#x27;r+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.read()</span><br><span class="line">        f.seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        f.write(<span class="string">&quot;ISSUE-%s %s&quot;</span> % (issue_number, content))</span><br></pre></td></tr></table></figure><p>首先，上面的 <code>prepare-commit-msg</code> 钩子告诉你如何收集传入脚本的所有参数。接下来，它调用了 <code>git symbolic-ref --short HEAD</code> 来获取对应 HEAD 的分支名。如果分支名以 <code>issue-</code> 开头，它会重写提交信息文件，在第一行加上 issue 编号。比如你的分支名 <code>issue-224</code>，下面的提交信息将会生成：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ISSUE-<span class="number">224</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Please enter the commit message for your changes. Lines starting</span></span><br><span class="line"><span class="comment"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="comment"># On branch issue-224</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   modified:   test.txt</span></span><br></pre></td></tr></table></figure><p>有一点要记住的是即使用户用 <code>-m</code> 传入提交信息，<code>prepare-commit-msg</code> 也会运行。也就是说，上面这个脚本会自动插入 <code>ISSUE-[#]</code> 字符串，而用户无法更改。你可以检查第二个参数是否是提交类型来处理这个情况。</p><p>但是，如果没有 <code>-m</code> 选项，<code>prepare-commit-msg</code> 钩子允许用户修改生成后的提交信息。所以脚本的目的是为了方便，而不是推行强制的提交信息规范。如果你要这么做，你需要下一节所讲的 <code>commit-msg</code> 钩子。</p><h3 id="commit-msg"><a href="#commit-msg" class="headerlink" title="commit-msg"></a>commit-msg</h3><p><code>commit-msg</code> 钩子和 <code>prepare-commit-msg</code> 钩子很像，但它会在用户输入提交信息之后被调用。这适合用来提醒开发者他们的提交信息不符合你团队的规范。</p><p>传入这个钩子唯一的参数是包含提交信息的文件名。如果它不喜欢用户输入的提交信息，它可以在原地修改这个文件（和 <code>prepare-commit-msg</code> 一样），或者它会以非 0 状态退出，放弃这个提交。</p><p>比如说，下面这个脚本确认用户没有删除 <code>prepare-commit-msg</code> 脚本自动生成的 <code>ISSUE-[#]</code> 字符串。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, os, re</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> check_output</span><br><span class="line"></span><br><span class="line"><span class="comment"># 收集参数</span></span><br><span class="line">commit_msg_filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测所在的分支</span></span><br><span class="line">branch = check_output([<span class="string">&#x27;git&#x27;</span>, <span class="string">&#x27;symbolic-ref&#x27;</span>, <span class="string">&#x27;--short&#x27;</span>, <span class="string">&#x27;HEAD&#x27;</span>]).strip()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;commit-msg: On branch &#x27;%s&#x27;&quot;</span> % branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测提交信息，判断是否是一个issue提交</span></span><br><span class="line"><span class="keyword">if</span> branch.startswith(<span class="string">&#x27;issue-&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;commit-msg: Oh hey, it&#x27;s an issue branch.&quot;</span></span><br><span class="line">    result = re.<span class="keyword">match</span>(<span class="string">&#x27;issue-(.*)&#x27;</span>, branch)</span><br><span class="line">    issue_number = result.group(<span class="number">1</span>)</span><br><span class="line">    required_message = <span class="string">&quot;ISSUE-%s&quot;</span> % issue_number</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(commit_msg_filepath, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.read()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> content.startswith(required_message):</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;commit-msg: ERROR! The commit message must start with &#x27;%s&#x27;&quot;</span> % required_message</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>虽然用户每次创建提交时，这个脚本都会运行。但你还是应该避免做检查提交信息之外的事情。如果你需要通知其他服务一个快照已经被提交了，你应该使用 <code>post-commit</code> 这个钩子。</p><h3 id="post-commit"><a href="#post-commit" class="headerlink" title="post-commit"></a>post-commit</h3><p><code>post-commit</code> 钩子在 <code>commit-msg</code> 钩子之后立即被运行 。它无法更改 <code>git commit</code> 的结果，所以这主要用于通知用途。</p><p>这个脚本没有参数，而且退出状态不会影响提交。对于大多数 <code>post-commit</code> 脚本来说，你只是想访问你刚刚创建的提交。你可以用 <code>git rev-parse HEAD</code> 来获得最近一次提交的SHA1哈希字串，或者你可以用 <code>git log -l HEAD</code> 获取完整的信息。</p><p>比如说，如果你需要每次提交快照时向老板发封邮件（也许对于大多数工作流来说这不是个好的想法），你可以加上下面这个 <code>post-commit</code> 钩子。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> check_output</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得新提交的git log --stat输出</span></span><br><span class="line">log = check_output([<span class="string">&#x27;git&#x27;</span>, <span class="string">&#x27;log&#x27;</span>, <span class="string">&#x27;-1&#x27;</span>, <span class="string">&#x27;--stat&#x27;</span>, <span class="string">&#x27;HEAD&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个纯文本的邮件内容</span></span><br><span class="line">msg = MIMEText(<span class="string">&quot;Look, I&#x27;m actually doing some work:\n\n%s&quot;</span> % log)</span><br><span class="line"></span><br><span class="line">msg[<span class="string">&#x27;Subject&#x27;</span>] = <span class="string">&#x27;Git post-commit hook notification&#x27;</span></span><br><span class="line">msg[<span class="string">&#x27;From&#x27;</span>] = <span class="string">&#x27;mary@example.com&#x27;</span></span><br><span class="line">msg[<span class="string">&#x27;To&#x27;</span>] = <span class="string">&#x27;boss@example.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送信息</span></span><br><span class="line">SMTP_SERVER = <span class="string">&#x27;smtp.example.com&#x27;</span></span><br><span class="line">SMTP_PORT = <span class="number">587</span></span><br><span class="line"></span><br><span class="line">session = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)</span><br><span class="line">session.ehlo()</span><br><span class="line">session.starttls()</span><br><span class="line">session.ehlo()</span><br><span class="line">session.login(msg[<span class="string">&#x27;From&#x27;</span>], <span class="string">&#x27;secretPassword&#x27;</span>)</span><br><span class="line"></span><br><span class="line">session.sendmail(msg[<span class="string">&#x27;From&#x27;</span>], msg[<span class="string">&#x27;To&#x27;</span>], msg.as_string())</span><br><span class="line">session.quit()</span><br></pre></td></tr></table></figure><p>你虽然可以用 <code>post-commit</code> 来触发本地的持续集成系统，但大多数时候你想用的是 <code>post-receive</code> 这个钩子。它运行在服务端而不是用户的本地机器，它同样在任何开发者推送代码时运行。那里更适合你进行持续集成。</p><h3 id="post-checkout"><a href="#post-checkout" class="headerlink" title="post-checkout"></a>post-checkout</h3><p><code>post-checkout</code> 钩子和 <code>post-commit</code> 钩子很像，但它在你用 <code>git checkout</code> 查看引用的时候被调用。这是用来清理你的工作目录中可能会令人困惑的生成文件。</p><p>这个钩子接受三个参数，它的返回状态不影响 <code>git checkout</code> 命令。</p><ul><li>HEAD 前一次提交的引用</li><li>新的 HEAD 的引用</li><li>1 或 0，分别代表是分支 checkout 还是文件 checkout。</li></ul><p>Python 程序员经常遇到的问题是切换分支后那些之前生成的 <code>.pyc</code> 文件。解释器有时使用 <code>.pyc</code> 而不是 <code>.py</code> 文件。为了避免歧义，你可以在每次用 <code>post-checkout</code> 切换到新的分支的时候，删除所有 <code>.pyc</code> 文件。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, os, re</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> check_output</span><br><span class="line"></span><br><span class="line"><span class="comment"># 收集参数</span></span><br><span class="line">previous_head = sys.argv[<span class="number">1</span>]</span><br><span class="line">new_head = sys.argv[<span class="number">2</span>]</span><br><span class="line">is_branch_checkout = sys.argv[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> is_branch_checkout == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;post-checkout: This is a file checkout. Nothing to do.&quot;</span></span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;post-checkout: Deleting all &#x27;.pyc&#x27; files in working directory&quot;</span></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">        ext = os.path.splitext(filename)[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> ext == <span class="string">&#x27;.pyc&#x27;</span>:</span><br><span class="line">            os.unlink(os.path.join(root, filename))</span><br></pre></td></tr></table></figure><p>钩子脚本当前的工作目录总是位于仓库的根目录下，所以 <code>os.walk(&#39;.&#39;)</code> 调用遍历了仓库中所有文件。接下来，我们检查它的拓展名，如果是 <code>.pyc</code> 就删除它。</p><p>通过 <code>post-checkout</code> 钩子，你还可以根据你切换的分支来来更改工作目录。比如说，你可以在代码库外面使用一个插件分支来储存你所有的插件。如果这些插件需要很多二进制文件而其他分支不需要，你可以选择只在插件分支上 build。</p><h3 id="pre-rebase"><a href="#pre-rebase" class="headerlink" title="pre-rebase"></a>pre-rebase</h3><p><code>pre-rebase</code> 钩子在 <code>git rebase</code> 发生更改之前运行，确保不会有什么糟糕的事情发生。</p><p>这个钩子有两个参数：fork 之前的上游分支，将要 rebase 的下游分支。如果 rebase 当前分支则第二个参数为空。以非 0 状态退出会放弃这次 rebase。</p><p>比如说，如果你想彻底禁用 rebase 操作，你可以使用下面的 <code>pre-rebase</code> 脚本：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用所有rebase</span></span><br><span class="line">echo <span class="string">&quot;pre-rebase: Rebasing is dangerous. Don&#x27;t do it.&quot;</span></span><br><span class="line">exit <span class="number">1</span></span><br></pre></td></tr></table></figure><p>每次运行 <code>git rebase</code>，你都会看到下面的信息：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pre-rebase: Rebasing is dangerous. Don&#x27;t do it.</span><br><span class="line">The pre-rebase hook refused to rebase.</span><br></pre></td></tr></table></figure><p>内置的 <code>pre-rebase.sample</code> 脚本是一个更复杂的例子。它在何时阻止 rebase 这方面更加智能。它会检查你当前的分支是否已经合并到了下一个分支中去（也就是主分支）。如果是的话，rebase 可能会遇到问题，脚本会放弃这次 rebase。</p><h2 id="服务端钩子"><a href="#服务端钩子" class="headerlink" title="服务端钩子"></a>服务端钩子</h2><p>服务端钩子和本地钩子几乎一样，只不过它们存在于服务端的仓库中（比如说中心仓库，或者开发者的公共仓库）。当和官方仓库连接时，其中一些可以用来拒绝一些不符合规范的提交。</p><p>这节中我们要讨论下面三个服务端钩子：</p><ul><li>pre-receive</li><li>update</li><li>post-receive</li></ul><p>这些钩子都允许你对 <code>git push</code> 的不同阶段做出响应。</p><p>服务端钩子的输出会传送到客户端的控制台中，所以给开发者发送信息是很容易的。但你要记住这些脚本在结束完之前都不会返回控制台的控制权，所以你要小心那些长时间运行的操作。</p><h3 id="pre-receive"><a href="#pre-receive" class="headerlink" title="pre-receive"></a>pre-receive</h3><p><code>pre-receive</code> 钩子在有人用 <code>git push</code> 向仓库推送代码时被执行。它只存在于远端仓库中，而不是原来的仓库中。</p><p>这个钩子在任意引用被更新前被执行，所以这是强制推行开发规范的好地方。如果你不喜欢推送的那个人（多大仇 &#x3D; &#x3D;），提交信息的格式，或者提交的更改，你都可以拒绝这次提交。虽然你不能阻止开发者写出糟糕的代码，但你可以用 <code>pre-receive</code> 防止这些代码流入官方的代码库。</p><p>这个脚本没有参数，但每一个推送上来的引用都会以下面的格式传入脚本的单独一行：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;old-value&gt; &lt;new-value&gt; &lt;ref-name&gt;</span><br></pre></td></tr></table></figure><p>你可以看到这个钩子做了非常简单的事，就是读取推送上来的引用并且把它们打印出来。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> fileinput</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取用户试图更新的所有引用</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fileinput.<span class="built_in">input</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;pre-receive: Trying to push ref: %s&quot;</span> % line</span><br><span class="line"></span><br><span class="line"><span class="comment"># 放弃推送</span></span><br><span class="line"><span class="comment"># sys.exit(1)</span></span><br></pre></td></tr></table></figure><p>这和其它钩子相比略微有些不同，因为信息是通过标准输入而不是命令行传入的。在远端仓库的 <code>.git/hooks</code> 中加上这个脚本，推送到 master 分支，你会看到下面这些信息打印出来：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b6b36c697eb2d24302f89aa22d9170dfe609855b 85baa88c22b52ddd24d71f05db31f4e46d579095 refs/heads/master</span><br></pre></td></tr></table></figure><p>你可以用 SHA1 哈希字串，或者底层的 Git 命令，来检查将要引入的更改。一些常见的使用包括：</p><ul><li>拒绝将上游分支 rebase 的更改</li><li>防止错综复杂的合并（非快速向前，会造成项目历史非线性）</li><li>检查用户是否有正确的权限来做这些更改（大多用于中心化的 Git 工作流中）</li><li>如果多个引用被推送，在 <code>pre-receive</code> 中返回非 0 状态，拒绝所有提交。如果你想一个个接受或拒绝分支，你需要使用 <code>update</code> 钩子</li></ul><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p><code>update</code> 钩子在 <code>pre-receive</code> 之后被调用，用法也差不多。它也是在实际更新前被调用的，但它可以分别被每个推送上来的引用分别调用。也就是说如果用户尝试推送到4个分支，<code>update</code> 会被执行 4 次。和 <code>pre-receive</code> 不一样，这个钩子不需要读取标准输入。事实上，它接受三个参数：</p><ul><li>更新的引用名称</li><li>引用中存放的旧的对象名称</li><li>引用中存放的新的对象名称</li></ul><p>这些信息和 <code>pre-receive</code> 相同，但因为每次引用都会分别触发更新，你可以拒绝一些引用而接受另一些。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">branch = sys.argv[<span class="number">1</span>]</span><br><span class="line">old_commit = sys.argv[<span class="number">2</span>]</span><br><span class="line">new_commit = sys.argv[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Moving &#x27;%s&#x27; from %s to %s&quot;</span> % (branch, old_commit, new_commit)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只放弃当前分支的推送</span></span><br><span class="line"><span class="comment"># sys.exit(1)</span></span><br></pre></td></tr></table></figure><p>上面这个钩子简单地输出了分支和新旧提交的哈希字串。当你向远程仓库推送超过一个分支时，你可以看到每个分支都有输出。</p><h3 id="post-receive"><a href="#post-receive" class="headerlink" title="post-receive"></a>post-receive</h3><p><code>post-receive</code> 钩子在成功推送后被调用，适合用于发送通知。对很多工作流来说，这是一个比 <code>post-commit</code> 更好的发送通知的地方，因为这些更改在公共的服务器而不是用户的本地机器上。给其他开发者发送邮件或者触发一个持续集成系统都是 <code>post-receive</code> 常用的操作。</p><p>这个脚本没有参数，但和 <code>pre-receive</code> 一样通过标准输入读取。</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，我们学习了如果用 Git 钩子来修改内部行为，当仓库中特定的事件发生时接受消息。钩子是存在于 <code>git/hooks</code> 仓库中的普通脚本，因此也非常容易安装和定制。</p><p>我们还看了一些常用的本地和服务端的钩子。这使得我们能够介入到整个开发生命周期中去。我们现在知道了如何在创建提交或推送的每个阶段执行自定义的操作。有了这些简单的脚本知识，你就可以对 Git 仓库为所欲为了 :]</p><hr><h1 id="4-5-Git提交引用和引用日志"><a href="#4-5-Git提交引用和引用日志" class="headerlink" title="4.5 Git提交引用和引用日志"></a>4.5 Git提交引用和引用日志</h1><p>提交是 Git 的精髓所在，你无时不刻不在创建和缓存提交、查看以前的提交，或者用各种Git命令在仓库间转移你的提交。大多数的命令都对同一个提交操作，而有些会接受提交的引用作为参数。比如，你可以给 <code>git checkout</code> 传入一个引用来查看以前的提交，或者传入一个分支名来切换到对应的分支。</p><p>知道提交的各种引用方式之后，Git 的命令就会变得更加强大。在这章中，我们研究提交的各种引用方式，来一窥 <code>git checkout</code>、<code>git branch</code>、<code>git push</code> 等命令的工作原理。</p><p>我们还会学到如何使用 Git 的引用日志查看似乎已被删除的提交。</p><h2 id="哈希字串"><a href="#哈希字串" class="headerlink" title="哈希字串"></a>哈希字串</h2><p>引用一个提交最直接的方式是通过 SHA-1 的哈希字串，这是每个提交唯一的 ID。你可以在 <code>git log</code> 的输出中找到提交的哈希字串。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">commit 0c708fdec272bc4446c6cabea4f0022c2b616eba</span><br><span class="line">Author: Mary Johnson &lt;mary@example.com&gt;</span><br><span class="line">Date:   Wed Jul 9 16:37:42 2014 -0500</span><br><span class="line"></span><br><span class="line">    一些提交信息</span><br></pre></td></tr></table></figure><p>在 Git 命令中传递时，你只需要提供足以确定那个提交的哈希子串即可。比如，你可以这样用 <code>git show</code> 的命令显示上面的提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show 0c708f</span><br></pre></td></tr></table></figure><p>有时，我们需要把分支、标签或者其他间接的引用转变成对应提交的哈希。<code>git rev-parse</code> 命令正是你需要的。下面这个命令返回 master 分支提交的哈希字串：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-parse master</span><br></pre></td></tr></table></figure><p>当你写的自定义脚本中需要将提交引用作为参数时，这个命令非常有用。你可以让 <code>git rev-parse</code> 帮你处理转换，而不用手动做这件事。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>ref 是提交的间接引用。你可以把它当做哈希字串的别名，但对用户更友好。这就是 Git 内部表示分支和标签的机制。</p><p>引用以一段普通的文本存在于 <code>.git/refs</code> 目录中，就是我们平时说的那个 <code>.git</code>。你去 <code>.git/refs</code> 文件夹查看仓库中的引用。你可以看到下面这样的结构，但具体的文件取决于你的仓库中有什么分支和标签，以及你的远程仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.git/refs/</span><br><span class="line">    heads/</span><br><span class="line">        master</span><br><span class="line">        some-feature</span><br><span class="line">    remotes/</span><br><span class="line">        origin/</span><br><span class="line">            master</span><br><span class="line">    tags/</span><br><span class="line">        v0.9</span><br></pre></td></tr></table></figure><p><code>heads</code>目录定义了你本地仓库中的所有分支。每一个文件名和你的分支名一一对应，文件中包含一个提交的哈希字串。这个就是分支顶端的所在位置。为了验证这一点，试试在 Git 根目录运行下面这两个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出`refs/heads/master`文件内容</span></span><br><span class="line">cat .git/refs/heads/master</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看`master`分支尾端的提交</span></span><br><span class="line">git log -1 master</span><br></pre></td></tr></table></figure><p><code>cat</code> 命令返回的哈希字串和 <code>git log</code> 命令显示的哈希字串应该是一致的。</p><p>如果要改变 master 分支的位置，Git 只需要更改 <code>refs/heads/master</code> 的文件内容。同样地，创建新的分支也只需要将当前提交的哈希字串写入到新的文件中。这也是为什么 Git 分支比 SVN 轻量那么多的其中一个原因。</p><p><code>tags</code> 目录也是以相同的方式存储，只不过其中存的是标签而不是分支。<code>remotes</code> 目录将你之前用 <code>git remote</code> 命令创建的所有远程仓库以子目录的形式一一列出。在每个文件夹中，你可以找到所有 fetch 到本地仓库的远程分支。</p><h3 id="指定引用"><a href="#指定引用" class="headerlink" title="指定引用"></a>指定引用</h3><p>当你向 Git 命令传入引用的时候，你既可以指定引用完整的名称，也可以使用缩写，然后让 Git 来寻找匹配。你应该已经对引用的缩写很熟悉了，每次你通过名称引用分支的时候都会这么做。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show some-feature</span><br></pre></td></tr></table></figure><p>这里的 <code>some-feature</code> 参数其实是分支名的缩写。Git 在使用前将它解析成 <code>refs/heads/some-feature</code>。你也可以在命令行中指定引用的全称，就像这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show refs/heads/some-feature</span><br></pre></td></tr></table></figure><p>这避免了引用可能产生的所有歧义。这是非常必要的，比如你同时有一个标签和分支都叫 <code>some-feature</code>。然而，如果使用正常的命名规范，你不应该有这样的歧义。</p><p>我们会在 refspec 一节见到更多引用名称。</p><h2 id="打包引用目录"><a href="#打包引用目录" class="headerlink" title="打包引用目录"></a>打包引用目录</h2><p>对于大型仓库，Git 会周期性地执行垃圾回收来移除不需要的对象，将所有引用文件压缩成单个文件来获得更好的性能。你可以使用这个命令强制垃圾回收来执行压缩：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git gc</span><br></pre></td></tr></table></figure><p>这个命令把 <code>refs</code> 文件夹中所有单独的分支和标签移动到了 <code>.git</code> 根目录下的 <code>packed-refs</code> 文件中。如果你打开这个文件，你会发现提交的哈希字串和引用之间的映射关系：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00f54250cf4e549fdfcafe2cf9a2c90bc3800285 refs/heads/feature</span><br><span class="line">0e25143693cfe9d5c2e83944bbaf6d3c4505eb17 refs/heads/master</span><br><span class="line">bb883e4c91c870b5fed88fd36696e752fb6cf8e6 refs/tags/v0.9</span><br></pre></td></tr></table></figure><p>另一方面，正常的 Git 功能不会受到任何影响。但如果你好奇你的 <code>.git/refs</code> 文件夹为什么是空的，这一节告诉你了答案。</p><h2 id="特殊的引用"><a href="#特殊的引用" class="headerlink" title="特殊的引用"></a>特殊的引用</h2><p>除了 <code>refs</code> 文件夹外，<code>.git</code> 根目录还有一些特殊的引用。如下所示：</p><ul><li>HEAD – 当前所在的提交或分支。</li><li>FETCH_HEAD – 远程仓库中 fetch 到的最新一次提交。</li><li>ORIG_HEAD – HEAD 的备份引用，避免损坏。</li><li>MERGE_HEAD – 你通过 <code>git merge</code> 并入当前分支的引用（们）。</li><li>CHERRY_PICK_HEAD – 你 <code>cherry pick</code> 使用的引用。</li></ul><p>这些引用由 Git 在需要时创建和更新。比如说，<code>git pull</code> 命令首先运行 <code>git fetch</code>，而 <code>FETCH_HEAD</code> 引用随之改变。然后，运行 <code>git merge FETCH_HEAD</code> 来将 fetch 到的分支最终并入仓库。当然，你也可以使用其他任何引用，因为我相信你已经对 <code>HEAD</code> 很熟悉了。</p><p>这些文件包含的内容取决于它们的类型和你的仓库状态。<code>HEAD</code> 引用可以包含符号链接（指向另一个引用而不是哈希字串），或是提交的哈希字串。比如说，看看当你在 master 分支上时 <code>HEAD</code> 的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">cat .git/HEAD</span><br></pre></td></tr></table></figure><p>这个命令会输出 <code>ref: refs/heads/master</code>，也就是说 HEAD 指向 <code>refs/heads/master</code> 这个引用。这也正是 Git 如何知道现在所在的是 master 分支。如果你要切换分支，<code>HEAD</code> 的内容将会被更新到新的分支。但如果你要切换到一个提交而不是分支，<code>HEAD</code> 会包含一个提交的哈希而不是符号引用。这就是 Git 如何知道现在 <code>HEAD</code> 处于分离状态。</p><p>在大多数情况下，<code>HEAD</code> 是你唯一用得到的引用。其它引用一般只在写底层脚本，接触到 Git 内部的工作机制时才会用到。</p><h2 id="refspec"><a href="#refspec" class="headerlink" title="refspec"></a>refspec</h2><p>refspec 将本地分支和远程分支对应起来。我们可以通过它用本地的 Git 命令管理远程分支，设置一些高级的 <code>git push</code> 和 <code>git fetch</code> 行为。</p><p>refspec 的定义是这样的：<code>[+]&lt;src&gt;:&lt;dst&gt;</code>。<code>&lt;src&gt;</code> 参数是本地的源分支，<code>&lt;dst&gt;</code> 是远程的目标分支。可选的 <code>+</code> 号强制远程仓库采用非快速向前的更新策略。</p><p>refspec 可以和 <code>git push</code> 一起使用，用来指定远程的分支的名称。比如，下面这个命令将 master 分支推送到远程 origin，就像一般的 <code>git push</code> 一样，但它使用 qa-master 作为远程仓库中的分支名。对于 QA 团队来说，这个方法非常有用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master:refs/heads/qa-master</span><br></pre></td></tr></table></figure><p>你也可以用 refspec 来删除远程分支。feature 分支的工作流经常会遇到这种情况，将 feature 分支推送到远程仓库中（比如说为了备份）。你删除本地的 feature 分支之后，远程的 feature 分支依然存在，虽然现在我们已经不再需要它。你可以 push 一个 <code>&lt;src&gt;</code> 参数为空的 refspec 来删除它们，就像这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin:some-feature</span><br></pre></td></tr></table></figure><p>这非常方便，因为你不需要登录到你的远程仓库然后手动删除这些远程分支。注意，在 Git v1.7.0 之后你可以用 <code>--delete</code> 标记代替上面这个方法。下面这个命令和上面的命令作用相同：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete some-feature</span><br></pre></td></tr></table></figure><p>在 Git 配置文件中增加几行，你就可以更改 <code>git fetch</code> 的行为。默认地，<code>git fetch</code> 会 fetch 远程仓库中所有分支。原因就是 <code>.git/config</code> 文件的这段配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url = https://git@github.com:mary/example-repo.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></table></figure><p>fetch 这一行告诉 <code>git fetch</code> 从 origin 仓库中下载所有分支。但是，一些工作流不需要所有分支。比如，很多持续集成工作流只关心 master 分支。为了做到这一点，我们需要将 fetch 这行改成下面这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url = https://git@github.com:mary/example-repo.git</span><br><span class="line">    fetch = +refs/heads/master:refs/remotes/origin/master</span><br></pre></td></tr></table></figure><p>你还可以类似地修改 <code>git push</code> 的配置。比如，如果你总是将 master 分支推送到 origin 仓库的 qa-master 分支（就像我们之前做的一样），你要把配置文件改成这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url = https://git@github.com:mary/example-repo.git</span><br><span class="line">    fetch = +refs/heads/master:refs/remotes/origin/master</span><br><span class="line">    push = refs/heads/master:refs/heads/qa-master</span><br></pre></td></tr></table></figure><p>refspec 给了你完全的掌控权，可以定制 Git 命令如何在仓库之间转移分支。你可以重命名或是删除你的本地分支，fetch 或是 push 不同的分支名，修改 <code>git push</code> 和 <code>git fetch</code> 的设置，只对你想要的分支进行操作。</p><h2 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h2><p>你还可以通过提交之间的相对关系来引用。<code>~</code> 符号让你访问父节点的提交。比如说，下面这个命令显示 <code>HEAD</code> 祖父节点的提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show HEAD~2</span><br></pre></td></tr></table></figure><p>但是，面对合并提交（merge commit）的时候，事情就会变得有些复杂。因为合并提交有多个父节点，所以你可以找到多条回溯的路径。对于 3 路合并，第一个父节点是你执行合并时的分支，第二个父节点是你传给 <code>git merge</code> 命令的分支。</p><p><code>~</code> 符号总是选择合并提交的第一个父节点。如果你想选择其他父节点，你需要用 <code>^</code> 符号来指定。比如说，<code>HEAD</code> 是一个合并提交，下面这个命令返回 <code>HEAD</code> 的第二个父节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show HEAD^2</span><br></pre></td></tr></table></figure><p>你可以使用不止一个 <code>^</code> 来查看超过一层的节点。比如，下面的命令显示的是 <code>HEAD</code> 的祖父节点，也就是 <code>HEAD</code> 第二个父节点的父节点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show HEAD^2^1</span><br></pre></td></tr></table></figure><p>为了阐明 <code>~</code> 和 <code>^</code> 是如何工作的，下面这张图告诉你如何使用相对引用，来指向任意的提交。有的提交可以通过多种方式引用。</p><p>相对引用在命令中的用法和普通的引用相同。比如，下面所有命令中使用的都是相对引用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只列出合并提交的第二个父节点的父节点</span></span><br><span class="line">git log HEAD^2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除当前分支最新的 3 个提交</span></span><br><span class="line">git reset HEAD~3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交互式rebase当前分支最新的 3 个提交</span></span><br><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure><h2 id="引用日志"><a href="#引用日志" class="headerlink" title="引用日志"></a>引用日志</h2><p>引用日志是 Git 的安全网。它记录了你在仓库中做的所有更改，不管你有没有提交。你也可以认为这是你本地更改的完整历史记录。运行 <code>git reflog</code> 命令查看引用日志。它应该会打印出像下面这样的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">400e4b7 HEAD@&#123;0&#125;: checkout: moving from master to HEAD~2</span><br><span class="line">0e25143 HEAD@&#123;1&#125;: commit (amend): 将一些很赞的新特性引入`master`</span><br><span class="line">00f5425 HEAD@&#123;2&#125;: commit (merge): 合并&#x27;feature&#x27;分支</span><br><span class="line">ad8621a HEAD@&#123;3&#125;: commit: 结束feature分支开发</span><br></pre></td></tr></table></figure><p>说人话就是：</p><ul><li>你刚刚切换到 <code>HEAD~2</code></li><li>你刚刚修改了一个提交信息</li><li>你刚刚把 feature 分支合并到了 master 分支</li><li>你刚刚提交了一份缓存</li></ul><p><code>HEAD&#123;&lt;n&gt;&#125;</code> 语法允许你引用保存在日志中的提交。这和上一节的 <code>HEAD~&lt;n&gt;</code> 引用差不多，不过 <code>&lt;n&gt;</code> 指的是引用日志中的对象，而不是提交历史。</p><p>你可以用办法回到之前可能已经丢失的状态。比如，你刚刚用 <code>git reset</code> 方法粉碎了新的 feature 分支。你的引用日志看上去可能会是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ad8621a HEAD@&#123;0&#125;: reset: moving to HEAD~3</span><br><span class="line">298eb9f HEAD@&#123;1&#125;: commit: 一些提交信息</span><br><span class="line">bbe9012 HEAD@&#123;2&#125;: commit: 继续开发</span><br><span class="line">9cb79fa HEAD@&#123;3&#125;: commit: 开始新特性开发</span><br></pre></td></tr></table></figure><p><code>git reset</code> 前的三个提交现在都成了悬挂的了，也就是说除了引用日志之外没有办法再引用到它们。现在，假设你意识到了你不应该丢掉你全部的工作。你只需要切换到 <code>HEAD@&#123;1&#125;</code> 这个提交就能回到你运行 <code>git reset</code> 之前仓库的状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD@&#123;1&#125;</span><br></pre></td></tr></table></figure><p>这会让你处于 <code>HEAD</code> 分离的状态。你可以从这里开始，创建新的分支，继续你的工作。</p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>你现在对 Git 提交的引用应该已经相当熟悉了。我们知道了分支和标签是如何存在于 <code>.git</code> 的子文件夹 refs 中，如何读取打包的引用文件，如何使用 refspec 来进行更高级的 push 和 fetch 操作，如何使用 <code>~</code> 和 <code>^</code> 符号来遍历分支结构。</p><p>我们还了解了引用日志，来引用到其他方式已经不存在的提交。这是一种很好的恢复误删提交的方法。</p><p>它的意义在于：在任何开发场景下，你都能找到你需要的特定提交。你很容易就可以把这些技巧用在你一有的 Git 知识中，因为很多常用的命令都接受引用作为参数，包括 <code>git log</code>、<code>git show</code>、<code>git checkout</code>、<code>git reset</code>、<code>git revert</code>、<code>git rebase</code> 等等。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-1-Git-简易指南&quot;&gt;&lt;a href=&quot;#1-1-Git-简易指南&quot; class=&quot;headerlink&quot; title=&quot;1.1 Git 简易指南&quot;&gt;&lt;/a&gt;1.1 Git 简易指南&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/img/git1.png&quot;&gt;</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>汇编</title>
    <link href="http://example.com/2023/10/26/%E6%B1%87%E7%BC%96/"/>
    <id>http://example.com/2023/10/26/%E6%B1%87%E7%BC%96/</id>
    <published>2023-10-26T11:45:36.000Z</published>
    <updated>2023-10-26T13:18:35.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-第一段代码：Hello-World"><a href="#1-第一段代码：Hello-World" class="headerlink" title="1. 第一段代码：Hello World"></a>1. 第一段代码：Hello World</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DSEG SEGMENT</span><br><span class="line">        MESS DB &#x27;Hello, World!&#x27;,0DH,0AH,24H</span><br><span class="line">DSEG ENDS</span><br><span class="line"></span><br><span class="line">SSEG SEGMENT PARA STACK</span><br><span class="line">             DW 256 DUP(?)</span><br><span class="line">SSEG ENDS</span><br><span class="line"></span><br><span class="line">CSEG SEGMENT</span><br><span class="line">              ASSUME CS:CSEG, DS:DSEG</span><br><span class="line">        BEGIN:MOV    AX,DSEG</span><br><span class="line">              MOV    DS,AX</span><br><span class="line">              MOV    DX,OFFSET MESS</span><br><span class="line">              </span><br><span class="line">              MOV    AH,9</span><br><span class="line">              INT    21H</span><br><span class="line">              </span><br><span class="line">              MOV    AH,4CH</span><br><span class="line">              INT    21H</span><br><span class="line">CSEG ENDS</span><br><span class="line">END BEGIN</span><br></pre></td></tr></table></figure><h1 id="2-基础指令"><a href="#2-基础指令" class="headerlink" title="2. 基础指令"></a>2. 基础指令</h1><p>用以下指令可以写一个基础的程序：</p><ol><li>段定义+Assume</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XXX SEGMENT(XXX:DATA/STACK/CODE)</span><br><span class="line">XXX ENDS</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CSEG, DS:DSEG, SS:SSEG</span><br><span class="line">MOV AX,DSEG</span><br><span class="line">MOV DS,AX</span><br><span class="line">MOV AX,SSEG</span><br><span class="line">MOV SS,AX</span><br></pre></td></tr></table></figure><ol start="2"><li>数据定义</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(ORG 1000)</span><br><span class="line">(NAME) DB ?/...</span><br><span class="line">(NAME) DB N DUP(?/...)</span><br><span class="line">db:12H/dw:1234H</span><br></pre></td></tr></table></figure><ol start="3"><li>MOV</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,Y</span><br><span class="line">MOV Y,AX</span><br><span class="line">MOV AX,BX</span><br></pre></td></tr></table></figure><ol start="4"><li>+-</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ADD AX,X;AX+=X</span><br><span class="line">SUB AX,X;</span><br><span class="line">INC AX;AX++</span><br><span class="line">DEC AX;AX--</span><br><span class="line"></span><br><span class="line">NEG AX ;取负</span><br></pre></td></tr></table></figure><ol start="5"><li>程序的终止</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AH,4CH</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><hr><h1 id="3-寄存器的使用"><a href="#3-寄存器的使用" class="headerlink" title="3. 寄存器的使用"></a>3. 寄存器的使用</h1><p>在汇编语言中，我们不能对内存中的数据进行直接操作，如果要操作，需要把数据先<code>MOV</code>到寄存器中再进行处理。</p><p>8086 CPU 中有14个16位寄存器 。16位的存储可以用16进制表示，BeLike：<code>123AH</code>（H表示16进制)在查看内存情况的时候，由于数据从高位到低位存储，BeLike：<code>3A 12</code></p><p><img src="/img/c-.1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DSEG ...</span><br><span class="line">X DB 12H</span><br><span class="line">Y DB ?</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">CSEG...</span><br><span class="line">...</span><br><span class="line">MOV AH,X</span><br><span class="line">MOV Y,AH ;Y--12H</span><br></pre></td></tr></table></figure><p>可以拆分为两个寄存器使用（AH和AL），不过各自有各自的独特作用，用到再提，这和它们的名字是关联的</p><p>说到底为什么<code>通用</code>寄存器会有<code>独特的作用</code>？<br>这是因为一些内置的指令依靠<strong>固定</strong>的寄存器传递参数，所以这些寄存器也有了独特的作用</p><p>一般来说随便用就可以，反正里面的东西不久存，只是用来做中转</p><h2 id="3-1-AX：Accumlator-累加器"><a href="#3-1-AX：Accumlator-累加器" class="headerlink" title="3.1 AX：Accumlator 累加器"></a>3.1 AX：Accumlator 累加器</h2><p>特殊功能和MUL&#x2F;DIV有关，后面再说</p><h2 id="3-2-BX：Base-基地址寄存器"><a href="#3-2-BX：Base-基地址寄存器" class="headerlink" title="3.2 BX：Base 基地址寄存器"></a>3.2 BX：Base 基地址寄存器</h2><p>可以存储地址并访问<br>说到地址，就得提一下汇编语言里地址的表示方法<br>在汇编语言里，内存中的地址BeLike：<code>204B:1001</code> （以16进制表示）<br><code>204B</code>是<strong>段地址</strong>，<code>1001</code>是<strong>偏移地址</strong>，各需要一个Word进行存储<br>有两个指令对应的获取内存单元的这两种地址<br>    <code>SEG</code>可以获取<strong>段地址</strong>（这个段就是指我们程序对应的段Segment），<code>OFFSET</code>可以获取<strong>偏移地址</strong><br>    使用这两个词只需要在MOV时加在变量前即可，比如<code>MOV BX offset X</code><br>在<code>通过地址找内容</code>这件事方面，一般用BX存储偏移地址<br>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X DW 1234H</span><br><span class="line">Y DW ?</span><br><span class="line">...</span><br><span class="line">MOV BX, OFFSET X;BX中存储了X的偏移地址</span><br><span class="line">MOV Y, [BX];BX存储的偏移地址对应的内容被存放到y</span><br></pre></td></tr></table></figure><p>一般来说，<code>[BX]</code>就是指 <code>DS:[BX]</code>，默认段地址为数据段，当然你也可以指定为CS和SS</p><h2 id="3-3-CX：Count-计数器"><a href="#3-3-CX：Count-计数器" class="headerlink" title="3.3 CX：Count 计数器"></a>3.3 CX：Count 计数器</h2><p>和循环指令<code>LOOP</code>有关</p><p>LOOP指令类似于C语言中的For循环，<code>loop NAME</code>近似于<code>for(cx;;cx--)</code><br>关于LOOP的用法，具体到程序结构再说好了~。</p><h2 id="3-4-DX：Data-数据寄存器"><a href="#3-4-DX：Data-数据寄存器" class="headerlink" title="3.4 DX：Data 数据寄存器"></a>3.4 DX：Data 数据寄存器</h2><p>特殊功能和MUL&#x2F;DIV有关，后面再说<br>也有与输入输出的暂存有关的功能（9.10号指令）</p><hr><h2 id="3-5-指针变址寄存器：SP，BP，SI，DI"><a href="#3-5-指针变址寄存器：SP，BP，SI，DI" class="headerlink" title="3.5 指针变址寄存器：SP，BP，SI，DI"></a>3.5 指针变址寄存器：SP，BP，SI，DI</h2><p>都倾向于用来存地址</p><h3 id="3-5-1-SP：Stack-Pointer"><a href="#3-5-1-SP：Stack-Pointer" class="headerlink" title="3.5.1 SP：Stack Pointer"></a>3.5.1 SP：Stack Pointer</h3><p>和堆栈段的使用有关，定义堆栈段要记得手动把SP放在栈顶</p><h3 id="3-5-2-BP：Base-Pointer"><a href="#3-5-2-BP：Base-Pointer" class="headerlink" title="3.5.2 BP：Base Pointer"></a>3.5.2 BP：Base Pointer</h3><p>和BX有类似的用法，只是一般更倾向于用在堆栈的数据里，<code>[BP]</code>默认为<code>SS:[BP]</code></p><h3 id="3-5-3-SI：Source-Index"><a href="#3-5-3-SI：Source-Index" class="headerlink" title="3.5.3 SI：Source Index"></a>3.5.3 SI：Source Index</h3><h3 id="3-5-4-DI：Destination-Index"><a href="#3-5-4-DI：Destination-Index" class="headerlink" title="3.5.4 DI：Destination Index"></a>3.5.4 DI：Destination Index</h3><p>和BX有类似的用法，<code>[SI]</code>默认为<code>DS:[SI]</code><br>如果要转移数据，倾向于用SI存原地址，DI存新地址</p><hr><h2 id="3-6-段寄存器：CS，DS，SS，ES，IP"><a href="#3-6-段寄存器：CS，DS，SS，ES，IP" class="headerlink" title="3.6 段寄存器：CS，DS，SS，ES，IP"></a>3.6 段寄存器：CS，DS，SS，ES，IP</h2><p>段的存在方便我们以<code>段地址+偏移地址</code>的方式定位内存单元<br>刚刚在例子中看到，一般的程序我们定义三个段，Data、Stack和Code，它们的作用和名字是一致的</p><p>这些寄存器都和程序段还有程序的运行有关。<br>在程序启动的时候，操作系统会把IP（Instruction Pointer）指向程序的第一句开始运行，之后IP会一直指向每次要运行的下一条指令</p><p>在代码段的开始，我们就用Assume语句声明CS、DS、SS的地址<br>和CS不同，DS和SS寄存器的值需要我们手动指定，而与SS寄存器绑定的SP指针也需要我们手动设置（SS:SP指向的就是栈顶元素）</p><p>ES是Extra Segment，程序有附加段落的时候才用，用法和DS SS差不多</p><h2 id="3-7-寄存器合集统计"><a href="#3-7-寄存器合集统计" class="headerlink" title="3.7 寄存器合集统计"></a>3.7 寄存器合集统计</h2><ul><li><p><strong>通用寄存器</strong> (General-Purpose Registers):</p><ul><li><code>AX</code>, <code>BX</code>, <code>CX</code>, <code>DX</code>: 16位寄存器</li><li><code>EAX</code>, <code>EBX</code>, <code>ECX</code>, <code>EDX</code>: 32位寄存器</li><li><code>RAX</code>, <code>RBX</code>, <code>RCX</code>, <code>RDX</code>: 64位寄存器</li></ul></li><li><p><strong>指针寄存器</strong> (Pointer Registers):</p><ul><li><code>SI</code>: 源变址寄存器 (Source Index)</li><li><code>DI</code>: 目的变址寄存器 (Destination Index)</li><li><code>BP</code>: 基址指针寄存器 (Base Pointer)</li><li><code>SP</code>: 堆栈指针寄存器 (Stack Pointer)</li></ul></li><li><p><strong>段寄存器</strong> (Segment Registers):</p><ul><li><code>CS</code>: 代码段寄存器 (Code Segment)</li><li><code>DS</code>: 数据段寄存器 (Data Segment)</li><li><code>SS</code>: 堆栈段寄存器 (Stack Segment)</li><li><code>ES</code>: 附加段寄存器 (Extra Segment)</li><li><code>FS</code>, <code>GS</code>: 额外段寄存器 (Additional Segment) [64位模式中常用于TLS]</li></ul></li><li><p><strong>指令指针寄存器</strong> (Instruction Pointer Register):</p><ul><li><code>IP</code>: 指令指针 (Instruction Pointer) - 16位</li><li><code>EIP</code>: 扩展指令指针 (Extended Instruction Pointer) - 32位</li><li><code>RIP</code>: 64位指令指针寄存器</li></ul></li><li><p><strong>标志寄存器</strong> (Flags Register):</p><ul><li><code>FLAGS</code>, <code>EFLAGS</code>, <code>RFLAGS</code>: 包含各种标志位，如零标志、进位标志、溢出标志等。</li></ul></li><li><p><strong>控制寄存器</strong> (Control Registers) 和 <strong>调试寄存器</strong> (Debug Registers): 主要用于系统控制和调试。</p><ul><li><code>CR0</code>, <code>CR2</code>, <code>CR3</code>, <code>CR4</code>: 控制寄存器</li><li><code>DR0</code>, <code>DR1</code>, <code>DR2</code>, <code>DR3</code>, <code>DR6</code>, <code>DR7</code>: 调试寄存器</li></ul></li><li><p><strong>测试寄存器</strong> (Test Registers): <code>TR6</code>, <code>TR7</code>，主要用于处理器内部测试。</p></li><li><p><strong>浮点寄存器</strong> (Floating-Point Registers): <code>ST0</code> 到 <code>ST7</code>，主要用于浮点运算。</p></li><li><p><strong>多媒体扩展寄存器</strong> (Multimedia Extension Registers): <code>MM0</code> 到 <code>MM7</code>，主要用于多媒体和SIMD（单指令多数据）操作。</p></li></ul><hr><h1 id="4-进阶指令"><a href="#4-进阶指令" class="headerlink" title="4. 进阶指令"></a>4. 进阶指令</h1><h2 id="4-1-Label和Jump：跳转"><a href="#4-1-Label和Jump：跳转" class="headerlink" title="4.1 Label和Jump：跳转"></a>4.1 Label和Jump：跳转</h2><p>一段代码可以拥有label，Jump NAME 即可跳转至label位置<br>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MAIN：MOV X,AX</span><br><span class="line">JUMP DONE</span><br><span class="line">MOV AX,Y</span><br><span class="line">...</span><br><span class="line">DONE:</span><br><span class="line">MOV AH, 4CH</span><br><span class="line">INT 21</span><br></pre></td></tr></table></figure><p>在这段程序中，<code>MOV AX,Y</code>就会直接被跳过</p><h2 id="4-2-分支和循环"><a href="#4-2-分支和循环" class="headerlink" title="4.2 分支和循环"></a>4.2 分支和循环</h2><h3 id="4-2-1-分支-CMP-JGE-…"><a href="#4-2-1-分支-CMP-JGE-…" class="headerlink" title="4.2.1 分支 CMP-JGE&#x2F;…"></a>4.2.1 分支 CMP-JGE&#x2F;…</h3><p><img src="/img/c-.3.png"></p><p>BeLike:(求abs(AX)保存在AX中)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MAIN:</span><br><span class="line">...</span><br><span class="line">CMP AX,0</span><br><span class="line">JGE DONE; Jump if Greater or Equal</span><br><span class="line">NEG AX</span><br><span class="line">DONE:</span><br><span class="line">...</span><br><span class="line">END MAIN</span><br></pre></td></tr></table></figure><h3 id="4-2-2-循环-LOOP"><a href="#4-2-2-循环-LOOP" class="headerlink" title="4.2.2 循环  LOOP"></a>4.2.2 循环  LOOP</h3><p>一种简单的循环，类似于<code>for(cx;;cx--)</code>。（事实上，你可以用JUMP和分支结构来实现循环）</p><p>LOOP NM过程中：<br>    0. CMP CX,0<br>    1. 如果CX&gt;0，继续执行以下语句，否则跳出<br>    2. DEC CX(CX&gt;0)<br>    3. JUMP NM</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV CX,6</span><br><span class="line">NM: ...</span><br><span class="line">LOOP NM;这样写一共执行CX次（声明NM时执行1次，LOOP中执行CX-1次）</span><br></pre></td></tr></table></figure><h2 id="4-3-堆栈的使用"><a href="#4-3-堆栈的使用" class="headerlink" title="4.3 堆栈的使用"></a>4.3 堆栈的使用</h2><h3 id="4-3-1-初始化"><a href="#4-3-1-初始化" class="headerlink" title="4.3.1 初始化"></a>4.3.1 初始化</h3><p>两个好用的方法</p><h4 id="4-3-1-1-堆栈段中做定义"><a href="#4-3-1-1-堆栈段中做定义" class="headerlink" title="4.3.1.1 堆栈段中做定义"></a>4.3.1.1 堆栈段中做定义</h4><ol><li>在堆栈段划分位置，保存栈顶位置</li><li>在程序段开始的时候把堆栈段的位置告诉堆栈寄存器SS，把栈顶的位置告诉指针寄存器SP</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SSEG SEGMENT</span><br><span class="line">      STACK DW  128 dup(?)</span><br><span class="line">      TOP   DW LENGTH STACK ;划定范围</span><br><span class="line">SSEG ENDS</span><br><span class="line"></span><br><span class="line">CSEG SEGMENT</span><br><span class="line">           ASSUME CS:CSEG,DS:DSEG,SS:SSEG</span><br><span class="line">      MAIN:</span><br><span class="line">           MOV    AX,DSEG</span><br><span class="line">           MOV    DS,AX</span><br><span class="line">           MOV    AX,SSEG</span><br><span class="line">           MOV    SS,AX</span><br><span class="line">           MOV    AX,TOP</span><br><span class="line">           MOV    SP,AX                        ;栈顶地址载入</span><br></pre></td></tr></table></figure><h5 id="4-3-1-2-程序段中划空间"><a href="#4-3-1-2-程序段中划空间" class="headerlink" title="4.3.1.2 程序段中划空间"></a>4.3.1.2 程序段中划空间</h5><p>直接给SP赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SSEG SEGMENT</span><br><span class="line">SSEG ENDS</span><br><span class="line">;ss:0000-ss:1000</span><br><span class="line">CSEG SEGMENT</span><br><span class="line">            ASSUME CS:CSEG, DS:DSEG,SS:SSEG</span><br><span class="line">      BEGIN:MOV    AX,DSEG</span><br><span class="line">            MOV    DS,AX</span><br><span class="line">            MOV    AX,SSEG</span><br><span class="line">            MOV    SS,AX</span><br><span class="line">            MOV    SP,1000H                      ;手动规定了1000H的空置空间(OFFSET 0H-1000H)</span><br></pre></td></tr></table></figure><h3 id="4-3-2-PUSH和POP"><a href="#4-3-2-PUSH和POP" class="headerlink" title="4.3.2 PUSH和POP"></a>4.3.2 PUSH和POP</h3><p>注意：<code>只能操作寄存器</code>，不能直接操作内存单元<br><code>PUSH AX</code>：将AX的值入栈（如果AX两个字节，就会入栈两个字节，SP也相应-2）<br><code>POP AX</code>：出栈，内容保存在AX（如果AX两个字节，就会入栈两个字节，SP也相应+2）</p><h3 id="4-3-3-用SP和BP操作堆栈"><a href="#4-3-3-用SP和BP操作堆栈" class="headerlink" title="4.3.3 用SP和BP操作堆栈"></a>4.3.3 用SP和BP操作堆栈</h3><p>在主程序只是暂存数据用的话，一般<code>不用</code>操作指针<br>但是，由于PROC需要使用到堆栈段，所以这是操作指针就是必要的，接下来在PROC中解释</p><hr><h2 id="4-4-函数：PROC和MACRO"><a href="#4-4-函数：PROC和MACRO" class="headerlink" title="4.4 函数：PROC和MACRO"></a>4.4 函数：PROC和MACRO</h2><blockquote><p>PROC&amp;CALL（子程序结构）</p></blockquote><h3 id="4-4-1-定义-PROC-RET-ENDP"><a href="#4-4-1-定义-PROC-RET-ENDP" class="headerlink" title="4.4.1 定义 PROC-RET-ENDP"></a>4.4.1 定义 PROC-RET-ENDP</h3><p>(Near 属性是默认值)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MAIN:</span><br><span class="line">CALL NM</span><br><span class="line"></span><br><span class="line">NM PROC</span><br><span class="line">...</span><br><span class="line">RET</span><br><span class="line">NM ENDP</span><br><span class="line">...</span><br><span class="line">END MAIN</span><br></pre></td></tr></table></figure><p>完整的表达式：<br>调用：<code>CALL FAR/NEAR PTR NM</code><br>定义：<code>NM PROC FAR/NEAR</code></p><h3 id="4-4-2-子程序属性和调用"><a href="#4-4-2-子程序属性和调用" class="headerlink" title="4.4.2 子程序属性和调用"></a>4.4.2 子程序属性和调用</h3><h4 id="4-4-2-1-段内调用"><a href="#4-4-2-1-段内调用" class="headerlink" title="4.4.2.1 段内调用"></a>4.4.2.1 段内调用</h4><p>只需要Main（主Label调用）的话空置即可（默认Near）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A:...</span><br><span class="line">CALL B;调用B</span><br><span class="line"></span><br><span class="line">PROC B:...;默认为near属性子程序</span><br><span class="line">RET</span><br><span class="line">B ENDP</span><br><span class="line">...</span><br><span class="line">END A</span><br></pre></td></tr></table></figure><h4 id="4-4-2-2-段间调用"><a href="#4-4-2-2-段间调用" class="headerlink" title="4.4.2.2 段间调用"></a>4.4.2.2 段间调用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PROC A:CALL FAR PTR B</span><br><span class="line">RET</span><br><span class="line">ENDP</span><br><span class="line"></span><br><span class="line">PROC B FAR:...;写明属性</span><br><span class="line">RET ENDP</span><br></pre></td></tr></table></figure><h3 id="4-4-3-注意堆栈"><a href="#4-4-3-注意堆栈" class="headerlink" title="4.4.3 注意堆栈"></a>4.4.3 注意堆栈</h3><p>PROC的本质是：入栈程序出口指针，RET时从回到出口指针的位置<br>所以：</p><ol><li>第一个出栈元素会是一个偏移地址</li><li>如果最后SP的指针位置不对，就无法正确RET</li></ol><p>简单的方法：<code>用寄存器BP保护SP</code>，使用BP进行数据的读取</p><blockquote><p>eg: x+y子程序化<br>…</p><ol><li>在堆栈段push任意两个长度为1word的数据</li><li>使用子程序，将这两个数据的和存储于AX</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SUM PROC ;取两个栈顶元素求和储存到AX中</span><br><span class="line">         MOV    BP,SP</span><br><span class="line">         MOV    AX,[BP+2]</span><br><span class="line">         ADD    AX,[BP+4]</span><br><span class="line">         RET</span><br><span class="line">SUM ENDP</span><br></pre></td></tr></table></figure><h3 id="4-4-4-Macro（宏定义）"><a href="#4-4-4-Macro（宏定义）" class="headerlink" title="4.4.4 Macro（宏定义）"></a>4.4.4 Macro（宏定义）</h3><p>PROC的使用有调用开销（程序的中断 跳转 继续），而MACRO没有<br>MACRO相当于写代码的人把重复写代码的过程交给了汇编器，相比子程序来说，是通过多占程序的内存来提高运行速度（对机器来说，每调用一次Macro，就是把这段指令重复了一次）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NM MACRO R1,R2...(参数)</span><br><span class="line">...</span><br><span class="line">END M</span><br><span class="line"></span><br><span class="line">NM MACRO AX,BX...(寄存器取值)</span><br></pre></td></tr></table></figure><hr><h2 id="4-5-INT-21H指令：输入-输出"><a href="#4-5-INT-21H指令：输入-输出" class="headerlink" title="4.5 INT 21H指令：输入&#x2F;输出"></a>4.5 INT 21H指令：输入&#x2F;输出</h2><h3 id="4-5-1-键盘输入"><a href="#4-5-1-键盘输入" class="headerlink" title="4.5.1 键盘输入"></a>4.5.1 键盘输入</h3><h4 id="4-5-1-1-1号指令：单个字符输入"><a href="#4-5-1-1-1号指令：单个字符输入" class="headerlink" title="4.5.1.1 1号指令：单个字符输入"></a>4.5.1.1 1号指令：单个字符输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AH,1</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><p>(内容会保存在AL)</p><h4 id="4-5-1-2-10号指令：从键盘输入字符串"><a href="#4-5-1-2-10号指令：从键盘输入字符串" class="headerlink" title="4.5.1.2 10号指令：从键盘输入字符串"></a>4.5.1.2 10号指令：从键盘输入字符串</h4><p>内存里需要划分三个部分：<br>    1.一个字节存放最大长度（你写，溢出会被裁掉）<br>    2.一个字节存放实际长度（指令运行完CPU会写）<br>    3.一些字节用来存字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">    MAXLENGTH    DB 100           ;一个字节，用它存最大的长度</span><br><span class="line">    ACTUALLENGTH DB ?             ;一个字节，用它存实际的长度，在指令执行后会被填写</span><br><span class="line">    STRING       DB 100 DUP(?)    ;用来存字符串</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">STACK SEGMENT</span><br><span class="line">STACK ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">         ASSUME DS:DATA,SS:STACK,CS:CODE</span><br><span class="line">    MAIN:</span><br><span class="line">         MOV    AX,DATA</span><br><span class="line">         MOV    DS,AX</span><br><span class="line">         MOV    DX,OFFSET MAXLENGTH         ;把需要用到的内存块（三个部分）的地址存入DX</span><br><span class="line"></span><br><span class="line">         MOV    AH,10</span><br><span class="line">         INT    21H</span><br><span class="line"></span><br><span class="line">         MOV    AH,4CH</span><br><span class="line">         INT    21H</span><br><span class="line">CODE ENDS</span><br><span class="line">END MAIN</span><br></pre></td></tr></table></figure><h3 id="4-5-2-显示器输出"><a href="#4-5-2-显示器输出" class="headerlink" title="4.5.2 显示器输出"></a>4.5.2 显示器输出</h3><h4 id="4-5-2-1-2号调用：单个字符输出"><a href="#4-5-2-1-2号调用：单个字符输出" class="headerlink" title="4.5.2.1 2号调用：单个字符输出"></a>4.5.2.1 2号调用：单个字符输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV DL,&#x27;A&#x27;</span><br><span class="line">MOV AH,2</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><h4 id="4-5-2-2-9号调用：字符串输出"><a href="#4-5-2-2-9号调用：字符串输出" class="headerlink" title="4.5.2.2 9号调用：字符串输出"></a>4.5.2.2 9号调用：字符串输出</h4><p>你的字符串必须要以’$‘结尾！不然输出不会结束！（类似于’\0’，’$‘是一种字符串的终止符）<br>程序会将DS:DX地址开始输出字符到’$‘结尾</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV DX,OFFSET STRING</span><br><span class="line">MOV AH,9</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-第一段代码：Hello-World&quot;&gt;&lt;a href=&quot;#1-第一段代码：Hello-World&quot; class=&quot;headerlink&quot; title=&quot;1. 第一段代码：Hello World&quot;&gt;&lt;/a&gt;1. 第一段代码：Hello World&lt;/h1&gt;&lt;fi</summary>
      
    
    
    
    <category term="C语言" scheme="http://example.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="汇编语言" scheme="http://example.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>CMake</title>
    <link href="http://example.com/2023/10/25/CMake/"/>
    <id>http://example.com/2023/10/25/CMake/</id>
    <published>2023-10-25T04:35:46.000Z</published>
    <updated>2023-10-25T13:02:46.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-CMake概述"><a href="#1-CMake概述" class="headerlink" title="1. CMake概述"></a>1. CMake概述</h1><p>CMake 是一个项目构建工具，并且是跨平台的。关于项目构建我们所熟知的还有Makefile（通过 make 命令进行项目的构建），大多是IDE软件都集成了make，比如：VS 的 nmake、linux 下的 GNU make、Qt 的 qmake等，如果自己动手写 makefile，会发现，makefile 通常依赖于当前的编译平台，而且编写 makefile 的工作量比较大，解决依赖关系时也容易出错。</p><p>而 CMake 恰好能解决上述问题， 其允许开发者指定整个工程的编译流程，在根据编译平台，<code>自动生成本地化的Makefile和工程文件</code>，最后用户只需<code>make</code>编译即可，所以可以把CMake看成一款自动生成 Makefile的工具，其编译流程如下图：</p><p><img src="/img/cmake1.png"></p><ul><li>蓝色虚线表示使用<code>makefile</code>构建项目的过程</li><li>红色实线表示使用<code>cmake</code>构建项目的过程</li></ul><p>介绍完CMake的作用之后，总结一下优点：</p><ul><li>跨平台</li><li>能够管理大型项目</li><li>简化编译构建过程和编译过程</li><li>可扩展：可以为 cmake 编写特定功能的模块，扩充 cmake 功能</li></ul><hr><h1 id="2-CMake的使用"><a href="#2-CMake的使用" class="headerlink" title="2. CMake的使用"></a>2. CMake的使用</h1><p><code>CMake</code>支持大写、小写、混合大小写的命令。如果在编写<code>CMakeLists.txt</code>文件时使用的工具有对应的命令提示，那么大小写随缘即可，不要太过在意。</p><h2 id="2-1-注释"><a href="#2-1-注释" class="headerlink" title="2.1 注释"></a>2.1 注释</h2><h3 id="2-1-1-注释行"><a href="#2-1-1-注释行" class="headerlink" title="2.1.1 注释行"></a>2.1.1 注释行</h3><p>CMake 使用 <code>#</code> 进行行注释，可以放在任何位置。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个 CMakeLists.txt 文件</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="2-1-2-注释块"><a href="#2-1-2-注释块" class="headerlink" title="2.1.2 注释块"></a>2.1.2 注释块</h3><p>CMake 使用 <code>#[[ ]]</code> 形式进行块注释。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[[ 这是一个 CMakeLists.txt 文件。</span></span><br><span class="line"><span class="comment">这是一个 CMakeLists.txt 文件</span></span><br><span class="line"><span class="comment">这是一个 CMakeLists.txt 文件]]</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="2-1-只有源文件"><a href="#2-1-只有源文件" class="headerlink" title="2.1 只有源文件"></a>2.1 只有源文件</h2><h3 id="2-1-1-共处一室"><a href="#2-1-1-共处一室" class="headerlink" title="2.1.1 共处一室"></a>2.1.1 共处一室</h3><blockquote><p>准备工作，为了方便测试，在我本地电脑准备了这么几个测试文件</p></blockquote><p><strong>add.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sub.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你好</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mult.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>div.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)a/b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>head.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HEAD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HEAD_H</span></span><br><span class="line"><span class="comment">// 加法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 减法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 乘法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 除法</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>main.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>, <span class="built_in">add</span>(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a - b = %d\n&quot;</span>, <span class="built_in">subtract</span>(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a * b = %d\n&quot;</span>, <span class="built_in">multiply</span>(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a / b = %f\n&quot;</span>, <span class="built_in">divide</span>(a, b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述文件的目录结构如下：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br></pre></td></tr></table></figure><blockquote><p>添加 CMakeLists.txt 文件</p></blockquote><p>在上述源文件所在目录下添加一个新文件 <code>CMakeLists.txt</code>，文件内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">add_executable</span>(app add.c div.c main.c mult.c sub.c)</span><br></pre></td></tr></table></figure><p>接下来依次介绍一下在 CMakeLists.txt 文件中添加的三个命令:</p><ul><li><code>cmake_minimum_required</code>：指定使用的 cmake 的最低版本<ul><li>可选，非必须，如果不加可能会有警告</li></ul></li><li><code>project</code>：定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言），如果不需要这些都是可以忽略的，只需要指定出工程名字即可。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PROJECT 指令的语法是：</span></span><br><span class="line"><span class="keyword">project</span>(&lt;<span class="keyword">PROJECT</span>-NAME&gt; [&lt;language-name&gt;...])</span><br><span class="line"><span class="keyword">project</span>(&lt;<span class="keyword">PROJECT</span>-NAME&gt;</span><br><span class="line">       [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]</span><br><span class="line">       [DESCRIPTION &lt;<span class="keyword">project</span>-description-<span class="keyword">string</span>&gt;]</span><br><span class="line">       [HOMEPAGE_URL &lt;url-<span class="keyword">string</span>&gt;]</span><br><span class="line">       [LANGUAGES &lt;language-name&gt;...])</span><br></pre></td></tr></table></figure><ul><li><code>add_executable</code>：定义工程会生成一个可执行程序</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(可执行程序名 源文件名称)</span><br></pre></td></tr></table></figure><p>这里的可执行程序名和<code>project</code>中的项目名没有任何关系</p><p>源文件名可以是一个也可以是<code>多个</code>，如有多个可用空格或<code>;</code>间隔</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 样式1</span></span><br><span class="line"><span class="keyword">add_executable</span>(app add.c div.c main.c mult.c sub.c)</span><br><span class="line"><span class="comment"># 样式2</span></span><br><span class="line"><span class="keyword">add_executable</span>(app add.c;div.c;main.c;mult.c;sub.c)</span><br></pre></td></tr></table></figure><blockquote><p>执行CMake 命令</p></blockquote><p>万事俱备只欠东风，将 <code>CMakeLists.txt</code> 文件编辑好之后，就可以执行 <code>cmake</code>命令了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cmake 命令原型</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake CMakeLists.txt文件所在路径</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br><span class="line"></span><br><span class="line">0 directories, 7 files</span><br><span class="line">robin@OS:~/Linux/3Day/calc$ cmake .</span><br></pre></td></tr></table></figure><p>当执行<code>cmake</code>命令之后，<code>CMakeLists.txt</code> 中的命令就会被执行，所以一定要注意给<code>cmake</code>命令指定路径的时候一定不能出错。</p><p>执行命令之后，看一下源文件所在目录中是否多了一些文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -L 1</span></span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── CMakeCache.txt         # new add file</span><br><span class="line">├── CMakeFiles             # new add dir</span><br><span class="line">├── cmake_install.cmake    # new add file</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── Makefile               # new add file</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br></pre></td></tr></table></figure><p>我们可以看到在对应的目录下生成了一个<code>makefile</code>文件，此时再执行<code>make</code>命令，就可以对项目进行构建得到所需的可执行程序了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">Scanning dependencies of target app</span><br><span class="line">[ 16%] Building C object CMakeFiles/app.dir/add.c.o</span><br><span class="line">[ 33%] Building C object CMakeFiles/app.dir/div.c.o</span><br><span class="line">[ 50%] Building C object CMakeFiles/app.dir/main.c.o</span><br><span class="line">[ 66%] Building C object CMakeFiles/app.dir/mult.c.o</span><br><span class="line">[ 83%] Building C object CMakeFiles/app.dir/sub.c.o</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Linking C executable app</span></span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target app</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看可执行程序是否已经生成</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -L 1</span></span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── app# 生成的可执行程序</span><br><span class="line">├── CMakeCache.txt</span><br><span class="line">├── CMakeFiles</span><br><span class="line">├── cmake_install.cmake</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── Makefile</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br></pre></td></tr></table></figure><p>最终可执行程序<code>app</code>就被编译出来了（这个名字是在<code>CMakeLists.txt</code>中指定的）。</p><hr><h3 id="2-1-2-VIP-包房"><a href="#2-1-2-VIP-包房" class="headerlink" title="2.1.2 VIP 包房"></a>2.1.2 VIP 包房</h3><p>通过上面的例子可以看出，如果在<code>CMakeLists.txt</code>文件所在目录执行了<code>cmake</code>命令之后就会生成一些目录和文件（包括 <code>makefile</code>文件），如果再基于<code>makefile</code>文件执行<code>make</code>命令，程序在编译过程中还会生成一些中间文件和一个可执行文件，这样会导致整个项目目录看起来很混乱，不太容易管理和维护，此时我们就可以把生成的这些与项目源码无关的文件统一放到一个对应的目录里边，比如将这个目录命名为<code>build</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- The C compiler identification is GNU 5.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 5.4.0</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/robin/Linux/build</span><br></pre></td></tr></table></figure><p>现在<code>cmake</code>命令是在<code>build</code>目录中执行的，但是<code>CMakeLists.txt</code>文件是<code>build</code>目录的上一级目录中，所以<code>cmake</code> 命令后指定的路径为<code>..</code>，即当前目录的上一级目录。</p><p>当命令执行完毕之后，在<code>build</code>目录中会生成一个<code>makefile</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree build -L 1</span></span><br><span class="line">build</span><br><span class="line">├── CMakeCache.txt</span><br><span class="line">├── CMakeFiles</span><br><span class="line">├── cmake_install.cmake</span><br><span class="line">└── Makefile</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br></pre></td></tr></table></figure><p>这样就可以在<code>build</code>目录中执行<code>make</code>命令编译项目，生成的相关文件自然也就被存储到<code>build</code>目录中了。这样通过<code>cmake</code>和<code>make</code>生成的所有文件就全部和项目源文件隔离开了，各回各家，各找各妈。</p><hr><h2 id="2-2-私人订制"><a href="#2-2-私人订制" class="headerlink" title="2.2 私人订制"></a>2.2 私人订制</h2><h3 id="2-2-1-定义变量"><a href="#2-2-1-定义变量" class="headerlink" title="2.2.1 定义变量"></a>2.2.1 定义变量</h3><p>在上面的例子中一共提供了5个源文件，假设这五个源文件需要反复被使用，每次都直接将它们的名字写出来确实是很麻烦，此时我们就需要定义一个变量，将文件名对应的字符串存储起来，在cmake里定义变量需要使用<code>set</code>。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SET 指令的语法是：</span></span><br><span class="line"><span class="comment"># [] 中的参数为可选项, 如不需要可以不写</span></span><br><span class="line"><span class="keyword">SET</span>(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span><br></pre></td></tr></table></figure><ul><li><code>VAR</code>：变量名</li><li><code>VALUE</code>：变量值</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式1: 各个源文件之间使用空格间隔</span></span><br><span class="line"><span class="comment"># set(SRC_LIST add.c  div.c   main.c  mult.c  sub.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2: 各个源文件之间使用分号 ; 间隔</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST add.c;div.c;main.c;mult.c;sub.c)</span><br><span class="line"><span class="keyword">add_executable</span>(app  <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="2-2-2-指定使用的C-标准"><a href="#2-2-2-指定使用的C-标准" class="headerlink" title="2.2.2 指定使用的C++标准"></a>2.2.2 指定使用的C++标准</h3><p>在编写C++程序的时候，可能会用到C++11、C++14、C++17、C++20等新特性，那么就需要在编译的时候在编译命令中制定出要使用哪个标准：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ *.cpp -std=c++11 -o app</span></span><br></pre></td></tr></table></figure><p>上面的例子中通过参数<code>-std=c++11</code>指定出要使用c++11标准编译程序，C++标准对应有一宏叫做<code>DCMAKE_CXX_STANDARD</code>。在CMake中想要指定C++标准有两种方式：</p><ol><li>在 CMakeLists.txt 中通过 set 命令指定</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加-std=c++11</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment">#增加-std=c++14</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="comment">#增加-std=c++17</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>在执行 cmake 命令的时候指定出这个宏的值</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">增加-std=c++11</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=11</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">增加-std=c++14</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=14</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">增加-std=c++17</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=17</span><br></pre></td></tr></table></figure><blockquote><p>在上面例子中 CMake 后的路径需要根据实际情况酌情修改。</p></blockquote><hr><h3 id="2-2-3-指定输出的路径"><a href="#2-2-3-指定输出的路径" class="headerlink" title="2.2.3 指定输出的路径"></a>2.2.3 指定输出的路径</h3><p>在CMake中指定可执行程序输出的路径，也对应一个宏，叫做<code>EXECUTABLE_OUTPUT_PATH</code>，它的值还是通过<code>set</code>命令进行设置:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(HOME /home/robin/Linux/Sort)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>/bin)</span><br></pre></td></tr></table></figure><ul><li>第一行：定义一个变量用于存储一个绝对路径</li><li>第二行：将拼接好的路径值设置给<code>EXECUTABLE_OUTPUT_PATH</code>宏<ul><li>如果这个路径中的子目录不存在，会自动生成，无需自己手动创建</li></ul></li></ul><p><font color = red>由于可执行程序是基于 cmake 命令生成的 makefile 文件然后再执行 make 命令得到的，所以如果此处指定可执行程序生成路径的时候使用的是相对路径 .&#x2F;xxx&#x2F;xxx，那么这个路径中的 .&#x2F; 对应的就是 makefile 文件所在的那个目录。</font></p><hr><h2 id="2-3-搜索文件"><a href="#2-3-搜索文件" class="headerlink" title="2.3 搜索文件"></a>2.3 搜索文件</h2><p>如果一个项目里边的源文件很多，在编写<code>CMakeLists.txt</code>文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦也不现实。所以，在CMake中为我们提供了搜索文件的命令，可以使用<code>aux_source_directory</code>命令或者<code>file</code>命令。</p><h3 id="2-3-1-方式1"><a href="#2-3-1-方式1" class="headerlink" title="2.3.1 方式1"></a>2.3.1 方式1</h3><p>在 CMake 中使用<code>aux_source_directory</code>命令可以查找某个路径下的所有源文件，命令格式为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(&lt; dir &gt; &lt; variable &gt;)</span><br></pre></td></tr></table></figure><ul><li><code>dir</code>：要搜索的目录</li><li><code>variable</code>：将从<code>dir</code>目录下搜索到的源文件列表存储到该变量中</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 搜索 src 目录下的源文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src SRC_LIST)</span><br><span class="line"><span class="keyword">add_executable</span>(app  <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-2-方式2"><a href="#2-3-2-方式2" class="headerlink" title="2.3.2 方式2"></a>2.3.2 方式2</h3><p>如果一个项目里边的源文件很多，在编写<code>CMakeLists.txt</code>文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦了。所以，在CMake中为我们提供了搜索文件的命令，他就是<code>file</code>（当然，除了搜索以外通过 &#96;file&#96;&#96; 还可以做其他事情）。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</span><br></pre></td></tr></table></figure><ul><li><code>GLOB</code>: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。</li><li><code>GLOB_RECURSE</code>：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。</li></ul><p><strong>搜索当前目录的src目录下所有的源文件，并存储到变量中</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/*.h)</span><br></pre></td></tr></table></figure><ul><li><p><code>CMAKE_CURRENT_SOURCE_DIR</code> 宏表示当前访问的 CMakeLists.txt 文件所在的路径。</p></li><li><p>关于要搜索的文件路径和类型可加双引号，也可不加:</p></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.h&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="2-4-包含头文件"><a href="#2-4-包含头文件" class="headerlink" title="2.4 包含头文件"></a>2.4 包含头文件</h2><p>在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能够找到这些头文件，并顺利通过编译。在CMake中设置要包含的目录也很简单，通过一个命令就可以搞定了，他就是<code>include_directories</code>:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(headpath)</span><br></pre></td></tr></table></figure><p>举例说明，有源文件若干，其目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">└── src</span><br><span class="line">    ├── add.cpp</span><br><span class="line">    ├── div.cpp</span><br><span class="line">    ├── main.cpp</span><br><span class="line">    ├── mult.cpp</span><br><span class="line">    └── sub.cpp</span><br><span class="line"></span><br><span class="line">3 directories, 7 files</span><br></pre></td></tr></table></figure><p><code>CMakeLists.txt</code>文件内容如下:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(HOME /home/robin/Linux/calc)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>/bin/)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(app  <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><p>其中，第六行指定就是头文件的路径，<code>PROJECT_SOURCE_DIR</code>宏对应的值就是我们在使用cmake命令时，后面紧跟的目录，一般是工程的根目录。</p><hr><h2 id="2-5-制作动态库或静态库"><a href="#2-5-制作动态库或静态库" class="headerlink" title="2.5 制作动态库或静态库"></a>2.5 制作动态库或静态库</h2><p>有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来讲解在cmake中生成这两类库文件的方法。</p><h3 id="2-5-1-制作静态库"><a href="#2-5-1-制作静态库" class="headerlink" title="2.5.1 制作静态库"></a>2.5.1 制作静态库</h3><p>在cmake中，如果要制作静态库，需要使用的命令如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(库名称 STATIC 源文件<span class="number">1</span> [源文件<span class="number">2</span>] ...) </span><br></pre></td></tr></table></figure><p>在Linux中，静态库名字分为三部分：<code>lib+库名字+.a</code>，此处<code>只需要指定出库的名字就可以了</code>，另外两部分在生成该文件的时候会自动填充。</p><p>在Windows中虽然库名和Linux格式不同，但也只需指定出名字即可。</p><p>下面有一个目录，需要将<code>src</code>目录中的源文件编译成静态库，然后再使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include           # 头文件目录</span><br><span class="line">│   └── head.h</span><br><span class="line">├── main.cpp          # 用于测试的源文件</span><br><span class="line">└── src               # 源文件目录</span><br><span class="line">    ├── add.cpp</span><br><span class="line">    ├── div.cpp</span><br><span class="line">    ├── mult.cpp</span><br><span class="line">    └── sub.cpp</span><br></pre></td></tr></table></figure><p>根据上面的目录结构，可以这样编写<code>CMakeLists.txt</code>文件:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><p>这样最终就会生成对应的静态库文件<code>libcalc.a</code>。</p><hr><h3 id="2-5-2-制作动态库"><a href="#2-5-2-制作动态库" class="headerlink" title="2.5.2 制作动态库"></a>2.5.2 制作动态库</h3><p>在cmake中，如果要制作动态库，需要使用的命令如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(库名称 SHARED 源文件<span class="number">1</span> [源文件<span class="number">2</span>] ...)</span><br></pre></td></tr></table></figure><p>在Linux中，动态库名字分为三部分：<code>lib+库名字+.so</code>，此处<code>只需要指定出库的名字就可以了</code>，另外两部分在生成该文件的时候会自动填充。</p><p>在Windows中虽然库名和Linux格式不同，但也只需指定出名字即可。</p><p>根据上面的目录结构，可以这样编写<code>CMakeLists.txt</code>文件:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(calc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><p>这样最终就会生成对应的动态库文件<code>libcalc.so</code>。</p><hr><h3 id="2-5-3-指定输出的路径"><a href="#2-5-3-指定输出的路径" class="headerlink" title="2.5.3 指定输出的路径"></a>2.5.3 指定输出的路径</h3><p><strong>方式1 - 适用于动态库</strong></p><p>对于生成的库文件来说和可执行程序一样都可以指定输出路径。<code>由于在Linux下生成的动态库默认是有执行权限的</code>，所以可以按照生成可执行程序的方式去指定它生成的目录：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="comment"># 设置动态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="keyword">add_library</span>(calc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><p>对于这种方式来说，其实就是通过<code>set</code>命令给<code>EXECUTABLE_OUTPUT_PATH</code>宏设置了一个路径，这个路径就是可执行文件生成的路径。</p><hr><p><strong>方式2 - 都适用</strong></p><p><code>由于在Linux下生成的静态库默认不具有可执行权限</code>，所以在指定静态库生成的路径的时候就不能使用<code>EXECUTABLE_OUTPUT_PATH</code>宏了，而应该使用<code>LIBRARY_OUTPUT_PATH</code>，这个宏对应静态库文件和动态库文件都适用。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="comment"># 设置动态库/静态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="comment">#add_library(calc SHARED $&#123;SRC_LIST&#125;)</span></span><br><span class="line"><span class="comment"># 生成静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="2-6-包含库文件"><a href="#2-6-包含库文件" class="headerlink" title="2.6 包含库文件"></a>2.6 包含库文件</h2><p>在编写程序的过程中，可能会用到一些系统提供的动态库或者自己制作出的动态库或者静态库文件，cmake中也为我们提供了相关的加载动态库的命令。</p><h3 id="2-6-1-链接静态库"><a href="#2-6-1-链接静态库" class="headerlink" title="2.6.1 链接静态库"></a>2.6.1 链接静态库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── add.cpp</span><br><span class="line">├── div.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── mult.cpp</span><br><span class="line">└── sub.cpp</span><br></pre></td></tr></table></figure><p>现在我们把上面<code>src</code>目录中的<code>add.cpp、div.cpp、mult.cpp、sub.cpp编译成一个静态库文件libcalc.a</code>。</p><p>测试目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span> </span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.a     # 制作出的静态库的名字</span><br><span class="line">└── src</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br><span class="line">4 directories, 4 files</span><br></pre></td></tr></table></figure><p>在cmake中，链接静态库的命令如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_libraries</span>(&lt;static lib&gt; [&lt;static lib&gt;...])</span><br></pre></td></tr></table></figure><ul><li>参数1：指定出要链接的静态库的名字<ul><li>可以是<code>全名</code> libxxx.a</li><li>也可以是<code>掐头</code>（lib）<code>去尾</code>（.a）之后的名字 xxx</li></ul></li><li>参数2-N：要链接的其它静态库的名字</li></ul><p>如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link_directories(&lt;lib path&gt;)</span><br></pre></td></tr></table></figure><p>这样，修改之后的<code>CMakeLists.txt</code>文件内容如下:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="comment"># 搜索指定目录下源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="comment"># 包含头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 包含静态库路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 链接静态库</span></span><br><span class="line"><span class="keyword">link_libraries</span>(calc)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><p>添加了第8行的代码，就可以根据参数指定的路径找到这个静态库了。</p><hr><h3 id="2-6-2-链接动态库"><a href="#2-6-2-链接动态库" class="headerlink" title="2.6.2 链接动态库"></a>2.6.2 链接动态库</h3><p>在程序编写过程中，除了在项目中引入静态库，好多时候也会使用一些标准的或者第三方提供的一些动态库，关于动态库的制作、使用以及在内存中的加载方式和静态库都是不同的</p><p>在<code>cmake</code>中链接动态库的命令如下:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">    &lt;<span class="keyword">target</span>&gt; </span><br><span class="line">    &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;... </span><br><span class="line">    [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)</span><br></pre></td></tr></table></figure><ul><li><code>target</code>：指定要加载动态库的文件的名字<ul><li>该文件可能是一个源文件</li><li>该文件可能是一个动态库文件</li><li>该文件可能是一个可执行文件</li></ul></li><li><code>PRIVATE|PUBLIC|INTERFACE</code>：动态库的访问权限，默认为&#96;PUBLIC&#96;&#96;<ul><li>如果各个动态库之间没有依赖关系，无需做任何设置，三者没有没有区别，<code>一般无需指定，使用默认的 PUBLIC 即可。</code></li><li><code>动态库的链接具有传递性</code>，如果动态库 A 链接了动态库B、C，动态库D链接了动态库A，此时动态库D相当于也链接了动态库B、C，并可以使用动态库B、C中定义的方法。</li></ul></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(A B C)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(D A)</span><br></pre></td></tr></table></figure><p><code>PUBLIC</code>：在public后面的库会被Link到前面的target中，并且里面的符号也会被导出，提供给第三方使用。</p><p><code>PRIVATE</code>：在private后面的库仅被link到前面的target中，并且终结掉，第三方不能感知你调了啥库</p><p><code>INTERFACE</code>：在interface后面引入的库不会被链接到前面的target中，只会导出符号。</p><p><strong>链接系统动态库</strong></p><p>动态库的链接和静态库是完全不同的：</p><ul><li>静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。</li><li>动态库在生成可执行程序的链接阶段<code>不会</code>被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存</li></ul><p>因此，在<code>cmake</code>中指定要链接的动态库的时候，<code>应该将命令写到生成了可执行文件之后：</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment"># 添加并指定最终生成的可执行程序名</span></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 指定可执行程序要链接的动态库名字</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(app pthread)</span><br></pre></td></tr></table></figure><p>在<code>target_link_libraries(app pthread)</code>中：</p><ul><li><code>app</code>: 对应的是最终生成的可执行程序的名字</li><li><code>pthread</code>：这是可执行程序要加载的动态库，这个库是系统提供的线程库，全名为<code>libpthread.so</code>，在指定的时候一般会掐头（lib）去尾（.so）。</li></ul><p><strong>链接第三方动态库</strong></p><p>现在，自己生成了一个动态库，对应的目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span> </span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h            # 动态库对应的头文件</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.so        # 自己制作的动态库文件</span><br><span class="line">└── main.cpp              # 测试用的源文件</span><br><span class="line"></span><br><span class="line">3 directories, 4 files</span><br></pre></td></tr></table></figure><p>假设在测试文件<code>main.cpp</code>中既使用了自己制作的动态库<code>libcalc.so</code>又使用了系统提供的线程库，此时<code>CMakeLists.txt</code>文件可以这样写：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app pthread calc)</span><br></pre></td></tr></table></figure><p>在第六行中，<code>pthread、calc</code>都是可执行程序<code>app</code>要链接的动态库的名字。当可执行程序<code>app</code>生成之后并执行该文件，会提示有如下错误信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./app</span> </span><br><span class="line">./app: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>这是因为可执行程序启动之后，去加载<code>calc</code>这个动态库，但是不知道这个动态库被放到了什么位置，所以就加载失败了，<font color = red>在 CMake 中可以在生成可执行程序之前，通过命令指定出要链接的动态库的位置，指定静态库位置使用的也是这个命令：</font></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(path)</span><br></pre></td></tr></table></figure><p>所以修改之后的<code>CMakeLists.txt</code>文件应该是这样的：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment"># 指定源文件或者动态库对应的头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 指定要链接的动态库的路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 添加并生成一个可执行程序</span></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 指定要链接的动态库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(app pthread calc)</span><br></pre></td></tr></table></figure><p>通过<code>link_directories</code>指定了动态库的路径之后，在执行生成的可执行程序的时候，就不会出现找不到动态库的问题了。</p><blockquote><p>温馨提示：使用 <code>target_link_libraries</code> 命令就可以链接动态库，<code>也可以链接静态库文件。</code></p></blockquote><hr><h2 id="2-7-日志"><a href="#2-7-日志" class="headerlink" title="2.7 日志"></a>2.7 日志</h2><p>在CMake中可以用用户显示一条消息，该命令的名字为<code>message：</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] <span class="string">&quot;message to display&quot;</span> ...)</span><br></pre></td></tr></table></figure><ul><li><code>(无)</code> ：重要消息</li><li><code>STATUS</code> ：非重要消息</li><li><code>WARNING</code>：CMake 警告, 会继续执行</li><li><code>AUTHOR_WARNING</code>：CMake 警告 (dev), 会继续执行</li><li><code>SEND_ERROR</code>：CMake 错误, 继续执行，但是会跳过生成的步骤</li><li><code>FATAL_ERROR</code>：CMake 错误, 终止所有处理过程</li></ul><p>CMake的命令行工具会在stdout上显示STATUS消息，在stderr上显示其他所有消息。CMake的GUI会在它的log区域显示所有消息。</p><p>CMake警告和错误消息的文本显示使用的是一种简单的标记语言。文本没有缩进，超过长度的行会回卷，段落之间以新行做为分隔符。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出一般日志信息</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 输出警告信息</span></span><br><span class="line"><span class="keyword">message</span>(WARNING <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 输出错误信息</span></span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="2-8-变量操作"><a href="#2-8-变量操作" class="headerlink" title="2.8 变量操作"></a>2.8 变量操作</h2><h3 id="2-8-1-追加"><a href="#2-8-1-追加" class="headerlink" title="2.8.1 追加"></a>2.8.1 追加</h3><p>有时候项目中的源文件并不一定都在同一个目录中，但是这些源文件最终却需要一起进行编译来生成最终的可执行文件或者库文件。如果我们通过<code>file</code>命令对各个目录下的源文件进行搜索，最后还需要做一个字符串拼接的操作，关于字符串拼接可以使用<code>set</code>命令也可以使用<code>list</code>命令。</p><p><strong>使用set拼接</strong></p><p>如果使用set进行字符串拼接，对应的命令格式如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(变量名<span class="number">1</span> <span class="variable">$&#123;变量名1&#125;</span> <span class="variable">$&#123;变量名2&#125;</span> ...)</span><br></pre></td></tr></table></figure><p>关于上面的命令其实就是将从第二个参数开始往后所有的字符串进行拼接，最后将结果存储到第一个参数中，如果第一个参数中原来有数据会对原数据就行覆盖。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">set</span>(TEMP <span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src1/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_2 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src2/*.cpp)</span><br><span class="line"><span class="comment"># 追加(拼接)</span></span><br><span class="line"><span class="keyword">set</span>(SRC_1 <span class="variable">$&#123;SRC_1&#125;</span> <span class="variable">$&#123;SRC_2&#125;</span> <span class="variable">$&#123;TEMP&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>使用list拼接</strong></p><p>如果使用list进行字符串拼接，对应的命令格式如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure><p><code>list</code>命令的功能比<code>set</code>要强大，字符串拼接只是它的其中一个功能，所以需要在它第一个参数的位置指定出我们要做的操作，<code>APPEND</code>表示进行数据追加，后边的参数和<code>set</code>就一样了。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">set</span>(TEMP <span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src1/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_2 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src2/*.cpp)</span><br><span class="line"><span class="comment"># 追加(拼接)</span></span><br><span class="line"><span class="keyword">list</span>(APPEND SRC_1 <span class="variable">$&#123;SRC_1&#125;</span> <span class="variable">$&#123;SRC_2&#125;</span> <span class="variable">$&#123;TEMP&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>在CMake中，使用<code>set</code>命令可以创建一个<code>list</code>。一个在list内部是一个由分号<code>;</code>分割的一组字符串。<br>例如，<code>set(var a b c d e)命令将会创建一个list:a;b;c;d;e，但是最终打印变量值的时候得到的是abcde。</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(tmp1 a;b;c;d;e)</span><br><span class="line"><span class="keyword">set</span>(tmp2 a b c d e)</span><br><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;tmp1&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;tmp2&#125;</span>)</span><br></pre></td></tr></table></figure><p>输出的结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abcde</span><br><span class="line">abcde</span><br></pre></td></tr></table></figure><hr><h3 id="2-8-2-字符串移除"><a href="#2-8-2-字符串移除" class="headerlink" title="2.8.2 字符串移除"></a>2.8.2 字符串移除</h3><p>我们在通过<code>file</code>搜索某个目录就得到了该目录下所有的源文件，但是其中有些源文件并不是我们所需要的，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── add.cpp</span><br><span class="line">├── div.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── mult.cpp</span><br><span class="line">└── sub.cpp</span><br><span class="line"></span><br><span class="line">0 directories, 5 files</span><br></pre></td></tr></table></figure><p>在当前这么目录有五个源文件，其中<code>main.cpp</code>是一个测试文件。如果我们想要把计算器相关的源文件生成一个动态库给别人使用，那么只需要<code>add.cpp、div.cp、mult.cpp、sub.cpp</code>这四个源文件就可以了。此时，就需要将<code>main.cpp</code>从搜索到的数据中剔除出去，想要实现这个功能，也可以使用<code>list</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(REMOVE_ITEM &lt;<span class="keyword">list</span>&gt; &lt;value&gt; [&lt;value&gt; ...])</span><br></pre></td></tr></table></figure><p>通过上面的命令原型可以看到删除和追加数据类似，只不过是第一个参数变成了<code>REMOVE_ITEM</code>。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">set</span>(TEMP <span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment"># 移除前日志</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 移除 main.cpp</span></span><br><span class="line"><span class="keyword">list</span>(REMOVE_ITEM SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/main.cpp)</span><br><span class="line"><span class="comment"># 移除后日志</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以看到，在第8行把将要移除的文件的名字指定给list就可以了。<font color = red> 但是一定要注意通过 file 命令搜索源文件的时候得到的是文件的绝对路径（在list中每个文件对应的路径都是一个item，并且都是绝对路径），那么在移除的时候也要将该文件的绝对路径指定出来才可以，否是移除操作不会成功。</font></p><p>关于list命令还有其它功能，但是并不常用，在此就不一一进行举例介绍了。</p><blockquote><p>获取 list 的长度。</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(LENGTH &lt;<span class="keyword">list</span>&gt; &lt;output variable&gt;)</span><br></pre></td></tr></table></figure><ul><li><code>LENGTH</code>：子命令LENGTH用于读取列表长度</li><li><code>&lt;list&gt;</code>：当前操作的列表</li><li><code>&lt;output variable&gt;</code>：新创建的变量，用于存储列表的长度。</li></ul><blockquote><p>读取列表中指定索引的的元素，可以指定多个索引</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(GET &lt;<span class="keyword">list</span>&gt; &lt;element index&gt; [&lt;element index&gt; ...] &lt;output variable&gt;)</span><br></pre></td></tr></table></figure><ul><li><code>&lt;list&gt;</code>：当前操作的列表</li><li><code>&lt;element index&gt;</code>：列表元素的索引<ul><li>从0开始编号，索引0的元素为列表中的第一个元素；</li><li>索引也可以是负数，<code>-1</code>表示列表的最后一个元素，-2表示列表倒数第二个元素，以此类推</li><li>当索引（不管是正还是负）超过列表的长度，运行会报错</li></ul></li><li><code>&lt;output variable&gt;</code>：新创建的变量，存储指定索引元素的返回结果，也是一个列表。</li></ul><blockquote><p>将列表中的元素用连接符（字符串）连接起来组成一个字符串</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (JOIN &lt;<span class="keyword">list</span>&gt; &lt;glue&gt; &lt;output variable&gt;)</span><br></pre></td></tr></table></figure><ul><li><code>&lt;list&gt;</code>：当前操作的列表</li><li><code>&lt;glue&gt;</code>：指定的连接符（字符串）</li><li><code>&lt;output variable&gt;</code>：新创建的变量，存储返回的字符串</li></ul><blockquote><p>查找列表是否存在指定的元素，若果未找到，返回-1</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(FIND &lt;<span class="keyword">list</span>&gt; &lt;value&gt; &lt;output variable&gt;)</span><br></pre></td></tr></table></figure><ul><li><code>&lt;list&gt;</code>：当前操作的列表</li><li><code>&lt;value&gt;</code>：需要再列表中搜索的元素</li><li><code>&lt;output variable&gt;</code>：新创建的变量<ul><li>如果列表<list>中存在<value>，那么返回<value>在列表中的索引</li><li>如果未找到则返回-1。</li></ul></li></ul><blockquote><p>将元素追加到列表中</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (APPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure><blockquote><p>在list中指定的位置插入若干元素</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(INSERT &lt;<span class="keyword">list</span>&gt; &lt;element_index&gt; &lt;element&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure><blockquote><p>将元素插入到列表的0索引位置</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (PREPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure><blockquote><p>将列表中最后元素移除</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (POP_BACK &lt;<span class="keyword">list</span>&gt; [&lt;out-var&gt;...])</span><br></pre></td></tr></table></figure><blockquote><p>将列表中第一个元素移除</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (POP_FRONT &lt;<span class="keyword">list</span>&gt; [&lt;out-var&gt;...])</span><br></pre></td></tr></table></figure><blockquote><p>将指定的元素从列表中移除</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (REMOVE_ITEM &lt;<span class="keyword">list</span>&gt; &lt;value&gt; [&lt;value&gt; ...])</span><br></pre></td></tr></table></figure><blockquote><p>将指定索引的元素从列表中移除</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (REMOVE_AT &lt;<span class="keyword">list</span>&gt; &lt;index&gt; [&lt;index&gt; ...])</span><br></pre></td></tr></table></figure><blockquote><p>移除列表中的重复元素</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (REMOVE_DUPLICATES &lt;<span class="keyword">list</span>&gt;)</span><br></pre></td></tr></table></figure><blockquote><p>列表翻转</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(REVERSE &lt;<span class="keyword">list</span>&gt;)</span><br></pre></td></tr></table></figure><blockquote><p>列表排序</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (SORT &lt;<span class="keyword">list</span>&gt; [COMPARE &lt;compare&gt;] [CASE &lt;case&gt;] [ORDER &lt;order&gt;])</span><br></pre></td></tr></table></figure><ul><li><code>COMPARE</code>：指定排序方法。有如下几种值可选：<ul><li><code>STRING</code>:按照字母顺序进行排序，为默认的排序方法</li><li><code>FILE_BASENAME</code>：如果是一系列路径名，会使用basename进行排序</li><li><code>NATURAL</code>：使用自然数顺序排序</li></ul></li><li><code>CASE</code>：指明是否大小写敏感。有如下几种值可选：<ul><li><code>SENSITIVE</code>: 按照大小写敏感的方式进行排序，为默认值</li><li><code>INSENSITIVE</code>：按照大小写不敏感方式进行排序</li></ul></li><li><code>ORDER</code>：指明排序的顺序。有如下几种值可选：<ul><li><code>ASCENDING</code>:按照升序排列，为默认值</li><li><code>DESCENDING</code>：按照降序排列</li></ul></li></ul><hr><h2 id="2-9-宏定义"><a href="#2-9-宏定义" class="headerlink" title="2.9 宏定义"></a>2.9 宏定义</h2><p>在进行程序测试的时候，我们可以在代码中添加一些宏定义，通过这些宏来控制这些代码是否生效，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER  3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是一个程序猿, 我不会爬树...\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;NUMBER; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, GCC!!!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序的第七行对<code>DEBUG</code>宏进行了判断，如果该宏被定义了，那么第八行就会进行日志输出，如果没有定义这个宏，第八行就相当于被注释掉了，因此最终无法看到日志输入出<code>（上述代码中并没有定义这个宏）</code>。</p><p>为了让测试更灵活，我们可以不在代码中定义这个宏，而是在测试的时候去把它定义出来，其中一种方式就是在<code>gcc/g++</code>命令中去指定，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc test.c -DDEBUG -o app</span></span><br></pre></td></tr></table></figure><p>在<code>gcc/g++</code>命令中通过参数 <code>-D</code> 指定出要定义的宏的名字，这样就相当于在代码中定义了一个宏，其名字为<code>DEBUG</code>。</p><p>在CMake中我们也可以做类似的事情，对应的命令叫做<code>add_definitions:</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>(-D宏名称)</span><br></pre></td></tr></table></figure><p>针对于上面的源文件编写一个<code>CMakeLists.txt</code>，内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="comment"># 自定义 DEBUG 宏</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-DDEBUG)</span><br><span class="line"><span class="keyword">add_executable</span>(app ./<span class="keyword">test</span>.c)</span><br></pre></td></tr></table></figure><p>通过这种方式，上述代码中的第八行日志就能够被输出出来了。</p><hr><h2 id="2-10-CMake的普通实例使用"><a href="#2-10-CMake的普通实例使用" class="headerlink" title="2.10 CMake的普通实例使用"></a>2.10 CMake的普通实例使用</h2><h3 id="2-10-1-CMake的普通编译"><a href="#2-10-1-CMake的普通编译" class="headerlink" title="2.10.1 CMake的普通编译"></a>2.10.1 CMake的普通编译</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(calc)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB HEAD <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD&#125;</span>) <span class="comment">#包头,路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/exeout) <span class="comment">#生成路径</span></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-10-2-CMake的动-静-态库的生成"><a href="#2-10-2-CMake的动-静-态库的生成" class="headerlink" title="2.10.2 CMake的动(静)态库的生成"></a>2.10.2 CMake的动(静)态库的生成</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(libtest)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/lib) <span class="comment">#库生成路径</span></span><br><span class="line"><span class="comment"># add_library(calc SHARED $&#123;SRC&#125;) #动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC&#125;</span>) <span class="comment">#静态库</span></span><br></pre></td></tr></table></figure><h3 id="2-10-3-CMake的动-静-态库的使用"><a href="#2-10-3-CMake的动-静-态库的使用" class="headerlink" title="2.10.3 CMake的动(静)态库的使用"></a>2.10.3 CMake的动(静)态库的使用</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(uselib)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/lib) <span class="comment">#静态库</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/lib_shared) <span class="comment">#动态库</span></span><br><span class="line"><span class="keyword">add_executable</span>(app main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app calc) <span class="comment">#链接静态库/动态库 一定要放在后面</span></span><br></pre></td></tr></table></figure><hr><hr><h1 id="3-预定义宏"><a href="#3-预定义宏" class="headerlink" title="3. 预定义宏"></a>3. 预定义宏</h1><p>下面的列表中为大家整理了一些CMake中常用的宏：</p><table><thead><tr><th>宏</th><th>功能</th></tr></thead><tbody><tr><td>PROJECT_SOURCE_DIR</td><td>使用cmake命令后紧跟的目录，一般是工程的根目录</td></tr><tr><td>PROJECT_BINARY_DIR</td><td>执行cmake命令的目录</td></tr><tr><td>CMAKE_CURRENT_SOURCE_DIR</td><td>当前处理的CMakeLists.txt所在的路径</td></tr><tr><td>CMAKE_CURRENT_BINARY_DIR</td><td>target编译目录</td></tr><tr><td>EXECUTABLE_OUTPUT_PATH</td><td>重新定义目标二进制可执行文件的存放位置</td></tr><tr><td>LIBRARY_OUTPUT_PATH</td><td>重新定义目标链接库文件的存放位置</td></tr><tr><td>PROJECT_NAME</td><td>返回通过PROJECT指令定义的项目名称</td></tr><tr><td>CMAKE_BINARY_DIR</td><td>项目实际构建路径，假设在<code>build</code>目录进行的构建，那么得到的就是这个目录的路径</td></tr></tbody></table><hr><h1 id="4-嵌套的CMake"><a href="#4-嵌套的CMake" class="headerlink" title="4. 嵌套的CMake"></a>4. 嵌套的CMake</h1><p>如果项目很大，或者项目中有很多的源码目录，在通过CMake管理项目的时候如果只使用一个<code>CMakeLists.txt</code>，那么这个文件相对会比较复杂，有一种化繁为简的方式就是给每个源码目录都添加一个<code>CMakeLists.txt</code>文件（头文件目录不需要），这样每个文件都不会太复杂，而且更灵活，更容易维护。</p><p>先来看一下下面的这个的目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── calc</span><br><span class="line">│   ├── add.cpp</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── div.cpp</span><br><span class="line">│   ├── mult.cpp</span><br><span class="line">│   └── sub.cpp</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   ├── calc.h</span><br><span class="line">│   └── sort.h</span><br><span class="line">├── sort</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── insert.cpp</span><br><span class="line">│   └── select.cpp</span><br><span class="line">├── test1</span><br><span class="line">│   ├── calc.cpp</span><br><span class="line">│   └── CMakeLists.txt</span><br><span class="line">└── test2</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── sort.cpp</span><br><span class="line"></span><br><span class="line">6 directories, 15 files</span><br></pre></td></tr></table></figure><ul><li><code>include</code> 目录：头文件目录</li><li><code>calc</code> 目录：目录中的四个源文件对应的加、减、乘、除算法<ul><li>对应的头文件是<code>include</code>中的<code>calc.h</code></li></ul></li><li><code>sort</code> 目录 ：目录中的两个源文件对应的是插入排序和选择排序算法<ul><li>对应的头文件是<code>include</code>中的<code>sort.h</code></li></ul></li><li><code>test1</code> 目录：测试目录，对加、减、乘、除算法进行测试</li><li><code>test2</code> 目录：测试目录，对排序算法进行测试</li></ul><p>可以看到各个源文件目录所需要的<code>CMakeLists.txt</code>文件现在已经添加完毕了。接下依次分析一下各个文件中需要添加的内容。</p><hr><h2 id="4-1-准备工作"><a href="#4-1-准备工作" class="headerlink" title="4.1 准备工作"></a>4.1 准备工作</h2><h3 id="4-1-1-节点关系"><a href="#4-1-1-节点关系" class="headerlink" title="4.1.1 节点关系"></a>4.1.1 节点关系</h3><p>众所周知，Linux的目录是树状结构，所以<code>嵌套的 CMake 也是一个树状结构，最顶层的 CMakeLists.txt 是根节点，其次都是子节点。</code>因此，我们需要了解一些关于 <code>CMakeLists.txt</code> 文件变量作用域的一些信息：</p><ul><li>根节点CMakeLists.txt中的变量全局有效</li><li>父节点CMakeLists.txt中的变量可以在子节点中使用</li><li>子节点CMakeLists.txt中的变量只能在当前节点中使用</li></ul><h3 id="4-1-2-添加子目录"><a href="#4-1-2-添加子目录" class="headerlink" title="4.1.2 添加子目录"></a>4.1.2 添加子目录</h3><p>接下来我们还需要知道在 CMake 中父子节点之间的关系是如何建立的，这里需要用到一个 CMake 命令：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure><ul><li><code>source_dir</code>：指定了<code>CMakeLists.txt</code>源文件和代码文件的位置，其实就是指定子目录</li><li><code>binary_dir</code>：指定了输出文件的路径，一般不需要指定，忽略即可。</li><li><code>EXCLUDE_FROM_ALL</code>：在子路径下的目标默认不会被包含到父路径的ALL目标里，并且也会被排除在IDE工程文件之外。用户必须显式构建在子路径下的目标。</li></ul><p>通过这种方式CMakeLists.txt文件之间的父子关系就被构建出来了。</p><hr><h2 id="4-2-解决问题"><a href="#4-2-解决问题" class="headerlink" title="4.2 解决问题"></a>4.2 解决问题</h2><p>在上面的目录中我们要做如下事情：</p><ol><li>通过 <code>test1 目录</code>中的测试文件进行计算器相关的测试</li><li>通过 <code>test2 目录</code>中的测试文件进行排序相关的测试</li></ol><p>现在相当于是要进行模块化测试，对于<code>calc</code>和<code>sort</code>目录中的源文件来说，可以将它们先编译成库文件（可以是静态库也可以是动态库）然后在提供给测试文件使用即可。库文件的本质其实还是代码，只不过是从文本格式变成了二进制格式。</p><hr><h3 id="4-2-1-根目录"><a href="#4-2-1-根目录" class="headerlink" title="4.2.1 根目录"></a>4.2.1 根目录</h3><p>根目录中的 <code>CMakeLists.txt</code>文件内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line"><span class="comment"># 静态库生成的路径</span></span><br><span class="line"><span class="keyword">set</span>(LIB_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 测试程序生成的路径</span></span><br><span class="line"><span class="keyword">set</span>(EXEC_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"><span class="comment"># 头文件目录</span></span><br><span class="line"><span class="keyword">set</span>(HEAD_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 静态库的名字</span></span><br><span class="line"><span class="keyword">set</span>(CALC_LIB calc)</span><br><span class="line"><span class="keyword">set</span>(SORT_LIB sort)</span><br><span class="line"><span class="comment"># 可执行程序的名字</span></span><br><span class="line"><span class="keyword">set</span>(APP_NAME_1 test1)</span><br><span class="line"><span class="keyword">set</span>(APP_NAME_2 test2)</span><br><span class="line"><span class="comment"># 添加子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(calc)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(sort)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(test1)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(test2)</span><br></pre></td></tr></table></figure><p>在根节点对应的文件中主要做了两件事情：<code>定义全局变量</code>和<code>添加子目录</code>。</p><ul><li>定义的全局变量主要是给子节点使用，目的是为了提高子节点中的<code>CMakeLists.txt</code>文件的可读性和可维护性，避免冗余并降低出差的概率。</li><li>一共添加了四个子目录，每个子目录中都有一个<code>CMakeLists.txt</code>文件，这样它们的父子关系就被确定下来了。</li></ul><hr><h3 id="4-2-2-calc-目录"><a href="#4-2-2-calc-目录" class="headerlink" title="4.2.2 calc 目录"></a>4.2.2 calc 目录</h3><p>calc 目录中的 CMakeLists.txt文件内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALCLIB)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;CALC_LIB&#125;</span> STATIC <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure><ul><li>第3行<code>aux_source_directory</code>：搜索当前目录（<code>calc</code>目录）下的所有源文件</li><li>第4行<code>include_directories</code>：包含头文件路径，<code>HEAD_PATH</code>是在根节点文件中定义的</li><li>第5行<code>set</code>：设置库的生成的路径，<code>LIB_PATH</code>是在根节点文件中定义的</li><li>第6行<code>add_library</code>：生成静态库，静态库名字<code>CALC_LIB</code>是在根节点文件中定义的</li></ul><hr><h3 id="4-2-3-sort-目录"><a href="#4-2-3-sort-目录" class="headerlink" title="4.2.3 sort 目录"></a>4.2.3 sort 目录</h3><p>sort 目录中的 CMakeLists.txt文件内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(SORTLIB)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;SORT_LIB&#125;</span> SHARED <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure><ul><li>第6行<code>add_library</code>：生成动态库，动态库名字<code>SORT_LIB</code>是在根节点文件中定义的</li></ul><p>这个文件中的内容和<code>calc</code>节点文件中的内容类似，只不过这次生成的是动态库。</p><blockquote><p>在生成库文件的时候，这个库可以是静态库也可以是动态库，一般需要根据实际情况来确定。如果生成的库比较大，建议将其制作成动态库。</p></blockquote><hr><h3 id="4-2-4-test1-目录"><a href="#4-2-4-test1-目录" class="headerlink" title="4.2.4 test1 目录"></a>4.2.4 test1 目录</h3><p>test1 目录中的 CMakeLists.txt文件内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALCTEST)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">link_libraries</span>(<span class="variable">$&#123;CALC_LIB&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;EXEC_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;APP_NAME_1&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure><ul><li>第4行<code>include_directories</code>：指定头文件路径，<code>HEAD_PATH</code>变量是在根节点文件中定义的</li><li>第6行<code>link_libraries</code>：指定可执行程序要链接的<code>静态库</code>，<code>CALC_LIB</code>变量是在根节点文件中定义的</li><li>第7行<code>set</code>：指定可执行程序生成的路径，<code>EXEC_PATH</code>变量是在根节点文件中定义的</li><li>第8行<code>add_executable</code>：生成可执行程序，<code>APP_NAME_1</code>变量是在根节点文件中定义的</li></ul><p><font color = red>此处的可执行程序链接的是静态库，最终静态库会被打包到可执行程序中，可执行程序启动之后，静态库也就随之被加载到内存中了。</font></p><hr><h3 id="4-2-5-test2-目录"><a href="#4-2-5-test2-目录" class="headerlink" title="4.2.5 test2 目录"></a>4.2.5 test2 目录</h3><p>test2 目录中的 CMakeLists.txt文件内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(SORTTEST)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;EXEC_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;APP_NAME_2&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;APP_NAME_2&#125;</span> <span class="variable">$&#123;SORT_LIB&#125;</span>)</span><br></pre></td></tr></table></figure><ul><li>第四行<code>include_directories</code>：包含头文件路径，<code>HEAD_PATH</code>变量是在根节点文件中定义的</li><li>第五行<code>set</code>：指定可执行程序生成的路径，<code>EXEC_PATH</code>变量是在根节点文件中定义的</li><li>第六行<code>link_directories</code>：指定可执行程序要链接的动态库的路径，<code>LIB_PATH</code>变量是在根节点文件中定义的</li><li>第七行<code>add_executable</code>：生成可执行程序，<code>APP_NAME_2</code>变量是在根节点文件中定义的</li><li>第八行<code>target_link_libraries</code>：指定可执行程序要链接的动态库的名字</li></ul><p><font color=red>在生成可执行程序的时候，动态库不会被打包到可执行程序内部。当可执行程序启动之后动态库也不会被加载到内存，只有可执行程序调用了动态库中的函数的时候，动态库才会被加载到内存中，且多个进程可以共用内存中的同一个动态库，所以动态库又叫共享库。</font></p><hr><h3 id="4-2-6-构建项目"><a href="#4-2-6-构建项目" class="headerlink" title="4.2.6 构建项目"></a>4.2.6 构建项目</h3><p>一切准备就绪之后，开始构建项目，进入到根节点目录的<code>build 目录</code>中，执行cmake 命令，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- The C compiler identification is GNU 5.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 5.4.0</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/robin/abc/cmake/calc/build</span><br></pre></td></tr></table></figure><p>可以看到在build目录中生成了一些文件和目录，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree build -L 1</span>     </span><br><span class="line">build</span><br><span class="line">├── calc                  # 目录</span><br><span class="line">├── CMakeCache.txt        # 文件</span><br><span class="line">├── CMakeFiles            # 目录</span><br><span class="line">├── cmake_install.cmake   # 文件</span><br><span class="line">├── Makefile              # 文件</span><br><span class="line">├── sort                  # 目录</span><br><span class="line">├── test1                 # 目录</span><br><span class="line">└── test2                 # 目录</span><br></pre></td></tr></table></figure><p>然后在<code>build 目录下执行make</code> 命令:</p><p><img src="/img/cmake2.png"></p><p>通过上图可以得到如下信息：</p><ol><li>在项目根目录的lib目录中生成了静态库<code>libcalc.a</code></li><li>在项目根目录的lib目录中生成了动态库<code>libsort.so</code></li><li>在项目根目录的bin目录中生成了可执行程序<code>test1</code></li><li>在项目根目录的bin目录中生成了可执行程序<code>test2</code></li></ol><p>最后再来看一下上面提到的这些文件是否真的被生成到对应的目录中了:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree bin/ lib/</span></span><br><span class="line">bin/</span><br><span class="line">├── test1</span><br><span class="line">└── test2</span><br><span class="line">lib/</span><br><span class="line">├── libcalc.a</span><br><span class="line">└── libsort.so</span><br></pre></td></tr></table></figure><p>由此可见，真实不虚，至此，项目构建完毕。</p><blockquote><p>写在最后：<br>在项目中，如果将程序中的某个模块制作成了动态库或者静态库并且在<code>CMakeLists.txt</code> 中指定了库的输出目录，而后其它模块又需要加载这个生成的库文件，此时直接使用就可以了，如果没有指定库的输出路径或者需要直接加载外部提供的库文件，此时就需要使用 <code>link_directories</code> 将库文件路径指定出来。</p></blockquote><hr><h1 id="5-流程控制"><a href="#5-流程控制" class="headerlink" title="5. 流程控制"></a>5. 流程控制</h1><p>在 CMake 的 CMakeLists.txt 中也可以进行流程控制，也就是说可以像写 shell 脚本那样进行<code>条件判断</code>和<code>循环</code>。</p><h2 id="5-1-条件判断"><a href="#5-1-条件判断" class="headerlink" title="5.1 条件判断"></a>5.1 条件判断</h2><p>关于条件判断其语法格式如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;condition&gt;)</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">elseif</span>(&lt;condition&gt;) <span class="comment"># 可选快, 可以重复</span></span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">else</span>()              <span class="comment"># 可选快</span></span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>在进行条件判断的时候，如果有多个条件，那么可以写多个<code>elseif</code>，最后一个条件可以使用<code>else</code>，<font color = red>但是开始和结束是必须要成对出现的 </font>，分别为：if和endif。</p><hr><h3 id="5-1-1-基本表达式"><a href="#5-1-1-基本表达式" class="headerlink" title="5.1.1 基本表达式"></a>5.1.1 基本表达式</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;expression&gt;)</span><br></pre></td></tr></table></figure><p>如果是基本表达式，<code>expression</code> 有以下三种情况：<code>常量、变量、字符串。</code></p><ul><li>如果是<code>1</code>, <code>ON</code>, <code>YES</code>, <code>TRUE</code>, <code>Y</code>, <code>非零值</code>，<code>非空字符串时</code>，条件判断返回True</li><li>如果是 <code>0</code>, <code>OFF</code>, <code>NO</code>, <code>FALSE</code>, <code>N</code>, <code>IGNORE</code>, <code>NOTFOUND</code>，<code>空字符串</code>时，条件判断返回False</li></ul><hr><h3 id="5-1-2-逻辑判断"><a href="#5-1-2-逻辑判断" class="headerlink" title="5.1.2 逻辑判断"></a>5.1.2 逻辑判断</h3><ul><li>NOT</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> &lt;condition&gt;)</span><br></pre></td></tr></table></figure><p>其实这就是一个取反操作，如果条件<code>condition</code>为<code>True</code>将返回<code>False</code>，如果条件<code>condition</code>为<code>False</code>将返回<code>True</code>。</p><ul><li>AND</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;cond1&gt; <span class="keyword">AND</span> &lt;cond2&gt;)</span><br></pre></td></tr></table></figure><p>如果<code>cond1</code>和<code>cond2</code>同时为<code>True</code>，返回<code>True</code>否则返回False。</p><ul><li>OR</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;cond1&gt; <span class="keyword">OR</span> &lt;cond2&gt;)</span><br></pre></td></tr></table></figure><p>如果<code>cond1</code>和<code>cond2</code>两个条件中至少有一个为<code>True</code>，返回<code>True</code>，如果两个条件都为<code>False</code>则返回<code>False</code>。</p><hr><h3 id="5-1-3-比较"><a href="#5-1-3-比较" class="headerlink" title="5.1.3 比较"></a>5.1.3 比较</h3><p><strong>基于数值的比较</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">LESS</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">GREATER</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">EQUAL</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">LESS_EQUAL</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">GREATER_EQUAL</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br></pre></td></tr></table></figure><ul><li><code>LESS</code>：如果左侧数值<code>小于</code>右侧，返回<code>True</code></li><li><code>GREATER</code>：如果左侧数值<code>大于</code>右侧，返回<code>True</code></li><li><code>EQUAL</code>：如果左侧数值<code>等于</code>右侧，返回<code>True</code></li><li><code>LESS_EQUAL</code>：如果左侧数值<code>小于等于</code>右侧，返回<code>True</code></li><li><code>GREATER_EQUAL</code>：如果左侧数值<code>大于等于</code>右侧，返回<code>True</code></li></ul><p><strong>基于字符串的比较</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">STRLESS</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">STRGREATER</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">STREQUAL</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">STRLESS_EQUAL</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">STRGREATER_EQUAL</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br></pre></td></tr></table></figure><ul><li><code>STRLESS</code>：如果左侧字符串<code>小于</code>右侧，返回<code>True</code></li><li><code>STRGREATER</code>：如果左侧字符串<code>大于</code>右侧，返回<code>True</code></li><li><code>STREQUAL</code>：如果左侧字符串<code>等于</code>右侧，返回<code>True</code></li><li><code>STRLESS_EQUAL</code>：如果左侧字符串<code>小于等于</code>右侧，返回<code>True</code><br><code>STRGREATER_EQUAL</code>：如果左侧字符串<code>大于等于</code>右侧，返回<code>True</code></li></ul><hr><h3 id="5-1-4-文件操作"><a href="#5-1-4-文件操作" class="headerlink" title="5.1.4 文件操作"></a>5.1.4 文件操作</h3><p><strong>判断文件或者目录是否存在</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">EXISTS</span> path-to-<span class="keyword">file</span>-<span class="keyword">or</span>-directory)</span><br></pre></td></tr></table></figure><p>如果文件或者目录存在返回True，否则返回False。</p><p><strong>判断是不是目录</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">IS_DIRECTORY</span> path)</span><br></pre></td></tr></table></figure><ul><li><font color = red> 此处目录的 path 必须是绝对路径</font></li><li>如果目录存在返回True，目录不存在返回False。</li></ul><p><strong>判断是不是软连接</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">IS_SYMLINK</span> <span class="keyword">file</span>-name)</span><br></pre></td></tr></table></figure><ul><li><font color = red>此处的 file-name 对应的路径必须是绝对路径</font></li><li>如果软链接存在返回True，软链接不存在返回False。</li><li>软链接相当于 Windows 里的快捷方式</li></ul><p><strong>判断是不是绝对路径</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">IS_ABSOLUTE</span> path)</span><br></pre></td></tr></table></figure><ul><li>关于绝对路径:<ul><li>如果是Linux，该路径需要从根目录开始描述</li><li>如果是Windows，该路径需要从盘符开始描述</li></ul></li><li>如果是绝对路径返回True，如果不是绝对路径返回False。</li></ul><hr><h3 id="5-1-5-其它"><a href="#5-1-5-其它" class="headerlink" title="5.1.5 其它"></a>5.1.5 其它</h3><p><strong>判断某个元素是否在列表中</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">IN_LIST</span> &lt;variable&gt;)</span><br></pre></td></tr></table></figure><ul><li><font color = red>CMake 版本要求：大于等于3.3</font></li><li>如果这个元素在列表中返回True，否则返回False。</li></ul><p><strong>比较两个路径是否相等</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; PATH_EQUAL &lt;variable|<span class="keyword">string</span>&gt;)</span><br></pre></td></tr></table></figure><ul><li><font color = red> CMake 版本要求：大于等于3.24</font></li><li>如果这个元素在列表中返回True，否则返回False。</li></ul><p>关于路径的比较其实就是另个字符串的比较，如果路径格式书写没有问题也可以通过下面这种方式进行比较：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">STREQUAL</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br></pre></td></tr></table></figure><p>我们在书写某个路径的时候，可能由于误操作会多写几个分隔符，比如把<code>/a/b/c写成/a//b///c</code>，此时通过<code>STREQUAL</code>对这两个字符串进行比较肯定是不相等的，但是通过<code>PATH_EQUAL</code>去比较两个路径，得到的结果确实相等的，可以看下面的例子：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.26</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;/home//robin///Linux&quot;</span> PATH_EQUAL <span class="string">&quot;/home/robin/Linux&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;路径相等&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;路径不相等&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;/home//robin///Linux&quot;</span> <span class="keyword">STREQUAL</span> <span class="string">&quot;/home/robin/Linux&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;路径相等&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;路径不相等&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>输出的日志信息如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">路径相等</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">路径不相等</span><br></pre></td></tr></table></figure><p><font color = red>在进行路径比较的时候，如果使用 PATH_EQUAL 可以自动剔除路径中多余的分割线然后再进行路径的对比，使用 STREQUAL 则只能进行字符串比较。</font></p><hr><h2 id="5-2-循环"><a href="#5-2-循环" class="headerlink" title="5.2 循环"></a>5.2 循环</h2><p>在 CMake 中循环有两种方式，分别是：<code>foreach</code>和<code>while</code>。</p><h3 id="5-2-1-foreach"><a href="#5-2-1-foreach" class="headerlink" title="5.2.1 foreach"></a>5.2.1 foreach</h3><p>使用 foreach 进行循环，语法格式如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt; &lt;items&gt;)</span><br><span class="line">    &lt;commands&gt;</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><p>通过<code>foreach</code>我们就可以对<code>items</code>中的数据进行遍历，然后通过<code>loop_var</code>将遍历到的当前的值取出，在取值的时候有以下几种用法：</p><p><strong>方法1</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt; RANGE &lt;stop&gt;)</span><br></pre></td></tr></table></figure><ul><li><code>RANGE</code>：关键字，表示要遍历范围</li><li><code>stop</code>：这是一个正整数，表示范围的结束值，在遍历的时候从 0 开始，最大值为 stop。</li><li><code>loop_var</code>：存储每次循环取出的值</li></ul><p>举例说明：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="comment"># 循环</span></span><br><span class="line"><span class="keyword">foreach</span>(item RANGE <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: $&#123;item&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><p>输出的日志信息是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- 当前遍历的值为: 0</span><br><span class="line">-- 当前遍历的值为: 1</span><br><span class="line">-- 当前遍历的值为: 2</span><br><span class="line">-- 当前遍历的值为: 3</span><br><span class="line">-- 当前遍历的值为: 4</span><br><span class="line">-- 当前遍历的值为: 5</span><br><span class="line">-- 当前遍历的值为: 6</span><br><span class="line">-- 当前遍历的值为: 7</span><br><span class="line">-- 当前遍历的值为: 8</span><br><span class="line">-- 当前遍历的值为: 9</span><br><span class="line">-- 当前遍历的值为: 10</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/robin/abc/a/build</span><br></pre></td></tr></table></figure><p><font color = red>再次强调：在对一个整数区间进行遍历的时候，得到的范围是这样的 【0，stop】，右侧是闭区间包含 stop 这个值。</font></p><p><strong>方法2</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt; RANGE &lt;start&gt; &lt;stop&gt; [&lt;step&gt;])</span><br></pre></td></tr></table></figure><p>这是上面<code>方法1</code>的加强版，我们在遍历一个整数区间的时候，除了可以指定起始范围，还可以指定步长。</p><ul><li><code>RANGE</code>：关键字，表示要遍历范围</li><li><code>start</code>：这是一个正整数，表示范围的起始值，也就是说最小值为 <code>start</code></li><li><code>stop</code>：这是一个正整数，表示范围的结束值，也就是说最大值为 <code>stop</code></li><li><code>step</code>：控制每次遍历的时候以怎样的步长增长，默认为1，可以不设置</li><li><code>loop_var</code>：存储每次循环取出的值</li></ul><p>举例说明：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(item RANGE <span class="number">10</span> <span class="number">30</span> <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: $&#123;item&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><p>输出的结果如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- 当前遍历的值为: 10</span><br><span class="line">-- 当前遍历的值为: 12</span><br><span class="line">-- 当前遍历的值为: 14</span><br><span class="line">-- 当前遍历的值为: 16</span><br><span class="line">-- 当前遍历的值为: 18</span><br><span class="line">-- 当前遍历的值为: 20</span><br><span class="line">-- 当前遍历的值为: 22</span><br><span class="line">-- 当前遍历的值为: 24</span><br><span class="line">-- 当前遍历的值为: 26</span><br><span class="line">-- 当前遍历的值为: 28</span><br><span class="line">-- 当前遍历的值为: 30</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/robin/abc/a/build</span><br></pre></td></tr></table></figure><p><font color = red>再次强调：在使用上面的方式对一个整数区间进行遍历的时候，得到的范围是这样的 【start，stop】，左右两侧都是闭区间，包含 start 和 stop 这两个值，步长 step 默认为1，可以不设置。</font></p><p><strong>方法3</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt; IN [LISTS [&lt;lists&gt;]] [ITEMS [&lt;items&gt;]])</span><br></pre></td></tr></table></figure><p>这是<code>foreach</code>的另一个变体，通过这种方式我们可以对更加复杂的数据进行遍历，前两种方式只适用于对某个正整数范围内的遍历。</p><ul><li><p><code>IN</code>：关键字，表示在 xxx 里边</p></li><li><p><code>LISTS</code>：关键字，对应的是列表<code>list</code>，通过<code>set</code>、<code>list</code>可以获得</p></li><li><p><code>ITEMS</code>：关键字，对应的也是列表</p></li><li><p><code>loop_var</code>：存储每次循环取出的值</p></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="comment"># 创建 list</span></span><br><span class="line"><span class="keyword">set</span>(WORD a b c d)</span><br><span class="line"><span class="keyword">set</span>(NAME ace sabo luffy)</span><br><span class="line"><span class="comment"># 遍历 list</span></span><br><span class="line"><span class="keyword">foreach</span>(item IN LISTS WORD NAME)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: $&#123;item&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><p>在上面的例子中，创建了两个 <code>list</code> 列表，在遍历的时候对它们两个都进行了遍历（<code>可以根据实际需求选择同时遍历多个或者只遍历一个</code>）。输出的日志信息如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- 当前遍历的值为: a</span><br><span class="line">-- 当前遍历的值为: b</span><br><span class="line">-- 当前遍历的值为: c</span><br><span class="line">-- 当前遍历的值为: d</span><br><span class="line">-- 当前遍历的值为: ace</span><br><span class="line">-- 当前遍历的值为: sabo</span><br><span class="line">-- 当前遍历的值为: luffy</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/robin/abc/a/build</span><br></pre></td></tr></table></figure><p>一共输出了7个字符串，说明遍历是没有问题的。接下来看另外一种方式：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(WORD a b c <span class="string">&quot;d e f&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(NAME ace sabo luffy)</span><br><span class="line"><span class="keyword">foreach</span>(item IN ITEMS <span class="variable">$&#123;WORD&#125;</span> <span class="variable">$&#123;NAME&#125;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: $&#123;item&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><p>在上面的例子中，遍历过程中将关键字<code>LISTS</code>改成了<code>ITEMS</code>，后边跟的还是一个或者多个列表，只不过此时需要通过<code>$&#123;&#125;</code>将列表中的值取出。其输出的信息和上一个例子是一样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- 当前遍历的值为: a</span><br><span class="line">-- 当前遍历的值为: b</span><br><span class="line">-- 当前遍历的值为: c</span><br><span class="line">-- 当前遍历的值为: d e f</span><br><span class="line">-- 当前遍历的值为: ace</span><br><span class="line">-- 当前遍历的值为: sabo</span><br><span class="line">-- 当前遍历的值为: luffy</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/robin/abc/a/build</span><br></pre></td></tr></table></figure><p><font color = red>细节：在通过 set 组织列表的时候，如果某个字符串中有空格，可以通过双引号将其包裹起来，具体的操作方法可以参考上面的例子。</font></p><p><strong>方法4</strong><br><font color = red>注意事项：这种循环方式要求CMake的版本大于等于 3.17。</font></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt;... IN ZIP_LISTS &lt;lists&gt;)</span><br></pre></td></tr></table></figure><p>通过这种方式，遍历的还是一个或多个列表，可以理解为是<code>方式3</code>的加强版。因为通过上面的方式遍历多个列表，但是又想把指定列表中的元素取出来使用是做不到的，在这个加强版中就可以轻松实现。</p><ul><li><code>loop_var</code>：存储每次循环取出的值，可以根据要遍历的列表的数量指定多个变量，用于存储对应的列表当前取出的那个值。<ul><li><code>如果指定了多个变量名，它们的数量应该和列表的数量相等</code></li><li><code>如果只给出了一个 loop_var，那么它将一系列的 loop_var_N 变量来存储对应列表中的当前项，也就是说 loop_var_0 对应第一个列表，loop_var_1 对应第二个列表，以此类推......</code></li><li><code>如果遍历的多个列表中一个列表较短，当它遍历完成之后将不会再参与后续的遍历（因为其它列表还没有遍历完）。</code></li></ul></li><li><code>IN</code>：关键字，表示在 xxx 里边</li><li><code>ZIP_LISTS</code>：关键字，对应的是列表<code>list</code>，通过<code>set</code> 、<code>list</code>可以获得</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.17</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="comment"># 通过list给列表添加数据</span></span><br><span class="line"><span class="keyword">list</span>(APPEND WORD hello world <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="keyword">list</span>(APPEND NAME ace sabo luffy zoro sanji)</span><br><span class="line"><span class="comment"># 遍历列表</span></span><br><span class="line"><span class="keyword">foreach</span>(item1 item2 IN ZIP_LISTS WORD NAME)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: item1 = $&#123;item1&#125;, item2=$&#123;item2&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;=============================&quot;</span>)</span><br><span class="line"><span class="comment"># 遍历列表</span></span><br><span class="line"><span class="keyword">foreach</span>(item  IN ZIP_LISTS WORD NAME)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: item1 = $&#123;item_0&#125;, item2=$&#123;item_1&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><p>在这个例子中关于列表数据的添加是通过<code>list</code>来实现的。在遍历列表的时候一共使用了两种方式，一种提供了多个变量来存储当前列表中的值，另一种只有一个变量，但是实际取值的时候需要通过<code>变量名_0、变量名_1、变量名_N</code> 的方式来操作，<font color = red>注意事项：第一个列表对应的编号是0，第一个列表对应的编号是0，第一个列表对应的编号是0。</font></p><p>上面的例子输出的结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- 当前遍历的值为: item1 = hello, item2=ace</span><br><span class="line">-- 当前遍历的值为: item1 = world, item2=sabo</span><br><span class="line">-- 当前遍历的值为: item1 = hello world, item2=luffy</span><br><span class="line">-- 当前遍历的值为: item1 = , item2=zoro</span><br><span class="line">-- 当前遍历的值为: item1 = , item2=sanji</span><br><span class="line">=============================</span><br><span class="line">-- 当前遍历的值为: item1 = hello, item2=ace</span><br><span class="line">-- 当前遍历的值为: item1 = world, item2=sabo</span><br><span class="line">-- 当前遍历的值为: item1 = hello world, item2=luffy</span><br><span class="line">-- 当前遍历的值为: item1 = , item2=zoro</span><br><span class="line">-- 当前遍历的值为: item1 = , item2=sanji</span><br><span class="line">-- Configuring done (0.0s)</span><br><span class="line">-- Generating done (0.0s)</span><br><span class="line">-- Build files have been written to: /home/robin/abc/a/build</span><br></pre></td></tr></table></figure><hr><h3 id="5-2-2-while"><a href="#5-2-2-while" class="headerlink" title="5.2.2 while"></a>5.2.2 while</h3><p>除了使用<code>foreach</code>也可以使用 <code>while</code> 进行循环，关于循环结束对应的条件判断的书写格式和<code>if/elseif</code> 是一样的。<code>while</code>的语法格式如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(&lt;condition&gt;)</span><br><span class="line">    &lt;commands&gt;</span><br><span class="line"><span class="keyword">endwhile</span>()</span><br></pre></td></tr></table></figure><p><code>while</code>循环比较简单，只需要指定出循环结束的条件即可：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="comment"># 创建一个列表 NAME</span></span><br><span class="line"><span class="keyword">set</span>(NAME luffy sanji zoro nami robin)</span><br><span class="line"><span class="comment"># 得到列表长度</span></span><br><span class="line"><span class="keyword">list</span>(LENGTH NAME LEN)</span><br><span class="line"><span class="comment"># 循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$&#123;LEN&#125;</span> <span class="keyword">GREATER</span>  <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;names = $&#123;NAME&#125;&quot;</span>)</span><br><span class="line">    <span class="comment"># 弹出列表头部元素</span></span><br><span class="line">    <span class="keyword">list</span>(POP_FRONT NAME)</span><br><span class="line">    <span class="comment"># 更新列表长度</span></span><br><span class="line">    <span class="keyword">list</span>(LENGTH NAME LEN)</span><br><span class="line"><span class="keyword">endwhile</span>()</span><br></pre></td></tr></table></figure><p>输出的结果如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- names = luffy;sanji;zoro;nami;robin</span><br><span class="line">-- names = sanji;zoro;nami;robin</span><br><span class="line">-- names = zoro;nami;robin</span><br><span class="line">-- names = nami;robin</span><br><span class="line">-- names = robin</span><br><span class="line">-- Configuring done (0.0s)</span><br><span class="line">-- Generating done (0.0s)</span><br><span class="line">-- Build files have been written to: /home/robin/abc/a/build</span><br></pre></td></tr></table></figure><p>可以看到当列表中的元素全部被弹出之后，列表的长度变成了0，此时<code>while</code>循环也就退出了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-CMake概述&quot;&gt;&lt;a href=&quot;#1-CMake概述&quot; class=&quot;headerlink&quot; title=&quot;1. CMake概述&quot;&gt;&lt;/a&gt;1. CMake概述&lt;/h1&gt;&lt;p&gt;CMake 是一个项目构建工具，并且是跨平台的。关于项目构建我们所熟知的还有Ma</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="CMake" scheme="http://example.com/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>回溯贪心算法篇</title>
    <link href="http://example.com/2023/10/22/%E5%9B%9E%E6%BA%AF%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AF%87/"/>
    <id>http://example.com/2023/10/22/%E5%9B%9E%E6%BA%AF%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AF%87/</id>
    <published>2023-10-22T01:56:20.000Z</published>
    <updated>2023-10-23T03:58:51.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-回溯算法"><a href="#1-回溯算法" class="headerlink" title="1.回溯算法"></a>1.回溯算法</h1><h2 id="1-1-77-组合"><a href="#1-1-77-组合" class="headerlink" title="1.1 77-组合"></a>1.1 77-组合</h2><p><a href="https://leetcode.cn/problems/combinations/description/">77</a></p><p><img src="/img/e.1.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="comment">//组合抽象为一个泡泡树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path); <span class="comment">//将泡泡数据加入结果</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//返回去等待删除一个泡泡</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt;= n-(k-path.<span class="built_in">size</span>())+<span class="number">1</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);  <span class="comment">//加入一个泡泡</span></span><br><span class="line">            <span class="built_in">backtracking</span>(n,k,i+<span class="number">1</span>); <span class="comment">//负责剩下的泡泡处理</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">//删除一个泡泡</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>画的巨抽象的图<br><img src="/img/e.2.png" alt="在这里插入图片描述"><br><img src="/img/e.3.png" alt="在这里插入图片描述"></p></blockquote><hr><h2 id="1-2-216-组合的综合III"><a href="#1-2-216-组合的综合III" class="headerlink" title="1.2 216-组合的综合III"></a>1.2 216-组合的综合III</h2><p><a href="https://leetcode.cn/problems/combination-sum-iii/">216</a></p><p><img src="/img/e.4.png" alt="在这里插入图片描述"></p><blockquote><p>注意剪枝</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> k , <span class="type">int</span> n, <span class="type">int</span> startindex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : path)</span><br><span class="line">                sum+=e;</span><br><span class="line">            <span class="keyword">if</span>(sum == n)</span><br><span class="line">                ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startindex; i &lt;= <span class="number">9</span> - (k-path.<span class="built_in">size</span>()) +<span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backtracking</span>(k,n,i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(k,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-3-17-电话号码的字母组合"><a href="#1-3-17-电话号码的字母组合" class="headerlink" title="1.3 17-电话号码的字母组合"></a>1.3 17-电话号码的字母组合</h2><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17</a></p><p><img src="/img/e.5.png" alt="在这里插入图片描述"><br><img src="/img/e.6.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string path;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    vector&lt;string&gt; dir=&#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string digits,<span class="type">int</span> startindex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startindex==digits.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num=digits[startindex]-<span class="string">&#x27;0&#x27;</span>; <span class="comment">//字符串转整形</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; dir[num].<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(dir[num][i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(digits,startindex+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>()==<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">backtracking</span>(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-4-39-组合总和"><a href="#1-4-39-组合总和" class="headerlink" title="1.4 39-组合总和"></a>1.4 39-组合总和</h2><p><a href="https://leetcode.cn/problems/combination-sum/">39</a></p><p><img src="/img/e.7.png" alt="在这里插入图片描述"><br><img src="/img/e.8.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target,<span class="type">int</span> sum,<span class="type">int</span> startindex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startindex; i &lt; candidates.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates,target,sum,i);</span><br><span class="line">            sum-=candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates,target,sum,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>然而还需要优化</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target,<span class="type">int</span> sum,<span class="type">int</span> startindex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将sum&gt;target的if移入至for中,由于已经排序,如果发生了,直接当作for的判断条件跳出循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startindex; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; </span><br><span class="line">            sum+candidates[i] &lt;= target; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates,target,sum,i);</span><br><span class="line">            sum-=candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>()); <span class="comment">//排序一下</span></span><br><span class="line">        <span class="built_in">backtracking</span>(candidates,target,sum,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-5-40-组合总和II"><a href="#1-5-40-组合总和II" class="headerlink" title="1.5 40-组合总和II"></a>1.5 40-组合总和II</h2><p><a href="https://leetcode.cn/problems/combination-sum-ii/solutions/857552/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-ig29/">40</a></p><p><img src="/img/e.9.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target,<span class="type">int</span> sum, <span class="type">int</span> startindex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startindex; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; sum+candidates[i] &lt;= target;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//防止candidates中有重复元素的影响,重复开始算入答案,导致结果有重复</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; startindex &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            sum+=candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates,target,sum,i+<span class="number">1</span>);</span><br><span class="line">            sum-=candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/e.10.png" alt="在这里插入图片描述"></p><hr><h2 id="1-6-131-分割回文串"><a href="#1-6-131-分割回文串" class="headerlink" title="1.6 131-分割回文串"></a>1.6 131-分割回文串</h2><p><a href="https://leetcode.cn/problems/palindrome-partitioning/description/">131</a></p><p><img src="/img/e.11.png" alt="在这里插入图片描述"><br><img src="/img/e.12.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_back</span><span class="params">(<span class="type">const</span> string&amp; str,<span class="type">int</span> start,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[start] != str[end])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string s,<span class="type">int</span> startindex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startindex == s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startindex; i &lt; s.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">is_back</span>(s,startindex,i))</span><br><span class="line">            &#123;</span><br><span class="line">                string tmp = s.<span class="built_in">substr</span>(startindex,i-startindex+<span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">backtracking</span>(s,i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>优化</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; isPalindrome; <span class="comment">// 放事先计算好的是否回文子串的结果</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span> <span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> startIndex)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome[startIndex][i]) </span><br><span class="line">            &#123;   </span><br><span class="line">                string str = s.<span class="built_in">substr</span>(startIndex, i - startIndex + <span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">push_back</span>(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>         </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(s, i + <span class="number">1</span>); <span class="comment">// 寻找i+1为起始位置的子串</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯过程，弹出本次已经填在的子串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">computePalindrome</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123; <span class="comment">//aab </span></span><br><span class="line">        <span class="comment">// true  true  false  j--i 为回文串?</span></span><br><span class="line">        <span class="comment">// false true  false</span></span><br><span class="line">        <span class="comment">// false false true</span></span><br><span class="line">        isPalindrome.<span class="built_in">resize</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>(), <span class="literal">false</span>)); </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == i) </span><br><span class="line">                    isPalindrome[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j - i == <span class="number">1</span>) </span><br><span class="line">                    isPalindrome[i][j] = (s[i] == s[j]);</span><br><span class="line">                <span class="keyword">else</span>    <span class="comment">//如果中间隔的多,只需判断首尾和通过表中的判断</span></span><br><span class="line">                    isPalindrome[i][j] = (s[i] == s[j] &amp;&amp; isPalindrome[i+<span class="number">1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">computePalindrome</span>(s);</span><br><span class="line">        <span class="built_in">backtracking</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-7-93-复原IP地址"><a href="#1-7-93-复原IP地址" class="headerlink" title="1.7 93-复原IP地址"></a>1.7 93-复原IP地址</h2><p><a href="https://leetcode.cn/problems/restore-ip-addresses/description/">93</a></p><p><img src="/img/e.13.png" alt="在这里插入图片描述"><br><img src="/img/e.14.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isvalid</span><span class="params">(string&amp; s,<span class="type">int</span> start,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) <span class="comment">//头部为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">//统计三个数是否合法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt;=end ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt;<span class="string">&#x27;9&#x27;</span> || s[i] &lt; <span class="string">&#x27;0&#x27;</span>) <span class="comment">//非法字符</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            sum = sum*<span class="number">10</span>+s[i]-<span class="string">&#x27;0&#x27;</span>; <span class="comment">//超过255</span></span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">255</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string&amp; s,<span class="type">int</span> startindex,<span class="type">int</span> pointnum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pointnum == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将最后一组全部放进去,还可以避免切的太小而导致的没有用完</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isvalid</span>(s,startindex,s.<span class="built_in">size</span>()<span class="number">-1</span>)) </span><br><span class="line">                ans.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startindex;i&lt;s.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isvalid</span>(s,startindex,i))</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>()+i+<span class="number">1</span>,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                pointnum++;</span><br><span class="line">                <span class="built_in">backtracking</span>(s,i+<span class="number">2</span>,pointnum); <span class="comment">//i跳两格,因为有.</span></span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()+i+<span class="number">1</span>); <span class="comment">//删除.</span></span><br><span class="line">                pointnum--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//不合法直接跳出去(递归中出去)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() &lt; <span class="number">4</span> || s.<span class="built_in">size</span>()&gt;<span class="number">12</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">backtracking</span>(s,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-8-78-子集"><a href="#1-8-78-子集" class="headerlink" title="1.8 78-子集"></a>1.8 78-子集</h2><p><a href="https://leetcode.cn/problems/subsets/">78</a></p><p><img src="/img/e.15.png" alt="在这里插入图片描述"><br><img src="/img/e.16.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> startindex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startindex; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums,i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-9-90-子集II"><a href="#1-9-90-子集II" class="headerlink" title="1.9 90-子集II"></a>1.9 90-子集II</h2><p><a href="https://leetcode.cn/problems/subsets-ii/description/">90</a></p><p><img src="/img/e.17.png" alt="在这里插入图片描述"></p><blockquote><p>相较于上一题,只是多了一步去重</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> startindex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startindex; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;startindex &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums,i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()); <span class="comment">//先排序以便去重</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-10-491-递增子序列"><a href="#1-10-491-递增子序列" class="headerlink" title="1.10 491-递增子序列"></a>1.10 491-递增子序列</h2><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/description/">491</a></p><p><img src="/img/e.18.png" alt="在这里插入图片描述"></p><blockquote><p>利用哈希来去重</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() &gt; <span class="number">1</span>) </span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> used[<span class="number">201</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 这里使用数组来进行去重操作，题目说数值范围[-100, 100]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((!path.<span class="built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="built_in">back</span>()) <span class="comment">//不满足递增</span></span><br><span class="line">                    || used[nums[i] + <span class="number">100</span>] == <span class="number">1</span>) <span class="comment">//有重复</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            used[nums[i] + <span class="number">100</span>] = <span class="number">1</span>; <span class="comment">// 记录这个元素在本层用过了，本层后面不能再用了</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-11-46-全排列"><a href="#1-11-46-全排列" class="headerlink" title="1.11 46-全排列"></a>1.11 46-全排列</h2><p><a href="https://leetcode.cn/problems/permutations/">46</a></p><p><img src="/img/e.19.png" alt="在这里插入图片描述"></p><blockquote><p>利用used数组和for的从0开始</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">bool</span>&gt;&amp; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(nums,used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>; <span class="comment">//记录元素是否被使用过</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums,used);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-12-47-全排列II"><a href="#1-12-47-全排列II" class="headerlink" title="1.12 47-全排列II"></a>1.12 47-全排列II</h2><p><a href="https://leetcode.cn/problems/permutations-ii/solutions/418230/47-quan-pai-lie-iiche-di-li-jie-pai-lie-zhong-de-q/">47</a></p><p><img src="/img/e.20.png" alt="在这里插入图片描述"></p><blockquote><p>相较于上一题多出了,树枝去重</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">bool</span>&gt;&amp; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//i&gt;0 且 有重复的数据时,判断used[i-1]</span></span><br><span class="line">            <span class="keyword">if</span>((i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; used[i<span class="number">-1</span>] == <span class="literal">false</span>) <span class="comment">//树枝去重</span></span><br><span class="line">                || used[i] == <span class="literal">true</span>) <span class="comment">//树层去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(nums,used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,used);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-13-51-N皇后"><a href="#1-13-51-N皇后" class="headerlink" title="1.13* 51-N皇后"></a>1.13* 51-N皇后</h2><p><a href="https://leetcode.cn/problems/n-queens/description/">51</a><br><img src="/img/e.21.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isvalid</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,vector&lt;string&gt;&amp; chessboard,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//check col</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//check lefter</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = row<span class="number">-1</span>,j = col<span class="number">-1</span>;i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>; --j,--i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//check righter</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = row<span class="number">-1</span>, j = col+<span class="number">1</span>; j &lt; n &amp;&amp; i&gt;=<span class="number">0</span>; ++j,--i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n , <span class="type">int</span> row,vector&lt;string&gt;&amp; chessboard)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(chessboard);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isvalid</span>(row,i,chessboard,n))</span><br><span class="line">            &#123;</span><br><span class="line">                chessboard[row][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="built_in">backtracking</span>(n,row+<span class="number">1</span>,chessboard);</span><br><span class="line">                chessboard[row][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">chessboard</span><span class="params">(n,string(n,<span class="string">&#x27;.&#x27;</span>))</span></span>; <span class="comment">//初始化棋盘</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n,<span class="number">0</span>,chessboard);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="2-贪心算法"><a href="#2-贪心算法" class="headerlink" title="2. 贪心算法"></a>2. 贪心算法</h1><h2 id="2-1-455-分发饼干"><a href="#2-1-455-分发饼干" class="headerlink" title="2.1 455-分发饼干"></a>2.1 455-分发饼干</h2><p><a href="https://leetcode.cn/problems/assign-cookies/description/">455</a></p><p><img src="/img/e.22.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//最大饼干坐标</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = g.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) <span class="comment">//从最大胃口开始遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(index &gt;= <span class="number">0</span> &amp;&amp; s[index] &gt;= g[i])</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-2-376-摆动序列"><a href="#2-2-376-摆动序列" class="headerlink" title="2.2 376-摆动序列"></a>2.2 376-摆动序列</h2><p><a href="https://leetcode.cn/problems/wiggle-subsequence/description/">376</a></p><p><img src="/img/e.23.png" alt="在这里插入图片描述"><br><img src="/img/e.24.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> curdif = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> prevdif = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>; <span class="comment">//第一个数没有比较,直接算上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() <span class="number">-1</span>;++i) <span class="comment">//最后一个数据不算入(i+1)</span></span><br><span class="line">        &#123;</span><br><span class="line">            curdif = nums[i+<span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="keyword">if</span>((prevdif &lt;= <span class="number">0</span> &amp;&amp; curdif&gt;<span class="number">0</span>) || (prevdif &gt;=<span class="number">0</span> &amp;&amp; curdif&lt;<span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                prevdif = curdif;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-3-53-最大数组和"><a href="#2-3-53-最大数组和" class="headerlink" title="2.3 53-最大数组和"></a>2.3 53-最大数组和</h2><p><a href="https://leetcode.cn/problems/maximum-subarray/description/">53</a></p><p><img src="/img/e.25.png" alt="在这里插入图片描述"><br><img src="/img/e.26.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            count+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(count &gt; ans) <span class="comment">//记录小段中的最大值,即答案</span></span><br><span class="line">                ans = count;</span><br><span class="line">            <span class="keyword">if</span>(count &lt;= <span class="number">0</span>) <span class="comment">//小段中如果小于0,累加之后就是亏,直接置0重新开始</span></span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-4-122-买股票的最佳时机II"><a href="#2-4-122-买股票的最佳时机II" class="headerlink" title="2.4 122-买股票的最佳时机II"></a>2.4 122-买股票的最佳时机II</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122</a></p><p><img src="/img/e.27.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (tmp &gt; <span class="number">0</span>) </span><br><span class="line">                profit += tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="2-5-55-跳跃游戏"><a href="#2-5-55-跳跃游戏" class="headerlink" title="2.5 55-跳跃游戏"></a>2.5 55-跳跃游戏</h2><p><a href="https://leetcode.cn/problems/jump-game/description/">55</a></p><p><img src="/img/e.28.png" alt="在这里插入图片描述"><br><img src="/img/e.29.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cover = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cover; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            cover = <span class="built_in">max</span>(i + nums[i], cover);</span><br><span class="line">            <span class="keyword">if</span> (cover &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-6-45-跳跃游戏II"><a href="#2-6-45-跳跃游戏II" class="headerlink" title="2.6 45-跳跃游戏II"></a>2.6 45-跳跃游戏II</h2><p><a href="https://leetcode.cn/problems/jump-game-ii/description/">45</a></p><p><img src="/img/e.30.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxPos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; end; i++)</span><br><span class="line">                maxPos = <span class="built_in">max</span>(maxPos, i + nums[i]);</span><br><span class="line">                </span><br><span class="line">            start = end;      <span class="comment">// 下一次起跳点范围开始的格子</span></span><br><span class="line">            end = maxPos + <span class="number">1</span>; <span class="comment">// 下一次起跳点范围结束的格子</span></span><br><span class="line">            ans++;            <span class="comment">// 跳跃次数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-7-1005-K次取反后最大化的数组和"><a href="#2-7-1005-K次取反后最大化的数组和" class="headerlink" title="2.7 1005-K次取反后最大化的数组和"></a>2.7 1005-K次取反后最大化的数组和</h2><p><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/">1005</a></p><p><img src="/img/e.31.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] *= <span class="number">-1</span>;</span><br><span class="line">                k--;</span><br><span class="line">                index = i + <span class="number">1</span>; <span class="comment">// 最后一个取反的元素的下标+1，也就是第一个没被取反的元素的下标&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到对所有负数取反后的最小非负数的下标,分别考虑原数组全正、全负、有正有负的情况</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span> &amp;&amp; index &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[index] &gt; nums[index - <span class="number">1</span>])</span><br><span class="line">            index = index - <span class="number">1</span>;<span class="comment">//对比正负交界处,如果原本是全正,根本就进不去</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index == nums.<span class="built_in">size</span>()) <span class="comment">//即原本是全负</span></span><br><span class="line">            index = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            ans -= nums[index] * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-8-134-加油站"><a href="#2-8-134-加油站" class="headerlink" title="2.8 134-加油站"></a>2.8 134-加油站</h2><p><a href="https://leetcode.cn/problems/gas-station/description/">134</a><br><img src="/img/e.32.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            curSum += gas[i] - cost[i]; <span class="comment">//计算起点</span></span><br><span class="line">            totalSum += gas[i] - cost[i]; <span class="comment">//计算是否可以跑完</span></span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                start = i + <span class="number">1</span>;  <span class="comment">// 起始位置更新为i+1</span></span><br><span class="line">                curSum = <span class="number">0</span>;     <span class="comment">// curSum从0开始</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 说明怎么走都不可能跑一圈了</span></span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-9-135-分发糖果"><a href="#2-9-135-分发糖果" class="headerlink" title="2.9* 135-分发糖果"></a>2.9* 135-分发糖果</h2><p><a href="https://leetcode.cn/problems/candy/">135</a></p><p><img src="/img/e.33.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candyVec</span><span class="params">(ratings.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从前向后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ratings.<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) </span><br><span class="line">                candyVec[i] = candyVec[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后向前</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>] ) </span><br><span class="line">                candyVec[i] = <span class="built_in">max</span>(candyVec[i], candyVec[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计结果</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; candyVec.<span class="built_in">size</span>(); i++) </span><br><span class="line">            result += candyVec[i];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="2-10-860-柠檬水找零"><a href="#2-10-860-柠檬水找零" class="headerlink" title="2.10 860-柠檬水找零"></a>2.10 860-柠檬水找零</h2><p><a href="https://leetcode.cn/problems/lemonade-change/description/">860</a></p><p><img src="/img/e.34.png" alt="在这里插入图片描述"><br><img src="/img/e.35.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>, twenty = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> bill : bills) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bill == <span class="number">5</span>) </span><br><span class="line">                five++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bill == <span class="number">10</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (five &lt;= <span class="number">0</span>) </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                ten++;</span><br><span class="line">                five--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (five &gt; <span class="number">0</span> &amp;&amp; ten &gt; <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    five--;</span><br><span class="line">                    ten--;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (five &gt;= <span class="number">3</span>) <span class="comment">//三个五块也能找零</span></span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> </span><br><span class="line">                    <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-11-406-根据身高重建队列"><a href="#2-11-406-根据身高重建队列" class="headerlink" title="2.11 406-根据身高重建队列"></a>2.11 406-根据身高重建队列</h2><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">406</a></p><p><img src="/img/e.36.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a,vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(),people.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        list&lt;vector&lt;<span class="type">int</span>&gt;&gt; que; <span class="comment">//链表插入效率高</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> position = people[i][<span class="number">1</span>];</span><br><span class="line">            list&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = que.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span>(position--)</span><br><span class="line">                it++;</span><br><span class="line">            que.<span class="built_in">insert</span>(it,people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(que.<span class="built_in">begin</span>(),que.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-12-452-用最少数量的箭引爆气球"><a href="#2-12-452-用最少数量的箭引爆气球" class="headerlink" title="2.12 452-用最少数量的箭引爆气球"></a>2.12 452-用最少数量的箭引爆气球</h2><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/">452</a><br><img src="/img/e.37.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points.<span class="built_in">size</span>() == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>; <span class="comment">// points 不为空至少需要一支箭</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>])   <span class="comment">// 气球i和气球i-1不挨着，注意这里不是&gt;=</span></span><br><span class="line">                result++; <span class="comment">// 需要一支箭</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">// 气球i和气球i-1挨着</span></span><br><span class="line">                points[i][<span class="number">1</span>] = <span class="built_in">min</span>(points[i - <span class="number">1</span>][<span class="number">1</span>], points[i][<span class="number">1</span>]); <span class="comment">// 更新重叠气球最小右边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="2-13-435-无重叠区间"><a href="#2-13-435-无重叠区间" class="headerlink" title="2.13 435-无重叠区间"></a>2.13 435-无重叠区间</h2><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435</a></p><p><img src="/img/e.38.png" alt="在这里插入图片描述"></p><blockquote><p>用引爆气球的方式可以通过</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 按照区间右边界排序</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span> <span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; <span class="comment">// 右边界排序 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>; <span class="comment">// points 不为空至少需要一支箭</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt;= intervals[i - <span class="number">1</span>][<span class="number">1</span>]) </span><br><span class="line">                result++; <span class="comment">// 需要一支箭</span></span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">// 气球i和气球i-1挨着</span></span><br><span class="line">                intervals[i][<span class="number">1</span>] = <span class="built_in">min</span>(intervals[i - <span class="number">1</span>][<span class="number">1</span>], intervals[i][<span class="number">1</span>]); <span class="comment">// 更新重叠气球最小右边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.<span class="built_in">size</span>() - result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>另外</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span> <span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; <span class="comment">// 改为左边界排序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 注意这里从0开始，因为是记录重叠区间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; intervals[i - <span class="number">1</span>][<span class="number">1</span>]) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">//重叠情况</span></span><br><span class="line">                intervals[i][<span class="number">1</span>] = <span class="built_in">min</span>(intervals[i - <span class="number">1</span>][<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-14-763-划分字母区间"><a href="#2-14-763-划分字母区间" class="headerlink" title="2.14 763-划分字母区间"></a>2.14 763-划分字母区间</h2><p><a href="https://leetcode.cn/problems/partition-labels/description/">763</a></p><p><img src="/img/e.39.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash[<span class="number">27</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// i为字符，hash[i]为字符出现的最后位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>(); i++)  <span class="comment">// 统计每一个字符最后出现的位置</span></span><br><span class="line">            hash[S[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            right = <span class="built_in">max</span>(right, hash[S[i] - <span class="string">&#x27;a&#x27;</span>]); <span class="comment">// 找到字符出现的最远边界</span></span><br><span class="line">            <span class="keyword">if</span> (i == right) </span><br><span class="line">            &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(right - left + <span class="number">1</span>);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="2-15-56-合并区间"><a href="#2-15-56-合并区间" class="headerlink" title="2.15 56-合并区间"></a>2.15 56-合并区间</h2><p><a href="https://leetcode.cn/problems/merge-intervals/description/">56</a></p><p><img src="/img/e.40.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> result; <span class="comment">// 区间集合为空直接返回</span></span><br><span class="line">        <span class="comment">// 排序的参数使用了lambda表达式</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;<span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个区间就可以放进结果集里，后面如果重叠，在result上直接合并</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.<span class="built_in">back</span>()[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]) </span><br><span class="line">            <span class="comment">// 发现重叠区间</span></span><br><span class="line">            <span class="comment">// 合并区间，只更新右边界就好，因为result.back()的左边界一定是最小值，因为我们按照左边界排序的</span></span><br><span class="line">                result.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(result.<span class="built_in">back</span>()[<span class="number">1</span>], intervals[i][<span class="number">1</span>]); </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                result.<span class="built_in">push_back</span>(intervals[i]); <span class="comment">// 区间不重叠 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-16-738-单调递增的数字"><a href="#2-16-738-单调递增的数字" class="headerlink" title="2.16 738-单调递增的数字"></a>2.16 738-单调递增的数字</h2><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/description/">738</a></p><p><img src="/img/e.41.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        string strNum = <span class="built_in">to_string</span>(N);</span><br><span class="line">        <span class="comment">// flag用来标记赋值9从哪里开始</span></span><br><span class="line">        <span class="comment">// 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行</span></span><br><span class="line">        <span class="type">int</span> flag = strNum.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = strNum.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (strNum[i - <span class="number">1</span>] &gt; strNum[i] ) </span><br><span class="line">            &#123;</span><br><span class="line">                flag = i;</span><br><span class="line">                strNum[i - <span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = flag; i &lt; strNum.<span class="built_in">size</span>(); i++)</span><br><span class="line">            strNum[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stoi</span>(strNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="2-17-968-监控二叉树"><a href="#2-17-968-监控二叉树" class="headerlink" title="2.17* 968-监控二叉树"></a>2.17* 968-监控二叉树</h2><p><a href="https://leetcode.cn/problems/binary-tree-cameras/description/">968</a></p><p><img src="/img/e.42.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 空节点，该节点有覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">traversal</span>(cur-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">traversal</span>(cur-&gt;right);  <span class="comment">// 右</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情况1</span></span><br><span class="line">        <span class="comment">// 左右节点都有覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">2</span> &amp;&amp; right == <span class="number">2</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情况2</span></span><br><span class="line">        <span class="comment">// left == 0 &amp;&amp; right == 0 左右节点无覆盖</span></span><br><span class="line">        <span class="comment">// left == 1 &amp;&amp; right == 0 左节点有摄像头，右节点无覆盖</span></span><br><span class="line">        <span class="comment">// left == 0 &amp;&amp; right == 1 左节点有无覆盖，右节点摄像头</span></span><br><span class="line">        <span class="comment">// left == 0 &amp;&amp; right == 2 左节点无覆盖，右节点覆盖</span></span><br><span class="line">        <span class="comment">// left == 2 &amp;&amp; right == 0 左节点覆盖，右节点无覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            result++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情况3</span></span><br><span class="line">        <span class="comment">// left == 1 &amp;&amp; right == 2 左节点有摄像头，右节点有覆盖</span></span><br><span class="line">        <span class="comment">// left == 2 &amp;&amp; right == 1 左节点有覆盖，右节点有摄像头</span></span><br><span class="line">        <span class="comment">// left == 1 &amp;&amp; right == 1 左右节点都有摄像头</span></span><br><span class="line">        <span class="comment">// 其他情况前段代码均已覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">1</span> || right == <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以上代码我没有使用else，主要是为了把各个分支条件展现出来，这样代码有助于读者理解</span></span><br><span class="line">        <span class="comment">// 这个 return -1 逻辑不会走到这里。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 情况4</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">traversal</span>(root) == <span class="number">0</span>)  <span class="comment">// root 无覆盖</span></span><br><span class="line">            result++;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-回溯算法&quot;&gt;&lt;a href=&quot;#1-回溯算法&quot; class=&quot;headerlink&quot; title=&quot;1.回溯算法&quot;&gt;&lt;/a&gt;1.回溯算法&lt;/h1&gt;&lt;h2 id=&quot;1-1-77-组合&quot;&gt;&lt;a href=&quot;#1-1-77-组合&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="代码随想录" scheme="http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="回溯算法" scheme="http://example.com/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
    <category term="贪心算法" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>视图,存储过程,触发器</title>
    <link href="http://example.com/2023/10/22/%E8%A7%86%E5%9B%BE-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>http://example.com/2023/10/22/%E8%A7%86%E5%9B%BE-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-%E8%A7%A6%E5%8F%91%E5%99%A8/</id>
    <published>2023-10-22T01:56:06.000Z</published>
    <updated>2023-10-22T06:32:05.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-视图"><a href="#1-视图" class="headerlink" title="1. 视图"></a>1. 视图</h1><p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。<br>通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上</p><p>作用:</p><ul><li>简单<br>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</li><li>安全<br>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据</li><li>数据独立<br>视图可帮助用户屏蔽真实表结构变化带来的影响</li></ul><h2 id="1-1-视图的基本操作"><a href="#1-1-视图的基本操作" class="headerlink" title="1.1 视图的基本操作"></a>1.1 视图的基本操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#创建</span><br><span class="line"><span class="keyword">create</span> [<span class="keyword">or</span> replace] <span class="keyword">view</span> 视图名称[(列名列表)] <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span> [<span class="keyword">cascaded</span> <span class="operator">|</span> <span class="keyword">local</span>] <span class="keyword">check</span> option];</span><br><span class="line"></span><br><span class="line">#查询</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> 视图名称;  #查看创建视图语句 :</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 视图名称...;  #查看视图数据 : </span><br><span class="line"></span><br><span class="line">#修改(两种方案)</span><br><span class="line"><span class="keyword">create</span> [<span class="keyword">or</span> replace] <span class="keyword">view</span> 视图名称[(列名列表)] <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span> [<span class="keyword">cascaded</span> <span class="operator">|</span> <span class="keyword">local</span>] <span class="keyword">check</span> option];</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> 视图名称[(列名列表)] <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span> [<span class="keyword">cascaded</span> <span class="operator">|</span> <span class="keyword">local</span>] <span class="keyword">check</span> option];</span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> [if <span class="keyword">exists</span>] 视图名称 [,视图名称]..</span><br></pre></td></tr></table></figure><blockquote><p>eg</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#创建视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#查询视图</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> stu_v_1;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_v_1;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_v_1 <span class="keyword">where</span> id<span class="operator">&lt;</span><span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">#修改视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name,num <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name,num <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#删除视图</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> if <span class="keyword">exists</span> stu_v_1;</span><br></pre></td></tr></table></figure><hr><h2 id="1-2-视图的检查选项"><a href="#1-2-视图的检查选项" class="headerlink" title="1.2 视图的检查选项"></a>1.2 视图的检查选项</h2><p>当使用<code>with check option</code>子句创建视图时，MySOL会通过视图检查正在更改的每个行，例如插入，更新，删除，以使其符合视图的定义。<br>MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项：<br><code>cascaded</code>和<code>local</code>，<code>默认值为CASCADED</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">20</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">20</span> <span class="keyword">with</span> <span class="keyword">local</span> <span class="keyword">check</span> option;</span><br></pre></td></tr></table></figure><blockquote><p>cascaded 的有向上传递性,即a2基于a1创建,a1没有check option ,a2 有, 那么a1也会变得拥有这个属性<br>local 并没有<br>检查的时候都会递归检查是否有check option并服从条件</p></blockquote><hr><h2 id="1-3-视图的更新"><a href="#1-3-视图的更新" class="headerlink" title="1.3 视图的更新"></a>1.3 视图的更新</h2><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：</p><ol><li><code>聚合函数或窗口函数</code> : SUM() 、MIN() 、MAX()、 COUNT() 等</li><li>distinct</li><li>group by</li><li>having</li><li>union或者union all</li></ol><blockquote><p>eg</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#创建视图，使用聚合函数</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> stu_v_count <span class="keyword">as</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_count <span class="keyword">vaLues</span>(<span class="number">10</span>); #报错</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span>为了保证数据库表的安全性，开发人员在操作tb_user表时，只能看到的用户的基本字段，屏蔽手机号邮箱两个字段</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> tb_user_view <span class="keyword">as</span> <span class="keyword">select</span> id,name,profession,age,gender,status,createtime <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">from</span> tb_user_view;</span><br><span class="line"></span><br><span class="line">#<span class="number">2.</span>查询每个学生所选修的课程（三张表联查），这个功能在很多的业务中都有使用到，为了简化操作，定义一个视图。</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> tb<span class="operator">-</span>stu_course_view <span class="keyword">as</span> <span class="keyword">select</span> S.name stu_name,S.no,c.name cou_name <span class="keyword">from</span> student S,student_course sc,course c <span class="keyword">where</span> S.id <span class="operator">=</span> Sc.studentid <span class="keyword">and</span> sc.courseid <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure><hr><h1 id="2-存储过程"><a href="#2-存储过程" class="headerlink" title="2. 存储过程"></a>2. 存储过程</h1><p>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的.<br>存储过程思想上很简单  就是数据库SQL语言层面的代码封装与重用。</p><p>特点:</p><ul><li>封装,复用</li><li>可以接受参数,也可以返回数据</li><li>减少网络交互,效率提升</li></ul><h2 id="2-1-存储过程的基本语法"><a href="#2-1-存储过程的基本语法" class="headerlink" title="2.1 存储过程的基本语法"></a>2.1 存储过程的基本语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#创建</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程的名称([参数列表])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">--SQL语句</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line"><span class="keyword">call</span> 存储过程名称([参数]);</span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_scheme.routines <span class="keyword">where</span> routine_scheme <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>; #查询指定数据库的存储过程及状态信息</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称; #查询某个存储过程的定义</span><br><span class="line">#eg</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.routines <span class="keyword">where</span> routine_schema <span class="operator">=</span> <span class="string">&#x27;9tse&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> [if <span class="keyword">exists</span>] 存储过程的名称;</span><br></pre></td></tr></table></figure><blockquote><p>如果在命令行中执行创建存储过程的SQL时,需要关键字<code>delimiter</code> 指定SQL语句的结束符</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">end</span>$$;</span><br></pre></td></tr></table></figure><hr><h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h2><h3 id="2-2-1-系统变量"><a href="#2-2-1-系统变量" class="headerlink" title="2.2.1 系统变量"></a>2.2.1 系统变量</h3><blockquote><p>系统变量是MySQL服务器提供的,不是用户定义的,属于服务器层面,分为全局变量(<code>global</code>),会话变量(<code>session</code>)</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查看系统变量</span><br><span class="line"><span class="keyword">show</span> [session <span class="operator">|</span> <span class="keyword">global</span>] variables; <span class="comment">--查看所有系统变量</span></span><br><span class="line"><span class="keyword">show</span> [session <span class="operator">|</span> <span class="keyword">global</span>] variables <span class="keyword">like</span> <span class="string">&#x27;....&#x27;</span>;<span class="comment">--可以通过like模糊匹配方式查找变量</span></span><br><span class="line"><span class="keyword">select</span> @@[session <span class="operator">|</span> <span class="keyword">global</span>] 系统变量名;<span class="comment">--查看指定变量的值</span></span><br><span class="line">#设置系统变量</span><br><span class="line"><span class="keyword">set</span> [session <span class="operator">|</span> <span class="keyword">global</span>] 系统变量名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">set</span> @@[session <span class="operator">|</span> <span class="keyword">global</span>]系统变量名 <span class="operator">=</span> 值;</span><br></pre></td></tr></table></figure><p>ps</p><ul><li>如果没有指定session&#x2F;global,<code>默认是session</code>,会话变量</li><li>MySQL服务器重新启动之后,所设置的全局参数会失效,要想不失校,可以在 <code>/etc/my.cnf</code> 中配置</li></ul><hr><h3 id="2-2-2-用户定义的变量"><a href="#2-2-2-用户定义的变量" class="headerlink" title="2.2.2 用户定义的变量"></a>2.2.2 用户定义的变量</h3><p>用户定义变量是用户根据需要自己定义的变量，<code>用户变量不用提前声明</code>，在用的时候直接用<code>@变量名</code> 使用就可以。其<code>作用域为当前连接</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#赋值</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@var_name</span> <span class="operator">=</span> expr;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr;</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr;</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> <span class="variable">@var_name</span> <span class="keyword">from</span> 表名;</span><br><span class="line"></span><br><span class="line">#使用</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@var_name</span>;</span><br></pre></td></tr></table></figure><p>ps</p><ul><li>用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL</li><li>推荐使用 :&#x3D; 避免和&#x3D;(判相等)认混</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@mygender</span> :<span class="operator">=</span><span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@mycolor</span> :<span class="operator">=</span> <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@mycount</span> <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure><hr><h3 id="2-2-3-局部变量"><a href="#2-2-3-局部变量" class="headerlink" title="2.2.3 局部变量"></a>2.2.3 局部变量</h3><p>局部变量是根据<code>需要定义的在局部生效的变量</code>，访问之前，需要<code>DECLARE</code>声明。可用作存储过程内的局部变量和输入参数，<code>局部变量的范围是在其内声明的begin,end块</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#声明</span><br><span class="line"><span class="keyword">declare</span> 变量名 变量类型 [<span class="keyword">default</span> ...];</span><br><span class="line">变量类型就是数据库字段类型：<span class="type">INT</span>、<span class="type">BIGINT</span>、<span class="type">CHAR</span>、 <span class="type">VARCHAR</span>、 <span class="type">DATE</span>、 <span class="type">TIME</span>等。</span><br><span class="line"></span><br><span class="line">#赋值</span><br><span class="line"><span class="keyword">SET</span> 变量名<span class="operator">=</span>值；</span><br><span class="line"><span class="keyword">SET</span> 变量名：<span class="operator">=</span>值</span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">INTO</span> 变量名 <span class="keyword">FROM</span> 表名...;</span><br></pre></td></tr></table></figure><hr><h2 id="2-3-关键字"><a href="#2-3-关键字" class="headerlink" title="2.3 关键字"></a>2.3 关键字</h2><p><strong>存储过程的参数</strong></p><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>in(默认)</td><td>该类参数作为输入,也就是需要调用时传入值</td></tr><tr><td>out</td><td>该类参数作为输出,也就是该参数可以作为返回值</td></tr><tr><td>inout</td><td>既可以作为输入参数,也可以作为输出参数</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([ <span class="keyword">in</span><span class="operator">/</span><span class="keyword">out</span><span class="operator">/</span><span class="keyword">inout</span> 参数名 参数类型])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h3 id="2-3-1-判断"><a href="#2-3-1-判断" class="headerlink" title="2.3.1 判断"></a>2.3.1 判断</h3><p><strong>if</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#语法</span><br><span class="line">if 条件<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">...</span><br><span class="line">elseif 条件<span class="number">2</span> <span class="keyword">then</span> <span class="comment">--可选</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span><span class="comment">--可选</span></span><br><span class="line">... </span><br><span class="line"><span class="keyword">end</span> if;</span><br></pre></td></tr></table></figure><hr><p><strong>case</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> case_value</span><br><span class="line">        <span class="keyword">when</span> search_condition1 <span class="keyword">then</span> statement_List1</span><br><span class="line">        [<span class="keyword">when</span> search_condition2 <span class="keyword">then</span> statement_list2] ..</span><br><span class="line">        [<span class="keyword">else</span> statement_list]</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure><blockquote><p>eg</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p6(<span class="keyword">in</span> <span class="keyword">month</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">      <span class="keyword">case</span></span><br><span class="line">            <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span> <span class="number">3</span> <span class="keyword">then</span></span><br><span class="line">               <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;第1季度&#x27;</span>;</span><br><span class="line">            <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">4</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span> <span class="number">6</span> <span class="keyword">then</span></span><br><span class="line">               <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;第2季度&#x27;</span>;</span><br><span class="line">            <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">7</span> <span class="keyword">and</span> month1<span class="operator">&lt;=</span><span class="number">9</span> <span class="keyword">then</span></span><br><span class="line">               <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;第3季度&#x27;</span>;</span><br><span class="line">            <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span> <span class="number">12</span> <span class="keyword">then</span></span><br><span class="line">               <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;第4季度&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;非法参数&#x27;</span>;</span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">case</span></span><br><span class="line">      <span class="keyword">select</span> concat(<span class="string">&#x27;您输入的月份为：&#x27;</span>,<span class="keyword">month</span>,<span class="string">&#x27;所属的季度为：&#x27;</span>,resut);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-2-循环"><a href="#2-3-2-循环" class="headerlink" title="2.3.2 循环"></a>2.3.2 循环</h3><p><strong>while</strong><br>while循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。<br>具体语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#先判定条件，如果条件为<span class="literal">true</span>，则执行逻辑，否则，不执行逻辑</span><br><span class="line">while 条件 do</span><br><span class="line">     <span class="keyword">SQL</span>逻辑.</span><br><span class="line"><span class="keyword">end</span> while;</span><br></pre></td></tr></table></figure><blockquote><p>eg</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line"><span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">while n<span class="operator">&gt;</span><span class="number">0</span> do</span><br><span class="line"><span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span>n;</span><br><span class="line"><span class="keyword">set</span> n :<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><hr><p>   <strong>repeat</strong><br>repeat是有条件的循环控制语句，当满足条件的时候退出循环。具体语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#先执行一次逻辑，然后判定逻辑是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span><br><span class="line">repeat</span><br><span class="line">      SQL..</span><br><span class="line">      until 条件</span><br><span class="line"><span class="keyword">end</span> repeat;</span><br></pre></td></tr></table></figure><blockquote><p>eg</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">repeat</span><br><span class="line"><span class="keyword">set</span> total :<span class="operator">=</span> total<span class="operator">+</span>n;</span><br><span class="line"><span class="keyword">set</span> n:<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">until n<span class="operator">&lt;=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">end</span> repeat;</span><br><span class="line"><span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><hr><p>   <strong>loop</strong><br>LOOP实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。<br>LOOP可以配合以下两个语句使用：<br>   <code>LEAVE</code>：配合循环使用，退出循环。<br>    <code>TERATE</code>：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] loop</span><br><span class="line">      <span class="keyword">SQL</span>逻辑...</span><br><span class="line"><span class="keyword">end</span> loop [end_label];</span><br><span class="line"></span><br><span class="line">leave label   <span class="comment">--退出指定标记的循环体</span></span><br><span class="line">iterate label <span class="comment">--直接进入下一次循环</span></span><br></pre></td></tr></table></figure><blockquote><p>eg</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">sum: loop</span><br><span class="line">if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">leave sum;</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">set</span> total :<span class="operator">=</span> total<span class="operator">+</span>n;</span><br><span class="line"><span class="keyword">set</span> n:<span class="operator">=</span>n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">end</span> loop sum;</span><br><span class="line"><span class="keyword">select</span>  total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p(<span class="number">90</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">2</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p2(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">sum:loop</span><br><span class="line">if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">leave sum;</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line">if n<span class="operator">%</span><span class="number">2</span> <span class="operator">=</span><span class="operator">=</span> <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> n :<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">iterate sum;</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line"><span class="keyword">set</span> n :<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">end</span> loop sum;</span><br><span class="line"><span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="2-4-游标"><a href="#2-4-游标" class="headerlink" title="2.4 游标"></a>2.4 游标</h2><p>游标（CURSOR）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。<br>游标的使用包括<code>游标的声明、OPEN、FETCH和CLOSE</code>，其语法分别如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#声明游标</span><br><span class="line"><span class="keyword">declare</span> 游标名称 <span class="keyword">cursor</span> <span class="keyword">for</span> 查询语句;</span><br><span class="line"> </span><br><span class="line">#打开游标</span><br><span class="line"><span class="keyword">open</span> 游标名称;</span><br><span class="line"> </span><br><span class="line">#获取游标记录</span><br><span class="line"><span class="keyword">fetch</span> 游标名称 <span class="keyword">into</span> 变量[,变量];</span><br><span class="line"> </span><br><span class="line">#关闭游标</span><br><span class="line"><span class="keyword">close</span> 游标名称;</span><br></pre></td></tr></table></figure><p><strong>条件处理程序</strong><br>可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> hander_action handler <span class="keyword">for</span> condition_value [,condition_value] ... statement;</span><br><span class="line"></span><br><span class="line">handler_action</span><br><span class="line">continue:继续执行当前程序</span><br><span class="line">exit : 种植执行当前程序</span><br><span class="line">condition_value</span><br><span class="line"><span class="keyword">sqlstate</span> sqlstate_value : 状态码,如<span class="number">02000</span></span><br><span class="line"><span class="keyword">sqlwarning</span> : 所有以<span class="number">01</span>开头的<span class="keyword">sqlstate</span>代码的简写</span><br><span class="line"><span class="keyword">not</span> found : 所有以<span class="number">02</span>开头的<span class="keyword">sqlstate</span>代码的简写</span><br><span class="line"><span class="keyword">sqlexception</span> : 所有没有被<span class="keyword">sqlwarning</span> 或 notfound 捕获的<span class="keyword">sqlstate</span>代码的简写</span><br></pre></td></tr></table></figure><blockquote><p>eg</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p(<span class="keyword">in</span> uage <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name,profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">&lt;=</span> uage;</span><br><span class="line"><span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">sqlstate</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">close</span> u_cursor;</span><br><span class="line">#<span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">not</span> found <span class="keyword">close</span> u_cursor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tb_user_pro(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> u_cursor;</span><br><span class="line">while <span class="literal">true</span> do</span><br><span class="line"><span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname,upro;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user_pro <span class="keyword">values</span>(<span class="keyword">null</span>,uname,upro);</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">close</span> u_cursor;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="2-5-存储函数"><a href="#2-5-存储函数" class="headerlink" title="2.5 存储函数"></a>2.5 存储函数</h2><p>存储函数在实际中应用不广泛,可以被存储过程代替<br><code>其参数只能时in类型</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 存储函数名称([参数列表])</span><br><span class="line"><span class="keyword">return</span> type [characteristic...]</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">return</span> ...;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">characteristic说明:</span><br><span class="line"><span class="keyword">deterministic</span> :相同的输入参数总是产生相同的结果</span><br><span class="line"><span class="keyword">no</span> <span class="keyword">sql</span> : 不包含<span class="keyword">SQL</span>语句</span><br><span class="line"><span class="keyword">reads</span> <span class="keyword">sql</span> data : 包含读取数据的语句,但不包含写入数据的语句</span><br></pre></td></tr></table></figure><blockquote><p>eg</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> fun(n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="type">int</span> <span class="keyword">deterministic</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">while n<span class="operator">&gt;</span><span class="number">0</span> do</span><br><span class="line"><span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line"><span class="keyword">set</span> n :<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> fun(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><hr><h1 id="3-触发器"><a href="#3-触发器" class="headerlink" title="3. 触发器"></a>3. 触发器</h1><p>触发器是与表有关的数据库对象，指在<code>insert/update/delete</code>之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。<br>使用别名<code>old</code>和<code>new</code>来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。<br>现在触发器还<code>只支持行级触发，不支持语句级触发。</code></p><table><thead><tr><th>触发器类型</th><th>new和old</th></tr></thead><tbody><tr><td>insert 型触发器</td><td>new表示将要或已经新增的数据</td></tr><tr><td>update 型触发器</td><td>old表示修改之前的数据,new表示将要或已经修改后的数据</td></tr><tr><td>delete 型触发器</td><td>. old表示将要或者已经删除的数据</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#创建</span><br><span class="line"><span class="keyword">create</span> tigger trigger_name</span><br><span class="line">before<span class="operator">/</span>after <span class="keyword">insert</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">/</span><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">on</span> tb_name <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> <span class="comment">--行级触发器</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">trigger_stmt;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line"><span class="keyword">show</span> triggers;</span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> [schema_name.]trigger_name; <span class="comment">--如果没有指定schema_name 默认为当前数据库</span></span><br></pre></td></tr></table></figure><blockquote><p>eg</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#需求：通过发器记录<span class="keyword">user</span>表的数据变更日志（user_ogs），包含培加，修改，除；</span><br><span class="line">#准备工作：口志表userlogs</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_logs(</span><br><span class="line">    id <span class="type">int</span>(<span class="number">11</span>） <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">    operation <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment<span class="string">&#x27;操作类型，insert/update/delete&#x27;</span>,</span><br><span class="line">    operate_time datetime <span class="keyword">not</span> nul comment<span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">    operate_id <span class="type">int</span>(<span class="number">11</span>） <span class="keyword">not</span> <span class="keyword">null</span> comment<span class="string">&#x27;操作的ID&#x27;</span>,</span><br><span class="line">    operate_params <span class="type">varchar</span>(<span class="number">500</span>） comment<span class="string">&#x27;操作参数&#x27;</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_insert_trigger</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id,operation,operate_time,operate_id,operate_params)<span class="keyword">values</span></span><br><span class="line">(<span class="keyword">null</span>,<span class="string">&#x27;insert&#x27;</span>,now(),new.id,concat(<span class="string">&#x27;insert msg : &#x27;</span> ,new.id,.....)</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-视图&quot;&gt;&lt;a href=&quot;#1-视图&quot; class=&quot;headerlink&quot; title=&quot;1. 视图&quot;&gt;&lt;/a&gt;1. 视图&lt;/h1&gt;&lt;p&gt;视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>存储引擎,索引,SQL优化</title>
    <link href="http://example.com/2023/10/22/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-SQL%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2023/10/22/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-SQL%E4%BC%98%E5%8C%96/</id>
    <published>2023-10-22T01:55:55.000Z</published>
    <updated>2023-10-22T06:31:05.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-存储引擎"><a href="#1-存储引擎" class="headerlink" title="1. 存储引擎"></a>1. 存储引擎</h1><h2 id="1-1-MySQL体系结构"><a href="#1-1-MySQL体系结构" class="headerlink" title="1.1 MySQL体系结构"></a>1.1 MySQL体系结构</h2><p><img src="/img/c.6.png" alt="在这里插入图片描述"></p><blockquote><ul><li>连接层<br>最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户<br>端验证它所具有的操作权限。</li><li>服务层<br>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</li><li>引擎层<br>存储引擎真正的负责了MSQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我<br>们可以根据自己的需要，采选取合适的存储引擎。</li><li>存储层<br>主要是将数据存储在文件系统之上，并完成与存储引的交互</li></ul></blockquote><hr><h2 id="1-2-存储引擎简述"><a href="#1-2-存储引擎简述" class="headerlink" title="1.2 存储引擎简述"></a>1.2 存储引擎简述</h2><blockquote><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> account; #查询建表语句,默认为innoDB</span><br><span class="line"><span class="keyword">show</span> engines; #查询当前数据库支持的搜索引擎</span><br><span class="line"></span><br><span class="line">#创建表时,指定存储引擎</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">字段<span class="number">1</span>,字段<span class="number">1</span>类型[comment 注释]</span><br><span class="line">) engine <span class="operator">=</span> innodb [comment 注释];</span><br></pre></td></tr></table></figure><hr><h2 id="1-3-存储引擎的特点"><a href="#1-3-存储引擎的特点" class="headerlink" title="1.3 存储引擎的特点"></a>1.3 存储引擎的特点</h2><h3 id="1-3-1-innoDB"><a href="#1-3-1-innoDB" class="headerlink" title="1.3.1 innoDB"></a>1.3.1 innoDB</h3><ul><li>介绍<br>nnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL5.5之后，InnoDB是默认的MySOL存储引擎。</li><li>特点<br>DML操作遵循ACID模型，支持<code>事务</code>；<br><code>行级锁</code>，提高并发访问性能<br>支持<code>外键</code>FOREIGNKEY约束，保证数据的完整性和正确性</li><li>文件<br>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。参数：innodb_file_per_table</li></ul><p><img src="/img/c.7.png" alt="在这里插入图片描述"></p><hr><h3 id="1-3-2-MyISAM"><a href="#1-3-2-MyISAM" class="headerlink" title="1.3.2 MyISAM"></a>1.3.2 MyISAM</h3><ul><li>介绍<br> MyISAM是MySQL早期的默认存储引擎。</li><li>特点<br> 不支持事务，不支持外键<br> 支持表锁，不支持行锁<br> 访问速度快</li><li>文件<br>xxx.sdi：存储表结构信息<br>XXX.MYD：存储数据<br>XXX.MYI：存储索引</li></ul><hr><h3 id="1-3-3-Memory"><a href="#1-3-3-Memory" class="headerlink" title="1.3.3 Memory"></a>1.3.3 Memory</h3><ul><li>介绍<br>Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</li><li>特点<br>内存存放<br>hash索引（默认）</li><li>文件<br>xxx.sdi：存储表结构信息</li></ul><hr><h3 id="1-3-4-存储引擎的选择"><a href="#1-3-4-存储引擎的选择" class="headerlink" title="1.3.4 存储引擎的选择"></a>1.3.4 存储引擎的选择</h3><ul><li><code>InnoDB</code>：是Mysl的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</li><li>MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的</li><li>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li></ul><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td>支持</td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>支持（5.6版本之后）</td><td>不支持</td><td>-</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N&#x2F;A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>支持</td><td>-</td><td>-</td></tr></tbody></table><hr><h1 id="2-Linux下的MySQL"><a href="#2-Linux下的MySQL" class="headerlink" title="2. Linux下的MySQL"></a>2. Linux下的MySQL</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先将MySQL导入至yum</span></span><br><span class="line">rpm -ivh https://dev.mysql.com/get/mysql80-community-release-el7-10.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment">#MySQL下载至yum</span></span><br><span class="line">yum info mysql-community-server</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过yum下载MySQL</span></span><br><span class="line">yum -y install mysql-community-server</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动MySQL</span></span><br><span class="line">systemctl start mysqld</span><br><span class="line"></span><br><span class="line"><span class="comment">#找到默认MySQL密码</span></span><br><span class="line">grep <span class="string">&#x27;temporary password&#x27;</span> /var/log/mysqld.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#登录MySQL</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="comment">#临时更改严格型密码</span></span><br><span class="line">alter user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;符合Linux检查的密码&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#改变Linux密码校验文件</span></span><br><span class="line"><span class="built_in">set</span> global validate_password.policy = 0; <span class="comment">#设置检查格式为0(默认1)</span></span><br><span class="line"><span class="built_in">set</span> global validate_password.length = 4; <span class="comment">#设置密码最短4个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置平常使用的密码</span></span><br><span class="line">alter user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;9tse&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建全域用户</span></span><br><span class="line">create user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified with mysql_native_password by <span class="string">&#x27;9tse&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#授予该用户所有权限</span></span><br><span class="line">grant all on *.* to <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#再登录即可</span></span><br></pre></td></tr></table></figure><p>如果数据库连接不到Linux中,则只需开放Linux3306端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开放端口</span></span><br><span class="line">sudo firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="comment">#刷新</span></span><br><span class="line">sudo firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查是否生效</span></span><br><span class="line">sudo firewall-cmd --list-all</span><br></pre></td></tr></table></figure><hr><h1 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h1><h2 id="3-1-索引概述"><a href="#3-1-索引概述" class="headerlink" title="3.1 索引概述"></a>3.1 索引概述</h2><blockquote><p>索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，  这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是案引</p></blockquote><table><thead><tr><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>提高数据检索的效率，降低数据库的IO成本</td><td>索引列也是要占用空间的</td></tr><tr><td>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</td><td>索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。</td></tr></tbody></table><hr><h2 id="3-2-索引结构"><a href="#3-2-索引结构" class="headerlink" title="3.2 索引结构"></a>3.2 索引结构</h2><blockquote><p>MySQL的索引是在存储引擎层实现的,不同的存储引擎有不同的结构</p></blockquote><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>最常见的索引类型，大部分引擎都支持B+树索引。</td></tr><tr><td>Hash索引</td><td>数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询。</td></tr><tr><td>R-tree（空间索引）</td><td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少。</td></tr><tr><td>Full-text（全文索引）</td><td>是一种通过建立倒排索引快速匹配文档的方式。类似于Lucene、Solr、Elasticsearch。</td></tr></tbody></table><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><p><code>我们平常所说的索引,如果没有特别指明,都是指的B+树结构组织的索引</code></p><p>MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能<br><img src="/img/c.8.png" alt="在这里插入图片描述"></p><p>Hash</p><ul><li>Hash索引特点<ol><li>Hash索引只能用于对等比较（&#x3D;，in），不支持范围查询（between，&gt;，&lt;，…)</li><li>无法利用素引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于B+tree索引</li></ol></li><li>存储引擎支持<br>在MySQL中，支持hash素引的是Memory引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。</li></ul><hr><h2 id="3-3-索引分类"><a href="#3-3-索引分类" class="headerlink" title="3.3 索引分类"></a>3.3 索引分类</h2><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>primary</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>unique</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td>-</td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词</td><td>可以有多个</td><td>fulltext</td></tr></tbody></table><p>InnoDB存储引擎中,根据索引的存储形式,又可以分为以下两种</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引</td><td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>聚集索引选取规则</p><ul><li>如果存在主键，主键引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一（unique）引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</li></ul><blockquote><p>思考,innoDB主键索引的B+tree高度为多高呢？</p></blockquote><p>假设：<br>    一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint，占用字节数为8<br>高度为2：<br>     n * 8+（n+1）* 6 &#x3D; 16 * 1024，算出n约为1170<br>     1171*16&#x3D;18736<br>高度为3<br>       1171 * 1171 * 16 &#x3D; 21939856</p><hr><h2 id="3-4-索引语法"><a href="#3-4-索引语法" class="headerlink" title="3.4 索引语法"></a>3.4 索引语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#创建索引</span><br><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span> <span class="operator">|</span> fulltext] index index_name <span class="keyword">on</span> table_name(index_col_name,...);</span><br><span class="line"></span><br><span class="line">#查看索引</span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> table_name;</span><br><span class="line"></span><br><span class="line">#删除索引</span><br><span class="line"><span class="keyword">drop</span> index index_name <span class="keyword">on</span> <span class="keyword">table</span> name;</span><br></pre></td></tr></table></figure><blockquote><p>eg</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span>  name字段为姓名字段，该字段的值可能会重复，为该字段创建索引。</span><br><span class="line"><span class="keyword">create</span> index idx_user_name <span class="keyword">on</span> tb_user(name);</span><br><span class="line"></span><br><span class="line">#<span class="number">2.</span>  phone手机号字段的值，是非空，且唯一的，为该字段创建唯一索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index idx_user_phone <span class="keyword">on</span> tb_user(phone);</span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span>  profession、age、status创建联合索引</span><br><span class="line"><span class="keyword">create</span> index idx_user_pro_age_sta <span class="keyword">on</span> tb_user(profession,age,status);</span><br><span class="line"></span><br><span class="line">#<span class="number">4.</span>  为email建立合适的引来提升查询效率。</span><br><span class="line"><span class="keyword">create</span> index idx_user_email <span class="keyword">on</span> tb_user(email);</span><br></pre></td></tr></table></figure><hr><h2 id="3-5-索引性能分析"><a href="#3-5-索引性能分析" class="headerlink" title="3.5 索引性能分析"></a>3.5 索引性能分析</h2><p><strong>SQL执行频率</strong></p><blockquote><p>MySQL客户端连接成功后，通过<code>show[session | global] status</code>命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、 SELECT的访问频次：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>; #七个_</span><br></pre></td></tr></table></figure><hr><p>  <strong>慢查询日志</strong></p><blockquote><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SOL语句的日志<br>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（<code>/etc/my.cnf</code>）中配置如下信息：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启MySQL慢日志查询开关</span></span><br><span class="line">slow_query_log=1</span><br><span class="line"><span class="comment">#设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span></span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure><p>配置完毕之后，重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息<code>/var/lib/mysql/localhost-slow.log</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查看慢查询是否开启</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实时跟踪慢查询日志文件记录的信息</span></span><br><span class="line"><span class="built_in">tail</span> -f localhost-slow.log </span><br></pre></td></tr></table></figure><hr><p>   <strong>profile详情</strong></p><blockquote><p><code>show profiles</code> 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。<br>通过 <code>have_profiling</code> 参数，能够看到当前MySQL是否支持profile操作：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#是否支持profile</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@have_profiling</span>;</span><br><span class="line"></span><br><span class="line">#profiling是否开启</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@profiling</span>;</span><br></pre></td></tr></table></figure><blockquote><p>默认profiling是关闭的，可以通过<code>set</code>语句在session&#x2F;global级别开启profiling</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>执行一系列的业务SOL的操作，然后通过如下指令查看指令的执行耗时</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查看每一条<span class="keyword">SQL</span>的耗时基本情况</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"></span><br><span class="line">#查看指定queny_id的<span class="keyword">SQL</span>语句各个阶段的耗时情况</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br><span class="line"></span><br><span class="line">#查看指定queryid的<span class="keyword">SQL</span>语句CPU的使用情况</span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure><hr><p> <strong>explain执行计划</strong></p><blockquote><p><code>EXPLAIN或者DESC</code>命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。语法：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#直接在<span class="keyword">select</span>语句之前加上关键字explain<span class="operator">/</span>des</span><br><span class="line">explain <span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure><p>EXPLAIN执行计划各字段含义：</p><ol><li>id<br> select查询的序列号，表示查询中执行select子句或者是操作表的顺序（<code>id相同，执行顺序从上到下；id不同，值越大，越先执行</code>）。</li><li>select_type<br> 表示SELECT的类型，常见的取值有SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION （UNION中的第二个或者后面的查询语句）、SUBQUE（SELECT&#x2F;WHERE之后包含了子查询）等</li><li>type<br>表示连接类型，性能由好到差的连接类型为<code>NULL</code>、system、<code>const</code>、eq_ref、ref、range、index、<code>all</code> </li><li>possible_key<br> 显示可能应用在这张表上的索引，一个或多个。</li><li>Key<br> 实际使用的索引，如果为NULL，则没有使用索引</li><li>Key_Len<br>表示索引中使用的字节数，该值为索引字段最大可能长度，<code>并非实际使用长度</code>，在不损失精确性的前提下，<code>长度越短越好</code>。</li><li>rows<br>MySQL<code>认为</code>必须要执行查询的行数，在innodb引l擎的表中，是一个<code>估计值</code>，可能并不总是准确的</li><li>filtered<br>表示返回结果的行数占需读取行数的百分比，fitered的值<code>越大越好</code>。</li></ol><hr><h2 id="3-6-索引的使用"><a href="#3-6-索引的使用" class="headerlink" title="3.6 索引的使用"></a>3.6 索引的使用</h2><p>  验证索引效率,略知索引的重要性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#在未建立索引之前，执行如下SOL语句，查看SOL的耗时。</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_sku <span class="keyword">where</span> sn <span class="operator">=</span> <span class="string">&#x27;100000003745001&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#针对字段创建索引</span><br><span class="line"><span class="keyword">create</span> index idx_sku_sn <span class="keyword">on</span> tb_sku(sn);</span><br><span class="line"></span><br><span class="line">#然后再次执行相同的<span class="keyword">SQL</span>语句，再次查看<span class="keyword">SQL</span>的耗时。</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_sku <span class="keyword">where</span> sn <span class="operator">=</span> <span class="string">&#x27;100000003745001&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="3-6-1-索引失效"><a href="#3-6-1-索引失效" class="headerlink" title="3.6.1 索引失效"></a>3.6.1 索引失效</h3><p>  <strong>最左前法则</strong></p><blockquote><p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，<code>索引将部分失效（后面的字段索引失效）</code>。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">3</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>; #以上索引都没有失效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> age<span class="operator">=</span><span class="number">3</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>; #profession不在,由于最左前缀法,索引失效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>; #profession,age的索引失效</span><br></pre></td></tr></table></figure><p>   <strong>范围查询</strong><br>联合索引中，出现范围查询（&gt;,&lt;），<code>范围查询右侧的列索引失效</code><br>而 &gt;&#x3D; &lt;&#x3D;就不会</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">##age索引失效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">&gt;</span> <span class="number">30</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">##不失效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profassion<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">&gt;=</span> <span class="number">30</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><p>  <strong>索引列运算</strong><br>不要在索引列上进行运算操作，索引将失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> <span class="built_in">substring</span>(phone,<span class="number">10</span>,<span class="number">2</span>) <span class="operator">=</span> <span class="string">&#x27;15&#x27;</span>;</span><br></pre></td></tr></table></figure><p>  <strong>字符串不加引号</strong><br>字符串类型字段使用时，不加引号，索引将失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span> <span class="number">3</span> <span class="keyword">and</span> status<span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="number">17799990015</span>;</span><br></pre></td></tr></table></figure><p>   <strong>模糊查询</strong><br>如果仅仅是尾部模糊匹配，索引不会失效。如果是<code>头部模糊匹配，索引失效</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profssion <span class="keyword">like</span> <span class="string">&#x27;软件%&#x27;</span>; #不失效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;%工程&#x27;</span>; ##失效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;%工%&#x27;</span>; ##失效</span><br></pre></td></tr></table></figure><p>  <strong>or连接的条件</strong><br>用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">or</span> age<span class="operator">=</span><span class="number">23</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone<span class="operator">=</span> <span class="string">&#x27;7799990017&#x27;</span> <span class="keyword">or</span> age<span class="operator">=</span> <span class="number">23</span>;</span><br></pre></td></tr></table></figure><p>由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。</p><p>  <strong>数据分布影响</strong><br>如果MySOL评估使用索引比全表更慢，则不使用索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">&gt;=</span> <span class="string">&#x27;17799990005&#x27;</span>; #手机号码都<span class="operator">&gt;</span><span class="number">05</span> 使用全表</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">&gt;=</span> <span class="string">&#x27;17799990015&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="3-6-2-索引使用"><a href="#3-6-2-索引使用" class="headerlink" title="3.6.2 索引使用"></a>3.6.2 索引使用</h3><p>  <strong>SQL提示</strong><br>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#use index</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user use index(idx_user_pro）<span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span>;</span><br><span class="line">#ignore index</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user ignore index(idx_user_pro）<span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span>;</span><br><span class="line">#force index</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user force index(idx_user_pro）<span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>覆盖索引</strong><br><code>尽量使用覆盖引</code>（查询使用了索引，并且需要返回的列，在该引中已经全部能够找到），减少select*</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">explain <span class="keyword">select</span> id,profession,age,status <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">explain <span class="keyword">select</span> id,profession,age,status,name <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><p>using index condition 查找使用了素引，但是需要<code>回表查询</code>数据<br>using where;using index查找使用了引，但是<code>需要的数据都在引列中能找到</code>，所以不需要回表查询数据</p><p><code>虽然是二级索引中寻找,但并不需要去聚集索引中再寻找</code></p><p>  <strong>前缀索引</strong><br>当字段类型为字符串（varchar，text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的<code>一部分前缀，建立索引</code>，这样可以大大节约索引空间，从而提高索引效率，</p><ul><li>语法<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_xxxx <span class="keyword">on</span> tale name(<span class="keyword">column</span>(n));</span><br><span class="line"></span><br><span class="line">#eg</span><br><span class="line"><span class="keyword">create</span> index idx_email_5 <span class="keyword">on</span> tb_user(email(<span class="number">5</span>));</span><br></pre></td></tr></table></figure></li><li>前缀长度<br> 可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高<br>  唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email)<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email,<span class="number">1</span>,<span class="number">5</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure><p>  <strong>单列索引与联合索引</strong><br>单列索引：即一个索引只包含单个列。<br>联合案引：即一个引包含了多个列<br><code>如果存在多个查询条件,考虑针对于查询字段建立索引时,建议建立联合索引</code></p><p><strong>素引设计原则</strong></p><ol><li>针对于数据量较大，且查询比较频繁的表建立索引。</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率，</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。<br>当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li></ol><hr><h1 id="4-SQL优化"><a href="#4-SQL优化" class="headerlink" title="4. SQL优化"></a>4. SQL优化</h1><h2 id="4-1-插入数据"><a href="#4-1-插入数据" class="headerlink" title="4.1 插入数据"></a>4.1 插入数据</h2><p> <strong>insert优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#批量插入</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;lery&#x27;</span>);</span><br><span class="line"></span><br><span class="line">#手动提交事务</span><br><span class="line">stat transaction; #<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;rom&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;sat&#x27;</span>),(<span class="number">6</span>,<span class="string">&#x27;perry&#x27;</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><blockquote><p>当大批量插入数据,使用insert语句插入性能较低,此时可以使用MySQL数据库提供的<code>load</code>插入</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#客户端连接服务器时,加上参数 <span class="comment">--loacl-infile</span></span><br><span class="line">mysql <span class="comment">--local-infile -u root -p  </span></span><br><span class="line"></span><br><span class="line">#设置全局参数 local_infile 为 <span class="number">1</span>,开启从本地加载文件导入数据的开关</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">#执行load指令将准备好的数据加载到表结构中</span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;/root/sql.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">&#x27;tb_user&#x27;</span> fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>主键顺序插入效率大于主键乱序</code></p><hr><h2 id="4-2-主键优化"><a href="#4-2-主键优化" class="headerlink" title="4.2 主键优化"></a>4.2 主键优化</h2><p>数据组织方式<br>在innoDB引擎中,表数据都是根据主键顺序组织存放的,这种存储方式的表成为<code>索引组织表</code>(index organized table) <code>IOT</code></p><p><strong>页分裂</strong><br><img src="/img/c.9.png" alt="在这里插入图片描述"></p><p><img src="/img/c.10.png" alt="在这里插入图片描述"></p><p><strong>页合并</strong><br><img src="/img/c.11.png" alt="在这里插入图片描述"></p><p>ps:<br>    <code>merge_threshold</code>: 合并页的阈值,可以自己设置,在创建表或者创建索引时指定</p><p>主键设计原则</p><ul><li>满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。(会导致非顺序)</li><li>业务操作时，避免对主键的修改</li></ul><hr><h2 id="4-3-order-by-优化"><a href="#4-3-order-by-优化" class="headerlink" title="4.3 order by 优化"></a>4.3 order by 优化</h2><ol><li><code>Using filesort</code>通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序</li><li><code>Using index</code>：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#以age,phone建立索引</span><br><span class="line">#不符合最左前缀法则</span><br><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> phone , age;</span><br><span class="line"></span><br><span class="line">#需要额外的排序,<span class="keyword">using</span> filesort</span><br><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>,phone <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line">#可以通过建立以下索引以使用<span class="keyword">using</span> index</span><br><span class="line"><span class="keyword">create</span> index idx_user_age_pho_ad <span class="keyword">on</span> tb_user(age <span class="keyword">asc</span>,phone <span class="keyword">desc</span>);</span><br></pre></td></tr></table></figure><p>原则</p><ul><li>据排序字段建立合适的索引，多字段排序时，也遵循最左前法则</li><li>尽量使用覆盖引。</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）</li><li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size（默认256K）</li></ul><hr><h2 id="4-4-limit优化"><a href="#4-4-limit优化" class="headerlink" title="4.4 limit优化"></a>4.4 limit优化</h2><p>imit 2000000 ,10，此时需要MySQL排序前20000 10记录，仅仅返回2000000-2000010的记录，其他记录丢弃，查询排序的代价非常大。<br>优化思路：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过<code>覆盖索引加子查询形式</code>进行优化。</p><hr><h2 id="4-5-count优化"><a href="#4-5-count优化" class="headerlink" title="4.5 count优化"></a>4.5 count优化</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure><ul><li>MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count（*）的时候会直接返回这个数，效率很高</li><li>InnoDB引擎就麻烦了，它执行count（*）的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数</li></ul><p><strong>count的几种用法</strong><br>count是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加，最后返回累计值。</p><p>用法：count（*）、count（主键）、count（字段）、count（1）</p><ul><li>count（主键）<br>  InnoDB引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加（主键不可能为null）</li><li>count（字段）<br>没有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。<br>有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</li><li>count （1）<br>InnoDB引擎遍历整张表，但<code>不取值</code>。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加</li><li>count （*）<br>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，<code>不取值</code>，服务层直接按行进行累加</li></ul><p><code>按照效率排序的话，count（字段）&lt; count（主键id）&lt; count（1）count（*），所以尽量使用count（*）</code></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-存储引擎&quot;&gt;&lt;a href=&quot;#1-存储引擎&quot; class=&quot;headerlink&quot; title=&quot;1. 存储引擎&quot;&gt;&lt;/a&gt;1. 存储引擎&lt;/h1&gt;&lt;h2 id=&quot;1-1-MySQL体系结构&quot;&gt;&lt;a href=&quot;#1-1-MySQL体系结构&quot; class=&quot;</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树篇</title>
    <link href="http://example.com/2023/10/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87/"/>
    <id>http://example.com/2023/10/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87/</id>
    <published>2023-10-22T01:55:23.000Z</published>
    <updated>2023-10-22T06:28:01.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-二叉树之层序遍历"><a href="#1-二叉树之层序遍历" class="headerlink" title="1. 二叉树之层序遍历"></a>1. 二叉树之层序遍历</h1><h2 id="1-1-144-二叉树的前序遍历"><a href="#1-1-144-二叉树的前序遍历" class="headerlink" title="1.1 144-二叉树的前序遍历"></a>1.1 144-二叉树的前序遍历</h2><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">144</a><br><img src="/img/d.1.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recursion</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">Recursion</span>(root-&gt;left,ans);</span><br><span class="line">        <span class="built_in">Recursion</span>(root-&gt;right,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">Recursion</span>(root,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>迭代难度更大</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur || !st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(cur) <span class="comment">//第一趟把左列节点放入栈和ans</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode* tmp = st.<span class="built_in">top</span>(); <span class="comment">//对应着左下角的节点</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            cur = tmp-&gt;right; <span class="comment">//开始右</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-2-94-二叉树的中序遍历"><a href="#1-2-94-二叉树的中序遍历" class="headerlink" title="1.2 94-二叉树的中序遍历"></a>1.2 94-二叉树的中序遍历</h2><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94</a><br><img src="/img/d.2.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recursion</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">Recursion</span>(root-&gt;left,ans);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">Recursion</span>(root-&gt;right,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">Recursion</span>(root,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>迭代法</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur || !st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(cur)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//ans.push_back(cur-&gt;val); 并不是最左边的数据放在第一个</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode* tmp = st.<span class="built_in">top</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp-&gt;val); </span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            cur = tmp-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-3-145-二叉树的后序遍历"><a href="#1-3-145-二叉树的后序遍历" class="headerlink" title="1.3 145-二叉树的后序遍历"></a>1.3 145-二叉树的后序遍历</h2><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145</a></p><p><img src="/img/d.3.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recursion</span><span class="params">(TreeNode*&amp; root,vector&lt;<span class="type">int</span>&gt;&amp; ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">Recursion</span>(root-&gt;left,ans);</span><br><span class="line">        <span class="built_in">Recursion</span>(root-&gt;right,ans);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">Recursion</span>(root,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>迭代法</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur || !st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(cur)</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode* top = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(!top-&gt;right || top-&gt;right == prev)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(top-&gt;val);</span><br><span class="line">                prev = top;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur = top-&gt;right; <span class="comment">//当左走完之后这一步可以走到右</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-4-102-二叉树的层序遍历"><a href="#1-4-102-二叉树的层序遍历" class="headerlink" title="1.4 102-二叉树的层序遍历"></a>1.4 102-二叉树的层序遍历</h2><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102</a></p><p><img src="/img/d.4.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recursion</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans,TreeNode* root,<span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">size</span>() &lt;= level) <span class="comment">//ans的层数不够,加层数</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        ans[level].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">Recursion</span>(ans,root-&gt;left,level+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Recursion</span>(ans,root-&gt;right,level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">Recursion</span>(ans,root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-5-107-二叉树的层序遍历II"><a href="#1-5-107-二叉树的层序遍历II" class="headerlink" title="1.5 107-二叉树的层序遍历II"></a>1.5 107-二叉树的层序遍历II</h2><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/">107</a></p><p><img src="/img/d.5.png" alt="在这里插入图片描述"></p><blockquote><p>上一题reverse一下就可以了</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recursion</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans,TreeNode* root,<span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">size</span>() &lt;= level)</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        ans[level].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">Recursion</span>(ans,root-&gt;left,level+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Recursion</span>(ans,root-&gt;right,level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">Recursion</span>(ans,root,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>也引入一下这题(上一题)的非递归写法</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) </span><br><span class="line">            que.<span class="built_in">push</span>(root); <span class="comment">//先放一个根节点</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">//从前往后一个一个取</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) </span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left); <span class="comment">//push进去当前层的下一层节点</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) </span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right); <span class="comment">//同理</span></span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec); <span class="comment">//加入一层</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 在这里反转一下数组即可</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-6-199-二叉树的右视图"><a href="#1-6-199-二叉树的右视图" class="headerlink" title="1.6 199-二叉树的右视图"></a>1.6 199-二叉树的右视图</h2><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199</a><br><img src="/img/d.6.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root) <span class="comment">//加入第一个节点</span></span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* tmp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i == (size<span class="number">-1</span>)) <span class="comment">//如果是位于尾部</span></span><br><span class="line">                    ans.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left)</span><br><span class="line">                    que.<span class="built_in">push</span>(tmp-&gt;left);<span class="comment">//加入下一层数据</span></span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right)</span><br><span class="line">                    que.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-7-637-二叉树的层平均值"><a href="#1-7-637-二叉树的层平均值" class="headerlink" title="1.7* 637-二叉树的层平均值"></a>1.7* 637-二叉树的层平均值</h2><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/">637</a></p><p><img src="/img/d.7.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* tmp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                sum+=tmp-&gt;val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left)</span><br><span class="line">                    que.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right)</span><br><span class="line">                    que.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(sum/size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-8-429-N叉树的层序遍历"><a href="#1-8-429-N叉树的层序遍历" class="headerlink" title="1.8* 429-N叉树的层序遍历"></a>1.8* 429-N叉树的层序遍历</h2><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/description/">429</a></p><p><img src="/img/d.8.png" alt="在这里插入图片描述"><br><img src="/img/d.9.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tmp_v;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                tmp_v.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; node-&gt;children.<span class="built_in">size</span>(); ++j) <span class="comment">//下一层节点加入que</span></span><br><span class="line">                    <span class="keyword">if</span>(node-&gt;children[j])</span><br><span class="line">                        que.<span class="built_in">push</span>(node-&gt;children[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp_v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-9-515-在每个树行中找最大值"><a href="#1-9-515-在每个树行中找最大值" class="headerlink" title="1.9 515-在每个树行中找最大值"></a>1.9 515-在每个树行中找最大值</h2><p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/">515</a></p><p><img src="/img/d.10.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> max = INT_MIN;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* tmp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;val&gt;max)</span><br><span class="line">                    max = tmp-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left)</span><br><span class="line">                    que.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right)</span><br><span class="line">                    que.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-10-116-填充每个节点的下一个右侧节点指针"><a href="#1-10-116-填充每个节点的下一个右侧节点指针" class="headerlink" title="1.10* 116-填充每个节点的下一个右侧节点指针"></a>1.10* 116-填充每个节点的下一个右侧节点指针</h2><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/">116</a></p><p><img src="/img/d.11.png" alt="在这里插入图片描述"></p><p><img src="/img/d.12.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node* leftest = root;</span><br><span class="line">        <span class="keyword">while</span>(leftest-&gt;left) <span class="comment">//如果该节点还有子节点,则说明可以进入循环处理其孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node* cur = leftest;</span><br><span class="line">            <span class="keyword">while</span>(cur) <span class="comment">//处理cur所有的子节点连接 </span></span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;left-&gt;next = cur-&gt;right; <span class="comment">//下一层的next连接</span></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;next)</span><br><span class="line">                    cur-&gt;right-&gt;next = cur-&gt;next-&gt;left; <span class="comment">//下一层隔支连接</span></span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            leftest = leftest-&gt;left; <span class="comment">//下一层最左边开始</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>若使用普通的层序遍历那么空间复杂度会达到N<br>而这种方式空间复杂度为1</p></blockquote><hr><h2 id="1-11-117-填充每个节点的下一个右侧节点指针II"><a href="#1-11-117-填充每个节点的下一个右侧节点指针II" class="headerlink" title="1.11 117-填充每个节点的下一个右侧节点指针II"></a>1.11 117-填充每个节点的下一个右侧节点指针II</h2><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/">117</a></p><p><img src="/img/d.13.png" alt="在这里插入图片描述"><br><img src="/img/d.14.png" alt="在这里插入图片描述"></p><blockquote><p>上一题是完全二叉树</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root &amp;&amp; (root-&gt;left || root-&gt;right)) <span class="comment">//root存在并且必须有一个孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right) <span class="comment">//如果有左有右,则连接孩子</span></span><br><span class="line">                root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//准备让孩子隔支连接</span></span><br><span class="line">            Node* child = root-&gt;right ? root-&gt;right : root-&gt;left;</span><br><span class="line">            Node* brodady = root-&gt;next; <span class="comment">//向右移动以便用孩子连接child</span></span><br><span class="line">            <span class="keyword">while</span>(brodady &amp;&amp; !(brodady-&gt;left||brodady-&gt;right)) <span class="comment">//直到brodady走到尽头,也要找到有孩子的brodady</span></span><br><span class="line">                brodady = brodady-&gt;next;</span><br><span class="line"></span><br><span class="line">            child-&gt;next = brodady ? (brodady-&gt;left ? brodady-&gt;left : brodady-&gt;right) : <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="built_in">connect</span>(root-&gt;right); <span class="comment">//先向右初始化出NULL</span></span><br><span class="line">            <span class="built_in">connect</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-12-104-二叉树的最大深度"><a href="#1-12-104-二叉树的最大深度" class="headerlink" title="1.12 104-二叉树的最大深度"></a>1.12 104-二叉树的最大深度</h2><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104</a></p><p><img src="/img/d.15.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-13-111-二叉树的最小深度"><a href="#1-13-111-二叉树的最小深度" class="headerlink" title="1.13 111-二叉树的最小深度"></a>1.13 111-二叉树的最小深度</h2><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111</a><br><img src="/img/d.16.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> min_depth = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            min_depth = <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left),min_depth);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            min_depth = <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;right),min_depth);</span><br><span class="line">        <span class="keyword">return</span> min_depth+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="2-二叉树之常见算法"><a href="#2-二叉树之常见算法" class="headerlink" title="2. 二叉树之常见算法"></a>2. 二叉树之常见算法</h1><h2 id="2-1-226-翻转二叉树"><a href="#2-1-226-翻转二叉树" class="headerlink" title="2.1 226-翻转二叉树"></a>2.1 226-翻转二叉树</h2><p><a href="https://leetcode.cn/problems/invert-binary-tree/description/">226</a><br><img src="/img/d.17.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-2-101-对称二叉树"><a href="#2-2-101-对称二叉树" class="headerlink" title="2.2 101-对称二叉树"></a>2.2 101-对称二叉树</h2><p><a href="https://leetcode.cn/problems/symmetric-tree/description/">101</a></p><p><img src="/img/d.18.png" alt="在这里插入图片描述"><br><img src="/img/d.19.png" alt="在这里插入图片描述"></p><blockquote><p>递归</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Recursion</span><span class="params">(TreeNode* left,TreeNode* right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!left&amp;&amp;right || left&amp;&amp;!right) <span class="comment">//如果长短不一</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!left &amp;&amp; !right) <span class="comment">//如果都没有后续了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left-&gt;val != right-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Recursion</span>(left-&gt;left,right-&gt;right) &amp;&amp;</span><br><span class="line">                <span class="built_in">Recursion</span>(left-&gt;right,right-&gt;left); </span><br><span class="line">                <span class="comment">//对称的两个节点比较</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Recursion</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>迭代(栈)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        st.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* leftNode = st.<span class="built_in">top</span>(); </span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* rightNode = st.<span class="built_in">top</span>(); </span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!leftNode &amp;&amp; !rightNode) <span class="comment">//左右节点都不存在,相当于对称,循环至下一次判断</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//左右不一样长 || 左右节点的值不一样</span></span><br><span class="line">            <span class="keyword">if</span> ((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            st.<span class="built_in">push</span>(leftNode-&gt;left);</span><br><span class="line">            st.<span class="built_in">push</span>(rightNode-&gt;right);</span><br><span class="line">            st.<span class="built_in">push</span>(leftNode-&gt;right);</span><br><span class="line">            st.<span class="built_in">push</span>(rightNode-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-3-222-完全二叉树的节点个数"><a href="#2-3-222-完全二叉树的节点个数" class="headerlink" title="2.3* 222-完全二叉树的节点个数"></a>2.3* 222-完全二叉树的节点个数</h2><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">222</a></p><p><img src="/img/d.20.png" alt="在这里插入图片描述"><br><img src="/img/d.21.png" alt="在这里插入图片描述"></p><blockquote><p>递归遍历 O(N)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recursion</span><span class="params">(TreeNode* root,<span class="type">int</span>&amp; count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">Recursion</span>(root-&gt;left,count);</span><br><span class="line">        <span class="built_in">Recursion</span>(root-&gt;right,count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">Recursion</span>(root,count);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>精简版递归</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">countNodes</span>(root-&gt;left) </span><br><span class="line">                + <span class="built_in">countNodes</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>最优</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> level = <span class="number">0</span>;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;left) </span><br><span class="line">        &#123;</span><br><span class="line">            level++;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">1</span> &lt;&lt; level; <span class="comment">// 层序遍历第low位为最深层最左侧节点序号 4</span></span><br><span class="line">        <span class="type">int</span> high = (<span class="number">1</span> &lt;&lt; (level + <span class="number">1</span>)) - <span class="number">1</span>; <span class="comment">//层序遍历第high位为最深层最右侧节点序号 7</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low; <span class="comment">//+1防止low+0 ,mid为两节点中间部分一个节点,偏右</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">exists</span>(root, level, mid))</span><br><span class="line">                low = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exists</span><span class="params">(TreeNode* root, <span class="type">int</span> level, <span class="type">int</span> mid)</span> <span class="comment">//6</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> bits = <span class="number">1</span> &lt;&lt; (level - <span class="number">1</span>); <span class="comment">//上一层的第一位序列</span></span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; bits &gt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bits &amp; mid)  <span class="comment">//0010 0110 0010 当不再同一树时判断后就进入循环</span></span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            bits &gt;&gt;= <span class="number">1</span>; <span class="comment">//bits是最左节点,往上靠</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度:O(logN*logN)<br>空间复杂度:O(1)</p></blockquote><hr><h2 id="2-4-110-平衡二叉树"><a href="#2-4-110-平衡二叉树" class="headerlink" title="2.4 110-平衡二叉树"></a>2.4 110-平衡二叉树</h2><p><a href="https://leetcode.cn/problems/balanced-binary-tree/description/">110</a><br><img src="/img/d.22.png" alt="在这里插入图片描述"><br><img src="/img/d.23.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Recursion</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">Recursion</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">Recursion</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(left-right) &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//执行后,以后的结果都为-1,递归其实已经可以看作结束了</span></span><br><span class="line">        <span class="keyword">return</span> left&gt;right?left+<span class="number">1</span>:right+<span class="number">1</span>; <span class="comment">//每一层都会记录层数+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Recursion</span>(root) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-5-257-二叉树的所有路径"><a href="#2-5-257-二叉树的所有路径" class="headerlink" title="2.5 257-二叉树的所有路径"></a>2.5 257-二叉树的所有路径</h2><p><a href="https://leetcode.cn/problems/binary-tree-paths/description/">257</a><br><img src="/img/d.24.png" alt="在这里插入图片描述"><br><img src="/img/d.25.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recursion</span><span class="params">(TreeNode* root,vector&lt;string&gt;&amp; vs,string s)</span> <span class="comment">//s传的是临时拷贝份</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root&amp;&amp;!root-&gt;left&amp;&amp;!root-&gt;right) <span class="comment">//无子,此时不加-&gt;</span></span><br><span class="line">        &#123;</span><br><span class="line">            s+=(<span class="built_in">to_string</span>(root-&gt;val));</span><br><span class="line">            vs.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s+=(<span class="built_in">to_string</span>(root-&gt;val)+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">Recursion</span>(root-&gt;left,vs,s); </span><br><span class="line">        <span class="built_in">Recursion</span>(root-&gt;right,vs,s); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; vs;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="built_in">Recursion</span>(root,vs,s);</span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-6-404-左子叶之和"><a href="#2-6-404-左子叶之和" class="headerlink" title="2.6 404-左子叶之和"></a>2.6 404-左子叶之和</h2><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/description/">404</a><br><img src="/img/d.26.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) <span class="comment">//左子存在且为叶</span></span><br><span class="line">            leftValue = root-&gt;left-&gt;val;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> leftValue + <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left) + <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-7-513-找树左下角的值"><a href="#2-7-513-找树左下角的值" class="headerlink" title="2.7* 513-找树左下角的值"></a>2.7* 513-找树左下角的值</h2><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/description/">513</a></p><p><img src="/img/d.27.png" alt="在这里插入图片描述"><br><img src="/img/d.28.png" alt="在这里插入图片描述"></p><blockquote><p>dfs</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recursion</span><span class="params">(TreeNode* cur,<span class="type">int</span> curdep,<span class="type">int</span>&amp; maxdep,<span class="type">int</span>&amp; ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cur-&gt;left&amp;&amp;!cur-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(curdep&gt;maxdep)</span><br><span class="line">            &#123;</span><br><span class="line">                maxdep = dep;</span><br><span class="line">                ans = cur-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left) <span class="comment">//cur-&gt;left在前面使得更早的占用ans,以防被right占用</span></span><br><span class="line">            <span class="built_in">Recursion</span>(cur-&gt;left,dep+<span class="number">1</span>,maxdep,ans);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">            <span class="built_in">Recursion</span>(cur-&gt;right,dep+<span class="number">1</span>,maxdep,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = root-&gt;val;</span><br><span class="line">        <span class="type">int</span> maxdep = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">Recursion</span>(root,<span class="number">0</span>,maxdep,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>bfs</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* cur = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">                que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">                que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            ans = cur-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-8-112-路径总和"><a href="#2-8-112-路径总和" class="headerlink" title="2.8 112-路径总和"></a>2.8 112-路径总和</h2><p><a href="https://leetcode.cn/problems/path-sum/description/">112</a></p><p><img src="/img/d.29.png" alt="在这里插入图片描述"><br><img src="/img/d.30.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Recursion</span><span class="params">(TreeNode* cur,<span class="type">int</span> sum,<span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cur)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!cur-&gt;left&amp;&amp;!cur-&gt;right&amp;&amp;sum+cur-&gt;val == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Recursion</span>(cur-&gt;left,sum+cur-&gt;val,target)</span><br><span class="line">            ||<span class="built_in">Recursion</span>(cur-&gt;right,sum+cur-&gt;val,target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Recursion</span>(root,<span class="number">0</span>,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-9-106-从中序与后续遍历序列构造二叉树"><a href="#2-9-106-从中序与后续遍历序列构造二叉树" class="headerlink" title="2.9* 106-从中序与后续遍历序列构造二叉树"></a>2.9* 106-从中序与后续遍历序列构造二叉树</h2><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">106</a></p><p><img src="/img/d.31.png" alt="在这里插入图片描述"><br><img src="/img/d.32.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Recursion</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder,vector&lt;<span class="type">int</span>&gt;&amp; postorder,<span class="type">int</span>&amp; rootindex,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* cur = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(postorder[rootindex]); <span class="comment">//cur为当前根节点</span></span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(mid = inorder.<span class="built_in">size</span>()<span class="number">-1</span> ; mid &gt;=<span class="number">0</span> ; --mid)</span><br><span class="line">            <span class="keyword">if</span>(inorder[mid] == postorder[rootindex])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//此时mid为inorder的根坐标</span></span><br><span class="line">        rootindex--; <span class="comment">//跳到下一个根</span></span><br><span class="line">        <span class="comment">//因为是后序所以先right,否则会出现构建出相反的树,并且大概率导致rootindex&lt;0而导致的越栈</span></span><br><span class="line">        cur-&gt;right = <span class="built_in">Recursion</span>(inorder,postorder,rootindex,mid+<span class="number">1</span>,right);</span><br><span class="line">        cur-&gt;left = <span class="built_in">Recursion</span>(inorder,postorder,rootindex,left,mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootindex = postorder.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Recursion</span>(inorder,postorder,rootindex,<span class="number">0</span>,rootindex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-10-105-从前序与中序遍历序列构造二叉树"><a href="#2-10-105-从前序与中序遍历序列构造二叉树" class="headerlink" title="2.10* 105-从前序与中序遍历序列构造二叉树"></a>2.10* 105-从前序与中序遍历序列构造二叉树</h2><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">105</a><br><img src="/img/d.33.png" alt="在这里插入图片描述"><br><img src="/img/d.34.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Recursion</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder,<span class="type">int</span>&amp; rootindex,<span class="type">int</span> left , <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* cur = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[rootindex]);</span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(mid = <span class="number">0</span> ; mid &lt; inorder.<span class="built_in">size</span>() ; ++mid)</span><br><span class="line">            <span class="keyword">if</span>(inorder[mid] == preorder[rootindex])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        rootindex++;</span><br><span class="line">        cur-&gt;left = <span class="built_in">Recursion</span>(preorder,inorder,rootindex,left,mid<span class="number">-1</span>);</span><br><span class="line">        cur-&gt;right = <span class="built_in">Recursion</span>(preorder,inorder,rootindex,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootindex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Recursion</span>(preorder,inorder,rootindex,<span class="number">0</span>,preorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-11-654-最大二叉树"><a href="#2-11-654-最大二叉树" class="headerlink" title="2.11* 654-最大二叉树"></a>2.11* 654-最大二叉树</h2><p><a href="https://leetcode.cn/problems/maximum-binary-tree/description/">654</a></p><p><img src="/img/d.35.png" alt="在这里插入图片描述"><br><img src="/img/d.36.png" alt="在这里插入图片描述"><br><img src="/img/d.37.png" alt="在这里插入图片描述"><br><img src="/img/d.37.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Recursion</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid = left; <span class="comment">//坐标</span></span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;    <span class="comment">//最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = mid ; i &lt;= right ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = i;       <span class="comment">//mid就是根的坐标</span></span><br><span class="line">                max = nums[i]; <span class="comment">//最大值就是根</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* cur = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(max); <span class="comment">//构建根</span></span><br><span class="line">        cur-&gt;left = <span class="built_in">Recursion</span>(nums,left,mid<span class="number">-1</span>);</span><br><span class="line">        cur-&gt;right = <span class="built_in">Recursion</span>(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Recursion</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-12-617-合并二叉树"><a href="#2-12-617-合并二叉树" class="headerlink" title="2.12 617-合并二叉树"></a>2.12 617-合并二叉树</h2><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">617</a></p><p><img src="/img/d.39.png" alt="在这里插入图片描述"><br><img src="/img/d.40.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root1)</span><br><span class="line">            <span class="keyword">return</span> root2; <span class="comment">//如果两个节点都不存在,也会返回nullptr(root2)</span></span><br><span class="line">        <span class="keyword">if</span>(!root2)</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root1-&gt;val+root2-&gt;val);</span><br><span class="line">        root-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left,root2-&gt;left);</span><br><span class="line">        root-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right,root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-13-236-二叉树的最近公共祖先"><a href="#2-13-236-二叉树的最近公共祖先" class="headerlink" title="2.13* 236-二叉树的最近公共祖先"></a>2.13* 236-二叉树的最近公共祖先</h2><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236</a></p><p><img src="/img/d.41.png" alt="在这里插入图片描述"></p><p><img src="/img/d.42.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">            </span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left&amp;&amp;right)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!left&amp;&amp;right)</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left&amp;&amp;!right)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="3-二叉搜索树"><a href="#3-二叉搜索树" class="headerlink" title="3. 二叉搜索树"></a>3. 二叉搜索树</h1><h2 id="3-1-700-二叉搜索树中的搜索"><a href="#3-1-700-二叉搜索树中的搜索" class="headerlink" title="3.1 700-二叉搜索树中的搜索"></a>3.1 700-二叉搜索树中的搜索</h2><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/description/">700</a></p><p><img src="/img/d.43.png" alt="在这里插入图片描述"><br><img src="/img/d.44.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left,val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; root-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right,val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-2-98-验证二叉搜索树"><a href="#3-2-98-验证二叉搜索树" class="headerlink" title="3.2* 98-验证二叉搜索树"></a>3.2* 98-验证二叉搜索树</h2><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">98</a></p><p><img src="/img/d.45.png" alt="在这里插入图片描述"><br><img src="/img/d.46.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root,TreeNode* minNode = <span class="literal">nullptr</span>,TreeNode* maxNode = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((minNode &amp;&amp; root-&gt;val &lt;= minNode-&gt;val) || <span class="comment">//右树用来判断是否比父小</span></span><br><span class="line">            (maxNode &amp;&amp; root-&gt;val &gt;= maxNode-&gt;val))  <span class="comment">//左树用来判断是否比父大</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                            <span class="comment">//不符合就false</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;left,minNode,root) &amp;&amp; <span class="comment">//对于左树,最大的就是根</span></span><br><span class="line">                <span class="built_in">isValidBST</span>(root-&gt;right,root,maxNode); <span class="comment">//对于右树,最小的就是根</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>更直观的方法</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* tmp = root-&gt;left;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;val&gt;=root-&gt;val) <span class="comment">//先判断和父的关系是否满足</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(tmp-&gt;right)       <span class="comment">//在判断自己的右孩子是否和自己对应</span></span><br><span class="line">            &#123;                       <span class="comment">//左孩子会通过递归(和父的关系)进行判断</span></span><br><span class="line">                tmp = tmp-&gt;right;</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;val&gt;=root-&gt;val)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* tmp = root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;val&lt;=root-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(tmp-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = tmp-&gt;left;</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;val&lt;=root-&gt;val)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;left) &amp;&amp; <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-3-530-二叉搜索树的最小绝对差"><a href="#3-3-530-二叉搜索树的最小绝对差" class="headerlink" title="3.3 530-二叉搜索树的最小绝对差"></a>3.3 530-二叉搜索树的最小绝对差</h2><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/">530</a></p><p><img src="/img/d.47.png" alt="在这里插入图片描述"><br><img src="/img/d.48.png" alt="在这里插入图片描述"></p><blockquote><p>递归</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recursion</span><span class="params">(TreeNode* root,TreeNode*&amp; prev,<span class="type">int</span>&amp; mindif)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">Recursion</span>(root-&gt;left,prev,mindif);</span><br><span class="line">        <span class="keyword">if</span>(prev)</span><br><span class="line">            mindif = <span class="built_in">min</span>(mindif,<span class="built_in">abs</span>(root-&gt;val-prev-&gt;val));</span><br><span class="line">            </span><br><span class="line">        prev = root; <span class="comment">//prev就是更深层的</span></span><br><span class="line">        <span class="built_in">Recursion</span>(root-&gt;right,prev,mindif);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> mindif = INT_MAX;</span><br><span class="line">        TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">Recursion</span>(root,prev,mindif); <span class="comment">//类似于采取中序遍历寻找mindif</span></span><br><span class="line">        <span class="keyword">return</span> mindif;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>完全遍历</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recursion</span><span class="params">(TreeNode* root,<span class="type">int</span>&amp; min)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* left = root-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(left)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp =<span class="built_in">abs</span>(root-&gt;val-left-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp&lt;min)</span><br><span class="line">                    min = tmp;</span><br><span class="line">                left = left-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* right = root-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(right)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = <span class="built_in">abs</span>(root-&gt;val-right-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp&lt;min)</span><br><span class="line">                    min = tmp;</span><br><span class="line">                right = right-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Recursion</span>(root-&gt;left,min);</span><br><span class="line">        <span class="built_in">Recursion</span>(root-&gt;right,min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> min = <span class="number">100000</span>;</span><br><span class="line">        <span class="built_in">Recursion</span>(root,min);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-4-501-二叉搜索树中的众数"><a href="#3-4-501-二叉搜索树中的众数" class="headerlink" title="3.4 501-二叉搜索树中的众数"></a>3.4 501-二叉搜索树中的众数</h2><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/">501</a></p><p><img src="/img/d.49.png" alt="在这里插入图片描述"><br><img src="/img/d.50.png" alt="在这里插入图片描述"></p><blockquote><p>hash通解,即非二叉树也可解</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init_um_Recursion</span><span class="params">(TreeNode* root,unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; um)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        um[root-&gt;val]++;</span><br><span class="line">        <span class="built_in">Init_um_Recursion</span>(root-&gt;left,um);</span><br><span class="line">        <span class="built_in">Init_um_Recursion</span>(root-&gt;right,um);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; um;</span><br><span class="line">        <span class="built_in">Init_um_Recursion</span>(root,um);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> max = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : um) <span class="comment">//算出最多的出现次数</span></span><br><span class="line">            <span class="keyword">if</span>(e.second &gt; max)</span><br><span class="line">                max = e.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : um)</span><br><span class="line">            <span class="keyword">if</span>(e.second == max)</span><br><span class="line">                ans.<span class="built_in">push_back</span>(e.first);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>针对</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> samenum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxcount = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Get_ret</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; ret)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">Get_ret</span>(root-&gt;left,ret);</span><br><span class="line">        ret.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(samenum == root-&gt;val) <span class="comment">//即使samenum初始值就和val相同也无所谓</span></span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            samenum = root-&gt;val;</span><br><span class="line">            count=<span class="number">1</span>; <span class="comment">//避免samenum初始就和val相同而导致的错误计数,也方便使用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(maxcount &lt; count)</span><br><span class="line">            maxcount = count;</span><br><span class="line">        <span class="built_in">Get_ret</span>(root-&gt;right,ret);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="built_in">Get_ret</span>(root,ret);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = maxcount<span class="number">-1</span>; <span class="comment">//left到right 可看作是窗口</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; ret.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ret[left] == ret[right])</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(ret[left]);</span><br><span class="line">                left = right+<span class="number">1</span>;</span><br><span class="line">                right = left+maxcount<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-5-235-二叉搜索树的最近公共祖先"><a href="#3-5-235-二叉搜索树的最近公共祖先" class="headerlink" title="3.5* 235-二叉搜索树的最近公共祖先"></a>3.5* 235-二叉搜索树的最近公共祖先</h2><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">235</a></p><p><img src="/img/d.51.png" alt="在这里插入图片描述"><br><img src="/img/d.52.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) <span class="comment">//都在根右边</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&lt;p-&gt;val&amp;&amp;root-&gt;val&lt;q-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-6-701-二叉搜索树中的插入操作"><a href="#3-6-701-二叉搜索树中的插入操作" class="headerlink" title="3.6* 701-二叉搜索树中的插入操作"></a>3.6* 701-二叉搜索树中的插入操作</h2><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">701</a></p><p><img src="/img/d.53.png" alt="在这里插入图片描述"><br><img src="/img/d.54.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root-&gt;val)</span><br><span class="line">            root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right,val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(val &lt; root-&gt;val)</span><br><span class="line">            root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left,val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-7-450-删除二叉搜索树中的节点"><a href="#3-7-450-删除二叉搜索树中的节点" class="headerlink" title="3.7* 450-删除二叉搜索树中的节点"></a>3.7* 450-删除二叉搜索树中的节点</h2><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">450</a></p><p><img src="/img/d.55.png" alt="在这里插入图片描述"><br><img src="/img/d.56.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">findMin</span><span class="params">(TreeNode* node)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node-&gt;left) </span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) </span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key &lt; root-&gt;val) </span><br><span class="line">            root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;val) </span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!root-&gt;left) </span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp = root-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;right) </span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp = root-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode* temp = <span class="built_in">findMin</span>(root-&gt;right); <span class="comment">//temp就是要替代的节点</span></span><br><span class="line">            root-&gt;val = temp-&gt;val;</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, temp-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-8-669-修剪二叉搜索树"><a href="#3-8-669-修剪二叉搜索树" class="headerlink" title="3.8* 669-修剪二叉搜索树"></a>3.8* 669-修剪二叉搜索树</h2><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/description/">669</a></p><p><img src="/img/d.57.png" alt="在这里插入图片描述"><br><img src="/img/d.58.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">//间接删除</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;low) <span class="comment">//范围全在右子树上</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;right,low,high);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&gt;high)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;left,low,high);</span><br><span class="line">            </span><br><span class="line">        root-&gt;left = <span class="built_in">trimBST</span>(root-&gt;left,low,high);</span><br><span class="line">        root-&gt;right = <span class="built_in">trimBST</span>(root-&gt;right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-9-108-将有序数组转换为二叉搜索树"><a href="#3-9-108-将有序数组转换为二叉搜索树" class="headerlink" title="3.9 108-将有序数组转换为二叉搜索树"></a>3.9 108-将有序数组转换为二叉搜索树</h2><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108</a></p><p><img src="/img/d.59.png" alt="在这里插入图片描述"><br><img src="/img/d.60.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Recursion</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid = left+((right-left)&gt;&gt;<span class="number">1</span>); <span class="comment">// &gt;&gt;1 可看作是 /2,默认左偏</span></span><br><span class="line">        TreeNode* newnode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        newnode-&gt;left = <span class="built_in">Recursion</span>(nums,left,mid<span class="number">-1</span>);</span><br><span class="line">        newnode-&gt;right = <span class="built_in">Recursion</span>(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> newnode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Recursion</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-10-538-把二叉搜索树转换为累加树"><a href="#3-10-538-把二叉搜索树转换为累加树" class="headerlink" title="3.10 538-把二叉搜索树转换为累加树"></a>3.10 538-把二叉搜索树转换为累加树</h2><p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/description/">538</a></p><p><img src="/img/d.61.png" alt="在这里插入图片描述"><br><img src="/img/d.62.png" alt="在这里插入图片描述"><br><img src="/img/d.63.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recursion</span><span class="params">(TreeNode* root,<span class="type">int</span>&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">Recursion</span>(root-&gt;right,val);</span><br><span class="line">        val+=root-&gt;val;</span><br><span class="line">        root-&gt;val = val;</span><br><span class="line">        <span class="built_in">Recursion</span>(root-&gt;left,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">Recursion</span>(root,val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-二叉树之层序遍历&quot;&gt;&lt;a href=&quot;#1-二叉树之层序遍历&quot; class=&quot;headerlink&quot; title=&quot;1. 二叉树之层序遍历&quot;&gt;&lt;/a&gt;1. 二叉树之层序遍历&lt;/h1&gt;&lt;h2 id=&quot;1-1-144-二叉树的前序遍历&quot;&gt;&lt;a href=&quot;#1-1</summary>
      
    
    
    
    <category term="代码随想录" scheme="http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>tips</title>
    <link href="http://example.com/2023/10/22/tips-1/"/>
    <id>http://example.com/2023/10/22/tips-1/</id>
    <published>2023-10-22T01:55:13.000Z</published>
    <updated>2023-10-22T06:11:02.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-MySQL基本使用"><a href="#1-MySQL基本使用" class="headerlink" title="1. MySQL基本使用"></a>1. MySQL基本使用</h1><hr><h2 id="1-1-MySQL的启动和登录"><a href="#1-1-MySQL的启动和登录" class="headerlink" title="1.1 MySQL的启动和登录"></a>1.1 MySQL的启动和登录</h2><hr><h3 id="1-1-1-MySQL的启动"><a href="#1-1-1-MySQL的启动" class="headerlink" title="1.1.1 MySQL的启动"></a>1.1.1 MySQL的启动</h3><p><strong>1. 管理员身份打开cmd</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net <span class="keyword">start</span> mysql80 ##启动MySQL</span><br><span class="line">net stop mysql80 ##关闭MySQL</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-2-MySQL的客户端连接"><a href="#1-1-2-MySQL的客户端连接" class="headerlink" title="1.1.2 MySQL的客户端连接"></a>1.1.2 MySQL的客户端连接</h3><p><strong>1. 管理员身份打开cmd</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql [<span class="operator">-</span>h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>] [<span class="operator">-</span>P <span class="number">3306</span>] <span class="operator">-</span>u root <span class="operator">-</span>p </span><br></pre></td></tr></table></figure><p><code>使用这种方法需要配置环境变量,MySQL的bin目录</code></p><p><strong>2. 打开mysql命令行客户端,输入密码以打开</strong></p><hr><h2 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2 数据模型"></a>1.2 数据模型</h2><blockquote><p>关系型数据库 (RDBMS)</p><ul><li>概念 : 建立在关系模型基础上,由多张相互连接的二维表组成的数据库</li><li>特点 : <ol><li>使用表存储数据,格式同意,便于维护</li><li>使用SQL语言操作,标准统一,使用方便</li></ol></li></ul></blockquote><hr><h1 id="2-SQL"><a href="#2-SQL" class="headerlink" title="2. SQL"></a>2. SQL</h1><blockquote><p>SQL通用语法</p><ol><li>SQL语句可以单行或多行书写,<code>以分号结尾</code></li><li>SQL依据可以使用空格&#x2F;TAB增强可读</li><li>MySQL数据库的SQL语句<code>不区分大小写</code>,<code>关键字建议大写</code></li><li>注释:<ul><li>单行注释 : –注释内容 &#x2F; # 注释内容(MySQL特有)</li><li>多行注释: &#x2F;*注释内容*&#x2F;</li></ul></li></ol></blockquote><table><thead><tr><th>分类</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td>数据定义语言，用来定义数据库对象（数据库，表，字段）</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td>数据操作语言，用来对数据库表中的数据进行增删改</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>数据查询语言，用来查询数据库中表的记录</td></tr><tr><td>DCL</td><td>Data Control Language</td><td>数据控制语言，用来创建数据库用户、控制数据库的访问权限</td></tr></tbody></table><p>如果您需要其他格式或有其他问题，请随时告诉我。</p><h2 id="2-1-SQL类型"><a href="#2-1-SQL类型" class="headerlink" title="2.1 SQL类型"></a>2.1 SQL类型</h2><h3 id="2-1-1-数值类型"><a href="#2-1-1-数值类型" class="headerlink" title="2.1.1 数值类型"></a>2.1.1 数值类型</h3><table><thead><tr><th>类型</th><th>大小</th><th>有符号范围</th><th>无符号范围</th><th>描述</th></tr></thead><tbody><tr><td>tinyint</td><td>1 byte</td><td>(-128，127)</td><td>(0, 255)</td><td>小整数值</td></tr><tr><td>smallint</td><td>2 bytes</td><td>(-32768，32767)</td><td>(0, 65535)</td><td>大整数值</td></tr><tr><td>mediumint</td><td>3 bytes</td><td>(-8388608，8388607)</td><td>(0, 16777215)</td><td>大整数值</td></tr><tr><td>int&#x2F;integer</td><td>4 bytes</td><td>(-2147483648，2147483647)</td><td>(0, 4294967295)</td><td>大整数值</td></tr><tr><td>bigint</td><td>8 bytes</td><td>(-2^63，2^63-1)</td><td>(0, 2^64-1)</td><td>极大整数值</td></tr><tr><td>float</td><td>4 bytes</td><td>(-3.402823466 E+38，3.402823466351 E+38)</td><td>(0, 3.402823466 E+38)</td><td>单精度浮点数值</td></tr><tr><td>double</td><td>8 bytes</td><td>(-1.7976931348623157 E+308，1.7976931348623157 E+308)</td><td>(0, 1.7976931348623157 E+308)</td><td>双精度浮点数值</td></tr><tr><td>decimal</td><td>依赖于M和D的值</td><td>依赖于M和D的值</td><td>依赖于M和D的值</td><td>小数值(精确定点数)</td></tr></tbody></table><p>ps : </p><ul><li>decimal : 123.45 精度(M)为5,标度(D)为2</li><li>无符号类型写法: tinyint unsigned</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>(<span class="number">4</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>4代表整体长度,1代表小数点后的位数</p><hr><h3 id="2-1-2-字符串类型"><a href="#2-1-2-字符串类型" class="headerlink" title="2.1.2 字符串类型"></a>2.1.2 字符串类型</h3><table><thead><tr><th>类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>char</td><td>0-255 bytes</td><td>定长字符串</td></tr><tr><td>varchar</td><td>0-65535 bytes</td><td>变长字符串</td></tr><tr><td>tinyblob</td><td>0-255 bytes</td><td>不超过255个字符的二进制数据</td></tr><tr><td>tinytext</td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td>blob</td><td>0-65,535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>text</td><td>0-65,535 bytes</td><td>长文本数据</td></tr><tr><td>mediumblob</td><td>0-16,777,215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>mediumtext</td><td>0-16,777,215 bytes</td><td>中等长度文本数据</td></tr><tr><td>longblob</td><td>0-4,294,967,295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>longtext</td><td>0-4,294,967,295 bytes</td><td>极大文本数据</td></tr></tbody></table><p>ps :</p><ul><li>char性能优与varchar<br>变长是指,在不超过最大容量时,1就是1,2就是2<br>定长是指,哪怕是1,也要占用最大容量</li></ul><hr><h3 id="2-1-3-日期类型"><a href="#2-1-3-日期类型" class="headerlink" title="2.1.3 日期类型"></a>2.1.3 日期类型</h3><table><thead><tr><th>类型</th><th>大小</th><th>范围</th><th>格式</th></tr></thead><tbody><tr><td>date</td><td>3</td><td>1000-01-01 至 9999-12-31</td><td>YYYY-MM-DD</td></tr><tr><td>time</td><td>3</td><td>-838:59:59 至 838:59:59</td><td>HH:MM:SS</td></tr><tr><td>year</td><td>1</td><td>1901 至 2155</td><td>YYYY</td></tr><tr><td>datetime</td><td>8</td><td>1000-01-01 00:00:00 至 9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td></tr><tr><td>timestamp</td><td>4</td><td>1970-01-01 00:00:01 至 2038-01-19 03:14:07</td><td>YYYY-MM-DD HH:MM:SS</td></tr></tbody></table><hr><h2 id="2-2-DDL"><a href="#2-2-DDL" class="headerlink" title="2.2 DDL"></a>2.2 DDL</h2><h3 id="2-2-1-数据库操作"><a href="#2-2-1-数据库操作" class="headerlink" title="2.2.1 数据库操作"></a>2.2.1 数据库操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#查询</span><br><span class="line"><span class="keyword">show</span> databases; # 查询所有数据库</span><br><span class="line"><span class="keyword">select</span> database(); #查询当前数据库</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建</span><br><span class="line"><span class="keyword">create</span> database [if <span class="keyword">not</span> <span class="keyword">exists</span>] 数据库名 [<span class="keyword">default</span> charset 字符集] [<span class="keyword">collate</span> 排序规则];</span><br><span class="line"></span><br><span class="line">#eg:</span><br><span class="line">creat datebase if <span class="keyword">not</span> <span class="keyword">exists</span> emp <span class="keyword">default</span> charset utf8mb4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line"><span class="keyword">drop</span> database [if <span class="keyword">exists</span>] 数据库名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#使用</span><br><span class="line">use 数据库名</span><br></pre></td></tr></table></figure><p><code>MySQL里实现的utf8最长使用3个字节,utf8mb4 是 utf8 的超集并完全兼容utf8，能够用四个字节存储更多的字符。</code></p><p>比如:最常见的就算现在手机端常用的表情字符 emoji和一些不常用的汉字，如 “墅” ，这些需要四个字节才能编码出来。</p><hr><h3 id="2-2-2-表操作-查询"><a href="#2-2-2-表操作-查询" class="headerlink" title="2.2.2 表操作 - 查询"></a>2.2.2 表操作 - 查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables; # 查询当前数据库的所有表</span><br><span class="line"></span><br><span class="line"><span class="keyword">desc</span> 表名; # 查询表结构</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名; # 查询指定表的建表语句</span><br></pre></td></tr></table></figure><hr><h3 id="2-2-3-表操作-创建表"><a href="#2-2-3-表操作-创建表" class="headerlink" title="2.2.3 表操作 - 创建表"></a>2.2.3 表操作 - 创建表</h3><p>语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 字段<span class="number">1</span>的类型 [comment <span class="string">&#x27;注释内容&#x27;</span>], #逗号</span><br><span class="line">...</span><br><span class="line">字段<span class="number">2</span> 字段<span class="number">2</span>的类型 [comment <span class="string">&#x27;注释内容&#x27;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>eg:创建一个如下表<br><img src="/img/c.1.png" alt="在这里插入图片描述"></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user(</span><br><span class="line">id <span class="type">int</span> comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">50</span>) comment <span class="string">&#x27;名字&#x27;</span>,</span><br><span class="line">age <span class="type">int</span> comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">gender <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">)comment <span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><blockquote><p>eg: 根据需求创建表<br>员工信息表,要求:</p><ol><li>编号(纯数字)</li><li>员工工号(字符串类型,长度不超过10位)</li><li>员工姓名(字符串类型,长度不超过10位)</li><li>性别</li><li>年龄</li><li>身份证号</li><li>入职时间(取值年月日即可)</li></ol></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">id <span class="type">int</span> comment<span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">worknum <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">gender <span class="type">char</span>(<span class="number">1</span>),</span><br><span class="line">age tinyint unsigned,</span><br><span class="line">idcard <span class="type">char</span>(<span class="number">18</span>),</span><br><span class="line">entrydate <span class="type">date</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h3 id="2-2-4-表操作-修改"><a href="#2-2-4-表操作-修改" class="headerlink" title="2.2.4 表操作 - 修改"></a>2.2.4 表操作 - 修改</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#添加字段</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 字段名 类型(长度) [comment 注释] [约束]; #添加字段</span><br><span class="line"></span><br><span class="line">#eg : 为emp表增加一个新的字段 &quot;昵称&quot; 为nickname,类型为<span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> nickname <span class="type">varchar</span>(<span class="number">20</span>) comment <span class="string">&#x27;昵称&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#修改字段</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 字段名 新数据类型(长度) # 修改数据类型</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束]; #修改字段名和字段类型</span><br><span class="line"></span><br><span class="line">#eg : 将emp表的nickname字段修改为username,类型为<span class="type">varchar</span>(<span class="number">30</span>)</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp change nickname username <span class="type">varchar</span>(<span class="number">30</span>) comment<span class="string">&#x27;昵称&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除字段</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 字段名;</span><br><span class="line"></span><br><span class="line">#eg : 将emp表的字段username删除</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">drop</span> username;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#修改表名</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 rename <span class="keyword">to</span> 新表名;</span><br><span class="line"></span><br><span class="line">#eg : 将emp表的表名修改为employee</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp rename <span class="keyword">to</span> employee;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除表</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> [if <span class="keyword">exists</span>] 表名;</span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名; ##删除指定表,并重新创建该表</span><br></pre></td></tr></table></figure><hr><h2 id="2-3-DML"><a href="#2-3-DML" class="headerlink" title="2.3 DML"></a>2.3 DML</h2><h3 id="2-3-1-添加数据"><a href="#2-3-1-添加数据" class="headerlink" title="2.3.1 添加数据"></a>2.3.1 添加数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(字段名<span class="number">1</span>,字段名<span class="number">2</span>,...) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...); #给指定字段添加数据</span><br><span class="line">#eg:</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(id,worknum,name,gender,age) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;9tse&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...); #给全部字段添加数据</span><br><span class="line">#eg:</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;sewerperson&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(字段名<span class="number">1</span>,字段名<span class="number">2</span>,...) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...),(值<span class="number">1</span>,值<span class="number">2</span>,...)...;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...),(值<span class="number">1</span>,值<span class="number">2</span>,...)...;</span><br><span class="line">#eg:</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;9tse&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">19</span>),(<span class="number">2</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;sewerperson&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>ps: </p><ol><li>插入数据时,指定的字段顺序需要与值的顺序对应</li><li>字符串和日期数据应该包含在引号中</li><li>插入数据大小,应在字段的规定范围内</li></ol><hr><h3 id="2-3-2-修改数据"><a href="#2-3-2-修改数据" class="headerlink" title="2.3.2 修改数据"></a>2.3.2 修改数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span>,字段名<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2</span>,... [<span class="keyword">where</span> 条件];</span><br><span class="line"></span><br><span class="line">#eg: 修改id为<span class="number">1</span>的数据,将name修改为<span class="number">9</span>tse</span><br><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;9tse&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"># 修改id为<span class="number">1</span>的数据,将name修改为 sewer,gender修改为 女</span><br><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;sewer&#x27;</span>,gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"># 将所有员工的入职日期修改为<span class="number">2008</span><span class="number">-01</span><span class="number">-01</span></span><br><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> entrydate <span class="operator">=</span> <span class="string">&#x27;2008-01-01&#x27;</span>;</span><br></pre></td></tr></table></figure><p>ps: </p><ul><li>修改语句的条件如果没有,默认修改整张表的所有数据</li></ul><hr><h3 id="2-3-3-删除数据"><a href="#2-3-3-删除数据" class="headerlink" title="2.3.3 删除数据"></a>2.3.3 删除数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件];</span><br><span class="line">#eg:删除gender为女的员工</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line"># 删除所有员工</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><p>ps:</p><ol><li>delete语句的条件如果没有,默认作用于整张表的所有数据</li><li>delete语句不能删除某一个字段的值(可以使用update)</li></ol><hr><h2 id="2-4-DQL"><a href="#2-4-DQL" class="headerlink" title="2.4 DQL"></a>2.4 DQL</h2><p>语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">字段列表</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">表名列表</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">条件列表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">分组字段列表</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">分组后条件判断</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">排序字段列表</span><br><span class="line">limit</span><br><span class="line">分页参数</span><br></pre></td></tr></table></figure><ul><li>基本查询</li><li>条件查询(where)</li><li>聚合函数(count,max,min,avg,sum)</li><li>分组查询(group by)</li><li>排序查询(order by)</li><li>分页查询(limit)</li></ul><h3 id="2-4-1-基本查询"><a href="#2-4-1-基本查询" class="headerlink" title="2.4.1 基本查询"></a>2.4.1 基本查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#查询多个字段</span><br><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span>,字段<span class="number">2</span>,字段<span class="number">3</span>,... <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名; #效率较低</span><br><span class="line"></span><br><span class="line">#设置别名</span><br><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span>[<span class="keyword">as</span>] 别名<span class="number">1</span>,字段<span class="number">2</span>[<span class="keyword">as</span>] 别名<span class="number">2</span> ... <span class="keyword">from</span> 表名;</span><br><span class="line"></span><br><span class="line">#去除重复记录</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 字段列表 <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#查询指定字段返回</span><br><span class="line"><span class="keyword">select</span> name,worknum,age <span class="keyword">from</span> emp; </span><br><span class="line"></span><br><span class="line">#查询所有字段返回</span><br><span class="line"><span class="keyword">select</span> id,worknum,name,gender,age;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp; #尽量不写<span class="operator">*</span>,影响效率</span><br><span class="line"></span><br><span class="line">#查询所有员工工作地址,起别名</span><br><span class="line"><span class="keyword">select</span> workaddress <span class="keyword">as</span> <span class="string">&#x27;工作地址&#x27;</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> workaddress <span class="string">&#x27;工作地址&#x27;</span> <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line">#查询工作员工的上班地址(不要重复)</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> workaddress <span class="string">&#x27;工作地址&#x27;</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><hr><h3 id="2-4-2-条件查询"><a href="#2-4-2-条件查询" class="headerlink" title="2.4.2 条件查询"></a>2.4.2 条件查询</h3><p>语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件列表;</span><br></pre></td></tr></table></figure><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !&#x3D;</td><td>不等于</td></tr><tr><td>between…and…</td><td>在某范围内(含最小,最大)</td></tr><tr><td>in(…)</td><td>在in之后的列表中的值,多选一</td></tr><tr><td>like 占位符</td><td>模糊匹配(_匹配单字符,%匹配任意个字符)</td></tr><tr><td>is null</td><td>是NULL</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND 或 &amp;&amp;</td><td>并且(多个条件同时成立)</td></tr><tr><td>OR 或 |\</td><td></td></tr><tr><td>NOT 或 !</td><td>非不是</td></tr></tbody></table><p>eg:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#查询年龄等于<span class="number">88</span>的员工</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">88</span>;</span><br><span class="line"></span><br><span class="line">#小于<span class="number">20</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">#查询没有身份证号的员工</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> idcard <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">#有身份证号的员工</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> idcard <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">#年龄在<span class="number">15</span>到<span class="number">20</span>(包含)的员工</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&gt;=</span> <span class="number">15</span> <span class="operator">&amp;&amp;</span> age <span class="operator">&lt;=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="keyword">between</span> <span class="number">15</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"># 性别女且小于<span class="number">25</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">and</span> age <span class="operator">&lt;</span> <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">18</span> <span class="number">20</span> <span class="number">40</span> 的</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">18</span> <span class="operator">||</span> age <span class="operator">=</span> <span class="number">20</span> <span class="operator">||</span> age <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="keyword">in</span>(<span class="number">18</span>,<span class="number">20</span>,<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">#名字是两个字的</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;__&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#身份证号最后一位为X的</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">from</span> emp <span class="keyword">where</span> idcard <span class="keyword">like</span> <span class="string">&#x27;%X&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-4-3-聚合函数"><a href="#2-4-3-聚合函数" class="headerlink" title="2.4.3 聚合函数"></a>2.4.3 聚合函数</h3><blockquote><p>介绍: 将一列数据作为一个整体,进行纵向计算</p></blockquote><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 聚合函数(字段列表) <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><p><strong>ps : null值不参与聚合函数的运算</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#统计员工数量</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(idcard) <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line">#统计平均年龄</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(age) <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line">#最大年龄</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(age) <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line">#最小</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(age) <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line">#西安地区员工年龄之和</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(age) <span class="keyword">from</span> emp <span class="keyword">where</span> workaddress <span class="operator">=</span> <span class="string">&#x27;西安&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-4-4-分组查询"><a href="#2-4-4-分组查询" class="headerlink" title="2.4.4 分组查询"></a>2.4.4 分组查询</h3><p>语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件] <span class="keyword">group</span> <span class="keyword">by</span> 分组字段名 [<span class="keyword">having</span> 分组后过滤条件];</span><br></pre></td></tr></table></figure><blockquote><p><code>where</code>和<code>having</code>的区别</p><ul><li>执行实际不同:<br>where是分组之前进行过滤,不满足where条件,不参与分组;<br>having是分组后对结果进行过滤</li><li>判断条件不同<br>where不能对聚合函数进行判断<br>having可以</li></ul><p>执行顺序 : where &gt; 聚合函数 &gt; having<br>分组后,查询的字段一般为聚合函数和分组字段,查询其他字段无意义</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#根据性别分组,统计男性员工和女性员工的数量</span><br><span class="line"><span class="keyword">select</span> gender,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"></span><br><span class="line">#根据性别分组,统计男女平均年龄</span><br><span class="line"><span class="keyword">select</span> gender,<span class="built_in">avg</span>(age) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"></span><br><span class="line">#查询年龄小于<span class="number">45</span>,根据工作地址分组,获取员工数量大于<span class="number">3</span>的工作地址</span><br><span class="line"><span class="keyword">select</span> workaddress,<span class="built_in">count</span>(<span class="operator">*</span>) address_count <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">45</span> <span class="keyword">group</span> <span class="keyword">by</span> workaddress <span class="keyword">having</span> address_count <span class="operator">&gt;=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-4-5-排序查询"><a href="#2-4-5-排序查询" class="headerlink" title="2.4.5 排序查询"></a>2.4.5 排序查询</h3><blockquote><p>语法</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span>, 字段<span class="number">2</span> 排序方式<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>排序方式:</p><ol><li>asc : 升序(默认值)</li><li>desc : 降序</li></ol><p><strong>ps: 如果是多字段排序,当第一个字段值相同时,才会根据第二个字段进行排序;</strong></p><blockquote><p>eg:</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#根据年龄升序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age;</span><br><span class="line"></span><br><span class="line">#入职时间降序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> entrydate <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line">#年龄升序,相同则入职时间降序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span> , entrydate <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-4-6-分页查询"><a href="#2-4-6-分页查询" class="headerlink" title="2.4.6 分页查询"></a>2.4.6 分页查询</h3><blockquote><p>语法</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 limit 起始索引,查询记录数;</span><br></pre></td></tr></table></figure><p>ps:</p><ol><li>起始索引从0开始,<code>起始索引 = (查询页码-1) * 每页显示记录数</code></li><li>分页查询时数据库方言,不同数据库由不同的实现,MySQL时limit</li><li>如果查询的是第一页数据,起始索引可以省略,直接简写为 limit 10</li></ol><blockquote><p>eg:</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#查询第一页员工数据,每页<span class="number">10</span>条</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp limit <span class="number">0</span>,<span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp limit <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#查询第二页,每页<span class="number">10</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp limit <span class="number">10</span>,<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#查询年龄为<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>岁的女性员工信息。</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> gender <span class="operator">=</span><span class="string">&#x27;女&#x27;</span> <span class="keyword">and</span> age <span class="keyword">in</span>(<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">#查询性别为 男 ，并且年龄在 <span class="number">20</span><span class="number">-40</span> 岁(含)以内的姓名为三个字的员工。</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span> <span class="keyword">and</span> ( age <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">40</span> ) <span class="keyword">and</span> name <span class="keyword">like</span> <span class="string">&#x27;___&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#统计员工表中，年龄小于<span class="number">60</span>岁的 ，男性员工和女性员工的人数。</span><br><span class="line"><span class="keyword">select</span> gender，<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">60</span> <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"></span><br><span class="line">#查询所有年龄小于等于<span class="number">35</span>岁员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按入职时间降序排序</span><br><span class="line"><span class="keyword">select</span> name , age <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&lt;=</span> <span class="number">35</span> <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span> , entrydate <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line">#查询男，<span class="number">20</span><span class="number">-40</span> 岁(含)以内的前<span class="number">5</span>个员工信息 按年龄升序，相同按入职时间升序排序。</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span> <span class="keyword">and</span> age <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">40</span> <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span> , entrydate <span class="keyword">asc</span> limit <span class="number">5</span> ;</span><br></pre></td></tr></table></figure><h3 id="2-4-7-执行顺序"><a href="#2-4-7-执行顺序" class="headerlink" title="2.4.7 执行顺序"></a>2.4.7 执行顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#查询年龄大于<span class="number">15</span>的员工的姓名、年龄，并根据年龄进行升序排序</span><br><span class="line">#通过设置别名和使用别名的方法进行验证</span><br><span class="line"><span class="keyword">select</span> e.name ename , e.age eage <span class="keyword">from</span> emp e <span class="keyword">where</span> e.age <span class="operator">&gt;</span> <span class="number">15</span> <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#编写顺序</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">字段列表</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">表名列表</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">条件列表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">分组字段列表</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">分组后条件判断</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">排序字段列表</span><br><span class="line">limit</span><br><span class="line">分页参数</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#执行顺序,selec跑到<span class="keyword">having</span>后</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">表名列表</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">条件列表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">分组字段列表</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">分组后条件判断</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">字段列表</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">排序字段列表</span><br><span class="line">limit</span><br><span class="line">分页参数</span><br></pre></td></tr></table></figure><hr><h2 id="2-5-DCL"><a href="#2-5-DCL" class="headerlink" title="2.5 DCL"></a>2.5 DCL</h2><h3 id="2-5-1-管理用户"><a href="#2-5-1-管理用户" class="headerlink" title="2.5.1 管理用户"></a>2.5.1 管理用户</h3><blockquote><p>语法</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#查询用户</span><br><span class="line">use mysql;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line">#创建用户</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#修改用户密码</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> identified <span class="keyword">with</span> mysal_native_password <span class="keyword">by</span> <span class="string">&#x27;新密码&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#删除用户</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span></span><br></pre></td></tr></table></figure><p>ps : </p><ul><li>主机名可以使用 % 通配<br> 使用这类SQL开发人员操作的比较少，主要是DBA (Database Administrator数据库管理员)</li></ul><blockquote><p>eg:</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#创建用户 <span class="number">9</span>tse ，只能够在当前主机Localhost访间，密码<span class="number">123456</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;9tse&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>:</span><br><span class="line"></span><br><span class="line">#创建用户 sewer ，可以在任意主机访问该数据库，密码<span class="number">123456</span> ;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;sewer&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#修改用户 <span class="number">9</span>tse 的访问密码为 <span class="number">1234</span> ;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;9tse&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;1234&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#删除<span class="number">9</span>tse<span class="variable">@localhost</span>用户</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span><span class="string">&#x27;9tse&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-5-2-权限控制"><a href="#2-5-2-权限控制" class="headerlink" title="2.5.2 权限控制"></a>2.5.2 权限控制</h3><p>常用权限如下</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td>CREATE</td><td>创建数据库&#x2F;表</td></tr></tbody></table><blockquote><p>语法</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查询权限</span><br><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#授予权限</span><br><span class="line"><span class="keyword">grant</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#撤销权限</span><br><span class="line"><span class="keyword">revoke</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">from</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure><p>ps:</p><ol><li>多个授权之间逗号隔开</li><li>授权时,数据库名和表名可以用通配符*表示所有;</li></ol><blockquote><p>eg:</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询权限</span></span><br><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;9tse&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授予权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> sewerperson.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;9tse&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 撤销权限</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">all</span> <span class="keyword">on</span> sewerperson.<span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;9tse&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h1><h2 id="3-1-字符串函数"><a href="#3-1-字符串函数" class="headerlink" title="3.1 字符串函数"></a>3.1 字符串函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>concat(s1, s2, … sn)</td><td>字符串拼接，将s1，s2，… sn拼接成一个字符串</td></tr><tr><td>lower(str)</td><td>将字符串str全部转为小写</td></tr><tr><td>upper(str)</td><td>将字符串str全部转为大写</td></tr><tr><td>lpad(str, n, pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>rpad(str, n, pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>trim(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>substring(str, start, len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><blockquote><p>字符串函数的基本使用</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- concat</span></span><br><span class="line"><span class="keyword">select</span> concat(<span class="string">&#x27;Hello&#x27;&#x27;MysQL&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Tower</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">lower</span>(<span class="string">&#x27;Hello&#x27;</span>):</span><br><span class="line"></span><br><span class="line"><span class="comment">-- upper</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">upper</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- lpad</span></span><br><span class="line"><span class="keyword">select</span> Lpad(<span class="string">&#x27;01&#x27;</span>，<span class="number">5</span>,<span class="string">&#x27;-&#x27;</span>); # <span class="comment">---01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- rpad</span></span><br><span class="line"><span class="keyword">select</span> rpad(<span class="string">&#x27;01&#x27;</span>，<span class="number">5</span>,<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- trim</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="string">&#x27; HelloMysQL&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- substring</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">substring</span>(<span class="string">&#x27;Hello MySL&#x27;</span>,<span class="number">1</span>,<span class="number">5</span>); # Hello</span><br></pre></td></tr></table></figure><blockquote><p>案例</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 业务需求变更，员工的工号统一5位数，不足5位数的全部在前面补0。比如: 1号员工的工号应该为00001.</span></span><br><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> workno <span class="operator">=</span> lpad(workno,<span class="number">5</span>,<span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="3-2-数值函数"><a href="#3-2-数值函数" class="headerlink" title="3.2 数值函数"></a>3.2 数值函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>ceil(x)</td><td>向上取整</td></tr><tr><td>floor(x)</td><td>向下取整</td></tr><tr><td>mod(x; y)</td><td>返回 x&#x2F;y 的模</td></tr><tr><td>rand()</td><td>返回 0~1 内的随机数</td></tr><tr><td>round(x; y)</td><td>求参数 x 的四舍五入的值，保留 y 位小数</td></tr></tbody></table><blockquote><p>数值函数的基本利用</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ceil</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">ceil</span>(<span class="number">1.1</span>):</span><br><span class="line"></span><br><span class="line"><span class="comment">-- floor</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">floor</span>(<span class="number">1.9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- mod</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">mod</span>(<span class="number">7</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- rand</span></span><br><span class="line"><span class="keyword">select</span> rand();</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> round</span><br><span class="line"><span class="keyword">select</span> round(<span class="number">2.344</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><blockquote><p>案例</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 案例：通过数据库的函数，生成一个六位数的随机验证码。select</span></span><br><span class="line">lpad(round(rand()<span class="operator">*</span><span class="number">1000000</span>, <span class="number">0</span>), <span class="number">6</span>, <span class="string">&#x27;0&#x27;</span>); </span><br></pre></td></tr></table></figure><hr><h2 id="3-3-日期函数"><a href="#3-3-日期函数" class="headerlink" title="3.3 日期函数"></a>3.3 日期函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>curdate()</td><td>返回当前日期</td></tr><tr><td>curtime()</td><td>返回当前时间</td></tr><tr><td>now()</td><td>返回当前日期和时间</td></tr><tr><td>year(date)</td><td>获取指定 date 的年份</td></tr><tr><td>month(date)</td><td>获取指定 date 的月份</td></tr><tr><td>day(date)</td><td>获取指定 date 的日期</td></tr><tr><td>date_add(date, interval expr type)</td><td>返回一个日期&#x2F;时间值加上一个时间间隔 expr 后的时间值</td></tr><tr><td>datediff(date1, date2)</td><td>返回起始时间 date1 和结束时间 date2 之间的天数</td></tr></tbody></table><blockquote><p>日期函数的基本使用</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- curtime()</span></span><br><span class="line"><span class="keyword">select</span> curtime();</span><br><span class="line"></span><br><span class="line"> <span class="comment">-- now()</span></span><br><span class="line"><span class="keyword">select</span> now();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- YEAR,MONTH,DAY </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">YEAR</span>(now());</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">MONTH</span>(now()); </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">DAY</span>(now()); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- date_add</span></span><br><span class="line"><span class="keyword">select</span> date_add(now(), <span class="type">interval</span> <span class="number">70</span> <span class="keyword">year</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- datediff</span></span><br><span class="line"><span class="keyword">select</span> datediff(<span class="string">&#x27;2021-10-01&#x27;</span>, <span class="string">&#x27;2021-12-01&#x27;</span>); </span><br></pre></td></tr></table></figure><blockquote><p>案例</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 案例：查询所有员工的入职天数，并根据入职天数倒序排序。</span></span><br><span class="line"><span class="keyword">select</span> name, datediff(curdate(), entrydate) <span class="keyword">as</span> <span class="string">&#x27;entrydays&#x27;</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> entrydays <span class="keyword">desc</span>; </span><br></pre></td></tr></table></figure><hr><h2 id="3-4-流程控制函数"><a href="#3-4-流程控制函数" class="headerlink" title="3.4 流程控制函数"></a>3.4 流程控制函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>if(value , t, f)</td><td>如果 value 为 true，则返回 t，否则返回 f</td></tr><tr><td>ifnull(value1, value2)</td><td>如果 value1 不为空，返回 value1，否则返回 value2</td></tr><tr><td>case when [val1] then [res1] … else [default] end</td><td>如果 val1 为 true，则返回 res1，… 否则返回 default 默认值</td></tr><tr><td>case [expr] when [val1] then [res1] … else [default] end</td><td>如果 expr 的值等于 val1，则返回 res1，… 否则返回 default 默认值</td></tr></tbody></table><blockquote><p>流程控制函数的基本使用</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--if</span></span><br><span class="line"><span class="keyword">select</span> if(<span class="literal">false</span>, <span class="string">&#x27;0k&#x27;</span>, <span class="string">&#x27;Error&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- ifnull</span></span><br><span class="line"><span class="keyword">select</span> ifnull(<span class="string">&#x27;0k&#x27;</span>,<span class="string">&#x27;Default&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> ifnull(<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;Default&#x27;</span>); </span><br><span class="line"><span class="keyword">select</span> ifnull(<span class="keyword">null</span>,<span class="string">&#x27;Default&#x27;</span>); </span><br></pre></td></tr></table></figure><blockquote><p>案例</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- case when then elserend</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 需求：查询emp表的员工姓名和工作地址（北京／上海————＞一线城市，其他————＞二线城市）</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">name,</span><br><span class="line">(<span class="keyword">case</span> workaddress <span class="keyword">when</span> ＇北京＇ <span class="keyword">then</span> ＇一线城市＇ <span class="keyword">when</span>＇上海＇ <span class="keyword">then</span> ＇一线城市＇ <span class="keyword">else</span> ＇二线城市＇<span class="keyword">end</span>)<span class="keyword">as</span>＇工作地址＇ </span><br><span class="line"><span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--案例: 统计班级各个学员的成绩，展示的规则如下:</span></span><br><span class="line"><span class="comment">--&gt;= 85,展示松秀</span></span><br><span class="line"><span class="comment">--&gt;= 60，展示及格</span></span><br><span class="line"><span class="comment">--否则，展示不及格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">id,</span><br><span class="line">name,</span><br><span class="line">(<span class="keyword">case</span> <span class="keyword">when</span> math <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> math <span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span>)<span class="string">&#x27;数学&#x27;</span>,</span><br><span class="line">(<span class="keyword">case</span> <span class="keyword">when</span> english <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> english <span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span>)<span class="string">&#x27;英语&#x27;</span>,</span><br><span class="line">(<span class="keyword">case</span> <span class="keyword">when</span> chinese <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> chinese <span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span>)<span class="string">&#x27;语文&#x27;</span>,</span><br><span class="line"><span class="keyword">from</span> score;</span><br></pre></td></tr></table></figure><hr><h1 id="4-约束"><a href="#4-约束" class="headerlink" title="4. 约束"></a>4. 约束</h1><h2 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h2><blockquote><p>概念 : 约束时作用于表中字段上的规则,用于限制存储在表中的数据<br>目的 : 保证数据库中数据的正确,有效性和完整性<br><code>注意</code> : 约束时作用于表中的字段上的,可以在创建表&#x2F;修改表的时候添加约束. </p></blockquote><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为 null</td><td>not null</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>unique</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>primary key</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>default</td></tr><tr><td>检查约束</td><td>检查约束 (8.0.16 版本之后) 保证字段值满足某一个条件</td><td>check</td></tr><tr><td>外键约束</td><td>用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td><td>foreign key</td></tr></tbody></table><hr><h2 id="4-2-案例"><a href="#4-2-案例" class="headerlink" title="4.2 案例"></a>4.2 案例</h2><p>建表要求:</p><table><thead><tr><th>字段名</th><th>字段含义</th><th>字段类型</th><th>约束条件</th><th>约束关键字</th></tr></thead><tbody><tr><td>id</td><td>ID唯一标识</td><td>int</td><td>主键，并且自动增长</td><td>primary key auto increment</td></tr><tr><td>name</td><td>姓名</td><td>varchar(10)</td><td>不为空，并且唯一</td><td>not null, unique</td></tr><tr><td>age</td><td>年龄</td><td>int</td><td>大于0，并且小于等于120</td><td>check (age &gt; 0 and age &lt;&#x3D; 120)</td></tr><tr><td>status</td><td>状态</td><td>char(1)</td><td>如果没有指定该值，默认为1</td><td>default ‘1’</td></tr><tr><td>gender</td><td>性别</td><td>char(1)</td><td>无</td><td></td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment comment <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span> comment <span class="string">&#x27;姓名&#x27;</span> ,</span><br><span class="line">age <span class="type">int</span> <span class="keyword">check</span> ( age <span class="operator">&gt;</span>  <span class="operator">&amp;&amp;</span> age <span class="operator">&lt;=</span> <span class="number">120</span> ) comment<span class="string">&#x27;年龄&#x27;</span></span><br><span class="line">status <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;1&#x27;</span> comment<span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">gender <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别&#x27;</span></span><br><span class="line">)comment<span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(name,age,status,gender) <span class="keyword">values</span> (<span class="string">&#x27;Tom1&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;男&#x27;</span>),(<span class="string">&#x27;Tom2&#x27;</span>,<span class="number">25</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(name,age,status,gender) <span class="keyword">values</span> (<span class="string">&#x27;Tom3&#x27;</span>,<span class="number">19</span>,<span class="number">1</span><span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(name,age,status,gender) <span class="keyword">values</span> (<span class="keyword">null</span>,<span class="number">19</span>,<span class="string">&#x27;1&#x27;</span>，<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(name,age,status,gender) <span class="keyword">values</span> (<span class="string">&#x27;Tom3&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;1&#x27;</span>，<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(name,age,status,gender) <span class="keyword">values</span> (<span class="string">&#x27;Tom4&#x27;</span>,<span class="number">80</span>,<span class="number">1</span><span class="string">&#x27;，男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(name,age,status,gender) <span class="keyword">values</span> (<span class="string">&#x27;Tom5&#x27;</span>,<span class="number">-1</span>,<span class="number">1</span><span class="string">&#x27;，男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(name,age,status,gender) <span class="keyword">values</span> (<span class="string">&#x27;Tom5&#x27;</span>,<span class="number">121</span>,<span class="string">&#x27;1&#x27;</span>，<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(name,age,gender) <span class="keyword">values</span> (<span class="string">&#x27;Tom5&#x27;</span>,<span class="number">120</span>，<span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>当不满足建表约束时就会报错 : 无法插入数据</code></p><hr><h2 id="4-3-外键约束"><a href="#4-3-外键约束" class="headerlink" title="4.3 外键约束"></a>4.3 外键约束</h2><blockquote><p>语法</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#添加外键</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">...</span><br><span class="line">[<span class="keyword">constraint</span>] [外键名称] <span class="keyword">foreign</span> key(外键字段名) <span class="keyword">references</span> 主表(主表列名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key(外键字段名) <span class="keyword">references</span> 主表(主表列名);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除外键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">foreign</span> key 外键名称;</span><br></pre></td></tr></table></figure><blockquote><p>案例</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> dept(id);</span><br><span class="line"><span class="comment">-- 删除外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">drop</span> <span class="keyword">foreign</span> key fk_emp_dept_id;</span><br></pre></td></tr></table></figure><p><code>实际中并不常用外键,会导致耦合度较高</code></p><blockquote><p>删除更新行为的函数</p></blockquote><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>no action</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。(与restrict一致)</td></tr><tr><td>restrict</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。(与no action 一致)</td></tr><tr><td>cascade</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除&#x2F;更新外键在子表中的记录。</td></tr><tr><td>set null</td><td>当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null (这就要求该外键允许取null)。</td></tr><tr><td>set default</td><td>父表有变更时，子表将外键列设置成一个默认的值(Innodb不支持)。</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key (外键字段) <span class="keyword">references</span> 主表名(主表字段名) <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> cascade;</span><br></pre></td></tr></table></figure><blockquote><p>案例</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 外键的删除和更新行为</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> dept(id) <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> cascade;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> dept(id) <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">set</span> <span class="keyword">null</span> <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">set</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="5-多表查询"><a href="#5-多表查询" class="headerlink" title="5. 多表查询"></a>5. 多表查询</h1><p><strong>先拿一段案例展示一下表之间的外键连接</strong></p><blockquote><p>多对多 中间以外键相连</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student_course(</span><br><span class="line">id <span class="type">int</span> auto increment comment <span class="string">&#x27;主键&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">studentid <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;学生ID&#x27;</span>,</span><br><span class="line">courseid  <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;课程ID&#x27;</span>,</span><br><span class="line"><span class="keyword">constraint</span> fk_courseid <span class="keyword">foreign</span> key (courseid) <span class="keyword">references</span> counse (id),</span><br><span class="line"><span class="keyword">constraint</span> fk_studentid <span class="keyword">foreign</span> key (studentid) <span class="keyword">references</span> student (id)</span><br><span class="line">)comment <span class="string">&#x27;学生课程中间表&#x27;</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_course <span class="keyword">values</span> (<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">2</span>),(<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">3</span>),(<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="keyword">null</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><blockquote><p>一对一 中间多创建一个表(tb_user_edu) 相连两个表</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user(</span><br><span class="line">id <span class="type">int</span> auto_increment <span class="keyword">primary</span> key comment comment <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">age <span class="type">int</span> comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">gender <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;1: 男 ，2: 女&#x27;</span>，</span><br><span class="line">phone <span class="type">char</span>(<span class="number">11</span>) comment <span class="string">&#x27;手机号&#x27;</span></span><br><span class="line">)comment <span class="string">&#x27;用户基本信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user_edu(</span><br><span class="line">id <span class="type">int</span> auto_increment <span class="keyword">primary</span> key comment <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">degree <span class="type">varchar</span>(<span class="number">20</span>) comment <span class="string">&#x27;学历&#x27;</span>,</span><br><span class="line">major <span class="type">varchar</span>(<span class="number">50</span>) comment <span class="string">&#x27;专业&#x27;</span>,</span><br><span class="line">primaryschool <span class="type">varchar</span>(<span class="number">50</span>) comment<span class="string">&#x27;小学&#x27;</span></span><br><span class="line">middleschool <span class="type">varchar</span>(<span class="number">50</span>) comment<span class="string">&#x27;中学&#x27;</span></span><br><span class="line">university <span class="type">varchar</span>(<span class="number">50</span>) comment<span class="string">&#x27;大学&#x27;</span>,</span><br><span class="line">userid <span class="type">int</span> <span class="keyword">unique</span> comment<span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line"><span class="keyword">constraint</span> fk_userid <span class="keyword">foreign</span> key (userid) <span class="keyword">references</span> tb_user(id)</span><br><span class="line">)comment<span class="string">&#x27;用户教育信息表&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>多表查询概述</strong></p><ul><li>概述：指从多张表中查询数据</li><li>笛卡尔积：笛卡尔乘积是指在数学中，两个集合A集合和B集合的所有组合情况。（在多表查询时，需要消除无效的笛卡尔积）</li></ul><blockquote><p><img src="/img/c.2.png" alt="在这里插入图片描述"></p></blockquote><p><code>可以通过where来消除笛卡尔积</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br></pre></td></tr></table></figure><p>多表查询可以分为</p><ul><li>连接查询<ul><li>内连接</li><li>外连接<ul><li>左外连接</li><li>右外连接</li></ul></li><li>自连接</li></ul></li><li>子查询</li></ul><p>具体含义在小章节会简述</p><hr><h2 id="5-1-连接查询"><a href="#5-1-连接查询" class="headerlink" title="5.1 连接查询"></a>5.1 连接查询</h2><h3 id="5-1-1-内连接"><a href="#5-1-1-内连接" class="headerlink" title="5.1.1 内连接"></a>5.1.1 内连接</h3><p> <code>内连接查询的是两张表交集的部分</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#内连接查询语法</span><br><span class="line"><span class="comment">-- 隐式内连接</span></span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span>,表<span class="number">2</span> <span class="keyword">where</span> 条件...；</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 显式内连接</span></span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> [<span class="keyword">inner</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 连接条件...；</span><br></pre></td></tr></table></figure><blockquote><p>eg:</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.查询每一个员工的姓名，及关联的部门的名称（隐式内连接实现）</span></span><br><span class="line"><span class="comment">-- 表结构：emp，dept</span></span><br><span class="line"><span class="comment">-- 连接条件：emp.dept_id=dept.id</span></span><br><span class="line"><span class="keyword">select</span> emp.name，dept.name <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br><span class="line"><span class="keyword">select</span> e.name,d.name <span class="keyword">from</span> emp e , dept d <span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.查询每一个员工的姓名，及关联的部门的名称（显式内连接实现）---- INNER JOIN..ON//</span></span><br><span class="line"><span class="comment">-- 表结构：emp，dept</span></span><br><span class="line"><span class="comment">-- 连接条件：emp.dept_id=dept.id</span></span><br><span class="line"><span class="keyword">select</span> e.name，d.name <span class="keyword">from</span> emp e <span class="keyword">inner</span> <span class="keyword">join</span> dept done.dept_id <span class="operator">=</span>d.id;</span><br><span class="line"><span class="keyword">select</span> e.name，d.name <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><hr><h3 id="5-1-2-外连接"><a href="#5-1-2-外连接" class="headerlink" title="5.1.2 外连接"></a>5.1.2 外连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#外连接查询语法</span><br><span class="line"><span class="comment">-- 左外连接</span></span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">left</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件...;</span><br><span class="line">#相当于查询表<span class="number">1</span>（左表）的所有数据包含表<span class="number">1</span>和表<span class="number">2</span>交集部分的数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 右外连接</span></span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">right</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件...;</span><br><span class="line">#相当于查询表<span class="number">2</span>（右表）的所有数据包含表<span class="number">1</span>和表<span class="number">2</span>交集部分的数据</span><br></pre></td></tr></table></figure><blockquote><p>eg</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1 查询emp表的所有数据，和对应的部门信息（左外连接</span></span><br><span class="line"><span class="comment">-- 表结构：emp，dept</span></span><br><span class="line"><span class="comment">-- 连接条件：emp.dept_id=dept.id</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>，d.name <span class="keyword">from</span> emp e <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id；</span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>，d.name <span class="keyword">from</span> emp e <span class="keyword">left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span>d.id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2 查询dept表的所有数据，和对应的员工信息（右外连接）</span></span><br><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span> , e. <span class="keyword">from</span> emp e <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id;</span><br><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span> , e. <span class="keyword">from</span> dept d <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> emp e <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><hr><h3 id="5-1-3-自连接"><a href="#5-1-3-自连接" class="headerlink" title="5.1.3 自连接"></a>5.1.3 自连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#自连接查询语法：</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A 别名A <span class="keyword">join</span> 表A 别名B <span class="keyword">on</span> 条件...;</span><br><span class="line">#自连接查询，可以是内连接查询，也可以是外连接查询</span><br></pre></td></tr></table></figure><blockquote><p>eg:</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.查询员工及其所属领导的名字</span></span><br><span class="line"><span class="comment">-- 表结构：emp</span></span><br><span class="line"><span class="keyword">select</span> a.name , b.name <span class="keyword">from</span> emp a , emp b <span class="keyword">where</span> a.managerid <span class="operator">=</span> b.id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2，查询所有员工emp及其领导的名字emp，如果员工没有领导，也需要查询出来</span></span><br><span class="line"><span class="comment">-- 表结构：emp a，emp b</span></span><br><span class="line"><span class="keyword">select</span> a.name  <span class="string">&#x27;员工&#x27;</span> , b.name <span class="string">&#x27;领导&#x27;</span> <span class="keyword">from</span> emp a <span class="keyword">left</span> <span class="keyword">join</span> emp b <span class="keyword">on</span> a.managerid <span class="operator">=</span> b.id；</span><br></pre></td></tr></table></figure><hr><h2 id="5-2-联合查询"><a href="#5-2-联合查询" class="headerlink" title="5.2 联合查询"></a>5.2 联合查询</h2><p><code>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表a ...</span><br><span class="line"><span class="keyword">union</span> [<span class="keyword">all</span>]</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表b ...;</span><br></pre></td></tr></table></figure><p>ps : </p><ul><li>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</li><li><strong>unionall会将全部的数据直接合并在一起， union会对合并之后的数据去重。</strong></li></ul><blockquote><p>eg : </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- union all , union</span></span><br><span class="line"><span class="comment">-- 1.将薪资低于50的员工，和年龄大于50岁的员工全部查询出来。</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">Where</span> salary<span class="operator">&lt;</span><span class="number">500</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age<span class="operator">&gt;</span><span class="number">50</span>;</span><br><span class="line"># 查询出的结果有可能出现重复的行</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary<span class="operator">&lt;</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">50</span>;</span><br><span class="line">#去掉 <span class="keyword">all</span> 就可以去重</span><br></pre></td></tr></table></figure><hr><h2 id="5-3-子查询"><a href="#5-3-子查询" class="headerlink" title="5.3 子查询"></a>5.3 子查询</h2><h3 id="5-3-1-标量子查询"><a href="#5-3-1-标量子查询" class="headerlink" title="5.3.1 标量子查询"></a>5.3.1 标量子查询</h3><blockquote><p>标量子查询<br>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为<code>标量子查询</code><br>常用的操作符：&#x3D;  ,&lt;&gt; ,  &gt; , &lt; , &gt;&#x3D;  , &lt;&#x3D; </p></blockquote><blockquote><p>eg : </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 标量子查询</span></span><br><span class="line"><span class="comment">-- 1. 查询“销售部”的所有员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询“销售部”部门ID</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name  <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b. 根据销售部部门ID， 查询员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 查询在“方东白”入职之后的员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询方东白的入职日期</span></span><br><span class="line"><span class="keyword">select</span> entrydate <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;方东白&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b.查询指定入职日期之后入职的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> entrydate <span class="operator">&gt;</span>（<span class="keyword">select</span> entrydate <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;方东白&#x27;</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="5-3-2-列子查询"><a href="#5-3-2-列子查询" class="headerlink" title="5.3.2 列子查询"></a>5.3.2 列子查询</h3><blockquote><p>子查询返回的结果是一列（可以是多行），这种子查询称为<code>列子查询</code><br>常用的操作符：IN、NOT IN、ANY、SOME、ALL</p></blockquote><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>in</td><td>在指定的集合范围之内，多选一</td></tr><tr><td>not in</td><td>不在指定的集合范围之内</td></tr><tr><td>any</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>some</td><td>与 any 等同，使用 some 的地方都可以使用 any</td></tr><tr><td>all</td><td>子查询返回列表的所有值都必须满足 in</td></tr></tbody></table><blockquote><p>eg : </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 列子查询</span></span><br><span class="line"><span class="comment">-- 1. 查询“销售部”和“市场部”的所有员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询“销售部”和“市场部”的部门ID</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>;</span><br><span class="line"><span class="comment">-- b. 根据部门ID，查询员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 查询比财务部所有工资都高的员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询所有财务部人员工资</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span>（<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>);</span><br><span class="line"><span class="comment">-- b.比财务部所有人工资都高的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">all</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 查询比研发部其中任意一人工资高的员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询研发部所有人工资</span></span><br><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> （<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>);</span><br><span class="line"><span class="comment">-- b. 比研发部其中任意一人工资高的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">Where</span> salary <span class="operator">&gt;</span> <span class="keyword">some</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="string">&#x27;研发部&#x27;</span>));</span><br></pre></td></tr></table></figure><hr><h3 id="5-3-3-行子查询"><a href="#5-3-3-行子查询" class="headerlink" title="5.3.3 行子查询"></a>5.3.3 行子查询</h3><blockquote><p>子查询返回的结果是一行（可以是多列），这种子查询称为<code>行子查询</code><br>常用的操作符：&#x3D; , &lt;&gt; , in , not in</p></blockquote><blockquote><p>eg : </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 查询与“张无”的薪资及直属领导相同的员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询“张无”的薪资及直属领导</span></span><br><span class="line"><span class="keyword">select</span> salary，managerid <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张无&#x27;</span></span><br><span class="line"><span class="comment">-- b. 查询与“张无”的薪资及直属领导相同的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (salary，managerid)<span class="operator">=</span>( <span class="keyword">select</span> salary， managerid <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张无&#x27;</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="5-3-4-表子查询"><a href="#5-3-4-表子查询" class="headerlink" title="5.3.4 表子查询"></a>5.3.4 表子查询</h3><blockquote><p>子查询返回的结果是多行多列，这种子查询称为<code>表子查询</code><br>常用的操作符：IN</p></blockquote><blockquote><p>eg : </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表子查询</span></span><br><span class="line"><span class="comment">-- 1. 查询与“鹿客”“宋远桥”的职位和薪资相同的员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询“鹿枝客”，“宋远桥”的职位和薪资</span></span><br><span class="line"><span class="keyword">select</span> job，salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;鹿客&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;宋远桥&#x27;</span>;</span><br><span class="line"><span class="comment">-- b. 查询与“鹿客”，“宋远桥”的职位和薪资相同的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (job,salary) <span class="keyword">in</span> (<span class="keyword">select</span> job，salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;鹿杖客&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;宋远桥&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 查询入职日期是“2086-01-01之后的员工信息，及其部门信息</span></span><br><span class="line"><span class="comment">-- a. 入职日期是“206-1-01”之后的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> entrydate <span class="operator">&gt;</span> <span class="string">&#x27;2006-01-01&#x27;</span>;</span><br><span class="line"><span class="comment">-- b. 查询这部分员工，对应的部门信息</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>,d.<span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">from</span> emp <span class="keyword">where</span> entrydate <span class="operator">&gt;</span> <span class="string">&#x27;2006-01-01&#x27;</span>）e <span class="keyword">left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id; </span><br></pre></td></tr></table></figure><hr><h2 id="5-4-多表查询案例"><a href="#5-4-多表查询案例" class="headerlink" title="5.4 多表查询案例"></a>5.4 多表查询案例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 查询员工的姓名、年龄、职位、部门信息 （隐式内连接）</span></span><br><span class="line"><span class="comment">-- 表：emp，dept</span></span><br><span class="line"><span class="comment">-- 连接条件：emp.dept_id = dept.id</span></span><br><span class="line"><span class="keyword">select</span> e.name , e.age , e.job , d.name <span class="keyword">from</span> emp e , dept d <span class="keyword">where</span> e.dept_id<span class="operator">=</span>d.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 查询年龄小于3岁的员工的姓名、年龄、职位、部门信息（显式内连接）</span></span><br><span class="line"><span class="comment">-- 表：emp，dept</span></span><br><span class="line"><span class="comment">-- 连接条件：emp.dept_id=dept.id</span></span><br><span class="line"><span class="keyword">select</span> e.name , e.age , e.job , d.name <span class="keyword">from</span> emp e <span class="keyword">inner</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id <span class="keyword">where</span> e.age <span class="operator">&lt;</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.查询拥有员工的部门ID、部门名称</span></span><br><span class="line"><span class="comment">-- 表：emp，dept</span></span><br><span class="line"><span class="comment">-- 连接条件：emp.dept_id=dept.i</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> d.id , d.name <span class="keyword">from</span> emp e , dept d <span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 查询所有年龄大于4岁的员工，及其归属的部门名称；如果员工没有分配部门，也需要展示出来</span></span><br><span class="line"><span class="comment">-- 表：emp，dept</span></span><br><span class="line"><span class="comment">-- 连接条件：emp.dept_id=dept.id</span></span><br><span class="line"><span class="comment">-- 外连接</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span> , d.name <span class="keyword">from</span> emp e <span class="keyword">Left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id <span class="keyword">where</span> e.age <span class="operator">&gt;</span> <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5. 查询所有员工的工资等级</span></span><br><span class="line"><span class="comment">-- 表：emp，sagrade</span></span><br><span class="line"><span class="comment">-- 连接条件：emp.salary&gt;= salgrade.losal and demp.salary &lt;= sagrade.hisal</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span> , s.grade , s.losal , s.hisal <span class="keyword">from</span> emp e , salgrade s <span class="keyword">where</span> e.salary <span class="operator">&gt;=</span> s.losa <span class="keyword">and</span> e.salary <span class="operator">&lt;=</span> s.hisal;</span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span> , s.grade , s.losal , s.hisal <span class="keyword">from</span> emp e , salgrade s <span class="keyword">where</span> e.salary <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 6. 查询“研发部”所有员工的信息及工资等级</span></span><br><span class="line"><span class="comment">-- 表：emp，salgrade，dept</span></span><br><span class="line"><span class="comment">-- 连接条件：emp.salary between salgrade.losal and salgrade.hisal , emp.dept_id = dept.id</span></span><br><span class="line"><span class="comment">-- 查询条件：dept.name= &#x27;研发部&#x27;</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span> ,  s.grade <span class="keyword">from</span> emp e , dept d , salgrade s <span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id <span class="keyword">and</span> (e.salary <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal)  <span class="keyword">and</span> d.name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7. 查询“研发部”员工的平均工资</span></span><br><span class="line"><span class="comment">-- 表：emp，dept</span></span><br><span class="line"><span class="comment">-- 连接条件： emp.dept_id = dept.id</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(e.salary) <span class="keyword">from</span> emp e , dept d <span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id <span class="keyword">and</span> d.name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 8. 查询工资比“灭绝”高的员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询“灭绝”的薪资</span></span><br><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;灭绝&#x27;</span>;</span><br><span class="line"><span class="comment">-- b. 查询比她工资高的员工数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;灭绝&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 9. 查询比平均薪资高的员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询员工的平均薪资</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(salary) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- b. 查询比平均薪资高的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(salary) <span class="keyword">from</span> emp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 10. 查询低于本部门平均工资的员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询指定部门平均薪资</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(e1.salary) <span class="keyword">from</span> emp e1 <span class="keyword">Where</span> e1.dept_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(e1.salary) <span class="keyword">from</span> emp e1 <span class="keyword">where</span> e1.dept_id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">-- b. 查询低于本部门平均工资的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp e2 <span class="keyword">where</span> e2.salary <span class="operator">&lt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(e1.salary) <span class="keyword">from</span> emp e1 <span class="keyword">where</span> e1.dept_id <span class="operator">=</span> e2.dept_id );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 11. 查询所有的部门信息，并统计部门的员工人数</span></span><br><span class="line"><span class="keyword">select</span> d.id , d.name , (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp e <span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id) <span class="string">&#x27;人数&#x27;</span> <span class="keyword">from</span> dept d;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 12. 查询所有学生的选课情况，展示出学生名称，学号，课程名称</span></span><br><span class="line"><span class="comment">-- 表 : student , course , student_course</span></span><br><span class="line"><span class="comment">-- 连接条件：student.id = student_course.studentid , course.id = student_course.courseid</span></span><br><span class="line"><span class="keyword">select</span> s.name , s.no , c.name <span class="keyword">from</span> student s , student_course sc , course c <span class="keyword">where</span> s.id <span class="operator">=</span> sc.studentid <span class="keyword">and</span> sc.courseid <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure><hr><h1 id="6-事务"><a href="#6-事务" class="headerlink" title="6. 事务"></a>6. 事务</h1><p>事务的四大特性(ACID)</p><ul><li>原子性(<code>A</code>tomicity) : 事务是不可分割的最小操作单元,要么全部成功,要么全部失败.</li><li>一致性(<code>C</code>onsistency) : 事务完成时,必须使所有的数据都保持一致状态.</li><li>隔离性(<code>I</code>solation) : 数据库系统提供的隔离机制,保证事务在不受外部并发操作影响的独立环境下运行.</li><li>持久性(<code>D</code>urability) : 事务一旦提交或回滚,他对数据库中的数据的改变就是永久的.</li></ul><h2 id="6-1-事务的基本操作"><a href="#6-1-事务的基本操作" class="headerlink" title="6.1 事务的基本操作"></a>6.1 事务的基本操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#查看<span class="operator">/</span>设置事务提交方式</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@autoccommit</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">--0是自动提交,1是手动提交,即使用commit</span></span><br><span class="line"></span><br><span class="line">#提交事务</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line">#回滚事务</span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><blockquote><p>eg : 方式一</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>； <span class="comment">--设置为手动提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 转账操作（张三给李四转账1088）</span></span><br><span class="line"><span class="comment">-- 1.查询张三账户余额</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.将张三账户余额-1080</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line">程执行报错... #手动报错</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.将李四账户余额+1000</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money<span class="operator">+</span><span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--提交事务</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--回滚事务</span></span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><blockquote><p>eg : 方式二</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#开启事务</span><br><span class="line"><span class="keyword">start</span> transaction 或 <span class="keyword">begin</span>;</span><br><span class="line"></span><br><span class="line">#提交事务</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line">#回滚事务</span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><p><code>已经设置为自动提交</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方式二</span></span><br><span class="line"><span class="comment">-- 转账操作（张三给李四转账1000</span></span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1. 查询张三账户余额</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 将张三账户余额-18</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line">手动执行报错...</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.将季四账户余额+1000</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--回滚事务</span></span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="6-2-并发事务问题"><a href="#6-2-并发事务问题" class="headerlink" title="6.2 并发事务问题"></a>6.2 并发事务问题</h2><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另外一个事务还没有提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 “幻影”。</td></tr></tbody></table><ul><li>脏读<br>B事务读取到了A事务还没有提交的数据<blockquote><p><img src="/img/c.3.png" alt="在这里插入图片描述"></p></blockquote></li><li>不可重复读<br>事务A用同样的方法读到了不一样的数据<blockquote><p><img src="/img/c.4.png" alt="在这里插入图片描述"></p></blockquote></li><li>幻读<br>事务A插入不进去,也读不出来,可以理解为,脏写,hhh<blockquote><p><img src="/img/c.5.png" alt="在这里插入图片描述"></p></blockquote></li></ul><hr><h2 id="6-3-事务的隔离级别"><a href="#6-3-事务的隔离级别" class="headerlink" title="6.3 事务的隔离级别"></a>6.3 事务的隔离级别</h2><table><thead><tr><th>隔离级别</th><th>读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>read uncommitted</td><td>false</td><td>false</td><td>false</td></tr><tr><td>read committed  (oracle 的默认)</td><td>true</td><td>false</td><td>false</td></tr><tr><td>repeatable read (默认)</td><td>true</td><td>true</td><td>false</td></tr><tr><td>serializable</td><td>true</td><td>true</td><td>true</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查看事务隔离级别</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@transaction_isolation</span>;</span><br><span class="line"></span><br><span class="line">#是指事务隔离级别</span><br><span class="line"><span class="keyword">set</span> [session<span class="operator">|</span><span class="keyword">global</span>] transaction isolation level [read uncommitted <span class="operator">|</span> read committed <span class="operator">|</span> repeatable read <span class="operator">|</span> serializable ];</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看事务隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@atransaction_isoation</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别</span></span><br><span class="line"><span class="keyword">set</span> session transaction isolation level read uncommitted ;</span><br><span class="line"><span class="keyword">set</span> session transaction isolation Level repeatable read ;</span><br></pre></td></tr></table></figure><p>需要注意的是 : <code>事务隔离级别越高,数据越安全,但是性能会越低</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-MySQL基本使用&quot;&gt;&lt;a href=&quot;#1-MySQL基本使用&quot; class=&quot;headerlink&quot; title=&quot;1. MySQL基本使用&quot;&gt;&lt;/a&gt;1. MySQL基本使用&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;1-1-MySQL的启动和登录&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>基本数据结构篇</title>
    <link href="http://example.com/2023/10/22/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/"/>
    <id>http://example.com/2023/10/22/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/</id>
    <published>2023-10-22T01:55:06.000Z</published>
    <updated>2023-10-23T04:00:38.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数组篇"><a href="#1-数组篇" class="headerlink" title="1.数组篇"></a>1.数组篇</h1><hr><h2 id="1-1-704-二分查找"><a href="#1-1-704-二分查找" class="headerlink" title="1.1 704-二分查找"></a>1.1 704-二分查找</h2><p><a href="https://leetcode.cn/problems/binary-search/description/">704</a></p><p><img src="/img/b.41.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> begin =<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt;= end)  <span class="comment">// -1,0,3,5,9,12</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid = begin+(end - begin)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                begin = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                end = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> mid;          </span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-2-27-移除数组"><a href="#1-2-27-移除数组" class="headerlink" title="1.2 27-移除数组"></a>1.2 27-移除数组</h2><p><a href="https://leetcode.cn/problems/remove-element/description/">27</a></p><p><img src="/img/b.42.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>,slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast != nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                fast++;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-3-977-有序数组的平方"><a href="#1-3-977-有序数组的平方" class="headerlink" title="1.3 977-有序数组的平方"></a>1.3 977-有序数组的平方</h2><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977</a></p><p><img src="/img/b.43.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> flag = right;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(right+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> leftq = nums[left]*nums[left] ;</span><br><span class="line">            <span class="type">int</span> rightq = nums[right]*nums[right];</span><br><span class="line">            <span class="keyword">if</span>(rightq &gt;= leftq)</span><br><span class="line">            &#123;</span><br><span class="line">                v[flag--] = rightq;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                v[flag--] = leftq;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-4-209–长度最小的子数组-滑动窗口"><a href="#1-4-209–长度最小的子数组-滑动窗口" class="headerlink" title="1.4* 209–长度最小的子数组(滑动窗口)"></a>1.4* 209–长度最小的子数组(滑动窗口)</h2><p><a href="https://gitee.com/link?target=https://leetcode.cn/problems/minimum-size-subarray-sum/">209</a><br><img src="/img/b.44.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>,sum = <span class="number">0</span>,min = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=nums[right]; <span class="comment">//统计左右指针之间的数据和</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target) <span class="comment">//当期间数据大于等于target时进入,左指针向右移动</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> newmin = right - left + <span class="number">1</span>;</span><br><span class="line">                min = newmin &lt; min ? newmin : min; <span class="comment">//期间数据个数</span></span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min==INT_MAX ? <span class="number">0</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度为 O(N)</p></blockquote><hr><h2 id="1-5-59-螺旋矩阵II"><a href="#1-5-59-螺旋矩阵II" class="headerlink" title="1.5* 59-螺旋矩阵II"></a>1.5* 59-螺旋矩阵II</h2><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59</a></p><p><img src="/img/b.45.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vv</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>; <span class="comment">//计数</span></span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>; <span class="comment">//活跃数字(填数坐标)</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//k依附坐标</span></span><br><span class="line">        <span class="type">int</span> j = n - <span class="number">1</span>; <span class="comment">//k依附坐标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) <span class="comment">//当为奇数时会k == i == j,循环进入却没有填入操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = i;</span><br><span class="line">            <span class="keyword">while</span>(k &lt; j)</span><br><span class="line">                vv[i][k++] = ++num;</span><br><span class="line">            </span><br><span class="line">            k = i;</span><br><span class="line">            <span class="keyword">while</span>(k &lt; j)</span><br><span class="line">                vv[k++][j] = ++num;</span><br><span class="line"></span><br><span class="line">            k = j;</span><br><span class="line">            <span class="keyword">while</span>(k &gt; i)</span><br><span class="line">                vv[j][k--] = ++num;</span><br><span class="line"></span><br><span class="line">            k = j;</span><br><span class="line">            <span class="keyword">while</span>(k &gt; i)</span><br><span class="line">                vv[k--][i] = ++num;</span><br><span class="line"></span><br><span class="line">            ++i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>)</span><br><span class="line">            vv[(n<span class="number">-1</span>)/<span class="number">2</span>][(n<span class="number">-1</span>)/<span class="number">2</span>] = ++num;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="2-链表篇"><a href="#2-链表篇" class="headerlink" title="2. 链表篇"></a>2. 链表篇</h1><h2 id="2-1-203-移除链表元素"><a href="#2-1-203-移除链表元素" class="headerlink" title="2.1 203-移除链表元素"></a>2.1 203-移除链表元素</h2><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203</a></p><p><img src="/img/b.46.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recursion</span><span class="params">(ListNode* prev,ListNode* cur,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">Recursion</span>(cur,cur-&gt;next,val);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val == val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp = cur;</span><br><span class="line">            prev-&gt;next = cur-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span> &amp;&amp; head-&gt;val == val)</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">nullptr</span> &amp;&amp; head-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="built_in">Recursion</span>(head,head-&gt;next,val);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-2-707-设计链表"><a href="#2-2-707-设计链表" class="headerlink" title="2.2 707-设计链表"></a>2.2 707-设计链表</h2><p><a href="https://leetcode.cn/problems/design-linked-list/description/">707</a></p><p><img src="/img/b.47.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> val)</span><br><span class="line">            :<span class="built_in">val</span>(val)</span><br><span class="line">            ,<span class="built_in">next</span>(<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size &lt;= index) <span class="comment">//判断是否可以进行循环</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">addAtIndex</span>(<span class="number">0</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">addAtIndex</span>(size,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size &lt; index) <span class="comment">//判断是否可以进行循环</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ListNode* newnode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">            cur = cur-&gt;next; <span class="comment">//cur 在index前</span></span><br><span class="line">        newnode-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = newnode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size &lt;= index)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        ListNode* del = cur-&gt;next;</span><br><span class="line">        ListNode* delnext = del-&gt;next;</span><br><span class="line">        cur-&gt;next = delnext;</span><br><span class="line">        <span class="keyword">delete</span> del;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListNode* head; <span class="comment">//头节点</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-3-206-反转链表"><a href="#2-3-206-反转链表" class="headerlink" title="2.3 206-反转链表"></a>2.3 206-反转链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/description/">206</a></p><p><img src="/img/b.48.png" alt="在这里插入图片描述"><br><img src="/img/b.49.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recursion</span><span class="params">(ListNode*&amp;head,ListNode* prev,ListNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cur-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            head = cur;</span><br><span class="line">            head-&gt;next = prev;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Recursion</span>(head,cur,cur-&gt;next);</span><br><span class="line">        cur-&gt;next = prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="built_in">Recursion</span>(head,<span class="literal">nullptr</span>,head);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-4-24-两两交换链表中的节点-跳针"><a href="#2-4-24-两两交换链表中的节点-跳针" class="headerlink" title="2.4* 24-两两交换链表中的节点(跳针)"></a>2.4* 24-两两交换链表中的节点(跳针)</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24</a></p><p><img src="/img/b.50.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recursion</span><span class="params">(ListNode*&amp; head,ListNode* prev,ListNode* cur,ListNode* next)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span> || cur-&gt;next == <span class="literal">nullptr</span>) <span class="comment">//当到头时,也就是cur在倒数第二个</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">Recursion</span>(head,cur-&gt;next,cur-&gt;next-&gt;next,next); <span class="comment">//next一直停留,为第一组第二个</span></span><br><span class="line">        next = cur-&gt;next; <span class="comment">//next置为未交换前的后一组的第二个,隔指</span></span><br><span class="line">        <span class="keyword">if</span>(prev == <span class="literal">nullptr</span>) <span class="comment">//执行初始最后一次递归</span></span><br><span class="line">            head = next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev-&gt;next = next;</span><br><span class="line">            </span><br><span class="line">        cur-&gt;next = next-&gt;next;</span><br><span class="line">        next-&gt;next = cur;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="comment">//如果只有&lt;两个直接return</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="built_in">Recursion</span>(head,<span class="literal">nullptr</span>,head,head-&gt;next); <span class="comment">//prev当作空</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-5-19-删除链表的倒数第N个节点-快慢指针"><a href="#2-5-19-删除链表的倒数第N个节点-快慢指针" class="headerlink" title="2.5* 19-删除链表的倒数第N个节点(快慢指针)"></a>2.5* 19-删除链表的倒数第N个节点(快慢指针)</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19</a></p><p><img src="/img/b.51.png" alt="在这里插入图片描述"><br><img src="/img/b.52.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//void Reucursion(ListNode* prev,ListNode* cur)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    </span></span><br><span class="line">    <span class="comment">//&#125; 1 2 3 4 5 6 7 8</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(n--) </span><br><span class="line">            fast = fast-&gt;next; <span class="comment">//fast先走,然后再走</span></span><br><span class="line">        <span class="keyword">if</span>(!fast) <span class="comment">//fast如果走到头了,倒过来就说明等同于头删</span></span><br><span class="line">        &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> slow;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next) <span class="comment">//fast第二次行动,直到走到尾</span></span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时slow位置就是要删除节点的上一位</span></span><br><span class="line">        <span class="comment">//开始删除</span></span><br><span class="line">        ListNode* tmp = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-6-链表相交"><a href="#2-6-链表相交" class="headerlink" title="2.6* 链表相交"></a>2.6* 链表相交</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">链表相交</a></p><p><img src="/img/b.53.png" alt="在这里插入图片描述"><br><img src="/img/b.54.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!headA || !headB)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pa = headA,* pb = headB;</span><br><span class="line">        <span class="keyword">while</span>(pa!=pb)</span><br><span class="line">        &#123;</span><br><span class="line">            pa = pa==<span class="literal">nullptr</span>? headB : pa-&gt;next;</span><br><span class="line">            pb = pb==<span class="literal">nullptr</span>? headA : pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-7-142-环形链表II"><a href="#2-7-142-环形链表II" class="headerlink" title="2.7 142-环形链表II"></a>2.7 142-环形链表II</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142</a></p><p><img src="/img/b.55.png" alt="在这里插入图片描述"><br><img src="/img/b.56.png" alt="在这里插入图片描述"></p><p><strong>方法一:哈希表</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; circle;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(circle.<span class="built_in">count</span>(head))</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            circle.<span class="built_in">insert</span>(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(N)，其中 N 为链表中节点的数目。我们恰好需要访问链表中的每一个节点。<br>空间复杂度：O(N)，其中 N 为链表中节点的数目。我们需要将链表中的每个节点都保存在哈希表当中。</p></blockquote><p><strong>方法二:快慢指针</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast) </span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!fast-&gt;next)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* cmcross = head;</span><br><span class="line">                <span class="keyword">while</span>(cmcross != slow)</span><br><span class="line">                &#123;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    cmcross = cmcross-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> cmcross;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(N)<br>空间复杂度：O(1)</p></blockquote><blockquote><p>fast走两步,slow走一步,相遇后:头节点和slow一起向前走,相遇即为循环节点</p></blockquote><hr><h1 id="3-哈希篇"><a href="#3-哈希篇" class="headerlink" title="3. 哈希篇"></a>3. 哈希篇</h1><h2 id="3-1-242-有效的字母异位词"><a href="#3-1-242-有效的字母异位词" class="headerlink" title="3.1 242-有效的字母异位词"></a>3.1 242-有效的字母异位词</h2><p><a href="https://leetcode.cn/problems/valid-anagram/submissions/437204993/">242</a></p><p><img src="/img/b.57.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : s)</span><br><span class="line">            record[e-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : t)</span><br><span class="line">            record[e-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : record)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(e &gt; <span class="number">0</span> || e &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n)，其中 n 为 s的长度。<br>空间复杂度：O(S)，其中 S 为字符集大小，此处 S&#x3D;26</p></blockquote><hr><h2 id="3-2-1002-查找共用字符"><a href="#3-2-1002-查找共用字符" class="headerlink" title="3.2* 1002-查找共用字符"></a>3.2* 1002-查找共用字符</h2><p><a href="https://leetcode.cn/problems/find-common-characters/">1002</a></p><p><img src="/img/b.58.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">commonChars</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> size = words.<span class="built_in">size</span>(); <span class="comment">// 判断几个字符串</span></span><br><span class="line">        vector&lt;string&gt; vs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e : words[<span class="number">0</span>])</span><br><span class="line">            record[e - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; ++i) <span class="comment">// 修改为从1遍历到size-1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 用临时数组存储当前单词中字符的出现次数</span></span><br><span class="line">            <span class="type">int</span> temp[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> e : words[i])</span><br><span class="line">                temp[e - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 更新record数组，保留每个字符在所有单词中的最小出现次数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)</span><br><span class="line">                record[j] = <span class="built_in">min</span>(record[j], temp[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (record[i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将字符插入到vs中，出现次数由record[i]控制</span></span><br><span class="line">                vs.<span class="built_in">push_back</span>(<span class="built_in">string</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span> + i));</span><br><span class="line">                record[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-3-349-两个数组的交集"><a href="#3-3-349-两个数组的交集" class="headerlink" title="3.3 349-两个数组的交集"></a>3.3 349-两个数组的交集</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349</a></p><p><img src="/img/b.59.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">start</span><span class="params">(nums1.begin(),nums1.end())</span></span>;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result; <span class="comment">//去重</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(start.<span class="built_in">find</span>(num) != start.<span class="built_in">end</span>())</span><br><span class="line">                result.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>当数组数据确认量少时</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set; <span class="comment">// 存放结果，之所以用set是为了给结果集去重</span></span><br><span class="line">        <span class="type">int</span> hash[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 默认数值为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums1) <span class="comment">// nums1中出现的字母在hash数组中做记录</span></span><br><span class="line">            hash[num] = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2)  <span class="comment">// nums2中出现话，result记录</span></span><br><span class="line">            <span class="keyword">if</span> (hash[num] == <span class="number">1</span>) </span><br><span class="line">                result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-4-202-快乐数"><a href="#3-4-202-快乐数" class="headerlink" title="3.4 202-快乐数"></a>3.4 202-快乐数</h2><p><a href="https://leetcode.cn/problems/happy-number/description/">202</a></p><p><img src="/img/b.60.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += (num % <span class="number">10</span>) * (num % <span class="number">10</span>);</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; us;</span><br><span class="line">        <span class="type">int</span> tmp = n; <span class="comment">// 使用tmp保存当前的数值</span></span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="number">1</span> &amp;&amp; us.<span class="built_in">find</span>(tmp) == us.<span class="built_in">end</span>()) <span class="comment">// 当tmp变为1或出现循环时停止</span></span><br><span class="line">        &#123;</span><br><span class="line">            us.<span class="built_in">insert</span>(tmp);</span><br><span class="line">            tmp = <span class="built_in">get</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp == <span class="number">1</span>; <span class="comment">// 如果tmp最终等于1，说明是快乐数，返回true，否则返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-5-1-两数之和"><a href="#3-5-1-两数之和" class="headerlink" title="3.5 1-两数之和"></a>3.5 1-两数之和</h2><p><a href="https://leetcode.cn/problems/two-sum/description/">1</a><br><img src="/img/b.61.png" alt="在这里插入图片描述"><br><img src="/img/b.62.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; um; <span class="comment">//key为值,value为坐标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = um.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it != um.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> &#123;i,it-&gt;second&#125;;</span><br><span class="line"></span><br><span class="line">            um.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(nums[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>T:O(N)  S:O(N)</p></blockquote><hr><h2 id="3-6-454-四数相加II"><a href="#3-6-454-四数相加II" class="headerlink" title="3.6* 454-四数相加II"></a>3.6* 454-四数相加II</h2><p><a href="https://leetcode.cn/problems/4sum-ii/description/">454</a></p><p><img src="/img/b.63.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; um; <span class="comment">//key为值,value为出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num1 : nums1)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> num2 : nums2)</span><br><span class="line">                um[num1+num2]++;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num3 : nums3)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> num4 : nums4)</span><br><span class="line">                <span class="keyword">if</span>(um.<span class="built_in">find</span>(<span class="number">0</span>-(num3+num4)) != um.<span class="built_in">end</span>())</span><br><span class="line">                    count+=um[(<span class="number">0</span>-(num3+num4))];</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-7-383-赎金信"><a href="#3-7-383-赎金信" class="headerlink" title="3.7 383-赎金信"></a>3.7 383-赎金信</h2><p><a href="https://leetcode.cn/problems/ransom-note/">383</a></p><p><img src="/img/b.64.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> e : magazine)</span><br><span class="line">            hash[e - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> e : ransomNote)</span><br><span class="line">            <span class="keyword">if</span>(--hash[e-<span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="4-双指针篇"><a href="#4-双指针篇" class="headerlink" title="4. 双指针篇"></a>4. 双指针篇</h1><h2 id="4-1-15-三数之和-双指针"><a href="#4-1-15-三数之和-双指针" class="headerlink" title="4.1 15-三数之和(双指针)"></a>4.1 15-三数之和(双指针)</h2><p><a href="https://leetcode.cn/problems/3sum/description/">15</a></p><p><img src="/img/b.65.png" alt="在这里插入图片描述"></p><blockquote><p>哈希其实过于复杂,实现起来不如双指针</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vv;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">2</span>; ++i) <span class="comment">//i为固定的数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//为避免重复答案,对固定数据进行判断</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> left = i+<span class="number">1</span>; <span class="comment">//中间数据</span></span><br><span class="line">            <span class="type">int</span> right = size<span class="number">-1</span>; <span class="comment">//末尾数据</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)</span><br><span class="line">                    right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    vv.<span class="built_in">push_back</span>(&#123;nums[i] , nums[left] , nums[right]&#125;);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//为了避免重复答案,要对下一组数据进行判断</span></span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>])</span><br><span class="line">                        left++;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right] == nums[right<span class="number">-1</span>])</span><br><span class="line">                        right--;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="4-2-18-四数之和"><a href="#4-2-18-四数之和" class="headerlink" title="4.2 18-四数之和"></a>4.2 18-四数之和</h2><p><a href="https://leetcode.cn/problems/4sum/solutions/436368/si-shu-zhi-he-by-leetcode-solution/">18</a></p><p><img src="/img/b.66.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;size;++i) <span class="comment">//固定第一个</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i<span class="number">-1</span>] == nums[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j&lt;size;++j) <span class="comment">//固定第二个</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j<span class="number">-1</span>] == nums[j]) <span class="comment">//j&gt;i+1,防止 2 2 2 2 情况</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> left = j+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right = size<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> sum =(<span class="type">long</span> <span class="type">long</span>)nums[i]+nums[j]+nums[left]+nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum &lt; target)</span><br><span class="line">                        left++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)</span><br><span class="line">                        right--;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(&#123;nums[i],nums[j],nums[left],nums[right]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>])</span><br><span class="line">                            left++;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right] == nums[right<span class="number">-1</span>])</span><br><span class="line">                            right--;</span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="5-字符串篇"><a href="#5-字符串篇" class="headerlink" title="5. 字符串篇"></a>5. 字符串篇</h1><h2 id="5-1-344-反转字符串"><a href="#5-1-344-反转字符串" class="headerlink" title="5.1 344-反转字符串"></a>5.1 344-反转字符串</h2><p><a href="https://leetcode.cn/problems/reverse-string/description/">344</a></p><p><img src="/img/b.67.png" alt="在这里插入图片描述"></p><blockquote><p>reverse函数也可以</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> left = <span class="number">0</span>,right = size<span class="number">-1</span> ; left &lt; right ; ++left,--right)</span><br><span class="line">            <span class="built_in">swap</span>(s[left],s[right]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="5-2-541-反转字符串II"><a href="#5-2-541-反转字符串II" class="headerlink" title="5.2 541-反转字符串II"></a>5.2 541-反转字符串II</h2><p><a href="https://leetcode.cn/problems/reverse-string-ii/description/">541</a></p><p><img src="/img/b.68.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += (<span class="number">2</span> * k)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>()) </span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k );</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="5-3-151-反转字符串中的单词"><a href="#5-3-151-反转字符串中的单词" class="headerlink" title="5.3* 151-反转字符串中的单词"></a>5.3* 151-反转字符串中的单词</h2><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">151</a></p><p><img src="/img/b.69.png" alt="在这里插入图片描述"><br><img src="/img/b.70.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(s[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()); <span class="comment">//去除开头多余空格</span></span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());<span class="comment">//blue is sky the</span></span><br><span class="line">        <span class="keyword">while</span>(s[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()); <span class="comment">//去除开头多余空格</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>, size = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span> ; i &lt; s.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            count++; <span class="comment">//表示当前为第几个字符</span></span><br><span class="line">            size++; <span class="comment">//表示这个单词有几个字符</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+flag, s.<span class="built_in">begin</span>()+flag+size<span class="number">-1</span>);</span><br><span class="line">                flag = count; <span class="comment">//记录下一个单词的起始位置</span></span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(s[i+<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) <span class="comment">//删除中间多余空格</span></span><br><span class="line">                    s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()+i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+flag,s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="5-4-182-动态口令"><a href="#5-4-182-动态口令" class="headerlink" title="5.4 182-动态口令"></a>5.4 182-动态口令</h2><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/description/">182</a></p><p><img src="/img/b.71.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//1 2 3 4 5 6 7 -&gt; 4 5 6 7 1 2 3</span></span><br><span class="line">        <span class="comment">//7 6 5 4 3 2 1 -&gt; 7 6 5 4 1 2 3 -&gt; 4 5 6 7 1 2 3</span></span><br><span class="line">    <span class="function">string <span class="title">dynamicPassword</span><span class="params">(string password, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = password.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> newstart = size - target;</span><br><span class="line">        <span class="built_in">reverse</span>(password.<span class="built_in">begin</span>(),password.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(password.<span class="built_in">begin</span>(),password.<span class="built_in">begin</span>()+newstart);</span><br><span class="line">        <span class="built_in">reverse</span>(password.<span class="built_in">begin</span>()+newstart,password.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="5-5-459-重复的子字符串"><a href="#5-5-459-重复的子字符串" class="headerlink" title="5.5* 459-重复的子字符串"></a>5.5* 459-重复的子字符串</h2><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/description/">459</a></p><p><img src="/img/b.72.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">string <span class="title">tmp</span><span class="params">(s.begin(),s.end())</span></span>;</span><br><span class="line">        tmp+=s;</span><br><span class="line">        tmp.<span class="built_in">erase</span>(tmp.<span class="built_in">begin</span>());</span><br><span class="line">        tmp.<span class="built_in">erase</span>(tmp.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//删去头尾</span></span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">find</span>(s) == string::npos)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//在tmp内寻找s,找到了就说明是重复组成的</span></span><br><span class="line">        <span class="comment">//abab -&gt;(a)b abab a(b)</span></span><br><span class="line">        <span class="comment">//abcdabcd -&gt; (a)bcd abcdabcd abc(d)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="5-6-28-找出字符串中第一个匹配项的下标-KMP"><a href="#5-6-28-找出字符串中第一个匹配项的下标-KMP" class="headerlink" title="5.6* 28-找出字符串中第一个匹配项的下标(KMP)"></a>5.6* 28-找出字符串中第一个匹配项的下标(KMP)</h2><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28</a></p><p><img src="/img/b.73.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">//aabaabaafa  aabaaf</span></span><br><span class="line">    <span class="comment">//前缀表的作用就是再两个字符串匹配失败时,能回到最近的匹配位置,记录能回到位置下标</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//-1 0  -1 0  1  -1</span></span><br><span class="line">        <span class="comment">//a  a  b  a  a  f</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123; </span><br><span class="line">             <span class="comment">//能进入就说明前面已经有重复的了</span></span><br><span class="line">            <span class="comment">//进不去说明和前面一样继续重复</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>])  <span class="comment">// 前后缀不相同了</span></span><br><span class="line">                j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>])  <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">                j++;</span><br><span class="line"></span><br><span class="line">            next[i] = j; <span class="comment">// 将j（前缀的长度）赋给next[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> size_ndl = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> size_hstk = haystack.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> next[size_ndl];</span><br><span class="line">        <span class="built_in">getNext</span>(next, needle);</span><br><span class="line">        <span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">// // 因为next数组里记录的起始位置为-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_hstk; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 注意i就从0开始</span></span><br><span class="line">            <span class="comment">//当数据和前缀表有重合时且当下不对应</span></span><br><span class="line">            <span class="comment">//while放在if(匹配)前面,防止j一直++匹配成功后又进入循环判断下一个不匹配而重置j</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="number">1</span>])</span><br><span class="line">                j = next[j]; <span class="comment">// j 寻找之前匹配的位置 //重新加载前缀表</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j + <span class="number">1</span>])  <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">                j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (j == (size_ndl - <span class="number">1</span>) )  <span class="comment">// //当数据和前缀表完全重合</span></span><br><span class="line">                <span class="keyword">return</span> (i - size_ndl + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="6-栈和队列篇"><a href="#6-栈和队列篇" class="headerlink" title="6. 栈和队列篇"></a>6. 栈和队列篇</h1><h2 id="6-1-232-用栈实现队列"><a href="#6-1-232-用栈实现队列" class="headerlink" title="6.1 232-用栈实现队列"></a>6.1 232-用栈实现队列</h2><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">232</a></p><p><img src="/img/b.74.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.<span class="built_in">empty</span>()) <span class="comment">//s2就相当于队列,s1存储数据,反转数据存入s2;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>());</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = s2.<span class="built_in">top</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        s2.<span class="built_in">push</span>(tmp);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">empty</span>() &amp;&amp; s2.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="6-2-225-用队列实现栈"><a href="#6-2-225-用队列实现栈" class="headerlink" title="6.2 225-用队列实现栈"></a>6.2 225-用队列实现栈</h2><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">225</a></p><p><img src="/img/b.75.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q1.<span class="built_in">empty</span>())</span><br><span class="line">            q1.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q2.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="comment">//将其中一个队列中size-1个元素全部移入另一个队列,留下的元素pop</span></span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(!q1.<span class="built_in">empty</span>()) <span class="comment">//q1不为空,将元素移动到q2</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(q1.<span class="built_in">size</span>() != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q2.<span class="built_in">push</span>(q1.<span class="built_in">front</span>());</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ans = q1.<span class="built_in">front</span>();</span><br><span class="line">            q1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(q2.<span class="built_in">size</span>() != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q1.<span class="built_in">push</span>(q2.<span class="built_in">front</span>());</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ans = q2.<span class="built_in">front</span>();</span><br><span class="line">            q2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">push</span>(tmp);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q1.<span class="built_in">empty</span>() &amp;&amp; q2.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="6-3-20-有效的括号"><a href="#6-3-20-有效的括号" class="headerlink" title="6.3 20-有效的括号"></a>6.3 20-有效的括号</h2><p><a href="https://leetcode.cn/problems/valid-parentheses/description/">20</a></p><p><img src="/img/b.76.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//&#123;([])&#125;</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> e : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(e==<span class="string">&#x27;[&#x27;</span> || e==<span class="string">&#x27;(&#x27;</span> || e==<span class="string">&#x27;&#123;&#x27;</span>) <span class="comment">//左符号进入栈中</span></span><br><span class="line">                st.<span class="built_in">push</span>(e);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(e == <span class="string">&#x27;)&#x27;</span> &amp;&amp; st.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span> </span><br><span class="line">                        || e == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; st.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span> </span><br><span class="line">                        || e == <span class="string">&#x27;]&#x27;</span> &amp;&amp;  st.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                    st.<span class="built_in">pop</span>(); <span class="comment">//找到对应的符号后删除左符号</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果不符合这个规则,那么就不构成</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>(); <span class="comment">//如果最后为空,则说明全部对应上了,否则即false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="6-4-1047-删除字符串中的所有相邻重复项"><a href="#6-4-1047-删除字符串中的所有相邻重复项" class="headerlink" title="6.4 1047-删除字符串中的所有相邻重复项"></a>6.4 1047-删除字符串中的所有相邻重复项</h2><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">1047</a></p><p><img src="/img/b.77.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> e : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">empty</span>() || e!=st.<span class="built_in">top</span>())</span><br><span class="line">                st.<span class="built_in">push</span>(e);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将栈中的正确答案转移至string类</span></span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//由于从栈中获取数据,因此答案要反转回来</span></span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="6-5-150-逆波兰表达式求值"><a href="#6-5-150-逆波兰表达式求值" class="headerlink" title="6.5 150-逆波兰表达式求值"></a>6.5 150-逆波兰表达式求值</h2><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">150</a></p><p><img src="/img/b.78.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(string&amp; e : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(e==<span class="string">&quot;+&quot;</span> || e==<span class="string">&quot;*&quot;</span> || e==<span class="string">&quot;/&quot;</span> || e==<span class="string">&quot;-&quot;</span>)<span class="comment">//如果为符号,则取栈顶两个数字进行运算</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> second = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> first = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">//取栈顶两个数据</span></span><br><span class="line">                <span class="keyword">if</span>(e==<span class="string">&quot;+&quot;</span>)</span><br><span class="line">                    st.<span class="built_in">push</span>(first+second);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(e==<span class="string">&quot;-&quot;</span>)</span><br><span class="line">                    st.<span class="built_in">push</span>(first-second);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(e==<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                    st.<span class="built_in">push</span>(first*second);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(e==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                    st.<span class="built_in">push</span>(first/second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//如果为数字则入栈</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoi</span>(e));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="6-6-239-滑动窗口最大值-双端队列"><a href="#6-6-239-滑动窗口最大值-双端队列" class="headerlink" title="6.6* 239-滑动窗口最大值(双端队列)"></a>6.6* 239-滑动窗口最大值(双端队列)</h2><p><a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239</a></p><p><img src="/img/b.79.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">back</span>() &lt; num) <span class="comment">//dq中第一个元素始终保证为最大值</span></span><br><span class="line">            dq.<span class="built_in">pop_back</span>(); </span><br><span class="line">        dq.<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() == num)</span><br><span class="line">            dq.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="comment">//创建第一组滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;k; ++i)</span><br><span class="line">            <span class="built_in">push</span>(nums[i]);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(dq.<span class="built_in">front</span>()); <span class="comment">//放入第一组滑动窗口的最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始处理后面的窗口</span></span><br><span class="line">        <span class="type">int</span> tmp = k;</span><br><span class="line">        <span class="keyword">while</span>(tmp &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pop</span>(nums[tmp-k]); <span class="comment">//尝试删除dq中最大数字(滑动窗口滑过了这个数字,需要更新,因此删除)</span></span><br><span class="line">            <span class="built_in">push</span>(nums[tmp++]); <span class="comment">//尝试更新</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(dq.<span class="built_in">front</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; dq; <span class="comment">//双端队列</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="6-7-347-前K个高频元素-优先级队列"><a href="#6-7-347-前K个高频元素-优先级队列" class="headerlink" title="6.7* 347-前K个高频元素(优先级队列)"></a>6.7* 347-前K个高频元素(优先级队列)</h2><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/description/">347</a></p><p><img src="/img/b.80.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SecondCmp</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; x,<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x.second&lt;y.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; um; <span class="comment">//key:元素 value:出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : nums)</span><br><span class="line">            um[e]++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使优先级队列升序排列,c++20适用</span></span><br><span class="line">        <span class="comment">//priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,decltype([]</span></span><br><span class="line">        <span class="comment">//(const pair&lt;int,int&gt;&amp; x,const pair&lt;int,int&gt;&amp; y)&#123;</span></span><br><span class="line">        <span class="comment">//    return x.second&lt;y.second;</span></span><br><span class="line">        <span class="comment">//&#125;)&gt; pq;</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,SecondCmp&gt; pq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : um)</span><br><span class="line">            pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(e.first,e.second));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(k--)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-数组篇&quot;&gt;&lt;a href=&quot;#1-数组篇&quot; class=&quot;headerlink&quot; title=&quot;1.数组篇&quot;&gt;&lt;/a&gt;1.数组篇&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;1-1-704-二分查找&quot;&gt;&lt;a href=&quot;#1-1-704-二分查找&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="代码随想录" scheme="http://example.com/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JSON和程序发布</title>
    <link href="http://example.com/2023/10/22/JSON%E5%92%8C%E7%A8%8B%E5%BA%8F%E5%8F%91%E5%B8%83/"/>
    <id>http://example.com/2023/10/22/JSON%E5%92%8C%E7%A8%8B%E5%BA%8F%E5%8F%91%E5%B8%83/</id>
    <published>2023-10-22T01:54:42.000Z</published>
    <updated>2023-10-22T05:53:18.856Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h1 id="1-JSON"><a href="#1-JSON" class="headerlink" title="1. JSON"></a>1. JSON</h1><p>JSON(<code>JavaScrip Object Notation</code>)是一种<code>轻量级的数据交换格式</code>。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用<code>完全独立于编程语言的文本格式来存储和表示数据</code>。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><p>关于上面的描述可以精简为一句话：<code>Json是一种数据格式，和语言无关，在什么语言中都可以使用Json。</code>基于这种通用的数据格式，一般处理两方面的任务：</p><ol><li>组织数据（数据序列化），用于数据的网络传输</li><li>组织数据（数据序列化），写磁盘文件实现数据的持久化存储（一般以.json作为文件后缀）<br>Json中主要有两种数据格式：Json数组和Json对象，并且这两种格式可以交叉嵌套使用，下面依次介绍下这两种数据格式：</li></ol><h2 id="1-1-Json数组"><a href="#1-1-Json数组" class="headerlink" title="1.1 Json数组"></a>1.1 Json数组</h2><p>Json数组使用 [] 表示，[]里边是元素，元素和元素之间使用逗号间隔，<code>最后一个元素后边没有逗号</code>，一个Json数组中支持同时存在多种不同类型的成员，<br>包括：整形、 浮点、 字符串、 布尔类型、 json数组、 json对象、 空值-null。<br>由此可见Json数组比起C&#x2F;C++数组要灵活很多。</p><ul><li>Json数组中的元素数据类型一致</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整形</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">[<span class="string">&quot;luffy&quot;</span>, <span class="string">&quot;sanji&quot;</span>, <span class="string">&quot;zoro&quot;</span>, <span class="string">&quot;nami&quot;</span>, <span class="string">&quot;robin&quot;</span>]</span><br></pre></td></tr></table></figure><ul><li>Json数组中的元素数据类型不一致</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">12</span>, <span class="number">13.34</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;hello,world&quot;</span>, <span class="literal">null</span>]</span><br></pre></td></tr></table></figure><ul><li>Json数组中的数组嵌套使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;panda&quot;</span>, <span class="string">&quot;beer&quot;</span>, <span class="string">&quot;rabbit&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;天津&quot;</span>, <span class="string">&quot;重庆&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;luffy&quot;</span>, <span class="string">&quot;boy&quot;</span>, <span class="number">19</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>Json数组和对象嵌套使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;luffy&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;age&quot;</span>:<span class="number">19</span>,</span><br><span class="line">            <span class="string">&quot;father&quot;</span>:<span class="string">&quot;Monkey·D·Dragon&quot;</span>,</span><br><span class="line">            <span class="string">&quot;grandpa&quot;</span>:<span class="string">&quot;Monkey D Garp&quot;</span>,</span><br><span class="line">            <span class="string">&quot;brother1&quot;</span>:<span class="string">&quot;Portgas D Ace&quot;</span>,</span><br><span class="line">            <span class="string">&quot;brother2&quot;</span>:<span class="string">&quot;Sabo&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h2 id="1-2-Json对象"><a href="#1-2-Json对象" class="headerlink" title="1.2 Json对象"></a>1.2 Json对象</h2><p>Json对象使用 {} 来描述，每个Json对象中可以存储若干个元素，每一个元素对应一个键值对（key：value 结构），元素和元素之间使用逗号间隔，最后一个元素后边没有逗号。对于每个元素中的键值对有以下细节需要注意：</p><ol><li>键值（key）必须是字符串，位于同一层级的键值不要重复（因为是通过键值取出对应的value值）</li><li>value值的类型是可选的，可根据实际需求指定，可用类型包括：整形、 浮点、 字符串、 布尔类型、 json数组、 json对象、 空值-null。</li></ol><p><strong>使用Json对象描述一个人的信息:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>:<span class="string">&quot;Ace&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sex&quot;</span>:<span class="string">&quot;man&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Age&quot;</span>:<span class="number">20</span>,</span><br><span class="line">    <span class="string">&quot;Family&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;Father&quot;</span>:<span class="string">&quot;Gol·D·Roger&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mother&quot;</span>:<span class="string">&quot;Portgas·D·Rouge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Brother&quot;</span>:[<span class="string">&quot;Sabo&quot;</span>, <span class="string">&quot;Monkey D. Luffy&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;IsAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;Comment&quot;</span>:<span class="string">&quot;yyds&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-3-注意事项"><a href="#1-3-注意事项" class="headerlink" title="1.3 注意事项"></a>1.3 注意事项</h2><p>通过上面的介绍可用看到，Json的结构虽然简单，但是进行嵌套之后就可以描述很复杂的事情，在项目开发过程中往往需要我们根据实际需求自己定义Json格式用来存储项目数据。</p><p>另外，如果需要将Json数据持久化到磁盘文件中<br>需要注意一个问题：<code>在一个Json文件中只能有一个Json数组或者Json对象的根节点，不允许同时存储多个并列的根节点。</code><br>举例说明：</p><p><strong>错误的写法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;luffy&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;user&quot;</span>:<span class="string">&quot;ace&quot;</span>,</span><br><span class="line">    <span class="string">&quot;passwd&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>错误原因：<br><code>在一个Json文件中有两个并列的Json根节点（并列包含Json对象和Json对象、Json对象和Json数组、Json数组和Json数组），根节点只能有一个。</code></p></blockquote><p><strong>正确的写法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>:<span class="string">&quot;Ace&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sex&quot;</span>:<span class="string">&quot;man&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Age&quot;</span>:<span class="number">20</span>,</span><br><span class="line">    <span class="string">&quot;Family&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;Father&quot;</span>:<span class="string">&quot;Gol·D·Roger&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mother&quot;</span>:<span class="string">&quot;Portgas·D·Rouge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Brother&quot;</span>:[<span class="string">&quot;Sabo&quot;</span>, <span class="string">&quot;Monkey D. Luffy&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;IsAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;Comment&quot;</span>:<span class="string">&quot;yyds&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中通过Json对象以及Json数组的嵌套描述了一个人的身份信息，并且根节点只有一个就是Json对象，如果还需要使用Json数组或者Json对象描述其他信息，需要将这些信息写入到其他文件中，<code>不要和这个Json对象并列写入到同一个文件里边</code></p><hr><h1 id="2-Qt中JSON操作"><a href="#2-Qt中JSON操作" class="headerlink" title="2. Qt中JSON操作"></a>2. Qt中JSON操作</h1><p>从<code>Qt 5.0</code>开始提供了对Json的支持，我们可以直接使用Qt提供的Json类进行数据的组织和解析。相关的类常用的主要有四个，具体如下：</p><table><thead><tr><th>Json类</th><th>介绍</th></tr></thead><tbody><tr><td>QJsonDocument</td><td>封装了一个完整的JSON文档，并且可以从UTF-8编码的基于文本的表示以及Qt自己的二进制格式读取和写入该文档。</td></tr><tr><td>QJsonArray</td><td>JSON数组是一个值列表。可以通过从数组中插入和删除QJsonValue来操作该列表。</td></tr><tr><td>QJsonObject</td><td>JSON对象是键值对的列表，其中键是唯一的字符串，值由QJsonValue表示。</td></tr><tr><td>QJsonValue</td><td>该类封装了JSON支持的数据类型。</td></tr></tbody></table><h2 id="2-1-QJsonValue"><a href="#2-1-QJsonValue" class="headerlink" title="2.1 QJsonValue"></a>2.1 QJsonValue</h2><p>在Qt中<code>QJsonValue</code>可以封装的基础数据类型有六种（和Json支持的类型一致），分别为：</p><ul><li>布尔类型：<code>QJsonValue::Bool</code></li><li>浮点类型（包括整形）： <code>QJsonValue::Double</code></li><li>字符串类型： <code>QJsonValue::String</code></li><li>Json数组类型： <code>QJsonValue::Array</code></li><li>Json对象类型：<code>QJsonValue::Object</code></li><li>空值类型： <code>QJsonValue::Null</code></li></ul><p>这个类型可以通过<code>QJsonValue</code>的构造函数被封装为一个类对象:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Json对象</span></span><br><span class="line"><span class="built_in">QJsonValue</span>(<span class="type">const</span> QJsonObject &amp;o);</span><br><span class="line"><span class="comment">// Json数组</span></span><br><span class="line"><span class="built_in">QJsonValue</span>(<span class="type">const</span> QJsonArray &amp;a);</span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="built_in">QJsonValue</span>(<span class="type">const</span> <span class="type">char</span> *s);</span><br><span class="line"><span class="built_in">QJsonValue</span>(QLatin1String s);</span><br><span class="line"><span class="built_in">QJsonValue</span>(<span class="type">const</span> QString &amp;s);</span><br><span class="line"><span class="comment">// 整形 and 浮点型</span></span><br><span class="line"><span class="built_in">QJsonValue</span>(qint64 v);</span><br><span class="line"><span class="built_in">QJsonValue</span>(<span class="type">int</span> v);</span><br><span class="line"><span class="built_in">QJsonValue</span>(<span class="type">double</span> v);</span><br><span class="line"><span class="comment">// 布尔类型</span></span><br><span class="line"><span class="built_in">QJsonValue</span>(<span class="type">bool</span> b);</span><br><span class="line"><span class="comment">// 空值类型</span></span><br><span class="line"><span class="built_in">QJsonValue</span>(QJsonValue::Type type = Null);</span><br></pre></td></tr></table></figure><p>如果我们得到一个<code>QJsonValue</code>对象，如何判断内部封装的到底是什么类型的数据呢？这时候就需要调用相关的判断函数了，具体如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否是Json数组</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isArray</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 是否是Json对象</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isObject</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 是否是布尔类型</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBool</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 是否是浮点类型(整形也是通过该函数判断)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDouble</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 是否是空值类型</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 是否是字符串类型</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 是否是未定义类型(无法识别的类型)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isUndefined</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>通过判断函数得到对象内部数据的实际类型之后，如果有需求就可以再次将其转换为对应的基础数据类型，对应的API函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换为Json数组</span></span><br><span class="line"><span class="function">QJsonArray <span class="title">toArray</span><span class="params">(<span class="type">const</span> QJsonArray &amp;defaultValue)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QJsonArray <span class="title">toArray</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 转换为布尔类型</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toBool</span><span class="params">(<span class="type">bool</span> defaultValue = <span class="literal">false</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 转换为浮点类型</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">toDouble</span><span class="params">(<span class="type">double</span> defaultValue = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 转换为整形</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">toInt</span><span class="params">(<span class="type">int</span> defaultValue = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 转换为Json对象</span></span><br><span class="line"><span class="function">QJsonObject <span class="title">toObject</span><span class="params">(<span class="type">const</span> QJsonObject &amp;defaultValue)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QJsonObject <span class="title">toObject</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 转换为字符串类型</span></span><br><span class="line"><span class="function">QString <span class="title">toString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QString <span class="title">toString</span><span class="params">(<span class="type">const</span> QString &amp;defaultValue)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="2-2-QJsonObject"><a href="#2-2-QJsonObject" class="headerlink" title="2.2 QJsonObject"></a>2.2 QJsonObject</h2><p><code>QJsonObject</code>封装了Json中的对象，在里边可以存储多个键值对，为了方便操作，键值为字符串类型，值为<code>QJsonValue</code>类型。关于这个类的使用类似于C++中的STL类，仔细阅读API文档即可熟练上手使用，下面介绍一些常用API函数:</p><ul><li>如何创建空的Json对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QJsonObject::<span class="built_in">QJsonObject</span>();<span class="comment">// 构造空对象</span></span><br></pre></td></tr></table></figure><ul><li>将键值对添加到空对象中</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">QJsonObject::insert</span><span class="params">(<span class="type">const</span> QString &amp;key, <span class="type">const</span> QJsonValue &amp;value)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>获取对象中键值对个数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QJsonObject::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QJsonObject::size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QJsonObject::length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><ul><li>通过key得到value</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QJsonValue <span class="title">QJsonObject::value</span><span class="params">(<span class="type">const</span> QString &amp;key)</span> <span class="type">const</span></span>;    <span class="comment">// utf8</span></span><br><span class="line"><span class="function">QJsonValue <span class="title">QJsonObject::value</span><span class="params">(QLatin1String key)</span> <span class="type">const</span></span>;    <span class="comment">// 字符串不支持中文</span></span><br><span class="line">QJsonValue QJsonObject::<span class="keyword">operator</span>[](<span class="type">const</span> QString &amp;key) <span class="type">const</span>;</span><br><span class="line">QJsonValue QJsonObject::<span class="keyword">operator</span>[](QLatin1String key) <span class="type">const</span>;</span><br></pre></td></tr></table></figure><ul><li>删除键值对</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QJsonObject::remove</span><span class="params">(<span class="type">const</span> QString &amp;key)</span></span>;</span><br><span class="line"><span class="function">QJsonValue <span class="title">QJsonObject::take</span><span class="params">(<span class="type">const</span> QString &amp;key)</span></span>;<span class="comment">// 返回key对应的value值</span></span><br></pre></td></tr></table></figure><ul><li>通过key进行查找</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">QJsonObject::find</span><span class="params">(<span class="type">const</span> QString &amp;key)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QJsonObject::contains</span><span class="params">(<span class="type">const</span> QString &amp;key)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>遍历，方式有三种：</p><ol><li><p>使用相关的迭代器函数</p></li><li><p>使用 [] 的方式遍历, 类似于遍历数组, []中是键值</p></li><li><p>先得到对象中所有的键值, 在遍历键值列表, 通过key得到value值</p></li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QStringList <span class="title">QJsonObject::keys</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="2-3-QJsonArray"><a href="#2-3-QJsonArray" class="headerlink" title="2.3 QJsonArray"></a>2.3 QJsonArray</h2><p><code>QJsonArray</code>封装了Json中的数组，在里边可以存储多个元素，为了方便操作，所有的元素类统一为<code>QJsonValue</code>类型。关于这个类的使用类似于C++中的STL类，仔细阅读API文档即可熟练上手使用，介绍一些常用API函数:</p><ul><li>创建空的Json数组</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QJsonArray::<span class="built_in">QJsonArray</span>();</span><br></pre></td></tr></table></figure><ul><li>添加数据</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QJsonArray::append</span><span class="params">(<span class="type">const</span> QJsonValue &amp;value)</span></span>;<span class="comment">// 在尾部追加</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QJsonArray::insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> QJsonValue &amp;value)</span></span>; <span class="comment">// 插入到 i 的位置之前</span></span><br><span class="line"><span class="function">iterator <span class="title">QJsonArray::insert</span><span class="params">(iterator before, <span class="type">const</span> QJsonValue &amp;value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QJsonArray::prepend</span><span class="params">(<span class="type">const</span> QJsonValue &amp;value)</span></span>; <span class="comment">// 添加到数组头部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QJsonArray::push_back</span><span class="params">(<span class="type">const</span> QJsonValue &amp;value)</span></span>; <span class="comment">// 添加到尾部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QJsonArray::push_front</span><span class="params">(<span class="type">const</span> QJsonValue &amp;value)</span></span>; <span class="comment">// 添加到头部</span></span><br></pre></td></tr></table></figure><ul><li>计算数组元素的个数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QJsonArray::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QJsonArray::size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><ul><li>从数组中取出某一个元素的值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QJsonValue <span class="title">QJsonArray::at</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QJsonValue <span class="title">QJsonArray::first</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 头部元素</span></span><br><span class="line"><span class="function">QJsonValue <span class="title">QJsonArray::last</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 尾部元素</span></span><br><span class="line">QJsonValueRef QJsonArray::<span class="keyword">operator</span>[](<span class="type">int</span> i);</span><br></pre></td></tr></table></figure><ul><li>删除数组中的某一个元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">QJsonArray::erase</span><span class="params">(iterator it)</span></span>;    <span class="comment">// 基于迭代器删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QJsonArray::pop_back</span><span class="params">()</span></span>;           <span class="comment">// 删除尾部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QJsonArray::pop_front</span><span class="params">()</span></span>;          <span class="comment">// 删除头部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QJsonArray::removeAt</span><span class="params">(<span class="type">int</span> i)</span></span>;      <span class="comment">// 删除i位置的元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QJsonArray::removeFirst</span><span class="params">()</span></span>;        <span class="comment">// 删除头部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QJsonArray::removeLast</span><span class="params">()</span></span>;         <span class="comment">// 删除尾部</span></span><br><span class="line"><span class="function">QJsonValue <span class="title">QJsonArray::takeAt</span><span class="params">(<span class="type">int</span> i)</span></span>;  <span class="comment">// 删除i位置的原始, 并返回删除的元素的值</span></span><br></pre></td></tr></table></figure><ul><li><p>Josn数组的遍历，常用的方式有两种：</p><ol><li>可以使用迭代器进行遍历（和使用迭代器遍历STL容器一样）</li><li>可以使用数组的方式遍历</li></ol></li></ul><hr><h2 id="2-4-QJsonDocument"><a href="#2-4-QJsonDocument" class="headerlink" title="2.4 QJsonDocument"></a>2.4 QJsonDocument</h2><p>它封装了一个完整的JSON文档，并且可以从UTF-8编码的基于文本的表示以及Qt自己的二进制格式读取和写入该文档。<code>QJsonObject</code> 和 <code>QJsonArray</code>这两个对象中的数据是不能直接转换为字符串类型的，如果要进行数据传输或者数据的持久化，操作的都是字符串类型而不是 <code>QJsonObject</code> 或者 <code>QJsonArray</code>类型，我们需要通过一个Json文档类进行二者之间的转换。</p><p>介绍一下这两个转换流程应该如何操作:</p><blockquote><p><code>QJsonObject</code> 或者 <code>QJsonArray</code> &#x3D;&#x3D;&#x3D;&gt; 字符串</p></blockquote><ol><li><strong>创建QJsonDocument对象</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QJsonDocument::<span class="built_in">QJsonDocument</span>(<span class="type">const</span> QJsonObject &amp;object);</span><br><span class="line">QJsonDocument::<span class="built_in">QJsonDocument</span>(<span class="type">const</span> QJsonArray &amp;array);</span><br></pre></td></tr></table></figure><p>可以看出，通过构造函数就可以将实例化之后的<code>QJsonObject</code> 或者 <code>QJsonArray</code> 转换为<code>QJsonDocument</code>对象了。</p><ol start="2"><li><strong>将文件对象中的数据进行序列化</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制格式的json字符串</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QJsonDocument::toBinaryData</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="comment">// 文本格式</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QJsonDocument::toJson</span><span class="params">(JsonFormat format = Indented)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>通过调用<code>toxxx()</code>方法就可以得到文本格式或者二进制格式的Json字符串了。</p><ol start="3"><li><strong>使用得到的字符串进行数据传输, 或者磁盘文件持久化</strong></li></ol><blockquote><p>字符串 &#x3D;&#x3D;&#x3D;&gt; <code>QJsonObject</code> 或者 <code>QJsonArray</code></p></blockquote><p>一般情况下，通过网络通信或者读磁盘文件就会得到一个Json格式的字符串，如果想要得到相关的原始数据就需要对字符串中的数据进行解析，具体解析流程如下：</p><ol><li>将得到的Json格式字符串通过 <code>QJsonDocument</code> 类的静态函数转换为<code>QJsonDocument</code>类对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">static</span>] <span class="function">QJsonDocument <span class="title">QJsonDocument::fromBinaryData</span><span class="params">(<span class="type">const</span> QByteArray &amp;data, DataValidation validation = Validate)</span></span>;</span><br><span class="line"><span class="comment">// 参数文件格式的json字符串</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QJsonDocument <span class="title">QJsonDocument::fromJson</span><span class="params">(<span class="type">const</span> QByteArray &amp;json, QJsonParseError *error = Q_NULLPTR)</span></span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>将文档对象转换为json数组&#x2F;对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断文档对象中存储的数据是不是数组</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QJsonDocument::isArray</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断文档对象中存储的数据是不是json对象</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QJsonDocument::isObject</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 文档对象中的数据转换为json对象</span></span></span><br><span class="line"><span class="function">QJsonObject <span class="title">QJsonDocument::object</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 文档对象中的数据转换为json数组</span></span><br><span class="line"><span class="function">QJsonArray <span class="title">QJsonDocument::array</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>通过调用<code>QJsonArray</code> , <code>QJsonObject</code> 类提供的 API 读出存储在对象中的数据。<br>关于Qt中Json数据对象以及字符串之间的转换的操作流程是固定的，我们在编码过程中只需要按照上述模板处理即可，相关的操作是没有太多的技术含量可言的。</li></ol><hr><h2 id="2-5-举例"><a href="#2-5-举例" class="headerlink" title="2.5 举例"></a>2.5 举例</h2><h3 id="2-5-1-写文件"><a href="#2-5-1-写文件" class="headerlink" title="2.5.1 写文件"></a>2.5.1 写文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeJson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QJsonObject obj;</span><br><span class="line">    obj.<span class="built_in">insert</span>(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Ace&quot;</span>);</span><br><span class="line">    obj.<span class="built_in">insert</span>(<span class="string">&quot;Sex&quot;</span>, <span class="string">&quot;man&quot;</span>);</span><br><span class="line">    obj.<span class="built_in">insert</span>(<span class="string">&quot;Age&quot;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    QJsonObject subObj;</span><br><span class="line">    subObj.<span class="built_in">insert</span>(<span class="string">&quot;Father&quot;</span>, <span class="string">&quot;Gol·D·Roger&quot;</span>);</span><br><span class="line">    subObj.<span class="built_in">insert</span>(<span class="string">&quot;Mother&quot;</span>, <span class="string">&quot;Portgas·D·Rouge&quot;</span>);</span><br><span class="line">    QJsonArray array;</span><br><span class="line">    array.<span class="built_in">append</span>(<span class="string">&quot;Sabo&quot;</span>);</span><br><span class="line">    array.<span class="built_in">append</span>(<span class="string">&quot;Monkey D. Luffy&quot;</span>);</span><br><span class="line">    subObj.<span class="built_in">insert</span>(<span class="string">&quot;Brother&quot;</span>, array);</span><br><span class="line">    obj.<span class="built_in">insert</span>(<span class="string">&quot;Family&quot;</span>, subObj);</span><br><span class="line">    obj.<span class="built_in">insert</span>(<span class="string">&quot;IsAlive&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    obj.<span class="built_in">insert</span>(<span class="string">&quot;Comment&quot;</span>, <span class="string">&quot;yyds&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">QJsonDocument <span class="title">doc</span><span class="params">(obj)</span></span>;</span><br><span class="line">    QByteArray json = doc.<span class="built_in">toJson</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;d:\\ace.json&quot;</span>)</span></span>;</span><br><span class="line">    file.<span class="built_in">open</span>(QFile::WriteOnly);</span><br><span class="line">    file.<span class="built_in">write</span>(json);</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-5-2-读文件"><a href="#2-5-2-读文件" class="headerlink" title="2.5.2 读文件"></a>2.5.2 读文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::readJson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;d:\\ace.json&quot;</span>)</span></span>;</span><br><span class="line">    file.<span class="built_in">open</span>(QFile::ReadOnly);</span><br><span class="line">    QByteArray json = file.<span class="built_in">readAll</span>();</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    QJsonDocument doc = QJsonDocument::<span class="built_in">fromJson</span>(json);</span><br><span class="line">    <span class="keyword">if</span>(doc.<span class="built_in">isObject</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        QJsonObject obj = doc.<span class="built_in">object</span>();</span><br><span class="line">        QStringList keys = obj.<span class="built_in">keys</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;keys.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            QString key = keys.<span class="built_in">at</span>(i);</span><br><span class="line">            QJsonValue value = obj.<span class="built_in">value</span>(key);</span><br><span class="line">            <span class="keyword">if</span>(value.<span class="built_in">isBool</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">qDebug</span>() &lt;&lt; key &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; value.<span class="built_in">toBool</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(value.<span class="built_in">isString</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">qDebug</span>() &lt;&lt; key &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; value.<span class="built_in">toString</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(value.<span class="built_in">isDouble</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">qDebug</span>() &lt;&lt; key &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; value.<span class="built_in">toInt</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(value.<span class="built_in">isObject</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">qDebug</span>()&lt;&lt; key &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">                <span class="comment">// 直接处理内部键值对, 不再进行类型判断的演示</span></span><br><span class="line">                QJsonObject subObj = value.<span class="built_in">toObject</span>();</span><br><span class="line">                QStringList ls = subObj.<span class="built_in">keys</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ls.<span class="built_in">size</span>(); ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    QJsonValue subVal = subObj.<span class="built_in">value</span>(ls.<span class="built_in">at</span>(i));</span><br><span class="line">                    <span class="keyword">if</span>(subVal.<span class="built_in">isString</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; ls.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; subVal.<span class="built_in">toString</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(subVal.<span class="built_in">isArray</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        QJsonArray array = subVal.<span class="built_in">toArray</span>();</span><br><span class="line">                        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; ls.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;array.<span class="built_in">size</span>(); ++j)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// 因为知道数组内部全部为字符串, 不再对元素类型进行判断</span></span><br><span class="line">                            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;       &quot;</span> &lt;&lt; array[j].<span class="built_in">toString</span>();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，对于Json字符串的解析函数都是有针对性的，因为需求不同设计的Json格式就会有所不同，所以不要试图写出一个通用的Json解析函数，这样只会使函数变得臃肿而且不易于维护，每个Json格式对应一个相应的解析函数即可。</p><p>上面的例子中演示Qt中Json类相关API函数的使用将解析步骤写的复杂了，因为在解析的时候我们是知道Json对象中的所有key值的，可以直接通过key值将对应的value值取出来，因此上面程序中的一些判断和循环其实是可以省去的。</p><hr><h1 id="3-cjson库的使用"><a href="#3-cjson库的使用" class="headerlink" title="3. cjson库的使用"></a>3. cjson库的使用</h1><p>C语言的Json库 – cJson。cJSON是一个超轻巧，携带方便，单文件，简单的可以作为ANSI-C标准的JSON解析器。</p><p>cJSON 是一个开源项目，<a href="https://github.com/DaveGamble/cJSON">github下载地址</a></p><p>cJSON，目前来说，主要的文件有两个，一个<code>cJSON.c</code> 一个<code>cJSON.h</code>。<br>使用的时候，将<code>头文件include进去即可</code>。<br>如果是在Linux操作系统中使用，编译 到时候需要添加数据库libm.so，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc  *.c  cJSON.c  -lm</span><br></pre></td></tr></table></figure><h2 id="3-1-cJSON结构体"><a href="#3-1-cJSON结构体" class="headerlink" title="3.1 cJSON结构体"></a>3.1 cJSON结构体</h2><p>在<code>cJSON.h</code>中定义了一个非常重要的结构体<code>cJSON</code>，<br>想要熟悉使用cJSON库函数可从cJSON结构体入手，cJSON结构体如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> &#123;</span>  </span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">next</span>,*<span class="title">prev</span>;</span>   </span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">child</span>;</span>   </span><br><span class="line">     <span class="type">int</span> type;   </span><br><span class="line">     <span class="type">char</span> *valuestring;        <span class="comment">// value值是字符串类型</span></span><br><span class="line">     <span class="type">int</span> valueint;  </span><br><span class="line">     <span class="type">double</span> valuedouble;   </span><br><span class="line">     <span class="type">char</span> *<span class="built_in">string</span>;             <span class="comment">// 对象中的key</span></span><br><span class="line">&#125; cJSON; </span><br></pre></td></tr></table></figure><p>关于这个结构体做如下几点的说明:</p><ol><li><p><code>cJOSN</code>结构体是一个双向链表，并且可通过<code>child</code>指针访问下一层。</p></li><li><p>结构体成员<code>type</code>变量用于描述数据元素的类型（如果是键值对表示<code>value</code>值的类型），数据元素可以是字符串可以是整形，也可以是浮点型。</p><ul><li>如果是整形值的话可通过<code>valueint</code>将值取出</li><li>如果是浮点型的话可通过<code>valuedouble</code>将值取出</li><li>如果是字符串类型的话可通过<code>valuestring</code>将值取出</li></ul></li><li><p>结构体成员<code>string</code>表示键值对中键值的名称。</p></li></ol><p><code>cJSON</code>作为<code>Json</code>格式的解析库，其主要功能就是构建和解析<code>Json</code>格式了，比如要发送数据：用途就是发送端将要发送的数据以<code>json</code>形式封装，然后发送，接收端收到此数据后，还是按<code>json</code>形式解析，就得到想要的数据了。</p><hr><h2 id="3-2-cJson-API"><a href="#3-2-cJson-API" class="headerlink" title="3.2 cJson API"></a>3.2 cJson API</h2><p>Json格式的数据无外乎有两种Json对象和Json数组，创建的Json数据串可能是二者中 的一种，也可能是二者的组合，不管哪一种通过调用相关的API函数都可以轻松的做到这一点。</p><h3 id="3-2-1-数据的封装"><a href="#3-2-1-数据的封装" class="headerlink" title="3.2.1 数据的封装"></a>3.2.1 数据的封装</h3><p>在<code>cJSON.h</code>头文件中可以看到一些函数声明，通过调用这些创建函数就可以将<code>Json</code>支持的数据类型封装为<code>cJSON</code>结构体类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空值类型</span></span><br><span class="line"><span class="keyword">extern</span> cJSON *<span class="title function_">cJSON_CreateNull</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 布尔类型</span></span><br><span class="line"><span class="keyword">extern</span> cJSON *<span class="title function_">cJSON_CreateTrue</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> cJSON *<span class="title function_">cJSON_CreateFalse</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> cJSON *<span class="title function_">cJSON_CreateBool</span><span class="params">(<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="comment">// 数值类型</span></span><br><span class="line"><span class="keyword">extern</span> cJSON *<span class="title function_">cJSON_CreateNumber</span><span class="params">(<span class="type">double</span> num)</span>;</span><br><span class="line"><span class="comment">// 字符串类型</span></span><br><span class="line"><span class="keyword">extern</span> cJSON *<span class="title function_">cJSON_CreateString</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span>)</span>;</span><br><span class="line"><span class="comment">// json数组(创建空数组)</span></span><br><span class="line"><span class="keyword">extern</span> cJSON *<span class="title function_">cJSON_CreateArray</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// json对象(创建空对象)</span></span><br><span class="line"><span class="keyword">extern</span> cJSON *<span class="title function_">cJSON_CreateObject</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>另外，cJson库中还给我我们提供了一些更为简便的操作函数，在创建数组的同时还可以进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Json数组, 元素为整形</span></span><br><span class="line"><span class="keyword">extern</span> cJSON *<span class="title function_">cJSON_CreateIntArray</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *numbers,<span class="type">int</span> count)</span>;</span><br><span class="line"><span class="comment">// 创建一个Json数组, 元素为浮点</span></span><br><span class="line"><span class="keyword">extern</span> cJSON *<span class="title function_">cJSON_CreateFloatArray</span><span class="params">(<span class="type">const</span> <span class="type">float</span> *numbers,<span class="type">int</span> count)</span>;</span><br><span class="line"><span class="keyword">extern</span> cJSON *<span class="title function_">cJSON_CreateDoubleArray</span><span class="params">(<span class="type">const</span> <span class="type">double</span> *numbers,<span class="type">int</span> count)</span>;</span><br><span class="line"><span class="comment">// 创建一个Json数组, 元素为字符串类型</span></span><br><span class="line"><span class="keyword">extern</span> cJSON *<span class="title function_">cJSON_CreateStringArray</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **strings,<span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-2-Json对象操作"><a href="#3-2-2-Json对象操作" class="headerlink" title="3.2.2 Json对象操作"></a>3.2.2 Json对象操作</h3><p>当得到一个<code>Json</code>对象之后，就可以往对象中添加键值对了，可以使用<code>cJSON_AddItemToObject()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">cJSON_AddItemToObject</span><span class="params">(cJSON *object,<span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span>,cJSON *item)</span>;</span><br></pre></td></tr></table></figure><p>在<code>cJSON</code>库中节点的从属关系是通过树来维护的，每一层节点都是通过链表来维护的，这样就能分析出该函数参数的含义：</p><ul><li>object：要添加的键值对从属于那个节点</li><li>string：添加的键值对的键值</li><li>item：添加的键值对的value值（需要先将其封装为cJSON类型的结构体）</li></ul><p>为了让我的操作更加方便，cJson库还给我们提供了一些宏函数，方便我们快速的往Json对象中添加键值对</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> cJSON_AddNullToObject(object,name)      cJSON_AddItemToObject(object, name, cJSON_CreateNull())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cJSON_AddTrueToObject(object,name)      cJSON_AddItemToObject(object, name, cJSON_CreateTrue())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cJSON_AddFalseToObject(object,name)     cJSON_AddItemToObject(object, name, cJSON_CreateFalse())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cJSON_AddBoolToObject(object,name,b)    cJSON_AddItemToObject(object, name, cJSON_CreateBool(b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cJSON_AddNumberToObject(object,name,n)  cJSON_AddItemToObject(object, name, cJSON_CreateNumber(n))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cJSON_AddStringToObject(object,name,s)  cJSON_AddItemToObject(object, name, cJSON_CreateString(s))</span></span><br></pre></td></tr></table></figure><p>我们还可以根据<code>Json</code>对象中的键值取出相应的<code>value</code>值，API函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> cJSON *<span class="title function_">cJSON_GetObjectItem</span><span class="params">(cJSON *object,<span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span>)</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-3-Json数组操作"><a href="#3-2-3-Json数组操作" class="headerlink" title="3.2.3 Json数组操作"></a>3.2.3 Json数组操作</h3><ul><li>添加数据到Json数组中（原始数据需要先转换为cJSON结构体类型）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">cJSON_AddItemToArray</span><span class="params">(cJSON *<span class="built_in">array</span>, cJSON *item)</span>;</span><br></pre></td></tr></table></figure><ul><li>得到Json数组中元素的个数:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">cJSON_GetArraySize</span><span class="params">(cJSON *<span class="built_in">array</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>得到Json数组中指定位置的原素，如果返回NULL表示取值失败了。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> cJSON *<span class="title function_">cJSON_GetArrayItem</span><span class="params">(cJSON *<span class="built_in">array</span>,<span class="type">int</span> item)</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-4-序列化"><a href="#3-2-4-序列化" class="headerlink" title="3.2.4 序列化"></a>3.2.4 序列化</h3><p>序列化就是将<code>Json</code>格式的数据转换为字符串的过程，<code>cJson</code>库中给我们提供了3个转换函数，具体如下：</p><p>第一个参数<code>item</code>表示Json数据块的根节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span>  *<span class="title function_">cJSON_Print</span><span class="params">(cJSON *item)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>  *<span class="title function_">cJSON_PrintUnformatted</span><span class="params">(cJSON *item)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *<span class="title function_">cJSON_PrintBuffered</span><span class="params">(cJSON *item,<span class="type">int</span> prebuffer,<span class="type">int</span> fmt)</span>;</span><br></pre></td></tr></table></figure><ul><li>调用<code>cJSON_Print()</code>函数我们可以得到一个带格式的<code>Json</code>字符串（有换行，看起来更直观）</li><li>调用<code>cJSON_PrintUnformatted()</code>函数会得到一个没有格式的<code>Json</code>字符串（没有换行，所有的数据都在同一行）。</li><li>调用<code>cJSON_PrintBuffered()</code>函数使用缓冲策略将<code>Json</code>实体转换为字符串，参数<code>prebuffer</code>是指定缓冲区的大小，参数<code>fmt==0</code>表示未格式化，<code>fmt==1</code>表示格式化。</li></ul><p>我们在编码过程中可以根据自己的实际需求调用相关的操作函数得到对应格式的Json字符串。</p><hr><h3 id="3-2-5-Json字符串的解析"><a href="#3-2-5-Json字符串的解析" class="headerlink" title="3.2.5 Json字符串的解析"></a>3.2.5 Json字符串的解析</h3><p>如果我们得到了一个Json格式的字符串，想要读出里边的数据，就需要对这个字符串进行解析，处理方式就是将字符串转换为<code>cJSON</code>结构体，然后再基于这个结构体读里边的原始数据，转换函数的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> cJSON *<span class="title function_">cJSON_Parse</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *value)</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-6-内存释放"><a href="#3-2-6-内存释放" class="headerlink" title="3.2.6 内存释放"></a>3.2.6 内存释放</h3><p>当我们将数据封装为<code>cJSON</code>结构类型的节点之后都会得到一块堆内存，当我们释放某个节点的时候可以调用<code>cJson</code>库提供的删除函数<code>cJSON_Delete()</code>，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span>   <span class="title function_">cJSON_Delete</span><span class="params">(cJSON *c)</span>;</span><br></pre></td></tr></table></figure><p>该函数的参数为要释放的节点的地址，强调：<br><code>在进行内存地址释放的时候，当前节点以及其子节点都会被删除。</code></p><hr><h2 id="3-3-Json数据的封装"><a href="#3-3-Json数据的封装" class="headerlink" title="3.3 Json数据的封装"></a>3.3 Json数据的封装</h2><h3 id="3-3-1-Json对象操作举例"><a href="#3-3-1-Json对象操作举例" class="headerlink" title="3.3.1 Json对象操作举例"></a>3.3.1 Json对象操作举例</h3><blockquote><p>创建一个对象，并向这个对象里添加字符串和整型键值：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;cJSON.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    cJSON * root;</span><br><span class="line">    cJSON *arry;</span><br><span class="line"></span><br><span class="line">    root=cJSON_CreateObject();                     <span class="comment">// 创建根数据对象</span></span><br><span class="line">    cJSON_AddStringToObject(root,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;luffy&quot;</span>);  <span class="comment">// 添加键值对</span></span><br><span class="line">    cJSON_AddStringToObject(root,<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;man&quot;</span>);     <span class="comment">// 添加键值对</span></span><br><span class="line">    cJSON_AddNumberToObject(root,<span class="string">&quot;age&quot;</span>,<span class="number">19</span>);        <span class="comment">// 添加键值对</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *out = cJSON_Print(root);   <span class="comment">// 将json形式转换成字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,out);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存  </span></span><br><span class="line">    cJSON_Delete(root);  </span><br><span class="line">    <span class="built_in">free</span>(out);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>:<span class="string">&quot;luffy&quot;</span>,</span><br><span class="line"><span class="string">&quot;sex&quot;</span>:<span class="string">&quot;man&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>:<span class="number">19</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若干说明:</p><ol><li><code>cJSON_CreateObject</code>函数可创建一个根对象，返回的是一个 <code>cJSON</code>指针，在这个指针用完了以后，需要手动调用 <code>cJSON_Delete(root)</code>进行内存回收。</li><li>函数<code>cJSON_Print()</code>内部封装了malloc函数，所以需要使用<code>free()</code>函数释放被<code>out</code>占用的内存空间。</li></ol><hr><h3 id="3-3-2-Json数组操作举例"><a href="#3-3-2-Json数组操作举例" class="headerlink" title="3.3.2 Json数组操作举例"></a>3.3.2 Json数组操作举例</h3><blockquote><p>创建一个数组，并向数组添加一个字符串和一个数字</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    cJSON *root;</span><br><span class="line">    root = cJSON_CreateArray();</span><br><span class="line">    cJSON_AddItemToArray(root, cJSON_CreateString(<span class="string">&quot;Hello world&quot;</span>));</span><br><span class="line">    cJSON_AddItemToArray(root, cJSON_CreateNumber(<span class="number">10</span>)); </span><br><span class="line">    <span class="comment">// char *s = cJSON_Print(root);</span></span><br><span class="line">    <span class="type">char</span> *s = cJSON_PrintUnformatted(root);</span><br><span class="line">    <span class="keyword">if</span>(s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %s \n&quot;</span>,s);</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    cJSON_Delete(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果:</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;Hello world&quot;</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="3-3-3-Json对象、数组嵌套使用"><a href="#3-3-3-Json对象、数组嵌套使用" class="headerlink" title="3.3.3 Json对象、数组嵌套使用"></a>3.3.3 Json对象、数组嵌套使用</h3><blockquote><p>对象里面包括一个数组，数组里面包括对象，对象里面再添加一个字符串和一个数字</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;person&quot;</span>:[&#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>:<span class="string">&quot;luffy&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>:<span class="number">19</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    cJSON *root, *body, *<span class="built_in">list</span>;</span><br><span class="line">    <span class="comment">// josn 对象 root</span></span><br><span class="line">    root = cJSON_CreateObject();</span><br><span class="line">    <span class="comment">// root 添加键值对 person:json数组A</span></span><br><span class="line">    cJSON_AddItemToObject(root,<span class="string">&quot;person&quot;</span>, body = cJSON_CreateArray());</span><br><span class="line">    <span class="comment">// json数组A 添加Json对象B</span></span><br><span class="line">    cJSON_AddItemToArray(body, <span class="built_in">list</span> = cJSON_CreateObject());</span><br><span class="line">    <span class="comment">// 在json对象B中添加键值对: &quot;name&quot;:&quot;luffy&quot;</span></span><br><span class="line">    cJSON_AddStringToObject(<span class="built_in">list</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;luffy&quot;</span>);</span><br><span class="line">    <span class="comment">// 在json对象B中添加键值对: &quot;age&quot;:19</span></span><br><span class="line">    cJSON_AddNumberToObject(<span class="built_in">list</span>,<span class="string">&quot;age&quot;</span>,<span class="number">19</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// char *s = cJSON_Print(root);</span></span><br><span class="line">    <span class="type">char</span> *s = cJSON_PrintUnformatted(root);</span><br><span class="line">    <span class="keyword">if</span>(s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %s \n&quot;</span>,s);</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        cJSON_Delete(root); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;person&quot;</span>:[&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;luffy&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">19</span>&#125;]&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-4-解析Json字符串"><a href="#3-4-解析Json字符串" class="headerlink" title="3.4 解析Json字符串"></a>3.4 解析Json字符串</h2><h3 id="3-4-1-解析Json对象"><a href="#3-4-1-解析Json对象" class="headerlink" title="3.4.1 解析Json对象"></a>3.4.1 解析Json对象</h3><p>Json字符串的解析流程和数据的封装流程相反，假设我们有这样一个Json字符串（字符串中的双引号需要通过转义字符将其转译为普通字符）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;\<span class="string">&quot;name\&quot;:\&quot;luffy\&quot;,\&quot;sex\&quot;:\&quot;man\&quot;,\&quot;age\&quot;:19&#125;</span></span><br></pre></td></tr></table></figure><p><strong>示例代码如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cJSON.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    cJSON *json, *name, *sex, *age;</span><br><span class="line">    <span class="type">char</span>* out=<span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;luffy\&quot;,\&quot;sex\&quot;:\&quot;man\&quot;,\&quot;age\&quot;:19&#125;&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    json = cJSON_Parse(out); <span class="comment">//解析成json形式</span></span><br><span class="line">    name = cJSON_GetObjectItem(json, <span class="string">&quot;name&quot;</span>);  <span class="comment">//获取键值内容</span></span><br><span class="line">    sex = cJSON_GetObjectItem(json, <span class="string">&quot;sex&quot;</span>);</span><br><span class="line">    age = cJSON_GetObjectItem(json, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name:%s,sex:%s,age:%d\n&quot;</span>, name-&gt;valuestring, sex-&gt;valuestring, age-&gt;valueint);</span><br><span class="line"> </span><br><span class="line">    cJSON_Delete(json);  <span class="comment">//释放内存 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出的结果:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name</span>:luffy,<span class="attr">sex</span>:man,<span class="attr">age</span>:<span class="number">19</span></span><br></pre></td></tr></table></figure><p><code>如果是在严格的场所，应该先判定每个 item 的 type，然后再考虑去取值。</code></p><hr><h3 id="3-4-2-解析嵌套的Json对象"><a href="#3-4-2-解析嵌套的Json对象" class="headerlink" title="3.4.2 解析嵌套的Json对象"></a>3.4.2 解析嵌套的Json对象</h3><blockquote><p>解析一个嵌套的Json对象，数据如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;\<span class="string">&quot;list\&quot;:&#123;\&quot;name\&quot;:\&quot;luffy\&quot;,\&quot;age\&quot;:19&#125;,\&quot;other\&quot;:&#123;\&quot;name\&quot;:\&quot;ace\&quot;&#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;&#123;\&quot;list\&quot;:&#123;\&quot;name\&quot;:\&quot;luffy\&quot;,\&quot;age\&quot;:19&#125;,\&quot;other\&quot;:&#123;\&quot;name\&quot;:\&quot;ace\&quot;&#125;&#125;&quot;</span>;</span><br><span class="line">    cJSON *root = cJSON_Parse(s);</span><br><span class="line">    <span class="keyword">if</span>(!root) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;get root faild !\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cJSON *js_list = cJSON_GetObjectItem(root, <span class="string">&quot;list&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!js_list) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no list!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;list type is %d\n&quot;</span>,js_list-&gt;type);</span><br><span class="line"></span><br><span class="line">    cJSON *name = cJSON_GetObjectItem(js_list, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!name) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No name !\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name type is %d\n&quot;</span>,name-&gt;type);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name is %s\n&quot;</span>,name-&gt;valuestring);</span><br><span class="line"></span><br><span class="line">    cJSON *age = cJSON_GetObjectItem(js_list, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!age) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no age!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age type is %d\n&quot;</span>, age-&gt;type);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age is %d\n&quot;</span>,age-&gt;valueint);</span><br><span class="line"></span><br><span class="line">    cJSON *js_other = cJSON_GetObjectItem(root, <span class="string">&quot;other&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!js_other) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no list!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;list type is %d\n&quot;</span>,js_other-&gt;type);</span><br><span class="line"></span><br><span class="line">    cJSON *js_name = cJSON_GetObjectItem(js_other, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!js_name) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No name !\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name type is %d\n&quot;</span>,js_name-&gt;type);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name is %s\n&quot;</span>,js_name-&gt;valuestring);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        cJSON_Delete(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list type is <span class="number">6</span></span><br><span class="line">name type is <span class="number">4</span></span><br><span class="line">name is luffy</span><br><span class="line">age type is <span class="number">3</span></span><br><span class="line">age is <span class="number">19</span></span><br><span class="line">list type is <span class="number">6</span></span><br><span class="line">name type is <span class="number">4</span></span><br><span class="line">name is ace</span><br></pre></td></tr></table></figure><hr><h3 id="3-4-3-解析Json数组"><a href="#3-4-3-解析Json数组" class="headerlink" title="3.4.3 解析Json数组"></a>3.4.3 解析Json数组</h3><p>如果我们遇到的Json字符串是一个Json数组格式，处理方式和Json对象差不多，比如我们要解析如下字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;\<span class="string">&quot;names\&quot;:[\&quot;luffy\&quot;,\&quot;robin\&quot;]&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;&#123;\&quot;names\&quot;:[\&quot;luffy\&quot;,\&quot;robin\&quot;]&#125;&quot;</span>;</span><br><span class="line">    cJSON *root = cJSON_Parse(s);</span><br><span class="line">    <span class="keyword">if</span>(!root) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;get root faild !\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cJSON *js_list = cJSON_GetObjectItem(root, <span class="string">&quot;names&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!js_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no list!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> array_size = cJSON_GetArraySize(js_list);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array size is %d\n&quot;</span>,array_size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; array_size; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        cJSON *item = cJSON_GetArrayItem(js_list, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;item type is %d\n&quot;</span>,item-&gt;type);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,item-&gt;valuestring);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        cJSON_Delete(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-4-4-解析嵌套的Json对象和数组"><a href="#3-4-4-解析嵌套的Json对象和数组" class="headerlink" title="3.4.4 解析嵌套的Json对象和数组"></a>3.4.4 解析嵌套的Json对象和数组</h3><p>对于Json字符串最复杂的个数莫过于Json对象和Json数组嵌套的形式，通过一个例子演示一下应该如何解析，字符串格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;\<span class="string">&quot;list\&quot;:[&#123;\&quot;name\&quot;:\&quot;luffy\&quot;,\&quot;age\&quot;:19&#125;,&#123;\&quot;name\&quot;:\&quot;sabo\&quot;,\&quot;age\&quot;:21&#125;]&#125;</span></span><br></pre></td></tr></table></figure><p>在解析的时候，我们只需要按照从属关系，一层层解析即可：</p><ol><li>根节点是一个Json对象，基于根节点中的key值取出对应的value值，得到一个Json数组</li><li>读出Json数组的大小，遍历里边的各个元素，每个元素都是一个Json对象</li><li>将Json对象中的键值对根据key值取出对应的value值</li><li>从取出的Value值中读出实际类型对应的数值</li></ol><p><strong>示例代码如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cJSON.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;&#123;\&quot;list\&quot;:[&#123;\&quot;name\&quot;:\&quot;luffy\&quot;,\&quot;age\&quot;:19&#125;,&#123;\&quot;name\&quot;:\&quot;sabo\&quot;,\&quot;age\&quot;:21&#125;]&#125;&quot;</span>;</span><br><span class="line">    cJSON *root = cJSON_Parse(s);</span><br><span class="line">    <span class="keyword">if</span>(!root) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;get root faild !\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cJSON *<span class="built_in">list</span> = cJSON_GetObjectItem(root, <span class="string">&quot;list&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">list</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no list!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> array_size = cJSON_GetArraySize(<span class="built_in">list</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array size is %d\n&quot;</span>,array_size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; array_size; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        cJSON* item = cJSON_GetArrayItem(<span class="built_in">list</span>, i);</span><br><span class="line">        cJSON* name = cJSON_GetObjectItem(item, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;name is %s\n&quot;</span>,name-&gt;valuestring);</span><br><span class="line">        cJSON* age = cJSON_GetObjectItem(item, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;age is %d\n&quot;</span>,age-&gt;valueint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        cJSON_Delete(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="4-jsoncpp的编译和使用"><a href="#4-jsoncpp的编译和使用" class="headerlink" title="4. jsoncpp的编译和使用"></a>4. jsoncpp的编译和使用</h1><h2 id="4-1-下载和编译"><a href="#4-1-下载和编译" class="headerlink" title="4.1 下载和编译"></a>4.1 下载和编译</h2><h3 id="4-1-1-下载"><a href="#4-1-1-下载" class="headerlink" title="4.1.1 下载"></a>4.1.1 下载</h3><p><strong>下载 jsoncpp</strong><br>Jsoncpp是个跨平台的C++开源库，提供的类为我们提供了很便捷的操作，而且使用的人也很多。在使用之前我们首先要从github仓库下载<a href="https://github.com/open-source-parsers/jsoncpp">源码</a></p><p><strong>下载 cmake 工具</strong><br>由于都是基于VS进行项目开发，下载的源码我们一般不会直接使用，而且将其编译成相应的库文件（动态库或者静态库），这样不论是从使用或者部署的角度来说，操作起来都会更方便一些。</p><p>但是，从github下载的源码不能直接通过VS打开，编译就更谈不上了。它提供的默认编译方式是cmake。我们可以通过使用cmake工具将下载的jsoncpp源码生成一个VS项目，这样就可以通过VS编译出需要的库文件了。</p><p><a href="https://cmake.org/download/">官方下载地址</a></p><hr><h3 id="4-1-2-生成VS项目"><a href="#4-1-2-生成VS项目" class="headerlink" title="4.1.2 生成VS项目"></a>4.1.2 生成VS项目</h3><p>打开CMake</p><p><img src="/img/b.1.png" alt="在这里插入图片描述"></p><p>需要在工具中指定本地的jsoncpp路径（git clone 之后就会得到这个目录），这是我本地的目录：<br><img src="/img/b.2.png" alt="在这里插入图片描述"></p><p>第二个需要指定的是一个文件存储路径（生成的VS项目会保存到这个目录下），保证这是一个本地的有效目录即可。</p><p><img src="/img/b.3.png" alt="在这里插入图片描述"></p><p>设置好之后进行配置，点击Configure按钮</p><p><img src="/img/b.4.png" alt="在这里插入图片描述"></p><p>此处需要设置一下，VS的版本以及生成器的平台位数，不填默认就是64位。</p><p><img src="/img/b.5.png" alt="在这里插入图片描述"></p><p>配置完成，开始生成VS项目。</p><p><img src="/img/b.6.png" alt="在这里插入图片描述"></p><p>打开在CMake工具中指定的生成目录，我这里是D:\output-project，基于项目文件jsoncpp.sln打开这个VS项目。</p><hr><h3 id="4-1-3-编译"><a href="#4-1-3-编译" class="headerlink" title="4.1.3 编译"></a>4.1.3 编译</h3><p>基于生成的项目文件打开VS项目之后，可以看到里边有很多子项目</p><p><img src="/img/b.7.png" alt="在这里插入图片描述"></p><p>我们只需要编译上图标记的那一个就可以了，编译成功之后就可以得到我们需要的库文件了。</p><p><img src="/img/b.8.png" alt="在这里插入图片描述"></p><p>通过输出的日志信息，就能找到我们想要的动态库了，把这两个文件收集起来备用。</p><hr><h2 id="4-2-jsoncpp-的使用"><a href="#4-2-jsoncpp-的使用" class="headerlink" title="4.2 jsoncpp 的使用"></a>4.2 jsoncpp 的使用</h2><p><code>jsoncpp</code>库中的类被定义到了一个Json命名空间中，建议在使用这个库的时候先声明这个命名空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Json;</span><br></pre></td></tr></table></figure><p>使用<code>jsoncpp</code>库解析<code>json</code>格式的数据，我们只需要掌握三个类：</p><ol><li><code>Value 类</code>：将json支持的数据类型进行了包装，最终得到一个Value类型</li><li><code>FastWriter类</code>：将Value对象中的数据序列化为字符串</li><li><code>Reader类</code>：反序列化, 将json字符串 解析成 Value 类型</li></ol><h3 id="4-2-1-Value类"><a href="#4-2-1-Value类" class="headerlink" title="4.2.1 Value类"></a>4.2.1 Value类</h3><p>这个类可以看做是一个包装器，它可以封装Json支持的所有类型，这样我们在处理数据的时候就方便多了。</p><table><thead><tr><th>枚举类型</th><th>说明</th><th>翻译</th></tr></thead><tbody><tr><td>nullValue</td><td>‘null’ value</td><td>不表示任何数据，空值</td></tr><tr><td>intValue</td><td>signed integer value</td><td>表示有符号整数</td></tr><tr><td>uintValue</td><td>unsigned integer value</td><td>表示无符号整数</td></tr><tr><td>realValue</td><td>double value</td><td>表示浮点数</td></tr><tr><td>stringValue</td><td>UTF-8 string value</td><td>表示utf8格式的字符串</td></tr><tr><td>booleanValue</td><td>bool value</td><td>表示布尔数</td></tr><tr><td>arrayValue</td><td>array value (ordered list)</td><td>表示数组，即JSON串中的[]</td></tr><tr><td>objectValue</td><td>object value (collection of name&#x2F;value pairs)</td><td>表示键值对，即JSON串中的{}</td></tr></tbody></table><p><strong>构造函数</strong><br>Value类为我们提供了很多构造函数，通过构造函数来封装数据，最终得到一个统一的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为Json::Value已经实现了各种数据类型的构造函数</span></span><br><span class="line"><span class="built_in">Value</span>(ValueType type = nullValue);</span><br><span class="line"><span class="built_in">Value</span>(Int value);</span><br><span class="line"><span class="built_in">Value</span>(UInt value);</span><br><span class="line"><span class="built_in">Value</span>(Int64 value);</span><br><span class="line"><span class="built_in">Value</span>(UInt64 value);</span><br><span class="line"><span class="built_in">Value</span>(<span class="type">double</span> value);</span><br><span class="line"><span class="built_in">Value</span>(<span class="type">const</span> <span class="type">char</span>* value);</span><br><span class="line"><span class="built_in">Value</span>(<span class="type">const</span> <span class="type">char</span>* begin, <span class="type">const</span> <span class="type">char</span>* end);</span><br><span class="line"><span class="built_in">Value</span>(<span class="type">bool</span> value);</span><br><span class="line"><span class="built_in">Value</span>(<span class="type">const</span> Value&amp; other);</span><br><span class="line"><span class="built_in">Value</span>(Value&amp;&amp; other);</span><br></pre></td></tr></table></figure><p><strong>检测保存的数据类型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测保存的数据类型</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBool</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isInt</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isInt64</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isUInt</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isUInt64</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isIntegral</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDouble</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isNumeric</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isArray</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isObject</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong>将Value对象转换为实际类型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Int <span class="title">asInt</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">UInt <span class="title">asUInt</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">Int64 <span class="title">asInt64</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">UInt64 <span class="title">asUInt64</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">LargestInt <span class="title">asLargestInt</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">LargestUInt <span class="title">asLargestUInt</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">JSONCPP_STRING <span class="title">asString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">asFloat</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">asDouble</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">asBool</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">asCString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong>对json数组的操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ArrayIndex <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">Value&amp; <span class="keyword">operator</span>[](ArrayIndex index);</span><br><span class="line">Value&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index);</span><br><span class="line"><span class="type">const</span> Value&amp; <span class="keyword">operator</span>[](ArrayIndex index) <span class="type">const</span>;</span><br><span class="line"><span class="type">const</span> Value&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span>;</span><br><span class="line"><span class="comment">// 根据下标的index返回这个位置的value值</span></span><br><span class="line"><span class="comment">// 如果没找到这个index对应的value, 返回第二个参数defaultValue</span></span><br><span class="line"><span class="function">Value <span class="title">get</span><span class="params">(ArrayIndex index, <span class="type">const</span> Value&amp; defaultValue)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">Value&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> Value&amp; value)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>对json对象的操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Value&amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">char</span>* key);</span><br><span class="line"><span class="type">const</span> Value&amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">char</span>* key) <span class="type">const</span>;</span><br><span class="line">Value&amp; <span class="keyword">operator</span>[](<span class="type">const</span> JSONCPP_STRING&amp; key);</span><br><span class="line"><span class="type">const</span> Value&amp; <span class="keyword">operator</span>[](<span class="type">const</span> JSONCPP_STRING&amp; key) <span class="type">const</span>;</span><br><span class="line">Value&amp; <span class="keyword">operator</span>[](<span class="type">const</span> StaticString&amp; key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过key, 得到value值</span></span><br><span class="line"><span class="function">Value <span class="title">get</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key, <span class="type">const</span> Value&amp; defaultValue)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">Value <span class="title">get</span><span class="params">(<span class="type">const</span> JSONCPP_STRING&amp; key, <span class="type">const</span> Value&amp; defaultValue)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">Value <span class="title">get</span><span class="params">(<span class="type">const</span> CppTL::ConstString&amp; key, <span class="type">const</span> Value&amp; defaultValue)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到对象中所有的键值</span></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::string&gt; Members;</span><br><span class="line"><span class="function">Members <span class="title">getMemberNames</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong>将Value对象数据序列化为string</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化得到的字符串有样式 -&gt; 带换行 -&gt; 方便阅读</span></span><br><span class="line"><span class="comment">// 写配置文件的时候</span></span><br><span class="line"><span class="function">std::string <span class="title">toStyledString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="4-2-2-FastWriter-类"><a href="#4-2-2-FastWriter-类" class="headerlink" title="4.2.2 FastWriter 类"></a>4.2.2 FastWriter 类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数据序列化 -&gt; 单行</span></span><br><span class="line"><span class="comment">// 进行数据的网络传输</span></span><br><span class="line">std::string Json::FastWriter::<span class="built_in">write</span>(<span class="type">const</span> Value&amp; root);</span><br></pre></td></tr></table></figure><hr><h3 id="4-2-3-Reader-类"><a href="#4-2-3-Reader-类" class="headerlink" title="4.2.3 Reader 类"></a>4.2.3 Reader 类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Json::Reader::<span class="built_in">parse</span>(<span class="type">const</span> std::string&amp; document,</span><br><span class="line">    Value&amp; root, <span class="type">bool</span> collectComments = <span class="literal">true</span>);</span><br><span class="line">    参数:</span><br><span class="line">        - document: json格式字符串</span><br><span class="line">        - root: 传出参数, 存储了json字符串中解析出的数据</span><br><span class="line">        - collectComments: 是否保存json字符串中的注释信息</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过begindoc和enddoc指针定位一个json字符串</span></span><br><span class="line"><span class="comment">// 这个字符串可以是完成的json字符串, 也可以是部分json字符串</span></span><br><span class="line"><span class="type">bool</span> Json::Reader::<span class="built_in">parse</span>(<span class="type">const</span> <span class="type">char</span>* beginDoc, <span class="type">const</span> <span class="type">char</span>* endDoc,</span><br><span class="line">    Value&amp; root, <span class="type">bool</span> collectComments = <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// write的文件流  -&gt; ofstream</span></span><br><span class="line"><span class="comment">// read的文件流   -&gt; ifstream</span></span><br><span class="line"><span class="comment">// 假设要解析的json数据在磁盘文件中</span></span><br><span class="line"><span class="comment">// is流对象指向一个磁盘文件, 读操作</span></span><br><span class="line"><span class="type">bool</span> Json::Reader::<span class="built_in">parse</span>(std::istream&amp; is, Value&amp; root, <span class="type">bool</span> collectComments = <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="4-3-VS的配置"><a href="#4-3-VS的配置" class="headerlink" title="4.3 VS的配置"></a>4.3 VS的配置</h2><p>如果想要在VS中使用编译出的<code>jsoncpp</code>库，我们还需要做如下配置：</p><h3 id="4-3-1-头文件"><a href="#4-3-1-头文件" class="headerlink" title="4.3.1 头文件"></a>4.3.1 头文件</h3><p>在编码过程中需要在项目文件中包含从github下载得到的头文件，有两种处理方式：</p><ol><li><p>将头文件放到项目目录下，直接被项目包含引用</p></li><li><p>将头文件放到一个本地固定目录，以后就不再动了，在VS项目属性中设置包含这个目录，推荐这种</p></li></ol><p><img src="/img/b.9.png" alt="在这里插入图片描述"></p><p>另外，在这个<code>include</code>目录中还有一个<code>json</code>子目录，所有的头文件都在这个子目录中，我们不要破坏这个目录结构：</p><p><img src="/img/b.10.png" alt="在这里插入图片描述"></p><p>在包含需要的头文件的时候，使用如下这种方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>把本地的头文件目录在项目属性窗口中进行配置：</p><p><img src="/img/b.11.png" alt="在这里插入图片描述"></p><p>这里头文件是放到了C盘的jsoncpp目录中：</p><p><img src="/img/b.12.png" alt="在这里插入图片描述"></p><hr><h3 id="4-3-2-库文件"><a href="#4-3-2-库文件" class="headerlink" title="4.3.2 库文件"></a>4.3.2 库文件</h3><p>我这里也是将生成的<code>jsoncpp.lib</code>和<code>jsoncpp.dll</code>放到了C盘（<code>C:\jsoncpp\lib</code>），在VS项目中需要指定这个库路径：</p><p><img src="/img/b.13.png" alt="在这里插入图片描述"><br><img src="/img/b.14.png" alt="在这里插入图片描述"></p><p>另外，还需要告诉VS需要加载的动态库是哪一个</p><p><img src="/img/b.15.png" alt="在这里插入图片描述"></p><p>此处指定的是动态库对应的<code>lib</code>文件，也就是<code>jsoncpp.lib</code></p><p><img src="/img/b.16.png" alt="在这里插入图片描述"></p><p>配置完成之后，如果项目中使用了<code>jsoncpp</code>就可以编译通过了。在程序执行的时候，如果提示找不到<code>jsoncpp</code>的动态库，<code>把 jsoncpp.dll 拷贝到可执行所在的目录下就可以解决了。</code></p><hr><h2 id="4-3-示例代码"><a href="#4-3-示例代码" class="headerlink" title="4.3 示例代码"></a>4.3 示例代码</h2><p>比如：我们要将下面这个Json数组写入的一个文件中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="number">12</span>, </span><br><span class="line">    <span class="number">12.34</span>, </span><br><span class="line">    <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;tom&quot;</span>, </span><br><span class="line">    [<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;ace&quot;</span>, <span class="string">&quot;robin&quot;</span>], </span><br><span class="line">    &#123;<span class="string">&quot;sex&quot;</span>:<span class="string">&quot;man&quot;</span>, <span class="string">&quot;girlfriend&quot;</span>:<span class="string">&quot;lucy&quot;</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Json;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">writeJson</span>();</span><br><span class="line">    <span class="built_in">readJson</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-3-1-写json文件"><a href="#4-3-1-写json文件" class="headerlink" title="4.3.1 写json文件"></a>4.3.1 写json文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeJson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将最外层的数组看做一个Value</span></span><br><span class="line">    <span class="comment">// 最外层的Value对象创建</span></span><br><span class="line">    Value root;</span><br><span class="line">    <span class="comment">// Value有一个参数为int 行的构造函数</span></span><br><span class="line">    root.<span class="built_in">append</span>(<span class="number">12</span>);<span class="comment">// 参数进行隐式类型转换</span></span><br><span class="line">    root.<span class="built_in">append</span>(<span class="number">12.34</span>);</span><br><span class="line">    root.<span class="built_in">append</span>(<span class="literal">true</span>);</span><br><span class="line">    root.<span class="built_in">append</span>(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建并初始化一个子数组</span></span><br><span class="line">    Value subArray;</span><br><span class="line">    subArray.<span class="built_in">append</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    subArray.<span class="built_in">append</span>(<span class="string">&quot;ace&quot;</span>);</span><br><span class="line">    subArray.<span class="built_in">append</span>(<span class="string">&quot;robin&quot;</span>);</span><br><span class="line">    root.<span class="built_in">append</span>(subArray);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建并初始化子对象</span></span><br><span class="line">    Value subObj;</span><br><span class="line">    subObj[<span class="string">&quot;sex&quot;</span>] = <span class="string">&quot;woman&quot;</span>;  <span class="comment">// 添加键值对</span></span><br><span class="line">    subObj[<span class="string">&quot;girlfriend&quot;</span>] = <span class="string">&quot;lucy&quot;</span>;</span><br><span class="line">    root.<span class="built_in">append</span>(subObj);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    <span class="comment">// 有格式的字符串</span></span><br><span class="line">    string str = root.<span class="built_in">toStyledString</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    FastWriter f;</span><br><span class="line">    string str = f.<span class="built_in">write</span>(root);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 将序列化的字符串写磁盘文件</span></span><br><span class="line">    <span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;test.json&quot;</span>)</span></span>;</span><br><span class="line">    ofs &lt;&lt; str;</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-3-2-读json文件"><a href="#4-3-2-读json文件" class="headerlink" title="4.3.2 读json文件"></a>4.3.2 读json文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">readJson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 将磁盘文件中的json字符串读到磁盘文件</span></span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;test.json&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 2. 反序列化 -&gt; value对象</span></span><br><span class="line">    Value root;</span><br><span class="line">    Reader r;</span><br><span class="line">    r.<span class="built_in">parse</span>(ifs, root);</span><br><span class="line">    <span class="comment">// 3. 从value对象中将数据依次读出</span></span><br><span class="line">    <span class="keyword">if</span> (root.<span class="built_in">isArray</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 数组, 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; root.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 依次取出各个元素, 类型是value类型</span></span><br><span class="line">            Value item = root[i];</span><br><span class="line">            <span class="comment">// 判断item中存储的数据的类型</span></span><br><span class="line">            <span class="keyword">if</span> (item.<span class="built_in">isString</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; item.<span class="built_in">asString</span>() &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="built_in">isInt</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; item.<span class="built_in">asInt</span>() &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="built_in">isBool</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; item.<span class="built_in">asBool</span>() &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="built_in">isDouble</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; item.<span class="built_in">asFloat</span>() &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="built_in">isArray</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; item.<span class="built_in">size</span>(); ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; item[j].<span class="built_in">asString</span>() &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="built_in">isObject</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 对象</span></span><br><span class="line">                <span class="comment">// 得到所有的key</span></span><br><span class="line">                Value::Members keys = item.<span class="built_in">getMemberNames</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; keys.<span class="built_in">size</span>(); ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; keys.<span class="built_in">at</span>(k) &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; item[keys[k]] &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面读Json文件的这段代码中，对读出的每个Value类型的节点进行了类型判断，其实一般情况下是不需要做这样的判断的，因为我们在解析的时候是明确地知道该节点的类型的。</p><p>虽然Json这种格式无外乎数组和对象两种，但是需求不同我们设计的Json文件的组织方式也不同，一般都是特定的文件对应特定的解析函数，一个解析函数可以解析任何的Json文件这种设计思路是坚决不推荐的。</p><hr><h1 id="5-Qt程序打包和发布"><a href="#5-Qt程序打包和发布" class="headerlink" title="5. Qt程序打包和发布"></a>5. Qt程序打包和发布</h1><h2 id="5-1-程序的发布"><a href="#5-1-程序的发布" class="headerlink" title="5.1 程序的发布"></a>5.1 程序的发布</h2><h3 id="5-1-1-生成Release版程序"><a href="#5-1-1-生成Release版程序" class="headerlink" title="5.1.1 生成Release版程序"></a>5.1.1 生成Release版程序</h3><p>在编写Qt程序的时候，不管我们使用的什么样的IDE都可以进行编译版本的切换，如果要发布程序需要切换为Release版本（Debug为调试版本），编译器会对生成的Release版可执行程序进行优化，生成的可执行程序会更小。这里以QtCreator为例，截图如下：</p><p><img src="/img/b.17.png" alt="在这里插入图片描述"></p><p>模式选择完毕之后开始构建当前项目，最后找到生成的带<code>Release</code>后缀的构建目录，如下图所示：</p><p><img src="/img/b.18.png" alt="在这里插入图片描述"></p><p>进图到release目录中，在里面就能找到我们要的可执行程序了</p><p><img src="/img/b.19.png" alt="在这里插入图片描述"></p><hr><h3 id="5-1-2-发布"><a href="#5-1-2-发布" class="headerlink" title="5.1.2 发布"></a>5.1.2 发布</h3><p>生成的可执行程序在运行的时候需要加载相关的Qt库文件，因此需要将这些动态库一并发布给使用者，Qt官方给我们提供了相关的发布工具，通过这个工具就可以非常轻松的找出这些动态库文件了，这个工具叫做<code>windeployqt.exe</code>，该文件位于Qt安装目录的编译套件目录的bin目录中，以我本地为例：<code>C:\Qt\5.15.2\mingw81_64\bin</code></p><ul><li>C:\Qt是Qt的安装目录</li><li>5.15.2是Qt的版本</li><li>mingw81_64是编译套件目录</li><li>bin存储windeployqt.exe文件的目录</li></ul><p>如果已经将这个路径设置到环境变量中了，那么在当前操作系统的任意目录下都可以访问<code>windeployqt.exe</code></p><p>知道Qt提供的这个工具之后就可以继续向下进行了，首先将生成的<code>Release</code>版本的可执行程序放到一个新建的空目录中：<br><img src="/img/b.20.png" alt="在这里插入图片描述"></p><p>进入到这个目录，按住键盘<code>shift</code>键然后鼠标右键就可以弹出一个右键菜单<br><img src="/img/b.21.png" alt="在这里插入图片描述"></p><p>打开Powershell窗口执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># LordCard.exe 是可执行程序的名字</span></span><br><span class="line"><span class="comment"># windeployqt.exe 的后缀 .exe 可以省略不写</span></span><br><span class="line">windeployqt.exe LordCard.exe</span><br></pre></td></tr></table></figure><p><img src="/img/b.22.png" alt="在这里插入图片描述"></p><p>这样<code>LordCard.exe</code>需要的动态库会被全部拷贝到当前的目录中，如下图：<br><img src="/img/b.23.png" alt="在这里插入图片描述"></p><p><code>使用这种方式Qt会将一些用不到的动态库也拷贝到当前的目录中，如果确定用不到可以手动将其删除，如果不在意这些，完全可以不用理会，选择后者。</code></p><p>现在一个绿色免安装版的程序就得到了，可以将这个目录打个压缩包发送</p><hr><h2 id="5-2-Qt程序打包"><a href="#5-2-Qt程序打包" class="headerlink" title="5.2 Qt程序打包"></a>5.2 Qt程序打包</h2><p>将应用程序和相关的动态库打包成安装包的工具有很多，我自己用过两个一个是<code>NIS Edit</code>，一个是<code>Inno Setup</code>这是一个免费的 Windows 安装程序制作软件，小巧、简便、精美。</p><p><a href="http://www.jrsoftware.org/isdl.php#stable">官方下载地址</a></p><p>其实这两个工具的使用方法是几乎一样的，下面拿<code>Inno Setup</code>使用举例。</p><p><strong>第一步：创建一个带向导的脚本文件</strong><br><img src="/img/b.24.png" alt="在这里插入图片描述"></p><p><strong>第二步：直接 Next，不要创建空的脚本文件</strong></p><p><img src="/img/b.25.png" alt="在这里插入图片描述"></p><p><strong>第三步：填写相关的应用程序信息</strong><br><img src="/img/b.26.png" alt="在这里插入图片描述"></p><p><strong>第四步：指定应用程序的安装目录相关的信息</strong><br><img src="/img/b.27.png" alt="在这里插入图片描述"></p><p><strong>第五步：选择可执行程序和相关的动态库，此处参考的是前边的 1.2 章节中的目录</strong><br><img src="/img/b.28.png" alt="在这里插入图片描述"></p><p>基于这个目录选择相关的文件和目录：<br><img src="/img/b.29.png" alt="在这里插入图片描述"></p><p>由于可执行程序关系的动态库有很多，所以可以直接添加动态库的目录，选中对应的目录之后，如果里边还有子目录会弹出如下对话框，选择是即可，需要包含这些子目录。<br><img src="/img/b.30.png" alt="在这里插入图片描述"></p><p><strong>第六步：给可执行程序关联本地的某种格式的磁盘文件（比如记事本程序会自动关联本地的 .txt 文件），对于我的可执行程序来说无需关联，因此没有做任何设置，直接下一步</strong><br><img src="/img/b.31.png" alt="在这里插入图片描述"></p><p><strong>第七步：给应用程序创建快捷方式，此处没有进行任何设置，使用的默认选项</strong><br><img src="/img/b.32.png" alt="在这里插入图片描述"></p><p><strong>第八步：指定许可文件，文件中的内容会显示到安装向导的相关窗口中，可以选择不指定，直接跳过。</strong><br><img src="/img/b.33.png" alt="在这里插入图片描述"></p><p><strong>第九步：选择安装模式（给系统的当前用户安装还是给所有用户安装），根据自己喜好指定即可</strong><br><img src="/img/b.34.png" alt="在这里插入图片描述"></p><p><strong>第十步：选择安装语言（这个工具没有提供中文，因此只能选择英文）</strong><br><img src="/img/b.35.png" alt="在这里插入图片描述"></p><p><strong>第十一步：指定安装包文件的相关信息</strong><br><img src="/img/b.36.png" alt="在这里插入图片描述"></p><p><strong>第十二步：向导结束</strong><br><img src="/img/b.37.png" alt="在这里插入图片描述"></p><p><strong>第十三步：提示是否要编译生成的脚本文件，脚本编译完成之后，安装包就生成了。</strong></p><p><img src="/img/b.38.png" alt="在这里插入图片描述"></p><p>之后弹出第二个对话框，建议通过向导生成的这个脚本文件，这样以后就可以直接基于这个脚本打包程序生成安装包了。<br><img src="/img/b.39.png" alt="在这里插入图片描述"></p><p><strong>编译完成之后，就可以去保存脚本文件的目录找生成的安装文件了</strong><br><img src="/img/b.40.png" alt="在这里插入图片描述"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-JSON&quot;&gt;&lt;a href=&quot;#1-JSON&quot; class=&quot;headerlink&quot; title=&quot;1. JSON&quot;&gt;&lt;/a&gt;1. JSON&lt;/h1&gt;&lt;p&gt;JSON(&lt;code&gt;JavaScrip Object Notation&lt;/code</summary>
      
    
    
    
    <category term="Qt" scheme="http://example.com/categories/Qt/"/>
    
    
    <category term="JSON" scheme="http://example.com/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>多线程和套接字通信</title>
    <link href="http://example.com/2023/10/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/"/>
    <id>http://example.com/2023/10/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/</id>
    <published>2023-10-22T01:54:27.000Z</published>
    <updated>2023-10-22T12:20:57.697Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-多线程的使用"><a href="#1-多线程的使用" class="headerlink" title="1. 多线程的使用"></a>1. 多线程的使用</h1><p>在进行桌面应用程序开发的时候， 假设应用程序在某些情况下需要处理比较复杂的逻辑， 如果只有一个线程去处理，就会导致窗口卡顿，无法处理用户的相关操作。这种情况下就需要使用多线程，其中一个线程处理窗口事件，其他线程进行逻辑运算，多个线程各司其职，不仅可以提高用户体验还可以提升程序的执行效率。</p><p>在qt中使用了多线程，有些事项是需要额外注意的：</p><ol><li>默认的线程在Qt中称之为窗口线程，也叫主线程，负责窗口事件处理或者窗口控件数据的更新</li><li>子线程负责后台的业务逻辑处理，子线程中不能对窗口对象做任何操作，这些事情需要交给窗口线程处理</li><li>主线程和子线程之间如果要进行数据的传递，需要使用Qt中的信号槽机制</li></ol><hr><h2 id="1-1-线程类-QThread"><a href="#1-1-线程类-QThread" class="headerlink" title="1.1 线程类 QThread"></a>1.1 线程类 QThread</h2><p>Qt中提供了一个线程类，通过这个类就可以创建子线程了，Qt中一共提供了两种创建子线程的方式，后边会依次介绍其使用方式。看一下这个类中提供的一些常用API函数：</p><h3 id="1-1-1-常用共用成员函数"><a href="#1-1-1-常用共用成员函数" class="headerlink" title="1.1.1 常用共用成员函数"></a>1.1.1 常用共用成员函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QThread 类常用 API</span></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QThread::<span class="built_in">QThread</span>(QObject *parent = Q_NULLPTR);</span><br><span class="line"><span class="comment">// 判断线程中的任务是不是处理完毕了</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThread::isFinished</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断子线程是不是在执行任务</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThread::isRunning</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Qt中的线程可以设置优先级</span></span><br><span class="line"><span class="comment">// 得到当前线程的优先级</span></span><br><span class="line"><span class="function">Priority <span class="title">QThread::priority</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QThread::setPriority</span><span class="params">(Priority priority)</span></span>;</span><br><span class="line">优先级:</span><br><span class="line">    QThread::IdlePriority         --&gt; 最低的优先级</span><br><span class="line">    QThread::LowestPriority</span><br><span class="line">    QThread::LowPriority</span><br><span class="line">    QThread::NormalPriority</span><br><span class="line">    QThread::HighPriority</span><br><span class="line">    QThread::HighestPriority</span><br><span class="line">    QThread::TimeCriticalPriority --&gt; 最高的优先级</span><br><span class="line">    QThread::InheritPriority      --&gt; 子线程和其父线程的优先级相同, 默认是这个</span><br><span class="line"><span class="comment">// 退出线程, 停止底层的事件循环</span></span><br><span class="line"><span class="comment">// 退出线程的工作函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QThread::exit</span><span class="params">(<span class="type">int</span> returnCode = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 调用线程退出函数之后, 线程不会马上退出因为当前任务有可能还没有完成, 调回用这个函数是</span></span><br><span class="line"><span class="comment">// 等待任务完成, 然后退出线程, 一般情况下会在 exit() 后边调用这个函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThread::wait</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> time = ULONG_MAX)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-2-信号槽"><a href="#1-1-2-信号槽" class="headerlink" title="1.1.2 信号槽"></a>1.1.2 信号槽</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和调用 exit() 效果是一样的</span></span><br><span class="line"><span class="comment">// 代用这个函数之后, 再调用 wait() 函数</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QThread::quit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 启动子线程</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QThread::start</span><span class="params">(Priority priority = InheritPriority)</span></span>;</span><br><span class="line"><span class="comment">// 线程退出, 可能是会马上终止线程, 一般情况下不使用这个函数</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QThread::terminate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程中执行的任务完成了, 发出该信号</span></span><br><span class="line"><span class="comment">// 任务函数中的处理逻辑执行完毕了</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QThread::finished</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 开始工作之前发出这个信号, 一般不使用</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QThread::started</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-3-静态函数"><a href="#1-1-3-静态函数" class="headerlink" title="1.1.3 静态函数"></a>1.1.3 静态函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个指向管理当前执行线程的QThread的指针</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QThread *<span class="title">QThread::currentThread</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回可以在系统上运行的理想线程数 == 和当前电脑的 CPU 核心数相同</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">int</span> <span class="title">QThread::idealThreadCount</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 线程休眠函数</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QThread::msleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> msecs)</span></span>;<span class="comment">// 单位: 毫秒</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QThread::sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> secs)</span></span>;<span class="comment">// 单位: 秒</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QThread::usleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> usecs)</span></span>;<span class="comment">// 单位: 微秒</span></span><br></pre></td></tr></table></figure><hr><h3 id="1-1-4-任务处理函数"><a href="#1-1-4-任务处理函数" class="headerlink" title="1.1.4 任务处理函数"></a>1.1.4 任务处理函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子线程要处理什么任务, 需要写到 run() 中</span></span><br><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QThread::run</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这个<code>run()</code>是一个虚函数，如果想让创建的子线程执行某个任务，需要写一个子类让其继承<code>QThread</code>，并且在子类中重写父类的<code>run()</code>方法，函数体就是对应的任务处理流程。另外，这个函数是一个受保护的成员函数，不能够在类的外部调用，如果想要让线程执行这个函数中的业务流程，需要通过当前线程对象调用槽函数<code>start()</code>启动子线程，当子线程被启动，这个<code>run()</code>函数也就在线程内部被调用了。</p><hr><h2 id="1-2-使用方式1"><a href="#1-2-使用方式1" class="headerlink" title="1.2 使用方式1"></a>1.2 使用方式1</h2><h3 id="1-2-1-操作步骤"><a href="#1-2-1-操作步骤" class="headerlink" title="1.2.1 操作步骤"></a>1.2.1 操作步骤</h3><p>Qt中提供的多线程的第一种使用方式的特点是： 简单。操作步骤如下：</p><ol><li>需要创建一个线程类的子类，让其继承QT中的线程类 QThread，比如:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>:<span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>重写父类的 run() 方法，在该函数内部编写子线程要处理的具体的业务流程</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>:<span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ........</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在主线程中创建子线程对象，new 一个就可以了</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyThread * subThread = <span class="keyword">new</span> MyThread;</span><br></pre></td></tr></table></figure><ol start="4"><li>启动子线程, 调用 start() 方法</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subThread-&gt;<span class="built_in">start</span>();</span><br></pre></td></tr></table></figure><p>不能在类的外部调用run() 方法启动子线程，在外部调用start()相当于让run()开始运行</p><p>当子线程别创建出来之后，父子线程之间的通信可以通过信号槽的方式，注意:</p><ul><li>在Qt中在子线程中不要操作程序中的窗口类型对象, 不允许, 如果操作了程序就挂了</li><li>只有主线程才能操作程序中的窗口对象, 默认的线程就是主线程, 自己创建的就是子线程</li></ul><hr><h3 id="1-2-2-示例代码"><a href="#1-2-2-示例代码" class="headerlink" title="1.2.2 示例代码"></a>1.2.2 示例代码</h3><p>举一个简单的数数的例子，假如只有一个线程，让其一直数数，会发现数字并不会在窗口中时时更新，并且这时候如果用户使用鼠标拖动窗口，就会出现无响应的情况，使用多线程就不会出现这样的现象了。</p><p>点击按钮开始在子线程中数数，让后通过信号槽机制将数据传递给UI线程，通过UI线程将数据更新到窗口中。</p><p><img src="/img/a.25.png" alt="在这里插入图片描述"></p><p><strong>mythread.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYTHREAD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYTHREAD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QThread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyThread</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">// 自定义信号, 传递数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">curNumber</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYTHREAD_H</span></span></span><br></pre></td></tr></table></figure><p><strong>mythread.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mythread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">MyThread::<span class="built_in">MyThread</span>(QObject *parent) : <span class="built_in">QThread</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyThread::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;当前线程对象的地址: &quot;</span> &lt;&lt; QThread::<span class="built_in">currentThread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">emit <span class="title">curNumber</span><span class="params">(num++)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">10000000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        QThread::<span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;run() 执行完毕, 子线程退出...&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mainwindow.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mythread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;主线程对象地址:  &quot;</span> &lt;&lt; QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    MyThread* subThread = <span class="keyword">new</span> MyThread;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(subThread, &amp;MyThread::curNumber, <span class="keyword">this</span>, [=](<span class="type">int</span> num)</span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;label-&gt;<span class="built_in">setNum</span>(num);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;startBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 启动子线程</span></span><br><span class="line">        subThread-&gt;<span class="built_in">start</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种在程序中添加子线程的方式是非常简单的，但是也有弊端<br><code>假设要在一个子线程中处理多个任务，所有的处理逻辑都需要写到run()函数中，这样该函数中的处理逻辑就会变得非常混乱，不太容易维护。</code></p><hr><h2 id="1-3-使用方式2"><a href="#1-3-使用方式2" class="headerlink" title="1.3 使用方式2"></a>1.3 使用方式2</h2><h3 id="1-3-1-操作步骤"><a href="#1-3-1-操作步骤" class="headerlink" title="1.3.1 操作步骤"></a>1.3.1 操作步骤</h3><p>Qt提供的第二种线程的创建方式弥补了第一种方式的缺点，用起来更加灵活，但是这种方式写起来会相对复杂一些，其具体操作步骤如下：</p><ol><li>创建一个新的类，让这个类从QObject派生</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span>:<span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在这个类中添加一个公共的成员函数，函数体就是我们要子线程中执行的业务逻辑</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span>:<span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    .......</span><br><span class="line">    <span class="comment">// 函数名自己指定, 叫什么都可以, 参数可以根据实际需求添加</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在主线程中创建一个QThread对象, 这就是子线程的对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QThread* sub = <span class="keyword">new</span> QThread;</span><br></pre></td></tr></table></figure><ol start="4"><li>在主线程中创建工作的类对象（千万不要指定给创建的对象指定父对象）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyWork* work = <span class="keyword">new</span> <span class="built_in">MyWork</span>(<span class="keyword">this</span>);    <span class="comment">// error</span></span><br><span class="line">MyWork* work = <span class="keyword">new</span> MyWork;          <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><ol start="5"><li>将MyWork对象移动到创建的子线程对象中, 需要调用QObject类提供的moveToThread()方法</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void QObject::moveToThread(QThread *targetThread);</span></span><br><span class="line"><span class="comment">// 如果给work指定了父对象, 这个函数调用就失败了</span></span><br><span class="line"><span class="comment">// 提示： QObject::moveToThread: Cannot move objects with a parent</span></span><br><span class="line">work-&gt;<span class="built_in">moveToThread</span>(sub);<span class="comment">// 移动到子线程中工作</span></span><br></pre></td></tr></table></figure><ol start="6"><li><p>启动子线程，调用 <code>start()</code>, 这时候线程启动了, 但是移动到线程中的对象并没有工作</p></li><li><p>调用MyWork类对象的工作函数，让这个函数开始执行，这时候是在移动到的那个子线程中运行的</p></li></ol><hr><h3 id="1-3-2-示例代码"><a href="#1-3-2-示例代码" class="headerlink" title="1.3.2 示例代码"></a>1.3.2 示例代码</h3><p>假设函数处理上面在程序中数数的这个需求，具体的处理代码如下：</p><p><strong>mywork.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYWORK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYWORK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyWork</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">curNumber</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYWORK_H</span></span></span><br></pre></td></tr></table></figure><p><strong>mywork.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mywork.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QThread&gt;</span></span></span><br><span class="line"></span><br><span class="line">MyWork::<span class="built_in">MyWork</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWork::working</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;当前线程对象的地址: &quot;</span> &lt;&lt; QThread::<span class="built_in">currentThread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">emit <span class="title">curNumber</span><span class="params">(num++)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">10000000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        QThread::<span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;run() 执行完毕, 子线程退出...&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mainwindow.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mywork.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;主线程对象的地址: &quot;</span> &lt;&lt; QThread::<span class="built_in">currentThread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程对象</span></span><br><span class="line">    QThread* sub = <span class="keyword">new</span> QThread;</span><br><span class="line">    <span class="comment">// 创建工作的类对象</span></span><br><span class="line">    <span class="comment">// 千万不要指定给创建的对象指定父对象</span></span><br><span class="line">    <span class="comment">// 如果指定了: QObject::moveToThread: Cannot move objects with a parent</span></span><br><span class="line">    MyWork* work = <span class="keyword">new</span> MyWork;</span><br><span class="line">    <span class="comment">// 将工作的类对象移动到创建的子线程对象中</span></span><br><span class="line">    work-&gt;<span class="built_in">moveToThread</span>(sub);</span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    sub-&gt;<span class="built_in">start</span>();</span><br><span class="line">    <span class="comment">// 让工作的对象开始工作, 点击开始按钮, 开始工作</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;startBtn, &amp;QPushButton::clicked, work, &amp;MyWork::working);</span><br><span class="line">    <span class="comment">// 显示数据</span></span><br><span class="line">    <span class="built_in">connect</span>(work, &amp;MyWork::curNumber, <span class="keyword">this</span>, [=](<span class="type">int</span> num)</span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;label-&gt;<span class="built_in">setNum</span>(num);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种多线程方式，假设有多个不相关的业务流程需要被处理，那么就可以创建多个类似于<code>MyWork</code>的类，将业务流程放多类的公共成员函数中，然后将这个业务类的实例对象移动到对应的子线程中<code>moveToThread()</code>就可以了，这样可让编写的程序更灵活，可读性强，易于维护。</p><hr><h1 id="2-线程池的使用"><a href="#2-线程池的使用" class="headerlink" title="2. 线程池的使用"></a>2. 线程池的使用</h1><h2 id="2-1-QRunnable"><a href="#2-1-QRunnable" class="headerlink" title="2.1 QRunnable"></a>2.1 QRunnable</h2><p>在Qt中使用线程池需要先创建任务，添加到线程池中的每一个任务都需要是一个<code>QRunnable</code>类型，因此在程序中需要创建子类继承<code>QRunnable</code>这个类，然后重写 <code>run()</code> 方法，在这个函数中编写要在线程池中执行的任务，并将这个子类对象传递给线程池，这样任务就可以被线程池中的某个工作的线程处理掉了。</p><p><code>QRunnable</code>类 常用函数不多，主要是设置任务对象传给线程池后，是否需要自动析构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在子类中必须要重写的函数, 里边是任务的处理流程</span></span><br><span class="line">[pure <span class="keyword">virtual</span>] <span class="function"><span class="type">void</span> <span class="title">QRunnable::run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数设置为 true: 这个任务对象在线程池中的线程中处理完毕, 这个任务对象就会自动销毁</span></span><br><span class="line"><span class="comment">// 参数设置为 false: 这个任务对象在线程池中的线程中处理完毕, 对象需要程序猿手动销毁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRunnable::setAutoDelete</span><span class="params">(<span class="type">bool</span> autoDelete)</span></span>;</span><br><span class="line"><span class="comment">// 获取当前任务对象的析构方式,返回true-&gt;自动析构, 返回false-&gt;手动析构</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QRunnable::autoDelete</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>创建一个要添加到线程池中的任务类，处理方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span> : <span class="keyword">public</span> QObject, <span class="keyword">public</span> QRunnable</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyWork</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 任务执行完毕,该对象自动销毁</span></span><br><span class="line">        <span class="built_in">setAutoDelete</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyWork</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中<code>MyWork</code>类是一个多重继承，如果需要在这个任务中使用Qt的信号槽机制进行数据的传递就必须继承<code>QObject</code>这个类，如果不使用信号槽传递数据就可以不继承了，只继承<code>QRunnable</code>即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span> :<span class="keyword">public</span> QRunnable</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 任务执行完毕,该对象自动销毁</span></span><br><span class="line">        <span class="built_in">setAutoDelete</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyWork</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-2-QThreadPool"><a href="#2-2-QThreadPool" class="headerlink" title="2.2 QThreadPool"></a>2.2 QThreadPool</h2><p>Qt中的 <code>QThreadPool</code> 类管理了一组 <code>QThreads</code>, 里边还维护了一个任务队列。QThreadPool 管理和回收各个 <code>QThread</code> 对象，以帮助减少使用线程的程序中的线程创建成本。每个Qt应用程序都有一个全局 <code>QThreadPool</code> 对象，可以通过调用 <code>globalInstance()</code> 来访问它。也可以单独创建一个 <code>QThreadPool</code> 对象使用。</p><p>线程池常用的API函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取和设置线程中的最大线程个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxThreadCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaxThreadCount</span><span class="params">(<span class="type">int</span> maxThreadCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给线程池添加任务, 任务是一个 QRunnable 类型的对象</span></span><br><span class="line"><span class="comment">// 如果线程池中没有空闲的线程了, 任务会放到任务队列中, 等待线程处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QThreadPool::start</span><span class="params">(QRunnable * runnable, <span class="type">int</span> priority = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 如果线程池中没有空闲的线程了, 直接返回值, 任务添加失败, 任务不会添加到任务队列中</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThreadPool::tryStart</span><span class="params">(QRunnable * runnable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池中被激活的线程的个数(正在工作的线程个数)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QThreadPool::activeThreadCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试性的将某一个任务从线程池的任务队列中删除, 如果任务已经开始执行就无法删除了</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThreadPool::tryTake</span><span class="params">(QRunnable *runnable)</span></span>;</span><br><span class="line"><span class="comment">// 将线程池中的任务队列里边没有开始处理的所有任务删除, 如果已经开始处理了就无法通过该函数删除了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QThreadPool::clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每个Qt应用程序中都有一个全局的线程池对象, 通过这个函数直接访问这个对象</span></span><br><span class="line"><span class="function"><span class="type">static</span> QThreadPool * <span class="title">QThreadPool::globalInstance</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>一般情况下，我们不需要在Qt程序中创建线程池对象，直接使用Qt为每个应用程序提供的线程池全局对象即可。得到线程池对象之后，调用<code>start()</code>方法就可以将一个任务添加到线程池中，这个任务就可以被线程池内部的线程池处理掉了，使用线程池比自己创建线程的这种多种多线程方式更加简单和易于维护。</p><p>具体的使用方式如下：</p><p><strong>mywork.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span> :<span class="keyword">public</span> QRunnable</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyWork</span><span class="params">()</span></span>;</span><br><span class="line">    ~<span class="built_in">MyWork</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mywork.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyWork::<span class="built_in">MyWork</span>() : <span class="built_in">QRunnable</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 任务执行完毕,该对象自动销毁</span></span><br><span class="line">    <span class="built_in">setAutoDelete</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWork::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 业务处理代码</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mainwindow.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池初始化，设置最大线程池数</span></span><br><span class="line">    QThreadPool::<span class="built_in">globalInstance</span>()-&gt;<span class="built_in">setMaxThreadCount</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 添加任务</span></span><br><span class="line">    MyWork* task = <span class="keyword">new</span> MyWork;</span><br><span class="line">    QThreadPool::<span class="built_in">globalInstance</span>()-&gt;<span class="built_in">start</span>(task);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="3-套接字通信"><a href="#3-套接字通信" class="headerlink" title="3. 套接字通信"></a>3. 套接字通信</h1><p>在标准C++没有提供专门用于套接字通信的类，所以只能使用操作系统提供的基于C的API函数，基于这些C的API函数我们也可以封装自己的C++类 。<br>但是Qt不一样，它是C++的一个框架并且里边提供了用于套接字通信的类（TCP、UDP）这样就使得我们的操作变得更加简单了（当然，在Qt中使用标准C的API进行套接字通信也是完全没有问题的）。</p><p>使用Qt提供的类进行基于TCP的套接字通信需要用到两个类：</p><ul><li>QTcpServer：服务器类，用于监听客户端连接以及和客户端建立连接。</li><li>QTcpSocket：通信的套接字类，客户端、服务器端都需要使用。</li></ul><p>这两个套接字通信类都属于网络模块network。</p><h2 id="3-1-QTcpServer"><a href="#3-1-QTcpServer" class="headerlink" title="3.1 QTcpServer"></a>3.1 QTcpServer</h2><p><code>QTcpServer</code>类用于监听客户端连接以及和客户端建立连接，在使用之前先介绍一下这个类提供的一些常用API函数：</p><h3 id="3-1-1-公共成员函数"><a href="#3-1-1-公共成员函数" class="headerlink" title="3.1.1 公共成员函数"></a>3.1.1 公共成员函数</h3><blockquote><p>构造函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QTcpServer::<span class="built_in">QTcpServer</span>(QObject *parent = Q_NULLPTR);</span><br></pre></td></tr></table></figure><blockquote><p>给监听的套接字设置监听</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTcpServer::listen</span><span class="params">(<span class="type">const</span> QHostAddress &amp;address = QHostAddress::Any, quint16 port = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 判断当前对象是否在监听, 是返回true，没有监听返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTcpServer::isListening</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 如果当前对象正在监听返回监听的服务器地址信息, 否则返回 QHostAddress::Null</span></span><br><span class="line"><span class="function">QHostAddress <span class="title">QTcpServer::serverAddress</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 如果服务器正在侦听连接，则返回服务器的端口; 否则返回0</span></span><br><span class="line"><span class="function">quint16 <span class="title">QTcpServer::serverPort</span><span class="params">()</span> <span class="type">const</span></span></span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>address：通过类QHostAddress可以封装IPv4、IPv6格式的IP地址，QHostAddress::Any表示自动绑定</li><li>port：如果指定为0表示随机绑定一个可用端口。</li></ul></li><li>返回值：绑定成功返回true，失败返回false</li></ul><blockquote><p>得到和客户端建立连接之后用于通信的<code>QTcpSocket</code>套接字对象，它是<code>QTcpServer</code>的一个子对象，当<code>QTcpServer</code>对象析构的时候会自动析构这个子对象，当然也可自己手动析构，建议用完之后自己手动析构这个通信的<code>QTcpSocket</code>对象。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTcpSocket *<span class="title">QTcpServer::nextPendingConnection</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>阻塞等待客户端发起的连接请求，<code>不推荐在单线程程序中使用，建议使用非阻塞方式处理新连接，即使用信号 newConnection() 。</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTcpServer::waitForNewConnection</span><span class="params">(<span class="type">int</span> msec = <span class="number">0</span>, <span class="type">bool</span> *timedOut = Q_NULLPTR)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>msec：指定阻塞的最大时长，单位为毫秒（ms）</li><li>timeout：传出参数，如果操作超时timeout为true，没有超时timeout为false</li></ul></li></ul><hr><h3 id="3-1-2-信号"><a href="#3-1-2-信号" class="headerlink" title="3.1.2 信号"></a>3.1.2 信号</h3><blockquote><p>当接受新连接导致错误时，将发射如下信号。socketError参数描述了发生的错误相关的信息。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QTcpServer::acceptError</span><span class="params">(QAbstractSocket::SocketError socketError)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>每次有新连接可用时都会发出 newConnection() 信号。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QTcpServer::newConnection</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="3-2-QTcpSocket"><a href="#3-2-QTcpSocket" class="headerlink" title="3.2 QTcpSocket"></a>3.2 QTcpSocket</h2><p><code>QTcpSocket</code>是一个套接字通信类，不管是客户端还是服务器端都需要使用。在Qt中发送和接收数据也属于IO操作（网络IO），先看这个类的继承关系：</p><p><img src="/img/a.26.png" alt="在这里插入图片描述"></p><h3 id="3-2-1-公共成员函数"><a href="#3-2-1-公共成员函数" class="headerlink" title="3.2.1 公共成员函数"></a>3.2.1 公共成员函数</h3><blockquote><p>构造函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QTcpSocket::<span class="built_in">QTcpSocket</span>(QObject *parent = Q_NULLPTR);</span><br></pre></td></tr></table></figure><blockquote><p>连接服务器，<code>需要指定服务器端绑定的IP和端口信息</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">virtual</span>] <span class="function"><span class="type">void</span> <span class="title">QAbstractSocket::connectToHost</span><span class="params">(<span class="type">const</span> QString &amp;hostName, quint16 port, OpenMode openMode = ReadWrite, NetworkLayerProtocol protocol = AnyIPProtocol)</span></span>;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">virtual</span>] <span class="function"><span class="type">void</span> <span class="title">QAbstractSocket::connectToHost</span><span class="params">(<span class="type">const</span> QHostAddress &amp;address, quint16 port, OpenMode openMode = ReadWrite)</span></span>;</span><br></pre></td></tr></table></figure><p><code>在Qt中不管调用读操作函数接收数据，还是调用写函数发送数据，操作的对象都是本地的由Qt框架维护的一块内存。因此，调用了发送函数数据不一定会马上被发送到网络中，调用了接收函数也不是直接从网络中接收数据，关于底层的相关操作是不需要使用者来维护的。</code></p><blockquote><p>接收数据</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定可接收的最大字节数 maxSize 的数据到指针 data 指向的内存中</span></span><br><span class="line"><span class="function">qint64 <span class="title">QIODevice::read</span><span class="params">(<span class="type">char</span> *data, qint64 maxSize)</span></span>;</span><br><span class="line"><span class="comment">// 指定可接收的最大字节数 maxSize，返回接收的字符串</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QIODevice::read</span><span class="params">(qint64 maxSize)</span></span>;</span><br><span class="line"><span class="comment">// 将当前可用操作数据全部读出，通过返回值返回读出的字符串</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QIODevice::readAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>发送数据</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送指针 data 指向的内存中的 maxSize 个字节的数据</span></span><br><span class="line"><span class="function">qint64 <span class="title">QIODevice::write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data, qint64 maxSize)</span></span>;</span><br><span class="line"><span class="comment">// 发送指针 data 指向的内存中的数据，字符串以 \0 作为结束标记</span></span><br><span class="line"><span class="function">qint64 <span class="title">QIODevice::write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data)</span></span>;</span><br><span class="line"><span class="comment">// 发送参数指定的字符串</span></span><br><span class="line"><span class="function">qint64 <span class="title">QIODevice::write</span><span class="params">(<span class="type">const</span> QByteArray &amp;byteArray)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-2-信号"><a href="#3-2-2-信号" class="headerlink" title="3.2.2 信号"></a>3.2.2 信号</h3><blockquote><p>在使用<code>QTcpSocket</code>进行套接字通信的过程中，如果该类对象发射出<code>readyRead()</code>信号，说明对端发送的数据达到了，之后就可以调用<code>read 函数</code>接收数据了。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QIODevice::readyRead</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>调用<code>connectToHost()</code>函数并成功建立连接之后发出<code>connected()</code>信号。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractSocket::connected</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>在套接字断开连接时发出<code>disconnected()</code>信号。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractSocket::disconnected</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="3-3-通信流程"><a href="#3-3-通信流程" class="headerlink" title="3.3 通信流程"></a>3.3 通信流程</h2><p>使用Qt提供的类进行套接字通信比使用标准C API进行网络通信要简单（因为在内部进行了封装） Qt中的套接字通信流程如下：</p><h3 id="3-3-1-服务器端"><a href="#3-3-1-服务器端" class="headerlink" title="3.3.1 服务器端"></a>3.3.1 服务器端</h3><h4 id="3-3-1-1-通信流程"><a href="#3-3-1-1-通信流程" class="headerlink" title="3.3.1.1 通信流程"></a>3.3.1.1 通信流程</h4><ol><li>创建套接字服务器<code>QTcpServer</code>对象</li><li>通过<code>QTcpServer</code>对象设置监听，即：<code>QTcpServer::listen()</code></li><li>基于<code>QTcpServer::newConnection()</code>信号检测是否有新的客户端连接</li><li>如果有新的客户端连接调用<code>QTcpSocket *QTcpServer::nextPendingConnection()</code>得到通信的套接字对象</li><li>使用通信的套接字对象<code>QTcpSocket</code>和客户端进行通信</li></ol><hr><h4 id="3-3-1-2-代码片段"><a href="#3-3-1-2-代码片段" class="headerlink" title="3.3.1.2 代码片段"></a>3.3.1.2 代码片段</h4><p>服务器端的窗口界面如下图所示：</p><p><img src="/img/a.27.png" alt="在这里插入图片描述"></p><p><strong>头文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTcpServer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">MainWindow</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_startBtn_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_sendBtn_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    QTcpServer* m_server;</span><br><span class="line">    QTcpSocket* m_tcp;</span><br><span class="line">    QLabel* m_status;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>源文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;Tcp - Server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建QServer对象</span></span><br><span class="line">    m_server = <span class="keyword">new</span> <span class="built_in">QTcpServer</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测是否有新的客户端连接</span></span><br><span class="line">    <span class="built_in">connect</span>(m_server,&amp;QTcpServer::newConnection,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        m_tcp = m_server-&gt;<span class="built_in">nextPendingConnection</span>();</span><br><span class="line">        <span class="comment">//连接成功后更新历史记录和底部状态栏</span></span><br><span class="line">        ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;connect sucessfully&quot;</span>);</span><br><span class="line">        m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/bingo&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//检测客户端是否发送数据</span></span><br><span class="line">        <span class="built_in">connect</span>(m_tcp,&amp;QTcpSocket::readyRead,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">            QString recvmsg = m_tcp-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">            ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;client say : &quot;</span> + recvmsg);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">connect</span>(m_tcp,&amp;QTcpSocket::disconnected,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">            ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;disconnect...&quot;</span>);</span><br><span class="line">            m_tcp-&gt;<span class="built_in">close</span>();</span><br><span class="line">            m_tcp-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">            m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/wrong&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    m_status = <span class="keyword">new</span> QLabel;</span><br><span class="line">    m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/wrong&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>));</span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;connect status : &quot;</span>));</span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(m_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_startBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port = ui-&gt;port-&gt;<span class="built_in">text</span>().<span class="built_in">toInt</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置服务器监听</span></span><br><span class="line">    m_server-&gt;<span class="built_in">listen</span>(QHostAddress::Any,port);</span><br><span class="line">    ui-&gt;startBtn-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_sendBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString sendmsg = ui-&gt;msg-&gt;<span class="built_in">toPlainText</span>();</span><br><span class="line">    m_tcp-&gt;<span class="built_in">write</span>(sendmsg.<span class="built_in">toUtf8</span>());</span><br><span class="line">    ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;server say : &quot;</span> +sendmsg);</span><br><span class="line">    ui-&gt;msg-&gt;<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="3-3-2-客户端"><a href="#3-3-2-客户端" class="headerlink" title="3.3.2 客户端"></a>3.3.2 客户端</h3><h4 id="3-3-2-1-通信流程"><a href="#3-3-2-1-通信流程" class="headerlink" title="3.3.2.1 通信流程"></a>3.3.2.1 通信流程</h4><ol><li>创建通信的套接字类<code>QTcpSocket</code>对象</li><li>使用服务器端绑定的IP和端口连接服务器<code>QAbstractSocket::connectToHost()</code></li><li>使用<code>QTcpSocket</code>对象和服务器进行通信</li></ol><hr><h4 id="3-3-2-2-代码片段"><a href="#3-3-2-2-代码片段" class="headerlink" title="3.3.2.2 代码片段"></a>3.3.2.2 代码片段</h4><p>客户端的窗口界面如下图所示：</p><p><img src="/img/a.28.png" alt="在这里插入图片描述"></p><p><strong>头文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">MainWindow</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_conBtn_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_disBtn_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_sendBtn_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    QTcpSocket* m_tcp;</span><br><span class="line">    QLabel* m_status;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>源文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;Tcp - client&quot;</span>);</span><br><span class="line">    <span class="comment">//创建套接字对象</span></span><br><span class="line">    m_tcp = <span class="keyword">new</span> <span class="built_in">QTcpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受服务器的消息</span></span><br><span class="line">    <span class="built_in">connect</span>(m_tcp,&amp;QTcpSocket::readyRead,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        QString recvmsg = m_tcp-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">        ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;server say : &quot;</span> + recvmsg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否和服务器连接成功</span></span><br><span class="line">    <span class="built_in">connect</span>(m_tcp,&amp;QTcpSocket::connected,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;connect sucessfully&quot;</span>);</span><br><span class="line">        m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/bingo&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测是否断开连接</span></span><br><span class="line">    <span class="built_in">connect</span>(m_tcp,&amp;QTcpSocket::disconnected,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;disconnect......&quot;</span>);</span><br><span class="line">        ui-&gt;disBtn-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);</span><br><span class="line">        ui-&gt;conBtn-&gt;<span class="built_in">setEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/wrong&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    m_status = <span class="keyword">new</span> QLabel;</span><br><span class="line">    m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/wrong&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>));</span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;connect status : &quot;</span>));</span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(m_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_conBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString ip = ui-&gt;Ip-&gt;<span class="built_in">text</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_tmp = ui-&gt;port-&gt;<span class="built_in">text</span>().<span class="built_in">toInt</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    m_tcp-&gt;<span class="built_in">connectToHost</span>(<span class="built_in">QHostAddress</span>(ip),port_tmp);</span><br><span class="line">    ui-&gt;conBtn-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);</span><br><span class="line">    ui-&gt;disBtn-&gt;<span class="built_in">setEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_disBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_tcp-&gt;<span class="built_in">close</span>();</span><br><span class="line">    ui-&gt;disBtn-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);</span><br><span class="line">    ui-&gt;conBtn-&gt;<span class="built_in">setEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_sendBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString sendmsg = ui-&gt;msg-&gt;<span class="built_in">toPlainText</span>();</span><br><span class="line">    m_tcp-&gt;<span class="built_in">write</span>(sendmsg.<span class="built_in">toUtf8</span>());</span><br><span class="line">    ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;client say : &quot;</span> + sendmsg);</span><br><span class="line">    ui-&gt;msg-&gt;<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-多线程的使用&quot;&gt;&lt;a href=&quot;#1-多线程的使用&quot; class=&quot;headerlink&quot; title=&quot;1. 多线程的使用&quot;&gt;&lt;/a&gt;1. 多线程的使用&lt;/h1&gt;&lt;p&gt;在进行桌面应用程序开发的时候， 假设应用程序在某些情况下需要处理比较复杂的逻辑</summary>
      
    
    
    
    <category term="Qt" scheme="http://example.com/categories/Qt/"/>
    
    
    <category term="套接字通信" scheme="http://example.com/tags/%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/"/>
    
    <category term="socket" scheme="http://example.com/tags/socket/"/>
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>事件</title>
    <link href="http://example.com/2023/10/22/%E4%BA%8B%E4%BB%B6/"/>
    <id>http://example.com/2023/10/22/%E4%BA%8B%E4%BB%B6/</id>
    <published>2023-10-22T01:54:18.000Z</published>
    <updated>2023-10-22T05:15:23.868Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-事件处理器"><a href="#1-事件处理器" class="headerlink" title="1. 事件处理器"></a>1. 事件处理器</h1><h2 id="1-1-事件"><a href="#1-1-事件" class="headerlink" title="1.1 事件"></a>1.1 事件</h2><p>Qt是一个基于C++的框架，主要用来开发带窗口的应用程序（不带窗口的也行，但不是主流）。我们使用的基于窗口的应用程序都是基于事件，其目的主要是用来实现回调（因为只有这样程序的效率才是最高的）。<br>所以在Qt框架内部为我们提供了一些列的事件处理机制，当窗口事件产生之后，事件会经过：<code>事件派发 -&gt; 事件过滤-&gt;事件分发-&gt;事件处理几个阶段</code>。Qt窗口中对于产生的一系列事件都有默认的处理动作，如果我们有特殊需求就需要在合适的阶段重写事件的处理动作。</p><p>事件（event）是由系统或者 Qt 本身在不同的场景下发出的。当用户按下&#x2F;移动鼠标、敲下键盘，或者是窗口关闭&#x2F;大小发生变化&#x2F;隐藏或显示都会发出一个相应的事件。一些事件在对用户操作做出响应时发出，如鼠标&#x2F;键盘事件等；另一些事件则是由系统自动发出，如计时器事件。</p><p>每一个Qt应用程序都对应一个唯一的 <code>QApplication</code>应用程序对象，然后调用这个对象的<code>exec()</code>函数，这样Qt框架内部的事件检测就开始了（<code>程序将进入事件循环来监听应用程序的事件</code>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow* w = <span class="keyword">new</span> MainWindow;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件在Qt中产生之后，的分发过程是这样的：</p><ol><li>当事件产生之后，Qt使用用应用程序对象调用notify()函数将事件发送到指定的窗口：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">override</span> <span class="keyword">virtual</span>] <span class="function"><span class="type">bool</span> <span class="title">QApplication::notify</span><span class="params">(QObject *receiver, QEvent *e)</span></span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>事件在发送过程中可以通过事件过滤器进行过滤，默认不对任何产生的事件进行过滤。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要先给窗口安装过滤器, 该事件才会触发</span></span><br><span class="line">[<span class="keyword">virtual</span>] <span class="function"><span class="type">bool</span> <span class="title">QObject::eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span></span><br></pre></td></tr></table></figure><ol start="3"><li>当事件发送到指定窗口之后，窗口的事件分发器会对收到的事件进行分类:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">override</span> <span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">bool</span> <span class="title">QWidget::event</span><span class="params">(QEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>事件分发器会将分类之后的事件（鼠标事件、键盘事件、绘图事件。。。）分发给对应的事件处理器函数进行处理，每个事件处理器函数都有默认的处理动作（我们也可以重写这些事件处理器函数），比如：鼠标事件：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 鼠标按下</span></span><br><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line"><span class="comment">// 鼠标释放</span></span><br><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line"><span class="comment">// 鼠标移动</span></span><br><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="1-2-事件处理器函数"><a href="#1-2-事件处理器函数" class="headerlink" title="1.2 事件处理器函数"></a>1.2 事件处理器函数</h2><p>通过上面的描述可以得知：Qt的事件处理器函数处于食物链的最末端，每个事件处理器函数都对应一个唯一的事件，这为我们重新定义事件的处理动作提供了便利。<br>另外，<code>Qt提供的这些事件处理器函数都是回调函数，也就是说作为使用者我们只需要指定函数的处理动作，关于函数的调用是不需要操心的，当某个事件被触发，Qt框架会调用对应的事件处理器函数。</code></p><p>QWidget类是Qt中所有窗口类的基类，在这个类里边定义了很多事件处理器函数，它们都是受保护的虚函数。我们可以在Qt的任意一个窗口类中重写这些虚函数来重定义它们的行为。下面介绍一些常用的事件处理器函数：</p><h3 id="1-2-1-鼠标事件"><a href="#1-2-1-鼠标事件" class="headerlink" title="1.2.1 鼠标事件"></a>1.2.1 鼠标事件</h3><ul><li><strong>鼠标按下事件</strong><br>当鼠标左键、鼠标右键、鼠标中键被按下，该函数被自动调用，通过参数可以得到当前按下的是哪个鼠标键</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>鼠标释放事件</strong><br>当鼠标左键、鼠标右键、鼠标中键被释放，该函数被自动调用，通过参数可以得到当前释放的是哪个鼠标键</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>鼠标移动事件</strong><br>当鼠标移动（也可以按住一个或多个鼠标键移动），该函数被自动调用，通过参数可以得到在移动过程中哪些鼠标键被按下了。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>鼠标双击事件</strong><br>当鼠标双击该函数被调用，通过参数可以得到是通过哪个鼠标键进行了双击操作。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mouseDoubleClickEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>鼠标进入事件</strong><br>当鼠标进入窗口的一瞬间，触发该事件，注意：只在进入的瞬间触发一次该事件</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::enterEvent</span><span class="params">(QEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>鼠标离开事件</strong><br>当鼠标离开窗口的一瞬间，触发该事件，注意：只在离开的瞬间触发一次该事件</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::leaveEvent</span><span class="params">(QEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-2-2-键盘事件"><a href="#1-2-2-键盘事件" class="headerlink" title="1.2.2 键盘事件"></a>1.2.2 键盘事件</h3><ul><li><strong>键盘按下事件</strong><br>当键盘上的按键被按下了，该函数被自动调用，通过参数可以得知按下的是哪个键。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::keyPressEvent</span><span class="params">(QKeyEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>键盘释放事件</strong><br>当键盘上的按键被释放了，该函数被自动调用，通过参数可以得知释放的是哪个键。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::keyReleaseEvent</span><span class="params">(QKeyEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-2-3-窗口重绘事件"><a href="#1-2-3-窗口重绘事件" class="headerlink" title="1.2.3 窗口重绘事件"></a>1.2.3 窗口重绘事件</h3><p>当窗口需要刷新的时候，该函数就会自动被调用。窗口需要刷新的情景很多，比如：窗口大小发生变化，窗口显示等，另外我们还可以通过该函数给窗口绘制背景图，总之这是一个需要经常被重写的一个事件处理器函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::paintEvent</span><span class="params">(QPaintEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-2-4-窗口关闭事件"><a href="#1-2-4-窗口关闭事件" class="headerlink" title="1.2.4 窗口关闭事件"></a>1.2.4 窗口关闭事件</h3><p>当窗口标题栏的关闭按钮被按下并且在窗口关闭之前该函数被调用，可以通过该函数控制窗口是否被关闭。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::closeEvent</span><span class="params">(QCloseEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-2-5-重置窗口大小事件"><a href="#1-2-5-重置窗口大小事件" class="headerlink" title="1.2.5 重置窗口大小事件"></a>1.2.5 重置窗口大小事件</h3><p>当窗口的大小发生变化，该函数被调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::resizeEvent</span><span class="params">(QResizeEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><p>除此之外，关于Qt窗口提供的其他事件处理器函数还有很多，感兴趣的话可以仔细阅读Qt的帮助文档，窗口的事件处理器函数非常好找，规律是这样的：</p><ol><li>受保护的虚函数</li><li>函数名分为两部分: 事件描述+Event</li><li>函数带一个事件类型的参数</li></ol><hr><h2 id="1-3-重写事件处理器函数"><a href="#1-3-重写事件处理器函数" class="headerlink" title="1.3 重写事件处理器函数"></a>1.3 重写事件处理器函数</h2><p>由于事件处理器函数都是虚函数，因此我们就可以添加一个标准窗口类的派生类，这样不仅使子类继承了父类的属性，还可以在这个子类中重写父类的虚函数，总起来说整个操作过程还easy </p><ol><li>创建一个Qt项目，添加一个窗口类（让其从某个标准窗口类派生）</li><li>在子类中重写从父类继承的虚函数（也就是事件处理器函数）</li></ol><h3 id="1-3-1-头文件"><a href="#1-3-1-头文件" class="headerlink" title="1.3.1 头文件"></a>1.3.1 头文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">MainWindow</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 重写事件处理器函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeEvent</span><span class="params">(QCloseEvent* ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resizeEvent</span><span class="params">(QResizeEvent* ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="1-3-2-源文件"><a href="#1-3-2-源文件" class="headerlink" title="1.3.2 源文件"></a>1.3.2 源文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCloseEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QResizeEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::closeEvent</span><span class="params">(QCloseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QMessageBox::Button btn = QMessageBox::<span class="built_in">question</span>(<span class="keyword">this</span>, <span class="string">&quot;关闭窗口&quot;</span>, <span class="string">&quot;您确定要关闭窗口吗?&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(btn == QMessageBox::Yes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收并处理这个事件</span></span><br><span class="line">        ev-&gt;<span class="built_in">accept</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 忽略这个事件</span></span><br><span class="line">        ev-&gt;<span class="built_in">ignore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::resizeEvent</span><span class="params">(QResizeEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;oldSize: &quot;</span> &lt;&lt; ev-&gt;<span class="built_in">oldSize</span>()</span><br><span class="line">             &lt;&lt; <span class="string">&quot;currentSize: &quot;</span> &lt;&lt; ev-&gt;<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>QCloseEvent</code>类是<code>QEvent</code>类的子类，程序中使用的<code>accept()</code>或者<code>ignore()</code>的作用参考时间分发器部分的<code>QEvent</code>类</p><hr><h3 id="1-3-3-效果"><a href="#1-3-3-效果" class="headerlink" title="1.3.3 效果"></a>1.3.3 效果</h3><p>在上面重写的<code>closeEvent</code>事件中添加了关闭窗口的判断，这样就可以避免误操作导致窗口被关闭了，效果如下：<br><img src="/img/a.18.png" alt="在这里插入图片描述"></p><p>如果想要时时检测窗口大小，就可以重写窗口的<code>resizeEvent</code>事件，这样就可以得到窗口的最新尺寸信息了：<br><img src="/img/a.19.png" alt="在这里插入图片描述"></p><hr><h2 id="1-4-自定义按钮"><a href="#1-4-自定义按钮" class="headerlink" title="1.4 自定义按钮"></a>1.4 自定义按钮</h2><p>基于Qt提供的事件处理器函数，我们可以非常轻松地按照自己的想法制作出一个按钮，按钮的要求如下：</p><ol><li>从视觉上看是一个不规则按钮（按钮实际上都是矩形的）</li><li>按钮上需要显示指定的背景图片</li><li>按钮在鼠标的不同操作阶段（无操作、鼠标悬停、鼠标按下）能够显示不同的背景图</li></ol><h3 id="1-4-1-添加子类"><a href="#1-4-1-添加子类" class="headerlink" title="1.4.1 添加子类"></a>1.4.1 添加子类</h3><p><code>新添加的按钮类可以让它继承 QPushButton，也可以让它继承其他的窗口类（代价是当鼠标点击事件触发之后需要自己发射自定义信号）</code>，这里让添加的子类从QWidget类派生。</p><p><strong>自定义类头文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYBUTTON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYBUTTON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyButton</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyButton</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setImage</span><span class="params">(QString normal, QString hover, QString pressed)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent* ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent* ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enterEvent</span><span class="params">(QEvent* ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">leaveEvent</span><span class="params">(QEvent* ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent* ev)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPixmap m_normal;</span><br><span class="line">    QPixmap m_press;</span><br><span class="line">    QPixmap m_hover;</span><br><span class="line">    QPixmap m_current;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYBUTTON_H</span></span></span><br></pre></td></tr></table></figure><p>自定义类源文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mybutton.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"></span><br><span class="line">MyButton::<span class="built_in">MyButton</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::setImage</span><span class="params">(QString normal, QString hover, QString pressed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 加载图片</span></span><br><span class="line">    m_normal.<span class="built_in">load</span>(normal);</span><br><span class="line">    m_hover.<span class="built_in">load</span>(hover);</span><br><span class="line">    m_press.<span class="built_in">load</span>(pressed);</span><br><span class="line">    m_current = m_normal;</span><br><span class="line">    <span class="comment">// 设置按钮和图片大小一致</span></span><br><span class="line">    <span class="built_in">setFixedSize</span>(m_normal.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::mousePressEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 鼠标被按下, 发射这个自定义信号</span></span><br><span class="line">    <span class="function">emit <span class="title">clicked</span><span class="params">()</span></span>;</span><br><span class="line">    m_current = m_press;</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::mouseReleaseEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_current = m_normal;</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::enterEvent</span><span class="params">(QEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_current = m_hover;</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::leaveEvent</span><span class="params">(QEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_current = m_normal;</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::paintEvent</span><span class="params">(QPaintEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(), m_current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-4-2-使用自定控件"><a href="#1-4-2-使用自定控件" class="headerlink" title="1.4.2 使用自定控件"></a>1.4.2 使用自定控件</h3><p>由于Qt的UI工具箱中提供的都是标准控件，自定义的控件是不能直接拖拽到UI窗口中的，这时我们需要先看一下自定义控件的基类类型：上面自定义的 <code>MyButton</code> 的基类是 <code>QWidget</code> 类型，因此需要往窗口中拖拽一个QWidget类型的标准控件，然后在这个标准控件上鼠标右键：</p><p><img src="/img/a.20.png" alt="在这里插入图片描述"></p><p>这样添加的控件类型就变成了自定义的子类类型：<br><img src="/img/a.21.png" alt="在这里插入图片描述"></p><hr><h3 id="1-4-3-设置图片"><a href="#1-4-3-设置图片" class="headerlink" title="1.4.3 设置图片"></a>1.4.3 设置图片</h3><p>在主窗口中通过添加的按钮的对象，调用子类的成员函数给其添加图片：</p><p><strong>mainwindow.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给自定义按钮设置图片</span></span><br><span class="line">    ui-&gt;button-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/ghost-1.png&quot;</span>, <span class="string">&quot;:/ghost-2.png&quot;</span>, <span class="string">&quot;:/ghost-3.png&quot;</span>);</span><br><span class="line">    <span class="comment">// 处理自定义按钮的鼠标点击事件</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;button, &amp;MyButton::clicked, <span class="keyword">this</span>, [=]()</span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;按钮&quot;</span>, <span class="string">&quot;莫要调戏我...&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="2-事件分发器"><a href="#2-事件分发器" class="headerlink" title="2. 事件分发器"></a>2. 事件分发器</h1><h2 id="2-1-QEvent"><a href="#2-1-QEvent" class="headerlink" title="2.1 QEvent"></a>2.1 QEvent</h2><p>当事件产生被发送到对应的窗口之后，窗口并不会直接处理这个事件，而是对这些事件进行细分，然后根据事件的类型再次进行分发（相当于公司接了个项目，对项目进行查分之后分发给各个职能部门，由各个部门进行模块的开发），对应的事件处理器函数得到这个分发的事件之后就开始处理这个事件。</p><p>关于窗口事件的分发，对应一个事件分发器，叫做<code>event</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">override</span> <span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">bool</span> <span class="title">QWidget::event</span><span class="params">(QEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><p>通过事件分发器的函数原型可以得知，关于事件类型的判断是基于参数完成的，这个参数是一个<code>QEvent</code>类型的对象，下面来看一下这个类中常用的一些API函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QEvent::accept</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>该函数的作用是让窗口接受传递过来的事件，<code>事件不会向上层窗口（父窗口）传递。</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QEvent::ignore</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>该函数的作用是让窗口忽略传递过来的事件，<code>事件被传递给父窗口（向上传递）。</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QEvent::isAccepted</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QEvent::setAccepted</span><span class="params">(<span class="type">bool</span> accepted)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>设置传递过来的事件是被接受还是被忽略<ul><li><code>setAccepted(true) == accept()</code></li><li><code>setAccepted(false) == ignore()</code></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QEvent::Type <span class="title">QEvent::type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><ul><li>得到传递的窗口的事件的类型，返回值是一个枚举类型，内容很多可以自己查帮助文档</li></ul><p><img src="/img/a.22.png" alt="在这里插入图片描述"></p><hr><h2 id="2-2-事件分发器"><a href="#2-2-事件分发器" class="headerlink" title="2.2 事件分发器"></a>2.2 事件分发器</h2><p>在不需要人为干预的情况下，事件分发器会自主的完成相关事件的分发，下面来还原一下事件分发器的分发流程，以下是这个函数的部分源码展示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QWidget::event</span><span class="params">(QEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(ev-&gt;<span class="built_in">type</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 鼠标移动</span></span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseMove:</span><br><span class="line">        <span class="built_in">mouseMoveEvent</span>((QMouseEvent*)event);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 鼠标按下</span></span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonPress:</span><br><span class="line">        <span class="built_in">mousePressEvent</span>((QMouseEvent*)event);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 鼠标释放</span></span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonRelease:</span><br><span class="line">        <span class="built_in">mouseReleaseEvent</span>((QMouseEvent*)event);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 鼠标双击</span></span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonDblClick:</span><br><span class="line">        <span class="built_in">mouseDoubleClickEvent</span>((QMouseEvent*)event);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 键盘按键被按下事件</span></span><br><span class="line">    <span class="keyword">case</span> QEvent::KeyPress:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直观的看到事件分发器在对事件进行判定之后会调用相关的事件处理器函数，这样事件就被最终处理掉了。</p><p>如果我们不想让某些触发的事件进入到当前窗口中，可以在事件分发器中进行拦截，拦截之前先来了解一下事件分发器函数的返回值：</p><ol><li><p>如果传入的事件已被识别并且处理，则需要返回 true，否则返回 false。如果返回值是 true，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。</p></li><li><p>在event()函数中，调用事件对象的 accept() 和 ignore() 函数是没有作用的，不会影响到事件的传播。</p></li></ol><p>也就是说如果想过滤某个事件，只需要在判断出这个事件之后直接返回 true 就可以了。</p><p>下面来举个例子，在窗口中过滤掉鼠标按下的事件:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::event</span><span class="params">(QEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonPress ||</span><br><span class="line">            ev-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonDblClick)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 过滤调用鼠标按下的事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">event</span>(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样窗口就再也收不到鼠标的单击和双击事件了，对于这两个事件以外的其他事件是没有任何影响的，因为在重写的事件分发器函数的最后调用了父类的事件分发器函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> QWidget::<span class="built_in">event</span>(ev);</span><br></pre></td></tr></table></figure><p>这样就能保证其他事件按照默认的分发流程进行分发，并最终被窗口处理掉。</p><hr><h1 id="3-事件过滤器"><a href="#3-事件过滤器" class="headerlink" title="3. 事件过滤器"></a>3. 事件过滤器</h1><h2 id="3-1-事件过滤器"><a href="#3-1-事件过滤器" class="headerlink" title="3.1 事件过滤器"></a>3.1 事件过滤器</h2><p>除了使用事件分发器来过滤Qt窗口中产生的事件，还可以通过事件过滤器过滤相关的事件。当Qt的事件通过应用程序对象发送给相关窗口之后，窗口接收到数据之前这个期间可对事件进行过滤，过滤掉的事件就不能被继续处理了。QObject有一个eventFilter()函数，用于建立事件过滤器。函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">virtual</span>] <span class="function"><span class="type">bool</span> <span class="title">QObject::eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>watched：要过滤的事件的所有者对象</li><li>event：要过滤的具体的事件</li></ul></li><li>返回值：如果想过滤掉这个事件，停止它被进一步处理，返回true，否则返回 false</li></ul><p>既然要过滤传递中的事件，首当其冲还是要搞明白如何通过事件过滤器进行事件的过滤，主要分为两步：</p><ol><li>给要被过滤事件的类对象安装事件过滤器</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QObject::installEventFilter</span><span class="params">(QObject *filterObj)</span></span>;</span><br></pre></td></tr></table></figure><p>假设调用<code>installEventFilter()</code>函数的对象为当前对象，那么就可以基于参数指定的<code>filterObj</code>对象来过滤当前对象中的指定的事件了。</p><ol start="2"><li>在要进行事件过滤的类中（filterObj 参数对应的类）重写从QObject类继承的虚函数eventFilter()。</li></ol><hr><h2 id="3-2-事件过滤器的使用"><a href="#3-2-事件过滤器的使用" class="headerlink" title="3.2 事件过滤器的使用"></a>3.2 事件过滤器的使用</h2><p>根据上面的使用步骤，举一个例子：</p><blockquote><p>在一个窗口中有一个多行文本输入框<code>QTextEdit</code>，需要让我们屏蔽掉键盘上的回车键，也就是按回车键之后在这个文本编辑框中再也不能换行了。</p></blockquote><p>其实上面的需求有三种解决方案：</p><ol><li>自定义一个新的类让其继承<code>QTextEdit</code>，在这个子类中重写键盘事件<code>keyPressEvent</code>，在这个函数里边屏蔽掉回车键</li><li>自定义一个新的类让其继承<code>QTextEdit</code>，在这个子类中重写事件分发器<code>event</code>，在这个函数里边屏蔽掉回车键</li><li>给<code>QTextEdit</code>安装事件过滤器，基于<code>QTextEdit</code>的父窗口对这个控件的事件进行过滤</li></ol><p>最简单的方式还是第三种，因为我们不需要再定义出一个子类就可以轻松的完成控件事件的过滤了。</p><p>准备工作：在主窗口中添加一个<code>QTextEdit</code>类型的控件，如下图：<br><img src="/img/a.23.png" alt="在这里插入图片描述"></p><p><strong>主窗口头文件： mainwindow.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">MainWindow</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>主窗口源文件： mainwindow.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    ui-&gt;textEdit-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 判断对象和事件</span></span><br><span class="line">    <span class="keyword">if</span>(watched == ui-&gt;textEdit &amp;&amp; event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress)</span><br><span class="line">    &#123;</span><br><span class="line">        QKeyEvent* keyEv = (QKeyEvent*)event;</span><br><span class="line">        <span class="keyword">if</span>(keyEv-&gt;<span class="built_in">key</span>() == Qt::Key_Enter ||         <span class="comment">// 小键盘确认</span></span><br><span class="line">                keyEv-&gt;<span class="built_in">key</span>() == Qt::Key_Return)     <span class="comment">// 大键盘回车</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;我是回车, 被按下了...&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在示例代码的第7行：给多行编辑框控件安装了事件过滤器，由<code>this</code>对应的主窗口进行事件的过滤</p><p>在示例代码的第15行：主窗口通过重新事件过滤器函数，对多行编辑框控件进行事件的过滤，在函数体内部关于键盘事件的过滤需要判断按键是否是回车键，此处需要注意：</p><ul><li>Qt::Key_Enter是小键盘上的回车（确认）键，有些键盘没有小键盘，因此也就没有该按键。</li><li>Qt::Key_Return是大键盘上的回车键</li></ul><p>通过这样的处理，事件在被应用程序对象发送出去之后，进入到对应的窗口之前就被其父窗口过滤掉了。</p><p>如果在Qt的窗口中有多层嵌套的窗口，如下图：<br><img src="/img/a.24.png" alt="在这里插入图片描述"></p><p>先来描述一下这四层窗口的关系：</p><ul><li>顶层窗口A的直接子窗口是 B，间接子窗口是 C，QTextEdit</li><li>二级窗口B的直接子窗口是 C，间接子窗口是 QTextEdit</li><li>三级窗口C的直接子窗口是 QTextEdit</li></ul><p>在这种多层嵌套窗口中如果想要过滤掉QTextEdit的某些事件，可以交给A或者B或者C去处理，当然也可以给QTextEdit同时安装多个过滤器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;textEdit-&gt;<span class="built_in">installEventFilter</span>(窗口A对象);</span><br><span class="line">ui-&gt;textEdit-&gt;<span class="built_in">installEventFilter</span>(窗口B对象);</span><br><span class="line">ui-&gt;textEdit-&gt;<span class="built_in">installEventFilter</span>(窗口C对象);</span><br></pre></td></tr></table></figure><p><code>如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是说窗口C先进行事件过滤，然后窗口B，最后窗口A。</code></p><blockquote><p>注意：<br>事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-事件处理器&quot;&gt;&lt;a href=&quot;#1-事件处理器&quot; class=&quot;headerlink&quot; title=&quot;1. 事件处理器&quot;&gt;&lt;/a&gt;1. 事件处理器&lt;/h1&gt;&lt;h2 id=&quot;1-1-事件&quot;&gt;&lt;a href=&quot;#1-1-事件&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Qt" scheme="http://example.com/categories/Qt/"/>
    
    
  </entry>
  
  <entry>
    <title>控件</title>
    <link href="http://example.com/2023/10/22/%E6%8E%A7%E4%BB%B6/"/>
    <id>http://example.com/2023/10/22/%E6%8E%A7%E4%BB%B6/</id>
    <published>2023-10-22T01:54:08.000Z</published>
    <updated>2023-10-22T05:11:18.128Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-按钮类型控件"><a href="#1-按钮类型控件" class="headerlink" title="1. 按钮类型控件"></a>1. 按钮类型控件</h1><h2 id="1-1-按钮基类-QAbstractButton"><a href="#1-1-按钮基类-QAbstractButton" class="headerlink" title="1.1 按钮基类 QAbstractButton"></a>1.1 按钮基类 QAbstractButton</h2><blockquote><p>在QT中为我们提供了可以直接使用的按钮控件, 如下图。这些按钮种类虽然繁多， 但是它们都拥有相同的父类<code>QAbstractButton</code>。这些子类按钮的大部分属性都是从这个基类继承的，因此搞明白这个类为我们提供的相关功能还是非常重要的。<br>其中<code>Dialog Button Box</code>比较特殊不是一个单一控件, 它是两个QPushButton的组合并且水平排列,这个不能作为一个新控件来研究。</p></blockquote><p><img src="/img/a.1.png" alt="在这里插入图片描述"></p><p>这些按钮控件之间的继承关系如下图：</p><p><img src="/img/a.2.png" alt="在这里插入图片描述"></p><p>介绍一下<code>QAbstractButton</code>中的一些常用API</p><hr><h3 id="1-1-1-标题和图标"><a href="#1-1-1-标题和图标" class="headerlink" title="1.1.1 标题和图标"></a>1.1.1 标题和图标</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数text的内容显示到按钮上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QAbstractButton::setText</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="comment">// 得到按钮上显示的文本内容, 函数的返回就是</span></span><br><span class="line"><span class="function">QString <span class="title">QAbstractButton::text</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到按钮设置的图标</span></span><br><span class="line"><span class="function">QIcon <span class="title">icon</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给按钮设置图标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setIcon</span><span class="params">(<span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到按钮图标大小</span></span><br><span class="line"><span class="function">QSize <span class="title">iconSize</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置按钮图标的大小</span></span></span><br><span class="line"><span class="function">[slot]<span class="type">void</span> <span class="title">setIconSize</span><span class="params">(<span class="type">const</span> QSize &amp;size)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-2-按钮的-Check-属性"><a href="#1-1-2-按钮的-Check-属性" class="headerlink" title="1.1.2 按钮的 Check 属性"></a>1.1.2 按钮的 Check 属性</h3><blockquote><p>对应按钮来说, 一般有三种常见状态, 分别为: <code>Normal</code>, <code>Hover</code>, <code>Pressed</code>。</p><ul><li><code>Normal</code>: 普通状态, 没有和鼠标做任何接触 </li><li><code>Hover</code>: 悬停状态, 鼠标位于按钮之上, 但是并未按下 </li><li><code>Pressed</code>: 按压状态,鼠标键在按钮上处于按下状态</li></ul><p> 默认情况下, 鼠标在按钮上按下, 按钮从 <code>Normal</code> 切换到 <code>Pressed</code>状态, 鼠标释放, 按钮<code>Pressed</code>恢复到<code>Normal</code>状态。<br> 当我们给按钮设置了 <code>check</code> 属性之后，情况就有所不同了， 在按钮上释放鼠标键， 按钮依然会处在 <code>Pressed</code>状态, 再次点击按钮, 按钮才能恢复到 <code>Normal</code> 状态。具有<code>check</code>属性的按钮就相当于一个开关,每点击一次才能实现一次状态的切换。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断按钮是否设置了checkable属性, 如果设置了点击按钮, 按钮一直处于选中状态</span></span><br><span class="line"><span class="comment">// 默认这个属性是关闭的, not checkable</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QAbstractButton::isCheckable</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置按钮的checkable属性</span></span><br><span class="line"><span class="comment">// 参数为true: 点击按钮, 按钮被选中, 松开鼠标, 按钮不弹起</span></span><br><span class="line"><span class="comment">// 参数为false: 点击按钮, 按钮被选中, 松开鼠标, 按钮弹起</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QAbstractButton::setCheckable</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 判断按钮是不是被按下的选中状态</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QAbstractButton::isChecked</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置按钮的选中状态: true-选中, false-没选中</span></span><br><span class="line"><span class="comment">// 设置该属性前, 必须先进行 checkable属性的设置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QAbstractButton::setChecked</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-3-信号"><a href="#1-1-3-信号" class="headerlink" title="1.1.3 信号"></a>1.1.3 信号</h3><blockquote><p>这些信号都按钮被点击之后发射出来的, 只是在细节上有细微的区别, 其中最常用的是 <code>clicked()</code><br>通过鼠标的不同瞬间状态可以发射出<code>pressed()</code> 和 <code>released()</code> 信号, 如果鼠标设置了 <code>check</code> 属性, 一般通过<code>toggled()</code>信号判断当前按钮是选中状态还是非选中状态。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当按钮被激活时(即，当鼠标光标在按钮内时按下然后释放)，当键入快捷键时，或者当click()或animateClick()被调用时，这个信号被发出。值得注意的是，如果调用setDown()、setChecked()或toggle()，则不会触发此信号。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::clicked</span><span class="params">(<span class="type">bool</span> checked = <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="comment">// 在按下按钮的时候发射这个信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::pressed</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 在释放这个按钮的时候发射直观信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::released</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 每当可检查按钮改变其状态时，就会发出此信号。checked在选中按钮时为true，在未选中按钮时为false。</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::toggled</span><span class="params">(<span class="type">bool</span> checked)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-4-槽函数"><a href="#1-1-4-槽函数" class="headerlink" title="1.1.4 槽函数"></a>1.1.4 槽函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行一个动画点击:按钮被立即按下，并在毫秒后释放(默认是100毫秒)。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::animateClick</span><span class="params">(<span class="type">int</span> msec = <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="comment">// 执行一次按钮点击, 相当于使用鼠标点击了按钮</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::click</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参考 1.2 中的函数介绍</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::setChecked</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"><span class="comment">// 设置按钮上图标大小</span></span><br><span class="line">[slot]<span class="function"><span class="type">void</span> <span class="title">setIconSize</span><span class="params">(<span class="type">const</span> QSize &amp;size)</span></span>;</span><br><span class="line"><span class="comment">// 切换可检查按钮的状态。 checked &lt;==&gt; unchecked</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::toggle</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>了解了基类提供的功能之后, 下边着重给大家介绍一下按钮组中常用的几这个按钮控件： <code>QPushButton</code>, <code>QToolButton</code>, <code>QRadioButton</code>, <code>QCheckBox</code>。</p><hr><h2 id="1-2-QPushButton"><a href="#1-2-QPushButton" class="headerlink" title="1.2 QPushButton"></a>1.2 QPushButton</h2><h3 id="1-2-1-常用API"><a href="#1-2-1-常用API" class="headerlink" title="1.2.1 常用API"></a>1.2.1 常用API</h3><blockquote><p>这种类型的按钮是Qt按钮中使用频率最高的一个, 对这个类进行操作, 大部分时候都需要使用它从父类继承过来的那些 API。<br>在<code>QPushButton</code>类中, 比较常用的一些API函数如下:</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">    - icon: 按钮上显示的图标</span></span><br><span class="line"><span class="comment">    - text: 按钮上显示的标题</span></span><br><span class="line"><span class="comment">    - parent: 按钮的父对象, 可以不指定</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QPushButton::<span class="built_in">QPushButton</span>(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;text, QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">QPushButton::<span class="built_in">QPushButton</span>(<span class="type">const</span> QString &amp;text, QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">QPushButton::<span class="built_in">QPushButton</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断按钮是不是默认按钮</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDefault</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 一般在对话框窗口中使用, 将按钮设置为默认按钮, 自动关联 Enter 键 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setDefault</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将弹出菜单菜单与此按钮关联起来。这将把按钮变成一个菜单按钮，</span></span><br><span class="line"><span class="comment">在某些样式中会在按钮文本的右边产生一个小三角形。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPushButton::setMenu</span><span class="params">(QMenu *menu)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">显示(弹出)相关的弹出菜单。如果没有这样的菜单，这个函数什么也不做。</span></span><br><span class="line"><span class="comment">这个函数直到弹出菜单被用户关闭后才返回。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QPushButton::showMenu</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-2-2-按钮的使用"><a href="#1-2-2-按钮的使用" class="headerlink" title="1.2.2 按钮的使用"></a>1.2.2 按钮的使用</h3><blockquote><p>通过API的介绍, 我们可以知道, 使用<code>QPushButton</code>这种类型的按钮, 有三种使用方式:</p><ul><li>作为普通按钮, 可以显示文本信息和图标 </li><li>设置check属性, 使其可以处于持续的被选中状态 </li><li>关联一个菜单, 点击按钮菜单弹出</li></ul></blockquote><p>具体操作可以参考如下代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通按钮, 没有checked属性</span></span><br><span class="line">    ui-&gt;normalBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;我是小猪佩奇&quot;</span>);</span><br><span class="line">    ui-&gt;normalBtn-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/Peppa-Pig.png&quot;</span>));</span><br><span class="line">    ui-&gt;normalBtn-&gt;<span class="built_in">setIconSize</span>(<span class="built_in">QSize</span>(<span class="number">30</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;normalBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;我是一个普通按钮, 图标是小猪佩奇...&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有checked属性的按钮</span></span><br><span class="line">    ui-&gt;checkedBtn-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;checkedBtn, &amp;QPushButton::toggled, <span class="keyword">this</span>, [=](<span class="type">bool</span> bl)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;我是一个checked按钮, 当前状态为:&quot;</span> &lt;&lt; bl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关联菜单</span></span><br><span class="line">    ui-&gt;menuBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;你喜欢哪种美女?&quot;</span>);</span><br><span class="line">    QMenu* menu = <span class="keyword">new</span> QMenu;</span><br><span class="line">    QAction* act = menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;可爱的&quot;</span>);</span><br><span class="line">    menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;粘人的&quot;</span>);</span><br><span class="line">    menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;胸大的&quot;</span>);</span><br><span class="line">    menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;屁股翘的&quot;</span>);</span><br><span class="line">    ui-&gt;menuBtn-&gt;<span class="built_in">setMenu</span>(menu);</span><br><span class="line">    <span class="built_in">connect</span>(act, &amp;QAction::triggered, <span class="keyword">this</span>, [=]&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;我是一个可爱的女人, 今晚约吗?&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-3-QToolButton"><a href="#1-3-QToolButton" class="headerlink" title="1.3 QToolButton"></a>1.3 QToolButton</h2><h3 id="1-3-1-常用API"><a href="#1-3-1-常用API" class="headerlink" title="1.3.1 常用API"></a>1.3.1 常用API</h3><blockquote><p>这个类也是一个常用按钮类, 使用方法和功能跟<code>QPushButton</code>基本一致, 只不过在对于关联菜单这个功能点上, <code>QToolButton</code>类可以设置弹出的菜单的属性, 以及在显示图标的时候可以设置更多的样式, 可以理解为是一个增强版的<code>QPushButton</code>。<br>和<code>QPushButton</code>类相同的是, 操作这个按钮使用的大部分函数都是从父类<code>QAbstractButton</code>继承过来的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////// 构造函数 /////////////////////////////</span></span><br><span class="line">QToolButton::<span class="built_in">QToolButton</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////// 公共成员函数 ///////////////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 将给定的菜单与此工具按钮相关联。</span></span><br><span class="line"><span class="comment">    2. 菜单将根据按钮的弹出模式显示。</span></span><br><span class="line"><span class="comment">    3. 菜单的所有权没有转移到“工具”按钮(不能建立父子关系)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolButton::setMenu</span><span class="params">(QMenu *menu)</span></span>;</span><br><span class="line"><span class="comment">// 返回关联的菜单，如果没有定义菜单，则返回nullptr。</span></span><br><span class="line"><span class="function">QMenu *<span class="title">QToolButton::menu</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">弹出菜单的弹出模式是一个枚举类型: QToolButton::ToolButtonPopupMode, 取值如下:</span></span><br><span class="line"><span class="comment">    - QToolButton::DelayedPopup: </span></span><br><span class="line"><span class="comment">        - 延时弹出, 按压工具按钮一段时间后才能弹出, 比如:浏览器的返回按钮</span></span><br><span class="line"><span class="comment">        - 长按按钮菜单弹出, 但是按钮的 clicked 信号不会被发射</span></span><br><span class="line"><span class="comment">    - QToolButton::MenuButtonPopup: </span></span><br><span class="line"><span class="comment">        - 在这种模式下，工具按钮会显示一个特殊的箭头，表示有菜单。</span></span><br><span class="line"><span class="comment">- 当按下按钮的箭头部分时，将显示菜单。按下按钮部分发射 clicked 信号</span></span><br><span class="line"><span class="comment">    - QToolButton::InstantPopup: </span></span><br><span class="line"><span class="comment">        - 当按下工具按钮时，菜单立即显示出来。</span></span><br><span class="line"><span class="comment">        - 在这种模式下，按钮本身的动作不会被触发(不会发射clicked信号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 设置弹出菜单的弹出方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPopupMode</span><span class="params">(QToolButton::ToolButtonPopupMode mode)</span></span>;</span><br><span class="line"><span class="comment">// 获取弹出菜单的弹出方式</span></span><br><span class="line"><span class="function">QToolButton::ToolButtonPopupMode <span class="title">popupMode</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">QToolButton可以帮助我们在按钮上绘制箭头图标, 是一个枚举类型, 取值如下: </span></span><br><span class="line"><span class="comment">    - Qt::NoArrow: 没有箭头</span></span><br><span class="line"><span class="comment">    - Qt::UpArrow: 箭头向上</span></span><br><span class="line"><span class="comment">    - Qt::DownArrow: 箭头向下</span></span><br><span class="line"><span class="comment">    - Qt::LeftArrow: 箭头向左</span></span><br><span class="line"><span class="comment">    - Qt::RightArrow: 箭头向右</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 显示一个箭头作为QToolButton的图标。默认情况下，这个属性被设置为Qt::NoArrow。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setArrowType</span><span class="params">(Qt::ArrowType type)</span></span>;</span><br><span class="line"><span class="comment">// 获取工具按钮上显示的箭头图标样式</span></span><br><span class="line"><span class="function">Qt::ArrowType <span class="title">arrowType</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////// 槽函数 /////////////////////////////</span></span><br><span class="line"><span class="comment">// 给按钮关联一个QAction对象, 主要目的是美化按钮</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QToolButton::setDefaultAction</span><span class="params">(QAction *action)</span></span>;</span><br><span class="line"><span class="comment">// 返回给按钮设置的QAction对象</span></span><br><span class="line"><span class="function">QAction *<span class="title">QToolButton::defaultAction</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">图标的显示样式是一个枚举类型-&gt;Qt::ToolButtonStyle, 取值如下:</span></span><br><span class="line"><span class="comment">    - Qt::ToolButtonIconOnly: 只有图标, 不显示文本信息</span></span><br><span class="line"><span class="comment">    - Qt::ToolButtonTextOnly: 不显示图标, 只显示文本信息</span></span><br><span class="line"><span class="comment">    - Qt::ToolButtonTextBesideIcon: 文本信息在图标的后边显示</span></span><br><span class="line"><span class="comment">    - Qt::ToolButtonTextUnderIcon: 文本信息在图标的下边显示</span></span><br><span class="line"><span class="comment">    - Qt::ToolButtonFollowStyle: 跟随默认样式(只显示图标)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 设置的这个属性决定工具按钮是只显示一个图标、只显示文本，还是在图标旁边/下面显示文本。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QToolButton::setToolButtonStyle</span><span class="params">(Qt::ToolButtonStyle style)</span></span>;</span><br><span class="line"><span class="comment">// 返回工具按钮设置的图标显示模式</span></span><br><span class="line"><span class="function">Qt::ToolButtonStyle <span class="title">toolButtonStyle</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示相关的弹出菜单。如果没有这样的菜单，这个函数将什么也不做。这个函数直到弹出菜单被用户关闭才会返回。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QToolButton::showMenu</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-3-2-按钮的使用"><a href="#1-3-2-按钮的使用" class="headerlink" title="1.3.2 按钮的使用"></a>1.3.2 按钮的使用</h3><blockquote><p>通过API的介绍, 我们可以知道, 使用QToolButton这种类型的按钮</p><ul><li>作为普通按钮, 可以显示文本信息和图标</li><li>按钮的图标可以使用不同的方式设置, 并且制定图标和文本信息的显示模式</li><li>设置check属性, 使其可以处于持续的被选中状态</li><li>关联一个菜单, 点击按钮菜单弹出, 并且可以设置菜单的弹出方式</li></ul></blockquote><p>具体操作可以参考如下代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通按钮, 没有checked属性</span></span><br><span class="line">    ui-&gt;normalBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;我是个屌丝&quot;</span>);</span><br><span class="line">    ui-&gt;normalBtn-&gt;<span class="built_in">setIconSize</span>(<span class="built_in">QSize</span>(<span class="number">50</span>, <span class="number">50</span>));</span><br><span class="line">    ui-&gt;normalBtn-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/mario.png&quot;</span>));</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;normalBtn, &amp;QToolButton::clicked, <span class="keyword">this</span>, [=]()</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;我是一个普通按钮, 是一个屌丝...&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 设置图标和文本的显示模式</span></span><br><span class="line">    ui-&gt;normalBtn-&gt;<span class="built_in">setToolButtonStyle</span>(Qt::ToolButtonTextBesideIcon);</span><br><span class="line">    <span class="comment">// 基于QAction的方式给按钮设置图标和文本信息</span></span><br><span class="line">    QAction* actBtn = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/mushroom_life.png&quot;</span>), <span class="string">&quot;奥利给&quot;</span>);</span><br><span class="line">    ui-&gt;actionBtn-&gt;<span class="built_in">setDefaultAction</span>(actBtn);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;actionBtn, &amp;QToolButton::triggered, <span class="keyword">this</span>, [=](QAction* act)</span><br><span class="line">    &#123;</span><br><span class="line">        act-&gt;<span class="built_in">setText</span>(<span class="string">&quot;我是修改之后的马里奥...&quot;</span>);</span><br><span class="line">        act-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/mario.png&quot;</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 设置图标和文本的显示模式</span></span><br><span class="line">    ui-&gt;actionBtn-&gt;<span class="built_in">setToolButtonStyle</span>(Qt::ToolButtonTextUnderIcon);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基于自带样式, 给按钮设置箭头图标</span></span><br><span class="line">    ui-&gt;arrowBtn-&gt;<span class="built_in">setArrowType</span>(Qt::UpArrow);</span><br><span class="line">    ui-&gt;arrowBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;向上&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置图标和文本的显示模式</span></span><br><span class="line">    ui-&gt;arrowBtn-&gt;<span class="built_in">setToolButtonStyle</span>(Qt::ToolButtonTextUnderIcon);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有checked属性的按钮</span></span><br><span class="line">    ui-&gt;checkedBtn-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;checkedBtn, &amp;QToolButton::toggled, <span class="keyword">this</span>, [=](<span class="type">bool</span> bl)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;我是一个checked按钮, 当前状态为:&quot;</span> &lt;&lt; bl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关联菜单</span></span><br><span class="line">    ui-&gt;menuBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;你喜欢哪种美女?&quot;</span>);</span><br><span class="line">    QMenu* menu = <span class="keyword">new</span> QMenu;</span><br><span class="line">    QAction* act = menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;可爱的&quot;</span>);</span><br><span class="line">    menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;粘人的&quot;</span>);</span><br><span class="line">    menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;胸大的&quot;</span>);</span><br><span class="line">    menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;屁股翘的&quot;</span>);</span><br><span class="line">    ui-&gt;menuBtn-&gt;<span class="built_in">setMenu</span>(menu);</span><br><span class="line">    <span class="built_in">connect</span>(act, &amp;QAction::triggered, <span class="keyword">this</span>, [=]&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;我是一个可爱的女人, 今晚约吗?&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ui-&gt;popmenu-&gt;<span class="built_in">setMenu</span>(menu);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    弹出菜单的弹出模式是一个枚举类型: QToolButton::ToolButtonPopupMode, 取值如下:</span></span><br><span class="line"><span class="comment">      - QToolButton::DelayedPopup: </span></span><br><span class="line"><span class="comment">          - 延时弹出, 按压工具按钮一段时间后才能弹出, 比如:浏览器的返回按钮</span></span><br><span class="line"><span class="comment">          - 长按按钮菜单弹出, 但是按钮的 clicked 信号不会被发射</span></span><br><span class="line"><span class="comment">      - QToolButton::MenuButtonPopup: </span></span><br><span class="line"><span class="comment">          - 在这种模式下，工具按钮会显示一个特殊的箭头，表示有菜单。</span></span><br><span class="line"><span class="comment">  - 当按下按钮的箭头部分时，将显示菜单。按下按钮部分发射 clicked 信号</span></span><br><span class="line"><span class="comment">      - QToolButton::InstantPopup: </span></span><br><span class="line"><span class="comment">          - 当按下工具按钮时，菜单立即显示出来。</span></span><br><span class="line"><span class="comment">          - 在这种模式下，按钮本身的动作不会被触发(不会发射clicked信号</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ui-&gt;popmenu-&gt;<span class="built_in">setPopupMode</span>(QToolButton::MenuButtonPopup);</span><br><span class="line">    <span class="comment">// 测试关联了菜单的按钮是否会发射clicked信号</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;popmenu, &amp;QToolButton::clicked, <span class="keyword">this</span>, [=]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;我是popMenu按钮, 好痒呀...&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-4-QRadioButton"><a href="#1-4-QRadioButton" class="headerlink" title="1.4 QRadioButton"></a>1.4 QRadioButton</h2><blockquote><p><code>QRadioButton</code>是Qt提供的单选按钮, 一般都是以组的方式来使用(<code>多个按钮中同时只能选中其中一个</code>)。操作这个按钮使用的大部分函数都是从父类继承过来的, 它的父类是<code>QAbstractButton</code>。<br>关于单选按钮的使用我们还需要注意一点, <code>如果单选按钮被选中, 再次点击这个按钮选中状态是不能被取消的。</code></p></blockquote><h3 id="1-4-1-常用API"><a href="#1-4-1-常用API" class="headerlink" title="1.4.1 常用API"></a>1.4.1 常用API</h3><blockquote><p>这个类混的很失败, 一直生活在父类的阴影之下, 没有什么作为, 在官方的帮助文档中, 处理构造函数就没有再提供其他可用的 API</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">    - text: 按钮上显示的标题</span></span><br><span class="line"><span class="comment">    - parent: 按钮的父对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QRadioButton::<span class="built_in">QRadioButton</span>(<span class="type">const</span> QString &amp;text, QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">QRadioButton::<span class="built_in">QRadioButton</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="1-4-2-按钮的使用"><a href="#1-4-2-按钮的使用" class="headerlink" title="1.4.2 按钮的使用"></a>1.4.2 按钮的使用</h3><blockquote><p>单选按钮一般是以组的形式来使用的, 如果在一个窗口中需要有多个单选按钮组, 应该如何处理呢?<br><code>在同一窗口中, Qt会认为所有的单选按钮都属于同一组, 如果需要多个单选按钮组, 应该将他们放到不同的子窗口中。</code></p></blockquote><p><img src="/img/a.3.png" alt="在这里插入图片描述"></p><blockquote><p>通过上图可以看到有两个单选按钮组, 在制作的时候分别将单选按钮放到了不同的容器窗口（组框）中，这样就被人为分隔为两组了。</p></blockquote><p><img src="/img/a.4.png" alt="在这里插入图片描述"></p><blockquote><p>如果我们使用鼠标点击了某个单选按钮, 按钮还是会发射出 <code>clicked()</code>信号, 简单的按钮测试代码如下所示:</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_redio_996_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;996&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_radio_nosalary_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;没有加班费&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_radio_nogirl_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;公司没有妹子...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clicked 信号传递的参数可以接收, 也可以不接收 </span></span><br><span class="line"><span class="comment">// 这个参数对应这中类型的按钮没啥用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_radio_notbeautiful_clicked</span><span class="params">(<span class="type">bool</span> checked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;前台小姐姐不好看!!!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-5-QCheckBox"><a href="#1-5-QCheckBox" class="headerlink" title="1.5 QCheckBox"></a>1.5 QCheckBox</h2><blockquote><p><code>QCheckBox</code>是Qt中的复选框按钮, 可以单独使用, 也可以以组的方式使用(同一组可以同时选中多个), <code>当复选按钮被选中, 再次点击之后可以取消选中状态, 这一点和单选按钮是不同的。</code><br>操作这个按钮使用的大部分函数都是从父类继承过来的, 它的父类是<code>QAbstractButton</code>。</p></blockquote><hr><h3 id="1-5-1-常用API"><a href="#1-5-1-常用API" class="headerlink" title="1.5.1 常用API"></a>1.5.1 常用API</h3><blockquote><p>我们对复选框按钮操作的时候, 可以设置选中和未选中状态, 并且还可以设置半选中状态, 这种半选中状态一般需要当前复选框按钮下还有子节点,类似一树状结构。</p></blockquote><ul><li>公共成员函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">    - text: 按钮上显示的文本信息</span></span><br><span class="line"><span class="comment">    - parent: 按钮的父对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QCheckBox::<span class="built_in">QCheckBox</span>(<span class="type">const</span> QString &amp;text, QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">QCheckBox::<span class="built_in">QCheckBox</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前复选框是否为三态复选框, 默认情况下为两种状态: 未选中, 选中</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isTristate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置当前复选框为三态复选框: 未选中, 选中, 半选中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTristate</span><span class="params">(<span class="type">bool</span> y = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数 state, 枚举类型 Qt::CheckState:</span></span><br><span class="line"><span class="comment">    - Qt::Unchecked      --&gt; 当前复选框没有被选中</span></span><br><span class="line"><span class="comment">    - Qt::PartiallyChecked    --&gt; 当前复选框处于半选中状态, 部分被选中(三态复选框)</span></span><br><span class="line"><span class="comment">    - Qt::Checked      --&gt; 当前复选框处于选中状态</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 设置复选框按钮的状态</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QCheckBox::setCheckState</span><span class="params">(Qt::CheckState state)</span></span>;</span><br><span class="line"><span class="comment">// 获取当前复选框的状态</span></span><br><span class="line"><span class="function">Qt::CheckState <span class="title">QCheckBox::checkState</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><ul><li>信号</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当复选框的状态改变时，即当用户选中或取消选中复选框时，他的信号就会发出。</span></span><br><span class="line"><span class="comment">// 参数 state 表示的是复选框的三种状态中某一种, 可参考 Qt::CheckState</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QCheckBox::stateChanged</span><span class="params">(<span class="type">int</span> state)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-5-2-按钮的使用"><a href="#1-5-2-按钮的使用" class="headerlink" title="1.5.2 按钮的使用"></a>1.5.2 按钮的使用</h3><blockquote><p>下面针对于复选框按钮的三种状态, 为大家展示一下对应的操作流程, 首先第一步搭建一个有树状关系的界面:</p></blockquote><p><img src="/img/a.5.png" alt="在这里插入图片描述"></p><blockquote><p>这些复选框按钮的关系以及 <code>objectName</code> 如下:</p></blockquote><p><img src="/img/a.6.png" alt="在这里插入图片描述"></p><blockquote><p>第二步, 在窗口类的头文件中添加槽函数, 槽函数处理复选框按钮的状态变化:</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.h</span></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">MainWindow</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="comment">// 添加槽函数, 处理复选框按钮状态变化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">statusChanged</span><span class="params">(<span class="type">int</span> state)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    <span class="type">int</span> m_number = <span class="number">0</span>;    <span class="comment">// 添加一个计数器, 记录有几个子节点被选中了</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>第三步, 在源文件中添加处理逻辑</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.cpp</span></span><br><span class="line"><span class="comment">// 窗口的构造函数</span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置根节点的三态属性</span></span><br><span class="line">    ui-&gt;wives-&gt;<span class="built_in">setTristate</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 处理根节点的鼠标点击事件</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;wives, &amp;QCheckBox::clicked, <span class="keyword">this</span>, [=](<span class="type">bool</span> bl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(bl)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 子节点全部设置为选中状态</span></span><br><span class="line">            ui-&gt;jianning-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);</span><br><span class="line">            ui-&gt;fangyi-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);</span><br><span class="line">            ui-&gt;longer-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);</span><br><span class="line">            ui-&gt;zengrou-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);</span><br><span class="line">            ui-&gt;mujianping-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);</span><br><span class="line">            ui-&gt;shuanger-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);</span><br><span class="line">            ui-&gt;ake-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 子节点全部设置为非选中状态</span></span><br><span class="line">            ui-&gt;jianning-&gt;<span class="built_in">setChecked</span>(<span class="literal">false</span>);</span><br><span class="line">            ui-&gt;fangyi-&gt;<span class="built_in">setChecked</span>(<span class="literal">false</span>);</span><br><span class="line">            ui-&gt;longer-&gt;<span class="built_in">setChecked</span>(<span class="literal">false</span>);</span><br><span class="line">            ui-&gt;zengrou-&gt;<span class="built_in">setChecked</span>(<span class="literal">false</span>);</span><br><span class="line">            ui-&gt;mujianping-&gt;<span class="built_in">setChecked</span>(<span class="literal">false</span>);</span><br><span class="line">            ui-&gt;shuanger-&gt;<span class="built_in">setChecked</span>(<span class="literal">false</span>);</span><br><span class="line">            ui-&gt;ake-&gt;<span class="built_in">setChecked</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理子节点的状态变化, 对应的槽函数相同</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;jianning, &amp;QCheckBox::stateChanged, <span class="keyword">this</span>, &amp;MainWindow::statusChanged);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;fangyi, &amp;QCheckBox::stateChanged, <span class="keyword">this</span>, &amp;MainWindow::statusChanged);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;longer, &amp;QCheckBox::stateChanged, <span class="keyword">this</span>, &amp;MainWindow::statusChanged);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;zengrou, &amp;QCheckBox::stateChanged, <span class="keyword">this</span>, &amp;MainWindow::statusChanged);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;mujianping, &amp;QCheckBox::stateChanged, <span class="keyword">this</span>, &amp;MainWindow::statusChanged);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;shuanger, &amp;QCheckBox::stateChanged, <span class="keyword">this</span>, &amp;MainWindow::statusChanged);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;ake, &amp;QCheckBox::stateChanged, <span class="keyword">this</span>, &amp;MainWindow::statusChanged);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::statusChanged</span><span class="params">(<span class="type">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state == Qt::Checked)</span><br><span class="line">    &#123;</span><br><span class="line">        m_number ++;<span class="comment">// 选中一个子节点, 计数器加1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_number --;   <span class="comment">// 取消选中一个子节点, 计数器减1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据计数器值判断根节点是否需要做状态的更新</span></span><br><span class="line">    <span class="keyword">if</span>(m_number == <span class="number">7</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;wives-&gt;<span class="built_in">setCheckState</span>(Qt::Checked);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m_number == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;wives-&gt;<span class="built_in">setCheckState</span>(Qt::Unchecked);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;wives-&gt;<span class="built_in">setCheckState</span>(Qt::PartiallyChecked);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="2-容器类型控件"><a href="#2-容器类型控件" class="headerlink" title="2. 容器类型控件"></a>2. 容器类型控件</h1><h2 id="2-1-QWidget"><a href="#2-1-QWidget" class="headerlink" title="2.1 QWidget"></a>2.1 QWidget</h2><blockquote><p>关于<code>QWidget</code>在前面的章节中已经介绍过了, 这个类是所有窗口类的父类, 可以作为独立窗口使用, 也可以内嵌到其它窗口中使用。<br>Qt中的所有控件都属于窗口类， 因此这个类也是所有控件类的基类。<br>如果一个窗口中还有子窗口， 为了让子窗口有序排列， 这时候我们可以选择一个<code>QWidget</code>类型的容器, 将子窗口放到里边, 然后再给这个<code>QWidget</code>类型窗口进行布局操作。<br>介绍一下关于这个类的一些属性，因为这个类是所有窗口类的基类，因此相关属性比较多</p></blockquote><p><img src="/img/a.7.png" alt="在这里插入图片描述"></p><blockquote><p>关于这些属性大部分都有对应的API函数, 在属性名前加 <code>set</code> 即可, 大家可以自己从 <code>QWidget</code> 这个类里边搜索，并仔细阅读关于这些函数的参数介绍。</p></blockquote><p>在Qt中我们除了使用<code>QWidget</code>类型窗口作为容器使用, 也可以根据实际需求选择其他类型的容器, 下面看看具体都有哪些。</p><p><img src="/img/a.8.png" alt="在这里插入图片描述"></p><p>上述容器中， 着重为介绍常用的， 比如：<code>Group Box</code>, <code>Scroll Area</code>, <code>Tool Box</code>, <code>Tab Widget</code>, <code>Stacked</code> <code>Widget, Frame</code>, 关于<code>Dock Widget</code> 已经介绍过, 不在赘述。</p><hr><h2 id="2-2-Frame"><a href="#2-2-Frame" class="headerlink" title="2.2 Frame"></a>2.2 Frame</h2><blockquote><p><code>QFrame</code>就是一个升级版的<code>QWidget</code>, 它继承了<code>QWidget</code>的属性, 并且做了拓展, 这种类型的容器窗口可以提供边框, 并且可以设置边框的样式、宽度以及边框的阴影。</p></blockquote><hr><h3 id="2-2-1-相关API"><a href="#2-2-1-相关API" class="headerlink" title="2.2.1 相关API"></a>2.2.1 相关API</h3><p>关于这个类的API, 一般是不在程序中调用的, 但是还是给大家介绍一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">边框形状为布尔类型, 可选项为:</span></span><br><span class="line"><span class="comment">    - QFrame::NoFrame: 没有边框</span></span><br><span class="line"><span class="comment">    - QFrame::Box: 绘制一个框</span></span><br><span class="line"><span class="comment">    - QFrame::Panel: 绘制一个面板，使内容显示为凸起或凹陷</span></span><br><span class="line"><span class="comment">    - QFrame::StyledPanel: 绘制一个外观取决于当前GUI样式的矩形面板。它可以上升也可以下沉。</span></span><br><span class="line"><span class="comment">    - QFrame::HLine: 画一条没有边框的水平线(用作分隔符)</span></span><br><span class="line"><span class="comment">    - QFrame::VLine: 画一条没有边框的垂直线(用作分隔符)</span></span><br><span class="line"><span class="comment">    - QFrame::WinPanel: 绘制一个矩形面板，可以像Windows 2000那样向上或向下移动。</span></span><br><span class="line"><span class="comment">                指定此形状将线宽设置为2像素。WinPanel是为了兼容而提供的。</span></span><br><span class="line"><span class="comment">                对于GUI风格的独立性，我们建议使用StyledPanel代替。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获取边框形状</span></span><br><span class="line"><span class="function">Shape <span class="title">frameShape</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置边框形状</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setFrameShape</span><span class="params">(Shape)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Qt中关于边框的阴影(QFrame::Shadow)提供了3种样式, 分别为: </span></span><br><span class="line"><span class="comment">    - QFrame::Plain: 简单的,朴素的, 框架和内容与周围环境显得水平;</span></span><br><span class="line"><span class="comment">             使用调色板绘制QPalette::WindowText颜色(没有任何3D效果)</span></span><br><span class="line"><span class="comment">    - QFrame::Raised: 框架和内容出现凸起;使用当前颜色组的明暗颜色绘制3D凸起线</span></span><br><span class="line"><span class="comment">    - QFrame::Sunken: 框架及内容物凹陷;使用当前颜色组的明暗颜色绘制3D凹线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获取边框阴影样式</span></span><br><span class="line"><span class="function">Shadow <span class="title">frameShadow</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置边框阴影样式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setFrameShadow</span><span class="params">(Shadow)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到边框线宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lineWidth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置边框线宽度, 默认值为1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setLineWidth</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到中线的宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">midLineWidth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置中线宽度, 默认值为0, 这条线会影响边框阴影的显示</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMidLineWidth</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-2-2-属性设置"><a href="#2-2-2-属性设置" class="headerlink" title="2.2.2 属性设置"></a>2.2.2 属性设置</h3><blockquote><p>这个类的属性并不多, 都是关于边框的设置的。</p></blockquote><p><img src="/img/a.9.png" alt="在这里插入图片描述"></p><blockquote><p>这个表格显示了一些<code>边框样式</code>和<code>线宽</code>以及<code>阴影</code>的组合:</p></blockquote><p><img src="/img/a.10.png" alt="在这里插入图片描述"></p><hr><h2 id="2-3-Group-Box"><a href="#2-3-Group-Box" class="headerlink" title="2.3 Group Box"></a>2.3 Group Box</h2><blockquote><p><code>QGroupBox</code>类的基类是<code>QWidget</code>, 在这种类型的窗口中可以绘制边框、给窗口指定标题, 并且还支持显示复选框。</p></blockquote><h3 id="2-3-1-相关API"><a href="#2-3-1-相关API" class="headerlink" title="2.3.1 相关API"></a>2.3.1 相关API</h3><blockquote><p>关于这个类的API不常用, 下面给大家介绍一下在编码过程中可能会用到的一些:</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QGroupBox::<span class="built_in">QGroupBox</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line">QGroupBox::<span class="built_in">QGroupBox</span>(<span class="type">const</span> QString &amp;title, QWidget *parent = Q_NULLPTR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QGroupBox::isCheckable</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置是否在组框中显示一个复选框</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGroupBox::setCheckable</span><span class="params">(<span class="type">bool</span> checkable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于对齐方式需要使用枚举类型 Qt::Alignment, 其可选项为:</span></span><br><span class="line"><span class="comment">    - Qt::AlignLeft: 左对齐(水平方向)</span></span><br><span class="line"><span class="comment">    - Qt::AlignRight: 右对齐(水平方向)</span></span><br><span class="line"><span class="comment">    - Qt::AlignHCenter: 水平居中</span></span><br><span class="line"><span class="comment">    - Qt::AlignJustify: 在可用的空间内调整文本(水平方向)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    - Qt::AlignTop: 上对齐(垂直方向)</span></span><br><span class="line"><span class="comment">    - Qt::AlignBottom: 下对齐(垂直方向)</span></span><br><span class="line"><span class="comment">    - Qt::AlignVCenter: 垂直居中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Qt::Alignment <span class="title">QGroupBox::alignment</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置组框标题的对其方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGroupBox::setAlignment</span><span class="params">(<span class="type">int</span> alignment)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">QGroupBox::title</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置组框的标题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGroupBox::setTitle</span><span class="params">(<span class="type">const</span> QString &amp;title)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QGroupBox::isChecked</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置组框中复选框的选中状态</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QGroupBox::setChecked</span><span class="params">(<span class="type">bool</span> checked)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-2-属性设置"><a href="#2-3-2-属性设置" class="headerlink" title="2.3.2 属性设置"></a>2.3.2 属性设置</h3><blockquote><p>关于组框的属性对应的就是上边介绍的那几个API函数, 属性窗口如下:</p></blockquote><p><img src="/img/a.11.png" alt="在这里插入图片描述"></p><blockquote><p>组框中的<code>flat</code>属性没有对应的API函数, 只能在属性窗口中设置, 它控制的是窗口边框的绘制方式, 如果打开该属性, 组框的边框就消失了, 效果如下:</p></blockquote><p><img src="/img/a.12.png" alt="在这里插入图片描述"></p><hr><h2 id="2-4-Scroll-Area"><a href="#2-4-Scroll-Area" class="headerlink" title="2.4 Scroll Area"></a>2.4 Scroll Area</h2><blockquote><p><code>QScrollArea</code>这种类型的容器, 里边可以放置一些窗口控件, <code>当放置的窗口控件大于当前区域导致无法全部显示的时候, 滚动区域容器会自动添加相应的滚动条(水平方向或者垂直方向), 保证放置到该区域中的所有窗口内容都可以正常显示出来。</code>对于使用者不需要做太多事情, 只需要把需要显示的窗口放到滚动区域中就行了。</p></blockquote><hr><h3 id="2-4-1-相关API"><a href="#2-4-1-相关API" class="headerlink" title="2.4.1 相关API"></a>2.4.1 相关API</h3><blockquote><p>在某些特定环境下, 我们需要动态的往滚动区域内部添加要显示的窗口, 或者动态的将显示的窗口移除, 这时候就必须要调用对应的API函数来完成这部分操作了。主要API有两个 <code>添加 - setWidget()</code>, <code>移除 - takeWidget()</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QScrollArea::<span class="built_in">QScrollArea</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 给滚动区域设置要显示的子窗口widget</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QScrollArea::setWidget</span><span class="params">(QWidget *widget)</span></span>;</span><br><span class="line"><span class="comment">// 删除滚动区域中的子窗口, 并返回被删除的子窗口对象</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QScrollArea::takeWidget</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于显示位置的设定, 是一个枚举类型, 可选项为:</span></span><br><span class="line"><span class="comment">    - Qt::AlignLeft: 左对齐</span></span><br><span class="line"><span class="comment">    - Qt::AlignHCenter: 水平居中</span></span><br><span class="line"><span class="comment">    - Qt::AlignRight: 右对齐</span></span><br><span class="line"><span class="comment">    - Qt::AlignTop: 顶部对齐</span></span><br><span class="line"><span class="comment">    - Qt::AlignVCenter: 垂直对其</span></span><br><span class="line"><span class="comment">    - Qt::AlignBottom: 底部对其</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获取子窗口在滚动区域中的显示位置</span></span><br><span class="line"><span class="function">Qt::Alignment <span class="title">alignment</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置滚动区域中子窗口的对其方式, 默认显示的位置是右上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAlignment</span><span class="params">(Qt::Alignment)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断滚动区域是否有自动调节小部件大小的属性</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">widgetResizable</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 设置滚动区域是否应该调整视图小部件的大小, 该属性默认为false, 滚动区域按照小部件的默认大小进行显示。</span></span><br><span class="line"><span class="comment">2. 如果该属性设置为true，滚动区域将自动调整小部件的大小，避免滚动条出现在本可以避免的地方，</span></span><br><span class="line"><span class="comment">   或者利用额外的空间。</span></span><br><span class="line"><span class="comment">3. 不管这个属性是什么，我们都可以使用widget()-&gt;resize()以编程方式调整小部件的大小，</span></span><br><span class="line"><span class="comment">   滚动区域将自动调整自己以适应新的大小。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWidgetResizable</span><span class="params">(<span class="type">bool</span> resizable)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-4-2-属性设置"><a href="#2-4-2-属性设置" class="headerlink" title="2.4.2 属性设置"></a>2.4.2 属性设置</h3><blockquote><p>关于滚动区域, 其属性窗口提供的属性一般不需要设置, 因为一般情况下即便是设置了也看不到效果</p></blockquote><p><img src="/img/a.13.png" alt="在这里插入图片描述"></p><hr><h3 id="2-4-3-窗口的动态添加和删除"><a href="#2-4-3-窗口的动态添加和删除" class="headerlink" title="2.4.3 窗口的动态添加和删除"></a>2.4.3 窗口的动态添加和删除</h3><blockquote><p>关于窗口的滚动区域对象创建有两种方式, 第一种比较简单在编辑页面直接拖拽一个控件到UI界面, 然后布局即可。第二种方式是在程序中通过<code>new</code>操作创建一个实例对象, 然后通过通过代码的方式将其添加到窗口的某个布局中, 相对来说要麻烦一点。<br>下面通过第一种方式，演示一下如果往滚动区域中添加多个子窗口。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个垂直布局对象</span></span><br><span class="line">    QVBoxLayout* vlayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">11</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建标签对象</span></span><br><span class="line">        QLabel* pic = <span class="keyword">new</span> QLabel;</span><br><span class="line">        <span class="comment">// 拼接图片在资源文件中的路径</span></span><br><span class="line">        QString name = <span class="built_in">QString</span>(<span class="string">&quot;:/images/%1.png&quot;</span>).<span class="built_in">arg</span>(i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 给标签对象设置显示的图片</span></span><br><span class="line">        pic-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(name));</span><br><span class="line">        <span class="comment">// 设置图片在便签内部的对其方式</span></span><br><span class="line">        pic-&gt;<span class="built_in">setAlignment</span>(Qt::AlignHCenter);</span><br><span class="line">        <span class="comment">// 将标签添加到垂直布局中</span></span><br><span class="line">        vlayout-&gt;<span class="built_in">addWidget</span>(pic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个窗口对象</span></span><br><span class="line">    QWidget* wg = <span class="keyword">new</span> QWidget;</span><br><span class="line">    <span class="comment">// 将垂直布局设置给窗口对象</span></span><br><span class="line">    wg-&gt;<span class="built_in">setLayout</span>(vlayout);</span><br><span class="line">    <span class="comment">// 将带有垂直布局的窗口设置到滚动区域中</span></span><br><span class="line">    ui-&gt;scrollArea-&gt;<span class="built_in">setWidget</span>(wg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于以上代码做以下说明, 调用<code>setWidget(wg)</code>之后, wg会自动平铺填充满整个滚动区域, 因此:</p><ul><li>在程序中调用 <code>void setWidgetResizable(bool resizable);</code>不会有明显效果</li><li>在程序中调用 <code>void setAlignment(Qt::Alignment);</code>不会看到任何效果</li><li>如果要设置显示的图片的对其方式要设置图片的载体对象即 <code>标签签对象</code></li><li>如果要动态移除滚动区域中的窗口, 直接使用滚动区域对象调用 <code>takeWidget()</code> 即可</li><li>滚动区域中只能通过<code>setWidget(wg)</code>添加一个子窗口, 如果要添加多个可使用布局的方式来实现</li></ul><hr><h2 id="2-5-Tool-Box"><a href="#2-5-Tool-Box" class="headerlink" title="2.5 Tool Box"></a>2.5 Tool Box</h2><blockquote><p><code>QToolBox</code>工具箱控件, 可以存储多个子窗口, 该控件可以实现类似QQ的抽屉效果, 每一个抽屉都可以设置图标和标题, 并且对应一个子窗口, 通过抽屉按钮就可以实现各个子窗口显示的切换。</p></blockquote><h3 id="2-5-1-相关API"><a href="#2-5-1-相关API" class="headerlink" title="2.5.1 相关API"></a>2.5.1 相关API</h3><blockquote><p>这个类对应的API函数相对较多, 一部分是控件属性对应的属性设置函数, 一部分是编程过程中可能会用的到的,理解为主吧, 知道有这么函数即可。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QToolBox::<span class="built_in">QToolBox</span>(QWidget *parent = Q_NULLPTR, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">addItem(), insertItem()函数相关参数:</span></span><br><span class="line"><span class="comment">    - widget: 添加到工具箱中的选项卡对应的子窗口对象</span></span><br><span class="line"><span class="comment">    - icon: 工具箱新的选项卡上显示的图标</span></span><br><span class="line"><span class="comment">    - text: 工具箱新的选项卡上显示的标题</span></span><br><span class="line"><span class="comment">    - index: 指定在工具箱中插入的新的选项卡的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 给工具箱尾部添加一个选项卡, 每个选项卡在工具箱中就是一个子窗口, 即参数widget</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::addItem</span><span class="params">(QWidget *widget, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::addItem</span><span class="params">(QWidget *widget, <span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="comment">// 在工具箱的指定位置添加一个选项卡, 即添加一个子窗口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::insertItem</span><span class="params">(<span class="type">int</span> index, QWidget *widget, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::insertItem</span><span class="params">(<span class="type">int</span> index, QWidget *widget, <span class="type">const</span> QIcon &amp;icon, </span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="comment">// 移除工具箱中索引index位置对应的选项卡, 注意: 只是移除对应的窗口对象并没有被销毁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolBox::removeItem</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置索引index位置的选项卡是否可用, 参数 enabled=true为可用, enabled=false为禁用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolBox::setItemEnabled</span><span class="params">(<span class="type">int</span> index, <span class="type">bool</span> enabled)</span></span>;</span><br><span class="line"><span class="comment">// 设置工具箱中index位置选项卡的图标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolBox::setItemIcon</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"><span class="comment">// 设置工具箱中index位置选项卡的标题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolBox::setItemText</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="comment">// 设置工具箱中index位置选项卡的提示信息(需要鼠标在选项卡上悬停一定时长才能显示)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolBox::setItemToolTip</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> QString &amp;toolTip)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果位置索引的项已启用，则返回true;否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QToolBox::isItemEnabled</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回位置索引处项目的图标，如果索引超出范围，则返回空图标。</span></span><br><span class="line"><span class="function">QIcon <span class="title">QToolBox::itemIcon</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回位于位置索引处的项的文本，如果索引超出范围，则返回空字符串。</span></span><br><span class="line"><span class="function">QString <span class="title">QToolBox::itemText</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回位于位置索引处的项的工具提示，如果索引超出范围，则返回空字符串。</span></span><br><span class="line"><span class="function">QString <span class="title">QToolBox::itemToolTip</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到当前工具箱中显示的选项卡对应的索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::currentIndex</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回指向当前选项卡对应的子窗口的指针，如果没有这样的项，则返回0。</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QToolBox::currentWidget</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回工具箱中子窗口的索引，如果widget对象不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::indexOf</span><span class="params">(QWidget *widget)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回工具箱中包含的项的数量。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号</span></span><br><span class="line"><span class="comment">// 工具箱中当前显示的选项卡发生变化, 该信号被发射, index为当前显示的新的选项卡的对应的索引</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QToolBox::currentChanged</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 槽函数</span></span><br><span class="line"><span class="comment">// 通过工具箱中选项卡对应的索引设置当前要显示哪一个选项卡中的子窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QToolBox::setCurrentIndex</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">// 通过工具箱中选项卡对应的子窗口对象设置当前要显示哪一个选项卡中的子窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QToolBox::setCurrentWidget</span><span class="params">(QWidget *widget)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-5-2-属性设置"><a href="#2-5-2-属性设置" class="headerlink" title="2.5.2 属性设置"></a>2.5.2 属性设置</h3><blockquote><p>关于这个容器控件的属性远比上边介绍的API要少</p></blockquote><p><img src="/img/a.14.png" alt="在这里插入图片描述"></p><hr><h2 id="2-6-Tab-Widget"><a href="#2-6-Tab-Widget" class="headerlink" title="2.6 Tab Widget"></a>2.6 Tab Widget</h2><blockquote><p><code>QTabWidget</code>的一种带标签页的窗口，在这种类型的窗口中可以存储多个子窗口，每个子窗口的显示可以通过对应的标签进行切换。</p></blockquote><h3 id="2-6-1-相关API"><a href="#2-6-1-相关API" class="headerlink" title="2.6.1 相关API"></a>2.6.1 相关API</h3><blockquote><p>介绍的这些API大部分是进行属性设置的, 因此我们可以完全不在程序中使用这些函数, 通属性窗口进行设置, 但是API操作比较灵活, 可以动态的设置相关属性。先来看公共成员函数:</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QTabWidget::<span class="built_in">QTabWidget</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">添加选项卡addTab()或者插入选项卡insertTab()函数相关的参数如下:</span></span><br><span class="line"><span class="comment">    - page: 添加或者插入的选项卡对应的窗口实例对象</span></span><br><span class="line"><span class="comment">    - label: 添加或者插入的选项卡的标题</span></span><br><span class="line"><span class="comment">    - icon: 添加或者插入的选项卡的图标</span></span><br><span class="line"><span class="comment">    - index: 将新的选项卡插入到索引index的位置上</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTabWidget::addTab</span><span class="params">(QWidget *page, <span class="type">const</span> QString &amp;label)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTabWidget::addTab</span><span class="params">(QWidget *page, <span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;label)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTabWidget::insertTab</span><span class="params">(<span class="type">int</span> index, QWidget *page, <span class="type">const</span> QString &amp;label)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTabWidget::insertTab</span><span class="params">(<span class="type">int</span> index, QWidget *page, </span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;label)</span></span>;</span><br><span class="line"><span class="comment">// 删除index位置的选项卡</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::removeTab</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到选项卡栏中的选项卡的数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 从窗口中移除所有页面，但不删除它们。调用这个函数相当于调用removeTab()，直到选项卡小部件为空为止。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取当前选项卡对应的索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTabWidget::currentIndex</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前选项卡对应的窗口对象地址</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QTabWidget::currentWidget</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回索引位置为index的选项卡页，如果索引超出范围则返回0。</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QTabWidget::widget</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">标签上显示的文本样式为枚举类型 Qt::TextElideMode, 可选项为:</span></span><br><span class="line"><span class="comment">    - Qt::ElideLeft: 省略号应出现在课文的开头，例如：.....是的,我很帅。</span></span><br><span class="line"><span class="comment">    - Qt::ElideRight: 省略号应出现在文本的末尾，例如：我帅吗.....。</span></span><br><span class="line"><span class="comment">    - Qt::ElideMiddle: 省略号应出现在文本的中间，例如：我帅.....很帅。</span></span><br><span class="line"><span class="comment">    - Qt::ElideNone: 省略号不应出现在文本中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获取标签上显示的文本模式</span></span><br><span class="line"><span class="function">Qt::TextElideMode <span class="title">QTabWidget::elideMode</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 如何省略标签栏中的文本, 此属性控制在给定的选项卡栏大小没有足够的空间显示项时如何省略项。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setElideMode</span><span class="params">(Qt::TextElideMode)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 得到选项卡上图标的尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">QTabWidget::iconSize</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置选项卡上显示的图标大小</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setIconSize</span><span class="params">(<span class="type">const</span> QSize &amp;size)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 判断用户是否可以在选项卡区域内移动选项卡, 可以返回true, 否则返回false</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTabWidget::isMovable</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 此属性用于设置用户是否可以在选项卡区域内移动选项卡。默认情况下，此属性为false;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setMovable</span><span class="params">(<span class="type">bool</span> movable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断选项卡是否可以自动隐藏, 如果可以自动隐藏返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTabWidget::tabBarAutoHide</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 如果为true，则当选项卡栏包含少于2个选项卡时，它将自动隐藏。默认情况下，此属性为false。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabBarAutoHide</span><span class="params">(<span class="type">bool</span> enabled)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断index对应的选项卡是否是被启用的, 如果是被启用的返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTabWidget::isTabEnabled</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 如果enable为true，则在索引位置的页面是启用的;否则，在位置索引处的页面将被禁用。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabEnabled</span><span class="params">(<span class="type">int</span> index, <span class="type">bool</span> enable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到index位置的标签对应的图标</span></span><br><span class="line"><span class="function">QIcon <span class="title">QTabWidget::tabIcon</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 在位置索引处设置标签的图标。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabIcon</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">选项卡标签的位置通过枚举值进行指定, 可使用的选项如下:</span></span><br><span class="line"><span class="comment">- QTabWidget::North: 北(上), 默认</span></span><br><span class="line"><span class="comment">- QTabWidget::South: 南(下)</span></span><br><span class="line"><span class="comment">- QTabWidget::West: 西(左)</span></span><br><span class="line"><span class="comment">- QTabWidget::East:  东(右)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 得到选项卡中显示的标签的位置, 即: 东, 西, 南, 北</span></span><br><span class="line"><span class="function">TabPosition <span class="title">QTabWidget::tabPosition</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置选项卡中标签显示的位置, 默认情况下，此属性设置为North。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabPosition</span><span class="params">(TabPosition)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">选项卡标签的形状通过枚举值进行指定, 可使用的选项如下:</span></span><br><span class="line"><span class="comment">- QTabWidget::Rounded: 标签以圆形的外观绘制。这是默认形状</span></span><br><span class="line"><span class="comment">- QTabWidget::Triangular: 选项卡以三角形外观绘制。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获得选项卡标签的形状</span></span><br><span class="line"><span class="function">TabShape <span class="title">QTabWidget::tabShape</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置选项卡标签的形状</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabShape</span><span class="params">(TabShape s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到index位置的标签的标题</span></span><br><span class="line"><span class="function">QString <span class="title">QTabWidget::tabText</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置选项卡index位置的标签的标题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabText</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> QString &amp;label)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取index对应的标签页上设置的提示信息</span></span><br><span class="line"><span class="function">QString <span class="title">QTabWidget::tabToolTip</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置选项卡index位置的标签的提示信息(鼠标需要悬停在标签上一定时长才能显示)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabToolTip</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> QString &amp;tip)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断选项卡标签也上是否有关闭按钮, 如果有返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTabWidget::tabsClosable</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置选项卡的标签页上是否显示关闭按钮, 该属性默认情况下为false</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabsClosable</span><span class="params">(<span class="type">bool</span> closeable)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断选项卡栏中是否有滚动按钮, 如果有返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTabWidget::usesScrollButtons</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置选项卡栏有许多标签时，它是否应该使用按钮来滚动标签。</span></span><br><span class="line"><span class="comment">// 当一个选项卡栏有太多的标签时，选项卡栏可以选择扩大它的大小，或者添加按钮，让标签在选项卡栏中滚动。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setUsesScrollButtons</span><span class="params">(<span class="type">bool</span> useButtons)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断窗口是否设置了文档模式, 如果设置了返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTabWidget::documentMode</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 此属性保存选项卡小部件是否以适合文档页面的模式呈现。这与macOS上的文档模式相同。</span></span><br><span class="line"><span class="comment">// 不设置该属性, QTabWidget窗口是带边框的, 如果设置了该属性边框就没有了。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setDocumentMode</span><span class="params">(<span class="type">bool</span> set)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>信号</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每当当前页索引改变时，就会发出这个信号。参数是新的当前页索引位置，如果没有新的索引位置，则为-1</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QTabWidget::currentChanged</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">// 当用户单击索引处的选项卡时，就会发出这个信号。index指所单击的选项卡，如果光标下没有选项卡，则为-1。</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QTabWidget::tabBarClicked</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 当用户双击索引上的一个选项卡时，就会发出这个信号。</span></span></span><br><span class="line"><span class="function"><span class="comment">// index是单击的选项卡的索引，如果光标下没有选项卡，则为-1。</span></span></span><br><span class="line"><span class="function">[signal] <span class="type">void</span> <span class="title">QTabWidget::tabBarDoubleClicked</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">// 此信号在单击选项卡上的close按钮时发出。索引是应该被删除的索引。 </span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QTabWidget::tabCloseRequested</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>槽函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置当前窗口中显示选项卡index位置对应的标签页内容</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QTabWidget::setCurrentIndex</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口中显示选项卡中子窗口widget中的内容</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QTabWidget::setCurrentWidget</span><span class="params">(QWidget *widget)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-6-2-属性设置"><a href="#2-6-2-属性设置" class="headerlink" title="2.6.2 属性设置"></a>2.6.2 属性设置</h3><blockquote><p>容器类型的控件其大多数情况下都是直接在属性窗口中直接设置, 因为这些属性设置完毕之后, 就无需再做修改了, 程序运行过程中无需做任何变化。下图为大家标注了每个属性对应的功能。</p></blockquote><p><img src="/img/a.15.png" alt="在这里插入图片描述"></p><hr><h3 id="2-6-3-控件使用"><a href="#2-6-3-控件使用" class="headerlink" title="2.6.3 控件使用"></a>2.6.3 控件使用</h3><blockquote><p>关于这个控件的使用, 主要是通过代码的方式演示一下相关信号发射的时机, 再有就是当标签页添加了关闭按钮并点击了该按钮, 如果移除该标签页已经如何将其再次添加到窗口中。</p></blockquote><blockquote><p>第一步, 在头文件中添加存储已关闭的<code>标签对应的窗口对象</code>和<code>标签标题的容器</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.h</span></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">MainWindow</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    QQueue&lt;QWidget*&gt; m_widgets;<span class="comment">// 存储标签对应的窗口对象</span></span><br><span class="line">    QQueue&lt;QString&gt; m_names;    <span class="comment">// 存储标签标题</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>第二步在源文件中添加处理动作</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.cpp</span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击了标签上的关闭按钮</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;tabWidget, &amp;QTabWidget::tabCloseRequested, <span class="keyword">this</span>, [=](<span class="type">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 保存信息</span></span><br><span class="line">        QWidget* wg = ui-&gt;tabWidget-&gt;<span class="built_in">widget</span>(index);</span><br><span class="line">        QString title = ui-&gt;tabWidget-&gt;<span class="built_in">tabText</span>(index);</span><br><span class="line">        m_widgets.<span class="built_in">enqueue</span>(wg);</span><br><span class="line">        m_names.<span class="built_in">enqueue</span>(title);</span><br><span class="line">        <span class="comment">// 移除tab页</span></span><br><span class="line">        ui-&gt;tabWidget-&gt;<span class="built_in">removeTab</span>(index);</span><br><span class="line">        ui-&gt;addBtn-&gt;<span class="built_in">setEnabled</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当标签被点击了之后的处理动作</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;tabWidget, &amp;QTabWidget::tabBarClicked, <span class="keyword">this</span>, [=](<span class="type">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;我被点击了一下, 我的标题是: &quot;</span> &lt;&lt; ui-&gt;tabWidget-&gt;<span class="built_in">tabText</span>(index);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换标签之后的处理动作</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;tabWidget, &amp;QTabWidget::currentChanged, <span class="keyword">this</span>, [=](<span class="type">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;当前显示的tab页, 我的标题是: &quot;</span> &lt;&lt; ui-&gt;tabWidget-&gt;<span class="built_in">tabText</span>(index);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击添加标签按钮点击之后的处理动作</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;addBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将被删除的标签页添加到窗口中</span></span><br><span class="line">        <span class="comment">// 1. 知道窗口对象, 窗口的标题</span></span><br><span class="line">        <span class="comment">// 2. 知道添加函数</span></span><br><span class="line">        ui-&gt;tabWidget-&gt;<span class="built_in">addTab</span>(m_widgets.<span class="built_in">dequeue</span>(), m_names.<span class="built_in">dequeue</span>());</span><br><span class="line">        <span class="keyword">if</span>(m_widgets.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ui-&gt;addBtn-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-7-Stacked-Widget"><a href="#2-7-Stacked-Widget" class="headerlink" title="2.7 Stacked Widget"></a>2.7 Stacked Widget</h2><blockquote><p><code>QStackedWidget</code> 栈类型窗口, 在这种类型的窗口中可以存储多个子窗口, 但是只有其中某一个可以被显示出来, 至于是哪个子窗口被显示, 需要在程序中进行控制，在这种类型的窗口中没有直接切换子窗口的按钮或者标签。</p></blockquote><h3 id="2-7-1-相关API"><a href="#2-7-1-相关API" class="headerlink" title="2.7.1 相关API"></a>2.7.1 相关API</h3><blockquote><p>先来了解一些这个类为我们提供的API, 在这些函数中最常用的就是它的槽函数, 并且名字和 <code>QToolBox</code>, <code>QTabWidget</code> 两个类提供的槽函数名字相同 分别为 <code>setCurrentIndex(int)</code>, <code>setCurrentWidget(QWidget*)</code> 用来设置当前显示的窗口。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QStackedWidget::<span class="built_in">QStackedWidget</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 在栈窗口中后边添加一个子窗口, 返回这个子窗口在栈窗口中的索引值(从0开始计数)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QStackedWidget::addWidget</span><span class="params">(QWidget *widget)</span></span>;</span><br><span class="line"><span class="comment">// 将子窗口widget插入到栈窗口的index位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QStackedWidget::insertWidget</span><span class="params">(<span class="type">int</span> index, QWidget *widget)</span></span>;</span><br><span class="line"><span class="comment">// 将子窗口widget从栈窗口中删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QStackedWidget::removeWidget</span><span class="params">(QWidget *widget)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回栈容器窗口中存储的子窗口的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QStackedWidget::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到当前栈窗口中显示的子窗口的索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QStackedWidget::currentIndex</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到当前栈窗口中显示的子窗口的指针(窗口地址)</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QStackedWidget::currentWidget</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 基于索引index得到栈窗口中对应的子窗口的指针</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QStackedWidget::widget</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 基于子窗口的指针(实例地址)得到其在栈窗口中的索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QStackedWidget::indexOf</span><span class="params">(QWidget *widget)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号</span></span><br><span class="line"><span class="comment">// 切换栈窗口中显示子窗口, 该信息被发射出来, index为新的当前窗口对应的索引值</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QStackedWidget::currentChanged</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">// 当栈窗口的子窗口被删除, 该信号被发射出来, index为被删除的窗口对应的索引值</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QStackedWidget::widgetRemoved</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 槽函数</span></span><br><span class="line"><span class="comment">// 基于子窗口的index索引指定当前栈窗口中显示哪一个子窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QStackedWidget::setCurrentIndex</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QStackedWidget::setCurrentWidget</span><span class="params">(QWidget *widget)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-7-2-属性设置"><a href="#2-7-2-属性设置" class="headerlink" title="2.7.2 属性设置"></a>2.7.2 属性设置</h3><blockquote><p>因为栈类型的窗口容器很简单, 所以对应的属性页很少, 只有两个:</p></blockquote><p><img src="/img/a.16.png" alt="在这里插入图片描述"></p><hr><h3 id="2-7-3-控件使用"><a href="#2-7-3-控件使用" class="headerlink" title="2.7.3 控件使用"></a>2.7.3 控件使用</h3><blockquote><p>这里主要给大家演示一下<code>QStackedWidget</code>类型的容器中的子窗口如何切换, 如下图所示, 我们在一个栈窗口容器中添加了两个子窗口, 通过两个按钮对这两个窗口进行切换</p></blockquote><p><img src="/img/a.17.png" alt="在这里插入图片描述"></p><blockquote><p>关于窗口的切换调用这个类的槽函数就可以了, 代码如下:</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 设置默认显示的窗口</span></span><br><span class="line">    ui-&gt;stackedWidget-&gt;<span class="built_in">setCurrentWidget</span>(ui-&gt;window1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;showWin1, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 切换显示第一个子窗口</span></span><br><span class="line">        ui-&gt;stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;showWin2, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 切换显示第二个子窗口, 调用这两个槽函数中的任何一个都可以</span></span><br><span class="line">        ui-&gt;stackedWidget-&gt;<span class="built_in">setCurrentWidget</span>(ui-&gt;window2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-按钮类型控件&quot;&gt;&lt;a href=&quot;#1-按钮类型控件&quot; class=&quot;headerlink&quot; title=&quot;1. 按钮类型控件&quot;&gt;&lt;/a&gt;1. 按钮类型控件&lt;/h1&gt;&lt;h2 id=&quot;1-1-按钮基类-QAbstractButton&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Qt" scheme="http://example.com/categories/Qt/"/>
    
    
  </entry>
  
  <entry>
    <title>窗口</title>
    <link href="http://example.com/2023/10/22/%E7%AA%97%E5%8F%A3/"/>
    <id>http://example.com/2023/10/22/%E7%AA%97%E5%8F%A3/</id>
    <published>2023-10-22T01:53:58.000Z</published>
    <updated>2023-10-22T03:44:26.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-基础窗口类"><a href="#1-基础窗口类" class="headerlink" title="1. 基础窗口类"></a>1. 基础窗口类</h1><h2 id="1-1-QWidget"><a href="#1-1-QWidget" class="headerlink" title="1.1 QWidget"></a>1.1 QWidget</h2><blockquote><p>QWidget类是所有窗口类的父类(控件类是也属于窗口类), 并且QWidget类的父类的QObject,<br>也就意味着<code>所有的窗口类对象只要指定了父对象, 都可以实现内存资源的自动回收。</code><br>关于这个窗口类的属性介绍, 参考容器控件之QWidget。</p></blockquote><p><img src="/img/9.53.png" alt="在这里插入图片描述"></p><h3 id="1-1-1-设置父对象"><a href="#1-1-1-设置父对象" class="headerlink" title="1.1.1 设置父对象"></a>1.1.1 设置父对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QWidget::<span class="built_in">QWidget</span>(QWidget *parent = <span class="literal">nullptr</span>, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 给当前窗口设置父对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setParent</span><span class="params">(QWidget *parent)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setParent</span><span class="params">(QWidget *parent, Qt::WindowFlags f)</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的父对象, 没有父对象返回 nullptr</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QWidget::parentWidget</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-2-窗口位置"><a href="#1-1-2-窗口位置" class="headerlink" title="1.1.2 窗口位置"></a>1.1.2 窗口位置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------- 窗口位置 -------------</span></span><br><span class="line"><span class="comment">// 得到相对于当前窗口父窗口的几何信息, 边框也被计算在内</span></span><br><span class="line"><span class="function">QRect <span class="title">QWidget::frameGeometry</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到相对于当前窗口父窗口的几何信息, 不包括边框</span></span><br><span class="line"><span class="function"><span class="type">const</span> QRect &amp;<span class="title">geometry</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口的几何信息(位置和尺寸信息), 不包括边框</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGeometry</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGeometry</span><span class="params">(<span class="type">const</span> QRect &amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 移动窗口, 重新设置窗口的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">const</span> QPoint &amp;)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>窗口位置设定和位置获取的测试代码如下:</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前窗口的位置信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_positionBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QRect rect = <span class="keyword">this</span>-&gt;<span class="built_in">frameGeometry</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;左上角: &quot;</span> &lt;&lt; rect.<span class="built_in">topLeft</span>()</span><br><span class="line">             &lt;&lt; <span class="string">&quot;右上角: &quot;</span> &lt;&lt; rect.<span class="built_in">topRight</span>()</span><br><span class="line">             &lt;&lt; <span class="string">&quot;左下角: &quot;</span> &lt;&lt; rect.<span class="built_in">bottomLeft</span>()</span><br><span class="line">             &lt;&lt; <span class="string">&quot;右下角: &quot;</span> &lt;&lt; rect.<span class="built_in">bottomRight</span>()</span><br><span class="line">             &lt;&lt; <span class="string">&quot;宽度: &quot;</span> &lt;&lt; rect.<span class="built_in">width</span>()</span><br><span class="line">             &lt;&lt; <span class="string">&quot;高度: &quot;</span> &lt;&lt; rect.<span class="built_in">height</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新设置当前窗口的位置以及宽度, 高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_geometryBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">100</span> + <span class="built_in">rand</span>() % <span class="number">500</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">100</span> + <span class="built_in">rand</span>() % <span class="number">500</span>;</span><br><span class="line">    <span class="type">int</span> width = <span class="keyword">this</span>-&gt;<span class="built_in">width</span>() + <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> height = <span class="keyword">this</span>-&gt;<span class="built_in">height</span>() + <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">setGeometry</span>(x, y, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 move() 方法移动窗口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_moveBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QRect rect = <span class="keyword">this</span>-&gt;<span class="built_in">frameGeometry</span>();</span><br><span class="line">    <span class="built_in">move</span>(rect.<span class="built_in">topLeft</span>() + <span class="built_in">QPoint</span>(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-3-窗口尺寸"><a href="#1-1-3-窗口尺寸" class="headerlink" title="1.1.3 窗口尺寸"></a>1.1.3 窗口尺寸</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------- 窗口尺寸 -------------</span></span><br><span class="line"><span class="comment">// 获取当前窗口的尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">// 重新设置窗口的尺寸信息</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">const</span> QSize &amp;)</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最大尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">maximumSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最小尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">minimumSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口固定的尺寸信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedSize</span><span class="params">(<span class="type">const</span> QSize &amp;s)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedSize</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口的最大尺寸信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumSize</span><span class="params">(<span class="type">const</span> QSize &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumSize</span><span class="params">(<span class="type">int</span> maxw, <span class="type">int</span> maxh)</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口的最小尺寸信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumSize</span><span class="params">(<span class="type">const</span> QSize &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumSize</span><span class="params">(<span class="type">int</span> minw, <span class="type">int</span> minh)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前窗口的高度    </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最小高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumHeight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最大高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximumHeight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置固定的高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedHeight</span><span class="params">(<span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最大高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumHeight</span><span class="params">(<span class="type">int</span> maxh)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最小高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumHeight</span><span class="params">(<span class="type">int</span> minh)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前窗口的宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">width</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最小宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumWidth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最大宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximumWidth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置固定宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedWidth</span><span class="params">(<span class="type">int</span> w)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最大宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumWidth</span><span class="params">(<span class="type">int</span> maxw)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最小宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumWidth</span><span class="params">(<span class="type">int</span> minw)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-4-窗口标题和图标"><a href="#1-1-4-窗口标题和图标" class="headerlink" title="1.1.4 窗口标题和图标"></a>1.1.4 窗口标题和图标</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------- 窗口图标 -------------</span></span><br><span class="line"><span class="comment">// 得到当前窗口的图标</span></span><br><span class="line"><span class="function">QIcon <span class="title">windowIcon</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 构造图标对象, 参数为图片的路径</span></span><br><span class="line">QIcon::<span class="built_in">QIcon</span>(<span class="type">const</span> QString &amp;fileName);</span><br><span class="line"><span class="comment">// 设置当前窗口的图标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowIcon</span><span class="params">(<span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------- 窗口标题 -------------</span></span><br><span class="line"><span class="comment">// 得到当前窗口的标题</span></span><br><span class="line"><span class="function">QString <span class="title">windowTitle</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口的标题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowTitle</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-5-信号"><a href="#1-1-5-信号" class="headerlink" title="1.1.5 信号"></a>1.1.5 信号</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QWidget::setContextMenuPolicy(Qt::ContextMenuPolicy policy);</span></span><br><span class="line"><span class="comment">// 窗口的右键菜单策略 contextMenuPolicy() 参数设置为 Qt::CustomContextMenu, 按下鼠标右键发射该信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QWidget::customContextMenuRequested</span><span class="params">(<span class="type">const</span> QPoint &amp;pos)</span></span>;</span><br><span class="line"><span class="comment">// 窗口图标发生变化, 发射此信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QWidget::windowIconChanged</span><span class="params">(<span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"><span class="comment">// 窗口标题发生变化, 发射此信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QWidget::windowTitleChanged</span><span class="params">(<span class="type">const</span> QString &amp;title)</span></span>;</span><br></pre></td></tr></table></figure><p>基于窗口策略实现右键菜单具体操作参考 Qt右键菜单的添加和使用(本章第六部分)</p><hr><h3 id="1-1-6-槽函数"><a href="#1-1-6-槽函数" class="headerlink" title="1.1.6 槽函数"></a>1.1.6 槽函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------- 窗口显示 -------------</span></span><br><span class="line"><span class="comment">// 关闭当前窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">bool</span> <span class="title">QWidget::close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 隐藏当前窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::hide</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 显示当前创建以及其子窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 全屏显示当前窗口, 只对windows有效</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::showFullScreen</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 窗口最大化显示, 只对windows有效</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::showMaximized</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 窗口最小化显示, 只对windows有效</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::showMinimized</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 将窗口回复为最大化/最小化之前的状态, 只对windows有效</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::showNormal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------- 窗口状态 -------------</span></span><br><span class="line"><span class="comment">// 判断窗口是否可用</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QWidget::isEnabled</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 非槽函数</span></span><br><span class="line"><span class="comment">// 设置窗口是否可用, 不可用窗口无法接收和处理窗口事件</span></span><br><span class="line"><span class="comment">// 参数true-&gt;可用, false-&gt;不可用</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::setEnabled</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"><span class="comment">// 设置窗口是否可用, 不可用窗口无法接收和处理窗口事件</span></span><br><span class="line"><span class="comment">// 参数true-&gt;不可用, false-&gt;可用</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::setDisabled</span><span class="params">(<span class="type">bool</span> disable)</span></span>;</span><br><span class="line"><span class="comment">// 设置窗口是否可见, 参数为true-&gt;可见, false-&gt;不可见</span></span><br><span class="line">[slot] <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::setVisible</span><span class="params">(<span class="type">bool</span> visible)</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="1-2-QDialog"><a href="#1-2-QDialog" class="headerlink" title="1.2 QDialog"></a>1.2 QDialog</h2><h3 id="1-2-1-常用API"><a href="#1-2-1-常用API" class="headerlink" title="1.2.1 常用API"></a>1.2.1 常用API</h3><blockquote><p>对话框类是<code>QWidget</code>类的子类, 处理继承自父类的属性之外, 还有一些自己所特有的属性</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QDialog::<span class="built_in">QDialog</span>(QWidget *parent = <span class="literal">nullptr</span>, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模态显示窗口</span></span><br><span class="line">[<span class="keyword">virtual</span> slot] <span class="function"><span class="type">int</span> <span class="title">QDialog::exec</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 隐藏模态窗口, 并且解除模态窗口的阻塞, 将 exec() 的返回值设置为 QDialog::Accepted</span></span><br><span class="line">[<span class="keyword">virtual</span> slot] <span class="function"><span class="type">void</span> <span class="title">QDialog::accept</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 隐藏模态窗口, 并且解除模态窗口的阻塞, 将 exec() 的返回值设置为 QDialog::Rejected</span></span><br><span class="line">[<span class="keyword">virtual</span> slot] <span class="function"><span class="type">void</span> <span class="title">QDialog::reject</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 关闭对话框并将其结果代码设置为r。finished()信号将发出r;</span></span><br><span class="line"><span class="comment">// 如果r是QDialog::Accepted 或 QDialog::Rejected，则还将分别发出accept()或Rejected()信号。</span></span><br><span class="line">[<span class="keyword">virtual</span> slot] <span class="function"><span class="type">void</span> <span class="title">QDialog::done</span><span class="params">(<span class="type">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QDialog::accepted</span><span class="params">()</span></span>;</span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QDialog::rejected</span><span class="params">()</span></span>;</span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QDialog::finished</span><span class="params">(<span class="type">int</span> result)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-2-2-常用使用方法"><a href="#1-2-2-常用使用方法" class="headerlink" title="1.2.2 常用使用方法"></a>1.2.2 常用使用方法</h3><blockquote><p>场景介绍:</p><ol><li>有两个窗口, 主窗口和一个对话框子窗口</li><li>对话框窗口先显示, 根据用户操作选择是否显示主窗口</li></ol></blockquote><ul><li>关于对话框窗口类的操作</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对话框窗口中三个普通按钮按下之后对应的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDialog::on_acceptBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">accept</span>();  <span class="comment">// exec()函数返回值为QDialog::Accepted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDialog::on_rejectBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">reject</span>();  <span class="comment">// exec()函数返回值为QDialog::Rejected</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDialog::on_donBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// exec()函数返回值为 done() 的参数, 并根据参数发射出对应的信号</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">done</span>(<span class="number">666</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据用户针对对话框窗口的按钮操作, 进行相应的逻辑处理。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对话框对象</span></span><br><span class="line">MyDialog dlg;    </span><br><span class="line"><span class="type">int</span> ret = dlg.<span class="built_in">exec</span>();</span><br><span class="line"><span class="keyword">if</span>(ret == QDialog::Accepted)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;accept button clicked...&quot;</span>;</span><br><span class="line">    <span class="comment">// 显示主窗口</span></span><br><span class="line">    MainWindow* w = <span class="keyword">new</span> MainWindow;</span><br><span class="line">    w-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ret == QDialog::Rejected)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;reject button clicked...&quot;</span>;</span><br><span class="line">    <span class="comment">// 不显示主窗口</span></span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ret == 666</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;done button clicked...&quot;</span>;</span><br><span class="line">    <span class="comment">// 根据需求进行逻辑处理</span></span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-3-QDialog的子类"><a href="#1-3-QDialog的子类" class="headerlink" title="1.3 QDialog的子类"></a>1.3 QDialog的子类</h2><h3 id="1-3-1-QMessageBox"><a href="#1-3-1-QMessageBox" class="headerlink" title="1.3.1 QMessageBox"></a>1.3.1 QMessageBox</h3><blockquote><p><code>QMessageBox</code> 对话框类是 <code>QDialog</code> 类的子类<br>通过这个类可显示一些简单的提示框,用于展示警告、错误、问题等信息。<br>关于这个类只需掌握一些静态方法即可。</p></blockquote><h4 id="1-3-1-1-API-静态函数"><a href="#1-3-1-1-API-静态函数" class="headerlink" title="1.3.1.1 API - 静态函数"></a>1.3.1.1 API - 静态函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示一个模态对话框, 将参数 text 的信息展示到窗口中</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QMessageBox::about</span><span class="params">(QWidget *parent, <span class="type">const</span> QString &amp;title, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">- parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">- title: 对话框窗口的标题</span></span><br><span class="line"><span class="comment">- text: 对话框窗口中显示的提示信息</span></span><br><span class="line"><span class="comment">- buttons: 对话框窗口中显示的按钮(一个或多个)</span></span><br><span class="line"><span class="comment">- defaultButton</span></span><br><span class="line"><span class="comment">    1. defaultButton指定按下Enter键时使用的按钮。</span></span><br><span class="line"><span class="comment">    2. defaultButton必须引用在参数 buttons 中给定的按钮。</span></span><br><span class="line"><span class="comment">    3. 如果defaultButton是QMessageBox::NoButton, QMessageBox会自动选择一个合适的默认值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 显示一个信息模态对话框</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMessageBox::StandardButton <span class="title">QMessageBox::information</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">           QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> QString &amp;text, </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButtons buttons = Ok,</span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButton defaultButton = NoButton)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示一个错误模态对话框</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMessageBox::StandardButton <span class="title">QMessageBox::critical</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">           QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> QString &amp;text, </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButtons buttons = Ok,</span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButton defaultButton = NoButton)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示一个问题模态对话框</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMessageBox::StandardButton <span class="title">QMessageBox::question</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">           QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> QString &amp;text, </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButtons buttons = StandardButtons(Yes | No), </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButton defaultButton = NoButton)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示一个警告模态对话框</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMessageBox::StandardButton <span class="title">QMessageBox::warning</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">           QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> QString &amp;text, </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButtons buttons = Ok,</span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButton defaultButton = NoButton)</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-3-1-2-测试代码"><a href="#1-3-1-2-测试代码" class="headerlink" title="1.3.1.2 测试代码"></a>1.3.1.2 测试代码</h4><ul><li>测试代码片段</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_msgbox_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QMessageBox::<span class="built_in">about</span>(<span class="keyword">this</span>, <span class="string">&quot;about&quot;</span>,  <span class="string">&quot;这是一个简单的消息提示框!!!&quot;</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">critical</span>(<span class="keyword">this</span>, <span class="string">&quot;critical&quot;</span>, <span class="string">&quot;这是一个错误对话框-critical...&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = QMessageBox::<span class="built_in">question</span>(<span class="keyword">this</span>, <span class="string">&quot;question&quot;</span>, </span><br><span class="line">             <span class="string">&quot;你要保存修改的文件内容吗???&quot;</span>,                                 </span><br><span class="line">              QMessageBox::Save|QMessageBox::Cancel, </span><br><span class="line">              QMessageBox::Cancel);</span><br><span class="line">    <span class="keyword">if</span>(ret == QMessageBox::Save)</span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;information&quot;</span>, <span class="string">&quot;恭喜你保存成功了, o(*￣︶￣*)o!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ret == QMessageBox::Cancel)</span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="string">&quot;warning&quot;</span>, <span class="string">&quot;你放弃了保存, ┭┮﹏┭┮ !!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>得到的对话框窗口效果如下图:<br><img src="/img/9.54.png" alt="在这里插入图片描述"></li></ul><hr><h3 id="1-3-2-QFileDialog"><a href="#1-3-2-QFileDialog" class="headerlink" title="1.3.2 QFileDialog"></a>1.3.2 QFileDialog</h3><blockquote><p><code>QFileDialog</code> 对话框类是 <code>QDialog</code> 类的子类<br>通过这个类可以选择要打开&#x2F;保存的文件或者目录。<br>关于这个类只需掌握一些静态方法的使用即可。</p></blockquote><h4 id="1-3-2-1-API-静态函数"><a href="#1-3-2-1-API-静态函数" class="headerlink" title="1.3.2.1 API - 静态函数"></a>1.3.2.1 API - 静态函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通用参数:</span></span><br><span class="line"><span class="comment">  - parent: 当前对话框窗口的父对象也就是父窗口</span></span><br><span class="line"><span class="comment">  - caption: 当前对话框窗口的标题</span></span><br><span class="line"><span class="comment">  - dir: 当前对话框窗口打开的默认目录</span></span><br><span class="line"><span class="comment">  - options: 当前对话框窗口的一些可选项,枚举类型, 一般不需要进行设置, 使用默认值即可</span></span><br><span class="line"><span class="comment">  - filter: 过滤器, 在对话框中只显示满足条件的文件, 可以指定多个过滤器, 使用 ;; 分隔</span></span><br><span class="line"><span class="comment">    - 样式举例: </span></span><br><span class="line"><span class="comment">- Images (*.png *.jpg)</span></span><br><span class="line"><span class="comment">- Images (*.png *.jpg);;Text files (*.txt)</span></span><br><span class="line"><span class="comment">  - selectedFilter: 如果指定了多个过滤器, 通过该参数指定默认使用哪一个, 不指定默认使用第一个过滤器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 打开一个目录, 得到这个目录的绝对路径</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QFileDialog::getExistingDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                  QWidget *parent = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;caption = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;dir = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  QFileDialog::Options options = ShowDirsOnly)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开一个文件, 得到这个文件的绝对路径</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QFileDialog::getOpenFileName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">              QWidget *parent = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> QString &amp;caption = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;dir = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;filter = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  QString *selectedFilter = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  QFileDialog::Options options = Options())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开多个文件, 得到这多个文件的绝对路径</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QStringList <span class="title">QFileDialog::getOpenFileNames</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">              QWidget *parent = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;caption = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;dir = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;filter = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  QString *selectedFilter = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  QFileDialog::Options options = Options())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开一个目录, 使用这个目录来保存指定的文件</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QFileDialog::getSaveFileName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      QWidget *parent = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;caption = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;dir = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;filter = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  QString *selectedFilter = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  QFileDialog::Options options = Options())</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-3-2-2-测试代码"><a href="#1-3-2-2-测试代码" class="headerlink" title="1.3.2.2 测试代码"></a>1.3.2.2 测试代码</h4><ul><li>打开一个已存在的本地目录</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_filedlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString dirName = QFileDialog::<span class="built_in">getExistingDirectory</span>(<span class="keyword">this</span>, <span class="string">&quot;打开目录&quot;</span>, <span class="string">&quot;e:\\temp&quot;</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;打开目录&quot;</span>, <span class="string">&quot;您选择的目录是: &quot;</span> + dirName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>对话框效果如下:<br><img src="/img/9.55.png" alt="在这里插入图片描述"></p></li><li><p>打开一个本地文件</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_filedlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QString <span class="title">arg</span><span class="params">(<span class="string">&quot;Text files (*.txt)&quot;</span>)</span></span>;</span><br><span class="line">    QString fileName = QFileDialog::<span class="built_in">getOpenFileName</span>(</span><br><span class="line">              <span class="keyword">this</span>, <span class="string">&quot;Open File&quot;</span>, <span class="string">&quot;e:\\temp&quot;</span>,</span><br><span class="line">              <span class="string">&quot;Images (*.png *.jpg);;Text files (*.txt)&quot;</span>, &amp;arg);</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;打开文件&quot;</span>, <span class="string">&quot;您选择的文件是: &quot;</span> + fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对话框效果如下:</li></ul><p><img src="/img/9.56.png" alt="在这里插入图片描述"></p><ul><li>打开多个本地文件</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_filedlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStringList fileNames = QFileDialog::<span class="built_in">getOpenFileNames</span>(</span><br><span class="line">              <span class="keyword">this</span>, <span class="string">&quot;Open File&quot;</span>, <span class="string">&quot;e:\\temp&quot;</span>,</span><br><span class="line">              <span class="string">&quot;Images (*.png *.jpg);;Text files (*.txt)&quot;</span>);</span><br><span class="line">    QString names;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;fileNames.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        names += fileNames.<span class="built_in">at</span>(i) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;打开文件(s)&quot;</span>, <span class="string">&quot;您选择的文件是: &quot;</span> + names);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对话框效果如下:</li></ul><p><img src="/img/9.57.png" alt="在这里插入图片描述"></p><ul><li>打开保存文件对话框</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_filedlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString fileName = QFileDialog::<span class="built_in">getSaveFileName</span>(<span class="keyword">this</span>, <span class="string">&quot;保存文件&quot;</span>, <span class="string">&quot;e:\\temp&quot;</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;保存文件&quot;</span>, <span class="string">&quot;您指定的保存数据的文件是: &quot;</span> + fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对话框效果如下:</p><p><img src="/img/9.58.png" alt="在这里插入图片描述"></p><hr><h3 id="1-3-3-QFontDialog"><a href="#1-3-3-QFontDialog" class="headerlink" title="1.3.3 QFontDialog"></a>1.3.3 QFontDialog</h3><blockquote><p><code>QFontDialog</code>类是<code>QDialog</code>的子类<br>通过这个类我们可以得到一个进行字体属性设置的对话框窗口<br>和前边介绍的对话框类一样,只需调用这个类的静态成员函数就可以得到想要的窗口了。</p></blockquote><h4 id="1-3-3-1-QFont-字体类"><a href="#1-3-3-1-QFont-字体类" class="headerlink" title="1.3.3.1 QFont 字体类"></a>1.3.3.1 QFont 字体类</h4><blockquote><p>关于字体的属性信息, 在QT框架中被封装到了一个叫<code>QFont</code>的类中</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">  QFont::<span class="built_in">QFont</span>();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  参数:</span></span><br><span class="line"><span class="comment">    - family: 本地字库中的字体名, 通过 office 等文件软件可以查看</span></span><br><span class="line"><span class="comment">    - pointSize: 字体的字号</span></span><br><span class="line"><span class="comment">    - weight: 字体的粗细, 有效范围为 0 ~ 99</span></span><br><span class="line"><span class="comment">    - italic: 字体是否倾斜显示, 默认不倾斜</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  QFont::<span class="built_in">QFont</span>(<span class="type">const</span> QString &amp;family, <span class="type">int</span> pointSize = <span class="number">-1</span>, <span class="type">int</span> weight = <span class="number">-1</span>, <span class="type">bool</span> italic = <span class="literal">false</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置字体</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setFamily</span><span class="params">(<span class="type">const</span> QString &amp;family)</span></span>;</span><br><span class="line">  <span class="comment">// 根据字号设置字体大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setPointSize</span><span class="params">(<span class="type">int</span> pointSize)</span></span>;</span><br><span class="line">  <span class="comment">// 根据像素设置字体大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setPixelSize</span><span class="params">(<span class="type">int</span> pixelSize)</span></span>;</span><br><span class="line">  <span class="comment">// 设置字体的粗细程度, 有效范围: 0 ~ 99</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setWeight</span><span class="params">(<span class="type">int</span> weight)</span></span>;</span><br><span class="line">  <span class="comment">// 设置字体是否加粗显示</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setBold</span><span class="params">(<span class="type">bool</span> enable)</span></span>;</span><br><span class="line">  <span class="comment">// 设置字体是否要倾斜显示</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setItalic</span><span class="params">(<span class="type">bool</span> enable)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取字体相关属性(一般规律: 去掉设置函数的 set 就是获取相关属性对应的函数名)</span></span><br><span class="line">  <span class="function">QString <span class="title">QFont::family</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">QFont::italic</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">QFont::pixelSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">QFont::pointSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">QFont::bold</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">QFont::weight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>如果一个QFont对象被创建, 并且进行了初始化, 我们可以将这个属性设置给某个窗口, 或者设置给当前应用程序对象。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QWidget 类</span></span><br><span class="line"><span class="comment">// 得到当前窗口使用的字体</span></span><br><span class="line"><span class="function"><span class="type">const</span> QWidget::QFont&amp; <span class="title">font</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给当前窗口设置字体, 只对当前窗口类生效</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFont</span><span class="params">(<span class="type">const</span> QFont &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QApplication 类</span></span><br><span class="line"><span class="comment">// 得到当前应用程序对象使用的字体</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QFont <span class="title">QApplication::font</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 给当前应用程序对象设置字体, 作用于当前应用程序的所有窗口</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QApplication::setFont</span><span class="params">(<span class="type">const</span> QFont &amp;font, <span class="type">const</span> <span class="type">char</span> *className = <span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-3-3-2-QFontDialog类的静态API"><a href="#1-3-3-2-QFontDialog类的静态API" class="headerlink" title="1.3.3.2 QFontDialog类的静态API"></a>1.3.3.2 QFontDialog类的静态API</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否获得了有效字体信息, 指定一个布尔类型变量地址</span></span><br><span class="line"><span class="comment">  - initial: 字体对话框中默认选中并显示该字体信息, 用于对话框的初始化</span></span><br><span class="line"><span class="comment">  - parent: 字体对话框窗口的父对象</span></span><br><span class="line"><span class="comment">  - title: 字体对话框的窗口标题</span></span><br><span class="line"><span class="comment">  - options: 字体对话框选项, 使用默认属性即可, 一般不设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  [<span class="type">static</span>] <span class="function">QFont <span class="title">QFontDialog::getFont</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">bool</span> *ok, <span class="type">const</span> QFont &amp;initial, </span></span></span><br><span class="line"><span class="params"><span class="function">QWidget *parent = <span class="literal">nullptr</span>, <span class="type">const</span> QString &amp;title = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">QFontDialog::FontDialogOptions options = FontDialogOptions())</span></span>;</span><br><span class="line">  </span><br><span class="line">  [<span class="type">static</span>] <span class="function">QFont <span class="title">QFontDialog::getFont</span><span class="params">(<span class="type">bool</span> *ok, QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-3-3-3-测试代码"><a href="#1-3-3-3-测试代码" class="headerlink" title="1.3.3.3 测试代码"></a>1.3.3.3 测试代码</h4><blockquote><p>通过字体对话框选择字体, 并将选择的字体设置给当前窗口</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_fontdlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    <span class="comment">// 方式1</span></span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">    QFont ft = QFontDialog::<span class="built_in">getFont</span>(</span><br><span class="line">                &amp;ok, <span class="built_in">QFont</span>(<span class="string">&quot;微软雅黑&quot;</span>, <span class="number">12</span>, QFont::Bold), <span class="keyword">this</span>, <span class="string">&quot;选择字体&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;ok value is: &quot;</span> &lt;&lt; ok;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 方式2</span></span><br><span class="line">    QFont ft = QFontDialog::<span class="built_in">getFont</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 将选择的字体设置给当前窗口对象</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFont</span>(ft);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字体对话框效果展示:<br><img src="/img/9.59.png" alt="在这里插入图片描述"></p><hr><h3 id="1-3-4-QColorDialog"><a href="#1-3-4-QColorDialog" class="headerlink" title="1.3.4 QColorDialog"></a>1.3.4 QColorDialog</h3><blockquote><p><code>QColorDialog</code>类是<code>QDialog</code>的子类<br> 通过这个类我们可以得到一个选择颜色的对话框窗口<br> 和前边介绍的对话框类一样,只需调用这个类的静态成员函数就可以得到想要的窗口了。</p></blockquote><h4 id="1-3-4-1-颜色类-QColor"><a href="#1-3-4-1-颜色类-QColor" class="headerlink" title="1.3.4.1 颜色类 QColor"></a>1.3.4.1 颜色类 QColor</h4><blockquote><p>关于颜色的属性信息, 在QT框架中被封装到了一个叫<code>QColor</code>的类中<br>各种颜色都是基于红, 绿, 蓝这三种颜色调配而成的, 并且颜色还可以进行透明度设置, 默认是不透明的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QColor::<span class="built_in">QColor</span>(Qt::GlobalColor color);</span><br><span class="line">QColor::<span class="built_in">QColor</span>(<span class="type">int</span> r, <span class="type">int</span> g, <span class="type">int</span> b, <span class="type">int</span> a = ...);</span><br><span class="line">QColor::<span class="built_in">QColor</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数设置 red, green, blue, alpha, 取值范围都是 0-255</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setRed</span><span class="params">(<span class="type">int</span> red)</span></span>;<span class="comment">// 红色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setGreen</span><span class="params">(<span class="type">int</span> green)</span></span>;<span class="comment">// 绿色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setBlue</span><span class="params">(<span class="type">int</span> blue)</span></span>;<span class="comment">// 蓝色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setAlpha</span><span class="params">(<span class="type">int</span> alpha)</span></span>;<span class="comment">// 透明度, 默认不透明(255)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setRgb</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> g, <span class="type">int</span> b, <span class="type">int</span> a = <span class="number">255</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QColor::red</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QColor::green</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QColor::blue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QColor::alpha</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::getRgb</span><span class="params">(<span class="type">int</span> *r, <span class="type">int</span> *g, <span class="type">int</span> *b, <span class="type">int</span> *a = <span class="literal">nullptr</span>)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-3-4-2-静态API函数"><a href="#1-3-4-2-静态API函数" class="headerlink" title="1.3.4.2 静态API函数"></a>1.3.4.2 静态API函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 弹出颜色选择对话框, 并返回选中的颜色信息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">    - initial: 对话框中默认选中的颜色, 用于窗口初始化</span></span><br><span class="line"><span class="comment">    - parent: 给对话框窗口指定父对象</span></span><br><span class="line"><span class="comment">    - title: 对话框窗口的标题</span></span><br><span class="line"><span class="comment">    - options: 颜色对话框窗口选项, 使用默认属性即可, 一般不需要设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  [<span class="type">static</span>] <span class="function">QColor <span class="title">QColorDialog::getColor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> QColor &amp;initial = Qt::white, </span></span></span><br><span class="line"><span class="params"><span class="function">QWidget *parent = <span class="literal">nullptr</span>, <span class="type">const</span> QString &amp;title = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">QColorDialog::ColorDialogOptions options = ColorDialogOptions())</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-3-4-3-测试代码"><a href="#1-3-4-3-测试代码" class="headerlink" title="1.3.4.3 测试代码"></a>1.3.4.3 测试代码</h4><blockquote><p>场景描述:<br>    1. 在窗口上放一个标签控件<br>    2. 通过颜色对话框选择一个颜色, 将选中的颜色显示到标签控件上<br>    3. 将选中的颜色的 RGBA 值分别显示出来</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_colordlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QColor color = QColorDialog::<span class="built_in">getColor</span>();</span><br><span class="line">    <span class="function">QBrush <span class="title">brush</span><span class="params">(color)</span></span>;</span><br><span class="line">    <span class="function">QRect <span class="title">rect</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, ui-&gt;color-&gt;width(), ui-&gt;color-&gt;height())</span></span>;</span><br><span class="line">    <span class="function">QPixmap <span class="title">pix</span><span class="params">(rect.width(), rect.height())</span></span>;</span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(&amp;pix)</span></span>;</span><br><span class="line">    p.<span class="built_in">fillRect</span>(rect, brush);</span><br><span class="line">    ui-&gt;color-&gt;<span class="built_in">setPixmap</span>(pix);</span><br><span class="line">    QString text = <span class="built_in">QString</span>(<span class="string">&quot;red: %1, green: %2, blue: %3, 透明度: %4&quot;</span>)</span><br><span class="line">            .<span class="built_in">arg</span>(color.<span class="built_in">red</span>()).<span class="built_in">arg</span>(color.<span class="built_in">green</span>()).<span class="built_in">arg</span>(color.<span class="built_in">blue</span>()).<span class="built_in">arg</span>(color.<span class="built_in">alpha</span>());</span><br><span class="line">    ui-&gt;colorlabel-&gt;<span class="built_in">setText</span>(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>颜色对话框窗口效果展示</p><p><img src="/img/9.60.png" alt="在这里插入图片描述"></p><p>测试代码效果展示<br><img src="/img/9.61.png" alt="在这里插入图片描述"></p><hr><h3 id="1-3-5-QInputDialog"><a href="#1-3-5-QInputDialog" class="headerlink" title="1.3.5 QInputDialog"></a>1.3.5 QInputDialog</h3><blockquote><p><code>QInputDialog</code>类是<code>QDialog</code>的子类, 通过这个类我们可以得到一个输入对话框窗口<br>根据实际需求我们可以在这个输入窗口中输入整形, 浮点型, 字符串类型的数据<br>并且还可以显示下拉菜单供使用者选择。<br>和前边介绍的对话框类一样, 只需调用这个类的静态成员函数就可以得到想要的窗口了。</p></blockquote><h4 id="1-3-5-1-API-静态函数"><a href="#1-3-5-1-API-静态函数" class="headerlink" title="1.3.5.1 API - 静态函数"></a>1.3.5.1 API - 静态函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到一个可以输入浮点数的对话框窗口, 返回对话框窗口中输入的浮点数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - value: 对话框窗口中显示的浮点值, 默认为 0</span></span><br><span class="line"><span class="comment">  - min: 对话框窗口支持显示的最小数值</span></span><br><span class="line"><span class="comment">  - max: 对话框窗口支持显示的最大数值</span></span><br><span class="line"><span class="comment">  - decimals: 浮点数的精度, 默认保留小数点以后1位</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">double</span> <span class="title">QInputDialog::getDouble</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;label, <span class="type">double</span> value = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> min = <span class="number">-2147483647</span>, <span class="type">double</span> max = <span class="number">2147483647</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> decimals = <span class="number">1</span>, <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个可以输入整形数的对话框窗口, 返回对话框窗口中输入的整形数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - value: 对话框窗口中显示的整形值, 默认为 0</span></span><br><span class="line"><span class="comment">  - min: 对话框窗口支持显示的最小数值</span></span><br><span class="line"><span class="comment">  - max: 对话框窗口支持显示的最大数值</span></span><br><span class="line"><span class="comment">  - step: 步长, 通过对话框提供的按钮调节数值每次增长/递减的量</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">int</span> <span class="title">QInputDialog::getInt</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;label, <span class="type">int</span> value = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> min = <span class="number">-2147483647</span>, <span class="type">int</span> max = <span class="number">2147483647</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> step = <span class="number">1</span>, <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个带下来菜单的对话框窗口, 返回选择的菜单项上边的文本信息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - items: 字符串列表, 用于初始化窗口中的下拉菜单, 每个字符串对应一个菜单项</span></span><br><span class="line"><span class="comment">  - current: 通过菜单项的索引指定显示下拉菜单中的哪个菜单项, 默认显示第一个(编号为0)</span></span><br><span class="line"><span class="comment">  - editable: 设置菜单项上的文本信息是否可以进行编辑, 默认为true, 即可以编辑</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串</span></span><br><span class="line"><span class="comment">    - 如果有特殊需求, 可以参数帮助文档进行相关设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QInputDialog::getItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;label, <span class="type">const</span> QStringList &amp;items, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> current = <span class="number">0</span>, <span class="type">bool</span> editable = <span class="literal">true</span>, <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags(), </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::InputMethodHints inputMethodHints = Qt::ImhNone)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个可以输入多行数据的对话框窗口, 返回用户在窗口中输入的文本信息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - text: 指定显示到多行输入框中的文本信息, 默认是空字符串</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串</span></span><br><span class="line"><span class="comment">    - 如果有特殊需求, 可以参数帮助文档进行相关设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QInputDialog::getMultiLineText</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, <span class="type">const</span> QString &amp;label, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;text = QString(), <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags(), </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::InputMethodHints inputMethodHints = Qt::ImhNone)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个可以输入单行信息的对话框窗口, 返回用户在窗口中输入的文本信息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口 </span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - mode: 指定单行编辑框中数据的反馈模式, 是一个 QLineEdit::EchoMode 类型的枚举值</span></span><br><span class="line"><span class="comment">    - QLineEdit::Normal: 显示输入的字符。这是默认值</span></span><br><span class="line"><span class="comment">    - QLineEdit::NoEcho: 不要展示任何东西。这可能适用于连密码长度都应该保密的密码。</span></span><br><span class="line"><span class="comment">    - QLineEdit::Password: 显示与平台相关的密码掩码字符，而不是实际输入的字符。</span></span><br><span class="line"><span class="comment">    - QLineEdit::PasswordEchoOnEdit: 在编辑时按输入显示字符，否则按密码显示字符。</span></span><br><span class="line"><span class="comment">  - text: 指定显示到单行输入框中的文本信息, 默认是空字符串</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串</span></span><br><span class="line"><span class="comment">     - 如果有特殊需求, 可以参数帮助文档进行相关设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QInputDialog::getText</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, <span class="type">const</span> QString &amp;label,</span></span></span><br><span class="line"><span class="params"><span class="function">    QLineEdit::EchoMode mode = QLineEdit::Normal, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;text = QString(), <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags(), </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::InputMethodHints inputMethodHints = Qt::ImhNone)</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-3-5-2-测试代码"><a href="#1-3-5-2-测试代码" class="headerlink" title="1.3.5.2 测试代码"></a>1.3.5.2 测试代码</h4><ul><li>整形输入框</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_inputdlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = QInputDialog::<span class="built_in">getInt</span>(<span class="keyword">this</span>, <span class="string">&quot;年龄&quot;</span>, <span class="string">&quot;您的当前年龄: &quot;</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">2</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;年龄&quot;</span>, <span class="string">&quot;您的当前年龄: &quot;</span> + QString::<span class="built_in">number</span>(ret));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>窗口效果展示:</li></ul><p><img src="/img/9.62.png" alt="在这里插入图片描述"></p><ul><li>浮点型输入框</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_inputdlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> ret = QInputDialog::<span class="built_in">getDouble</span>(<span class="keyword">this</span>, <span class="string">&quot;工资&quot;</span>, <span class="string">&quot;您的工资: &quot;</span>, <span class="number">2000</span>, <span class="number">1000</span>, <span class="number">6000</span>, <span class="number">2</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;工资&quot;</span>, <span class="string">&quot;您的当前工资: &quot;</span> + QString::<span class="built_in">number</span>(ret));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>窗口效果展示:</li></ul><p><img src="/img/9.63.png" alt="在这里插入图片描述"></p><ul><li>带下拉菜单的输入框</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_inputdlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStringList items;</span><br><span class="line">    items &lt;&lt; <span class="string">&quot;苹果&quot;</span> &lt;&lt; <span class="string">&quot;橙子&quot;</span> &lt;&lt; <span class="string">&quot;橘子&quot;</span> &lt;&lt; <span class="string">&quot;葡萄&quot;</span> &lt;&lt; <span class="string">&quot;香蕉&quot;</span> &lt;&lt; <span class="string">&quot;哈密瓜&quot;</span>;</span><br><span class="line">    QString item = QInputDialog::<span class="built_in">getItem</span>(<span class="keyword">this</span>, <span class="string">&quot;请选择你喜欢的水果&quot;</span>, <span class="string">&quot;你最喜欢的水果:&quot;</span>, items, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;水果&quot;</span>, <span class="string">&quot;您最喜欢的水果是: &quot;</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>窗口效果展示:</li></ul><p><img src="/img/9.64.png" alt="在这里插入图片描述"></p><ul><li>多行字符串输入框</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_inputdlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString info = QInputDialog::<span class="built_in">getMultiLineText</span>(<span class="keyword">this</span>, <span class="string">&quot;表白&quot;</span>, <span class="string">&quot;您最想对漂亮小姐姐说什么呢?&quot;</span>, <span class="string">&quot;呦吼吼...&quot;</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;知心姐姐&quot;</span>, <span class="string">&quot;您最想对小姐姐说: &quot;</span> + info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>窗口效果展示:<br><img src="/img/9.65.png" alt="在这里插入图片描述"></p><ul><li>单行字符串输入框</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_inputdlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString text = QInputDialog::<span class="built_in">getText</span>(<span class="keyword">this</span>, <span class="string">&quot;密码&quot;</span>, <span class="string">&quot;请输入新的密码&quot;</span>, QLineEdit::Password, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;密码&quot;</span>, <span class="string">&quot;您设置的密码是: &quot;</span> + text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>窗口效果展示:</p><p><img src="/img/9.66.png" alt="在这里插入图片描述"></p><hr><h3 id="1-3-6-QProgressDialog"><a href="#1-3-6-QProgressDialog" class="headerlink" title="1.3.6 QProgressDialog"></a>1.3.6 QProgressDialog</h3><blockquote><p><code>QProgressDialog</code>类是<code>QDialog</code>的子类, 通过这个类我们可以得到一个带进度条的对话框窗口<br>这种类型的对话框窗口一般常用于文件拷贝、数据传输等实时交互的场景中。</p></blockquote><h4 id="1-3-6-1-常用API"><a href="#1-3-6-1-常用API" class="headerlink" title="1.3.6.1 常用API"></a>1.3.6.1 常用API</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - labelText: 对话框中显示的提示信息</span></span><br><span class="line"><span class="comment">  - cancelButtonText: 取消按钮上显示的文本信息</span></span><br><span class="line"><span class="comment">  - minimum: 进度条最小值</span></span><br><span class="line"><span class="comment">  - maximum: 进度条最大值</span></span><br><span class="line"><span class="comment">  - parent: 当前窗口的父对象</span></span><br><span class="line"><span class="comment">  - f: 当前进度窗口的flag属性, 使用默认属性即可, 无需设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QProgressDialog::<span class="built_in">QProgressDialog</span>(</span><br><span class="line">QWidget *parent = <span class="literal">nullptr</span>, </span><br><span class="line">Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line">QProgressDialog::<span class="built_in">QProgressDialog</span>(</span><br><span class="line"><span class="type">const</span> QString &amp;labelText, <span class="type">const</span> QString &amp;cancelButtonText, </span><br><span class="line"><span class="type">int</span> minimum, <span class="type">int</span> maximum, QWidget *parent = <span class="literal">nullptr</span>,</span><br><span class="line">Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置取消按钮显示的文本信息</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setCancelButtonText</span><span class="params">(<span class="type">const</span> QString &amp;cancelButtonText)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数和槽函数</span></span><br><span class="line"><span class="function">QString <span class="title">QProgressDialog::labelText</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setLabelText</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到进度条最小值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QProgressDialog::minimum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置进度条最小值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setMinimum</span><span class="params">(<span class="type">int</span> minimum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到进度条最大值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QProgressDialog::maximum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置进度条最大值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setMaximum</span><span class="params">(<span class="type">int</span> maximum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置进度条范围(最大和最小值)</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setRange</span><span class="params">(<span class="type">int</span> minimum, <span class="type">int</span> maximum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到进度条当前的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QProgressDialog::value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置进度条当前的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setValue</span><span class="params">(<span class="type">int</span> progress)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QProgressDialog::autoReset</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 当value() = maximum()时，进程对话框是否调用reset()，此属性默认为true。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setAutoReset</span><span class="params">(<span class="type">bool</span> reset)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QProgressDialog::autoClose</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 当value() = maximum()时，进程对话框是否调用reset()并且隐藏，此属性默认为true。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setAutoClose</span><span class="params">(<span class="type">bool</span> close)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断用户是否按下了取消键, 按下了返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wasCanceled</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置进度条</span></span><br><span class="line"><span class="comment">// 重置进度对话框。wascancelled()变为true，直到进程对话框被重置。进度对话框被隐藏。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::cancel</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 重置进度对话框。如果autoClose()为真，进程对话框将隐藏。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::reset</span><span class="params">()</span></span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号</span></span><br><span class="line"><span class="comment">// 当单击cancel按钮时，将发出此信号。默认情况下，它连接到cancel()槽。</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::canceled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置窗口的显示状态(模态, 非模态)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">Qt::NonModal  -&gt; 非模态</span></span><br><span class="line"><span class="comment">Qt::WindowModal-&gt; 模态, 阻塞父窗口</span></span><br><span class="line"><span class="comment">Qt::ApplicationModal -&gt; 模态, 阻塞应用程序中的所有窗口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setWindowModality</span><span class="params">(Qt::WindowModality windowModality)</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-3-6-2-测试代码"><a href="#1-3-6-2-测试代码" class="headerlink" title="1.3.6.2 测试代码"></a>1.3.6.2 测试代码</h4><blockquote><p>场景描述:<br>    1. 基于定时器模拟文件拷贝的场景<br>    2. 点击窗口按钮, 进度条窗口显示, 同时启动定时器<br>    3. 通过定时器信号, 按照固定频率更新对话框窗口进度条<br>    4. 当进度条当前值 &#x3D;&#x3D; 最大值, 关闭定时器, 关闭并析构进度对话框</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_progressdlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建进度条对话框窗口对象</span></span><br><span class="line">    QProgressDialog *progress = <span class="keyword">new</span> <span class="built_in">QProgressDialog</span>(</span><br><span class="line">                <span class="string">&quot;正在拷贝数据...&quot;</span>, <span class="string">&quot;取消拷贝&quot;</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 2. 初始化并显示进度条窗口</span></span><br><span class="line">    progress-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;请稍后&quot;</span>);</span><br><span class="line">    progress-&gt;<span class="built_in">setWindowModality</span>(Qt::WindowModal);</span><br><span class="line">    progress-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 更新进度条</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    QTimer *timer = <span class="keyword">new</span> QTimer;</span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, [=]()</span><br><span class="line">    &#123;</span><br><span class="line">         progress-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line">         value++;</span><br><span class="line">         <span class="comment">// 当value &gt; 最大值的时候</span></span><br><span class="line">         <span class="keyword">if</span>(value &gt; progress-&gt;<span class="built_in">maximum</span>())</span><br><span class="line">         &#123;</span><br><span class="line">             timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">             value = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">delete</span> progress;</span><br><span class="line">             <span class="keyword">delete</span> timer;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(progress, &amp;QProgressDialog::canceled, <span class="keyword">this</span>, [=]()</span><br><span class="line">    &#123;</span><br><span class="line">        timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">        value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">delete</span> progress;</span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>进度窗口效果展示:<br><img src="/img/9.67.png" alt="在这里插入图片描述"></p></blockquote><hr><h2 id="1-4-QMainWindow"><a href="#1-4-QMainWindow" class="headerlink" title="1.4 QMainWindow"></a>1.4 QMainWindow</h2><blockquote><p>QMainWindow是标准基础窗口中结构最复杂的窗口, 其组成如下:</p><ul><li>提供了<code>菜单栏, 工具栏, 状态栏, 停靠窗口</code></li><li>菜单栏: 只能有一个, 位于窗口的最上方 </li><li>工具栏: 可以有多个, 默认提供了一个,窗口的上下左右都可以停靠 </li><li>状态栏: 只能有一个, 位于窗口最下方 </li><li>停靠窗口: 可以有多个, 默认没有提供, 窗口的上下左右都可以停靠</li></ul></blockquote><p><img src="/img/9.68.png" alt="在这里插入图片描述"></p><h3 id="1-4-1-菜单栏"><a href="#1-4-1-菜单栏" class="headerlink" title="1.4.1 菜单栏"></a>1.4.1 菜单栏</h3><ul><li>添加菜单项</li></ul><blockquote><p>关于顶级菜单可以直接在UI窗口中双击, 直接输入文本信息即可, 对应子菜单项也可以通过先双击在输入的方式完成添加,但是这种方式<code>不支持中文的输入</code>。</p></blockquote><p><img src="/img/9.69.png" alt="在这里插入图片描述"></p><ul><li>常用的添加方式</li></ul><blockquote><p>一般情况下, 我们都是先在外面创建出QAction对象, 然后再将其拖拽到某个菜单下边, 这样子菜单项的添加就完成了。</p></blockquote><p><img src="/img/9.70.png" alt="在这里插入图片描述"></p><ul><li>通过代码的方式添加菜单或者菜单项</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给菜单栏添加菜单</span></span><br><span class="line"><span class="function">QAction *<span class="title">QMenuBar::addMenu</span><span class="params">(QMenu *menu)</span></span>;</span><br><span class="line"><span class="function">QMenu *<span class="title">QMenuBar::addMenu</span><span class="params">(<span class="type">const</span> QString &amp;title)</span></span>;</span><br><span class="line"><span class="function">QMenu *<span class="title">QMenuBar::addMenu</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;title)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给菜单对象添加菜单项(QAction)</span></span><br><span class="line"><span class="function">QAction *<span class="title">QMenu::addAction</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="function">QAction *<span class="title">QMenu::addAction</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加分割线</span></span><br><span class="line"><span class="function">QAction *<span class="title">QMenu::addSeparator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>菜单项 QAction 事件的处理</li></ul><p><strong>单击菜单项, 该对象会发出一个信号</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击QAction对象发出该信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAction::triggered</span><span class="params">(<span class="type">bool</span> checked = <span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// save_action 是某个菜单项对象名, 点击这个菜单项会弹出一个对话框</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;save_action, &amp;QAction::triggered, <span class="keyword">this</span>, [=]()</span><br><span class="line">&#123;</span><br><span class="line">      QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;Triggered&quot;</span>, <span class="string">&quot;我是菜单项, 你不要调戏我...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="1-4-2-工具栏"><a href="#1-4-2-工具栏" class="headerlink" title="1.4.2 工具栏"></a>1.4.2 工具栏</h3><h4 id="1-4-2-1-添加工具按钮"><a href="#1-4-2-1-添加工具按钮" class="headerlink" title="1.4.2.1 添加工具按钮"></a>1.4.2.1 添加工具按钮</h4><blockquote><p>窗口中的工具栏我们经常见到, 并不会为此感到陌生, 如何往工具栏中添加工具按钮?<br>一共有两种方式</p></blockquote><ul><li><p>方式1：先创建QAction对象, 然后拖拽到工具栏中, 和添加菜单项的方式相同<br><img src="/img/9.71.png" alt="在这里插入图片描述"></p></li><li><p>方式2：如果不通过UI界面直接操作，那么就需要调用相关的API函数了</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在QMainWindow窗口中添加工具栏</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QMainWindow::addToolBar</span><span class="params">(Qt::ToolBarArea area, QToolBar *toolbar)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QMainWindow::addToolBar</span><span class="params">(QToolBar *toolbar)</span></span>;</span><br><span class="line"><span class="function">QToolBar *<span class="title">QMainWindow::addToolBar</span><span class="params">(<span class="type">const</span> QString &amp;title)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Qt控件放到工具栏中</span></span><br><span class="line"><span class="comment">// 工具栏类: QToolBar</span></span><br><span class="line"><span class="comment">// 添加的对象只要是QWidget或者启子类都可以被添加</span></span><br><span class="line"><span class="function">QAction *<span class="title">QToolBar::addWidget</span><span class="params">(QWidget *widget)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加QAction对象</span></span><br><span class="line"><span class="function">QAction *<span class="title">QToolBar::addAction</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="function">QAction *<span class="title">QToolBar::addAction</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加分隔线</span></span><br><span class="line"><span class="function">QAction *<span class="title">QToolBar::addSeparator</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>通过代码的方式对工具栏进行操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加第二个工具栏</span></span><br><span class="line">    QToolBar* toolbar = <span class="keyword">new</span> <span class="built_in">QToolBar</span>(<span class="string">&quot;toolbar&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addToolBar</span>(Qt::LeftToolBarArea, toolbar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给工具栏添加按钮和单行输入框</span></span><br><span class="line">    ui-&gt;toolBar-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;搜索&quot;</span>));</span><br><span class="line">    QLineEdit* edit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">    edit-&gt;<span class="built_in">setMaximumWidth</span>(<span class="number">200</span>);</span><br><span class="line">    edit-&gt;<span class="built_in">setFixedWidth</span>(<span class="number">100</span>);</span><br><span class="line">    ui-&gt;toolBar-&gt;<span class="built_in">addWidget</span>(edit);</span><br><span class="line">    <span class="comment">// 添加QAction类型的菜单项</span></span><br><span class="line">    ui-&gt;toolBar-&gt;<span class="built_in">addAction</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/er-dog&quot;</span>), <span class="string">&quot;二狗子&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="1-4-2-2-工具栏的属性设置"><a href="#1-4-2-2-工具栏的属性设置" class="headerlink" title="1.4.2.2 工具栏的属性设置"></a>1.4.2.2 工具栏的属性设置</h4><blockquote><p>在UI窗口的树状列表中, 找到工具栏节点, 就可以得到工具栏的属性设置面板了<br>这样就可根据个人需求对工具栏的属性进行设置和修改了。</p></blockquote><p><img src="/img/9.72.png" alt="在这里插入图片描述"></p><blockquote><p>在Qt控件的属性窗口中对应了一些属性, 这些属性大部分都应了一个设置函数</p><ul><li>在对应的类中函数名叫什么? <ul><li>规律: <code>set+属性名 == 函数名</code></li></ul></li><li>某些属性没有对应的函数, 只能在属性窗口中设置</li></ul></blockquote><hr><h3 id="1-4-3-状态栏"><a href="#1-4-3-状态栏" class="headerlink" title="1.4.3 状态栏"></a>1.4.3 状态栏</h3><blockquote><p>一般情况下, 需要在状态栏中添加某些控件, 显示某些属性, 用最多的就是添加标签 <code>QLabel</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型: QStatusBar</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QStatusBar::addWidget</span><span class="params">(QWidget *widget, <span class="type">int</span> stretch = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QStatusBar::clearMessage</span><span class="params">()</span></span>;</span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QStatusBar::showMessage</span><span class="params">(<span class="type">const</span> QString &amp;message, <span class="type">int</span> timeout = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>相关的操作代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态栏添加子控件</span></span><br><span class="line">    <span class="comment">// 按钮</span></span><br><span class="line">    QPushButton* button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮&quot;</span>);</span><br><span class="line">    ui-&gt;statusBar-&gt;<span class="built_in">addWidget</span>(button);</span><br><span class="line">    <span class="comment">// 标签</span></span><br><span class="line">    QLabel* label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    ui-&gt;statusBar-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-4-4-停靠窗口"><a href="#1-4-4-停靠窗口" class="headerlink" title="1.4.4 停靠窗口"></a>1.4.4 停靠窗口</h3><blockquote><p>停靠窗口可以通过鼠标拖动停靠到窗口的上、下、左、右，或者浮动在窗口上方。<br>如果需要这种类型的窗口必须手动添加<br><code>如果在非QMainWindow类型的窗口中添加了停靠窗口,那么这个窗口是不能移动和浮动的。</code><br> 浮动窗口在工具栏中， 直接将其拖拽到UI界面上即可。</p></blockquote><p><img src="/img/9.73.png" alt="在这里插入图片描述"></p><ul><li>停靠窗口也有一个属性面板, 我们可以在其对应属性面板中直接进行设置和修改相关属性。</li></ul><p><img src="/img/9.74.png" alt="在这里插入图片描述"></p><hr><h2 id="1-5-资源文件-qrc"><a href="#1-5-资源文件-qrc" class="headerlink" title="1.5 资源文件 .qrc"></a>1.5 资源文件 .qrc</h2><blockquote><p>资源文件顾名思义就是一个存储资源的文件，在Qt中引入资源文件好处在于他能提高应用程序的部署效率并且减少一些错误的发生。<br><code>在程序编译过程中，添加到资源文件中的文件也会以二进制的形式被打包到可执行程序中，这样这些资源就永远和可执行程序捆绑到一起了，不会出现加载资源却找不到的问题。</code><br>虽然资源文件优势很明显，但是它也不是万能的，资源文件中一般添加的都是比较小的资源，比如： 图片，配置文件，MP3等，如果是类似视频这类比较大的文件就不适合放到资源文件中了。</p></blockquote><ul><li>比如我们需要给某个窗口设置图标, 代码如下:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建图标对象</span></span><br><span class="line">QIcon::<span class="built_in">QIcon</span>(<span class="type">const</span> QString &amp;fileName);</span><br><span class="line"><span class="comment">// QWidget类的 公共成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowIcon</span><span class="params">(<span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给窗口设置图标</span></span><br><span class="line"><span class="comment">// 弊端: 发布的 exe 必须要加载 d:\\pic\\1.ico 如果当前主机对应的目录中没有图片, 图标就无法被加载</span></span><br><span class="line"><span class="comment">// 发布 exe 需要额外发布图片, 将其部署到某个目录中</span></span><br><span class="line"><span class="built_in">setWindowIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;d:\\pic\\1.ico&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><p>我们可以使用资源文件解决上述的弊端, 这样发布应用程序的时候直接发布exe就可以, 不需要再额外提供图片了。</p></blockquote><p>介绍一下关于资源文件的创建步骤:</p><p><img src="/img/9.75.png" alt="在这里插入图片描述"></p><p><img src="/img/9.76.png" alt="在这里插入图片描述"><br><img src="/img/9.77.png" alt="在这里插入图片描述"><br><img src="/img/9.78.png" alt="在这里插入图片描述"></p><ul><li>资源文件添加完毕之后, 继续给大家介绍资源文件的使用</li></ul><ol><li>使用<code>资源编辑器</code>打开资源文件</li></ol><p><img src="/img/9.79.png" alt="在这里插入图片描述"></p><ol start="2"><li>给资源添加前缀</li></ol><blockquote><p>一个资源文件中可以添加多个前缀, 前缀就是添加的资源在资源文件中的路径, 前缀根据实际需求制定即可, 路径以<code>/</code>开头</p></blockquote><p><img src="/img/9.80.png" alt="在这里插入图片描述"></p><ol start="3"><li>添加文件</li></ol><blockquote><p>前缀添加完毕, 就可以在某个前缀下边添加相关的资源了。</p></blockquote><p><img src="/img/9.81.png" alt="在这里插入图片描述"></p><ul><li>弹出以文件选择对话框, 选择资源文件<ul><li>资源文件放到什么地方?<ul><li><code>放到和 项目文件 .pro 同一级目录或者更深的目录中</code></li><li><code>错误的做法: 将资源文件放到 .pro文件的上级目录, 这样资源文件无法被加载到</code></li></ul></li></ul></li><li>可以给添加的资源文件设置别名, 设置别名之后原来的名字就不能使用了</li></ul><blockquote><p>温馨提示:</p><ol><li>在高版本的QtCreator中, 资源文件名字或者别名不支持中文</li><li>如果设置了中文会出现编译会报错</li><li>在此只是演示, 使用过程中需要额外注意该问题</li></ol></blockquote><p><img src="/img/9.82.png" alt="在这里插入图片描述"></p><ol start="4"><li>如何在程序中使用资源文件中的图片</li></ol><blockquote><p>将项目树中的资源文件节点展开</p></blockquote><p><img src="/img/9.83.png" alt="在这里插入图片描述"></p><blockquote><p>找到需要使用的资源图片节点, 鼠标右键, 弹出的菜单中选择<code>Copy Path ...</code></p></blockquote><p><img src="/img/9.84.png" alt="在这里插入图片描述"></p><hr><h2 id="1-6-在Qt窗口中添加右键菜单"><a href="#1-6-在Qt窗口中添加右键菜单" class="headerlink" title="1.6 在Qt窗口中添加右键菜单"></a>1.6 在Qt窗口中添加右键菜单</h2><p>如果想要在某一窗口中显示右键菜单, 其处理方式大体上有两种<br>这两种方式分别为基于<code>鼠标事件实现</code>和<code>基于窗口的菜单策略实现</code>。<br>其中第二种方式中又有三种不同的实现方式<br>因此想要在窗口中显示一个右键菜单共四种实现方式</p><h3 id="1-6-1-基于鼠标事件实现"><a href="#1-6-1-基于鼠标事件实现" class="headerlink" title="1.6.1 基于鼠标事件实现"></a>1.6.1 基于鼠标事件实现</h3><h4 id="1-6-1-1-实现思路"><a href="#1-6-1-1-实现思路" class="headerlink" title="1.6.1.1 实现思路"></a>1.6.1.1 实现思路</h4><blockquote><p>使用这种方式实现右键菜单的显示需要使用<code>事件处理器函数</code>, 在Qt中这类函数都是回调函数,<br>并且在自定义窗口类中我们还可以自定义事件处理器函数的行为（因为子类继承了父类的这个方法并且这类函数是虚函数）。 </p></blockquote><p>实现步骤如下：</p><ol><li>在当前窗口类中重写鼠标操作相关的的事件处理器函数，有两个可以选择</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两个事件二选一即可, 只是事件函数被调用的时机不同罢了</span></span><br><span class="line"><span class="comment">// 这个时机对右键菜单的显示没有任何影响</span></span><br><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>在数据表事件处理器函数内部判断是否按下了鼠标右键</p></li><li><p>如果按下了鼠标右键创建菜单对象(也可以提前先创建处理), 并将其显示出来</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关于QMenu类型的菜单显示需要调用的 API</span></span><br><span class="line"><span class="comment">// 参数 p 就是右键菜单需要显示的位置, 这个坐标需要使用屏幕坐标</span></span><br><span class="line"><span class="comment">// 该位置坐标一般通过调用 QCursor::pos() 直接就可以得到了</span></span><br><span class="line"><span class="function">QAction *<span class="title">QMenu::exec</span><span class="params">(<span class="type">const</span> QPoint &amp;p, QAction *action = <span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-6-1-2-代码实现"><a href="#1-6-1-2-代码实现" class="headerlink" title="1.6.1.2 代码实现"></a>1.6.1.2 代码实现</h4><blockquote><p>在头文件中添加要重写的鼠标事件处理器函数声明, 这里使用的是 <code>mousePressEvent()</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainWindow</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 鼠标按下, 该函数被Qt框架调用, 需要重写该函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在源文件中重写从父类继承的虚函数<code>mousePressEvent()</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 判断用户按下的是哪一个鼠标键</span></span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>() == Qt::RightButton)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 弹出一个菜单, 菜单项是 QAction 类型</span></span><br><span class="line">        QMenu menu;</span><br><span class="line">        QAction* act = menu.<span class="built_in">addAction</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        <span class="built_in">connect</span>(act, &amp;QAction::triggered, <span class="keyword">this</span>, [=]()</span><br><span class="line">        &#123;</span><br><span class="line">            QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;您选择的是C++...&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        menu.<span class="built_in">addAction</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        menu.<span class="built_in">addAction</span>(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">        menu.<span class="built_in">exec</span>(QCursor::<span class="built_in">pos</span>()); <span class="comment">// 右键菜单被模态显示出来了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-6-2-基于窗口的菜单策略实现"><a href="#1-6-2-基于窗口的菜单策略实现" class="headerlink" title="1.6.2 基于窗口的菜单策略实现"></a>1.6.2 基于窗口的菜单策略实现</h3><blockquote><p>这种方式是使用 Qt 中 <code>QWidget</code> 类中的右键菜单函数<br><code>QWidget::setContextMenuPolicy(Qt::ContextMenuPolicy policy)</code> 来实现,<br>因为这个函数的参数可以指定不同的值, 因此不同参数对应的具体的实现方式也不同。 </p></blockquote><p>这个函数的函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型:</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setContextMenuPolicy</span><span class="params">(Qt::ContextMenuPolicy policy)</span></span>;</span><br><span class="line">参数: </span><br><span class="line">  - Qt::NoContextMenu     --&gt; 不能实现右键菜单</span><br><span class="line">  - Qt::PreventContextMenu   --&gt; 不能实现右键菜单</span><br><span class="line">  - Qt::DefaultContextMenu   --&gt; 基于事件处理器函数 QWidget::<span class="built_in">contextMenuEvent</span>() 实现</span><br><span class="line">  - Qt::ActionsContextMenu   --&gt; 添加到当前窗口中所有 QAction 都会作为右键菜单项显示出来</span><br><span class="line">  - Qt::CustomContextMenu    --&gt; 基于 QWidget::<span class="built_in">customContextMenuRequested</span>() 信号实现</span><br></pre></td></tr></table></figure><h4 id="1-6-2-1-Qt-DefaultContextMenu"><a href="#1-6-2-1-Qt-DefaultContextMenu" class="headerlink" title="1.6.2.1 Qt::DefaultContextMenu"></a>1.6.2.1 Qt::DefaultContextMenu</h4><blockquote><p>使用这个策略实现右键菜单, 需要借助窗口类从父类继承的虚函<code>QWidget::contextMenuEvent()</code>并重写它来实现。</p></blockquote><ul><li>第一步是在窗口类的头文件中添加这个函数的声明</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainWindow</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 如果窗口设置了 Qt::DefaultContextMenu 策略, </span></span><br><span class="line">    <span class="comment">// 点击鼠标右键该函数被Qt框架调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">contextMenuEvent</span><span class="params">(QContextMenuEvent *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>第二步在这个窗口类的构造函数设置右键菜单策略</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.cpp</span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给窗口设置策略: Qt::DefaultContextMenu</span></span><br><span class="line">    <span class="comment">// 在窗口中按下鼠标右键, 这个事件处理器函数被qt框架调用 QWidget::contextMenuEvent()</span></span><br><span class="line">    <span class="built_in">setContextMenuPolicy</span>(Qt::DefaultContextMenu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>第三步在这个窗口类的源文件中重写事件处理器函数 contextMenuEvent()</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::contextMenuEvent</span><span class="params">(QContextMenuEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 弹出一个菜单, 菜单项是 QAction 类型</span></span><br><span class="line">    QMenu menu;</span><br><span class="line">    QAction* act = menu.<span class="built_in">addAction</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">    <span class="built_in">connect</span>(act, &amp;QAction::triggered, <span class="keyword">this</span>, [=]()</span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;您选择的是C++...&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    menu.<span class="built_in">addAction</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">    menu.<span class="built_in">addAction</span>(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">    menu.<span class="built_in">exec</span>(QCursor::<span class="built_in">pos</span>());<span class="comment">// 右键菜单被模态显示出来了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="1-6-2-2-Qt-ActionsContextMenu"><a href="#1-6-2-2-Qt-ActionsContextMenu" class="headerlink" title="1.6.2.2 Qt::ActionsContextMenu"></a>1.6.2.2 Qt::ActionsContextMenu</h4><blockquote><p>使用这个策略实现右键菜单, 是最简单的一种, 我们只需要创建一些 <code>QAction</code> 类型的对象并且将他们添加到当前的窗口中,当我们在窗口中点击鼠标右键这些QAction类型的菜单项就可以显示出来了。<br>虽然这种方法比较简单，但是它有一定的局限性，就是在一个窗口中不能根据不同的需求制作不同的右键菜单，这种方式只能得到一个唯一的右键菜单。<br>相关的处理代码如下：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.cpp</span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要将某个QAction添加给对应的窗口, 这个action就是这个窗口右键菜单中的一个菜单项了</span></span><br><span class="line">    <span class="comment">// 在窗口中点击鼠标右键, 就可以显示这个菜单</span></span><br><span class="line">    <span class="built_in">setContextMenuPolicy</span>(Qt::ActionsContextMenu);</span><br><span class="line">    <span class="comment">// 给当前窗口添加QAction对象</span></span><br><span class="line">    QAction* act1  = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">    QAction* act2 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">    QAction* act3  = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addAction</span>(act1);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addAction</span>(act2);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addAction</span>(act3);</span><br><span class="line">    <span class="built_in">connect</span>(act1, &amp;QAction::triggered, <span class="keyword">this</span>, [=]()</span><br><span class="line">    &#123;</span><br><span class="line">         QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;您选择的是C++...&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="1-6-2-3-Qt-CustomContextMenu"><a href="#1-6-2-3-Qt-CustomContextMenu" class="headerlink" title="1.6.2.3 Qt::CustomContextMenu"></a>1.6.2.3 Qt::CustomContextMenu</h4><blockquote><p>使用这个策略实现右键菜单, 当点击鼠标右键，窗口会产生一个 <code>QWidget::customContextMenuRequested()</code>信号<br>注意仅仅只是发射信号，意味着要自己写显示右键菜单的槽函数（slot），这个信号是QWidget唯一与右键菜单有关的信号。</p></blockquote><p>来看一下这个信号的函数原型:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意: 信号中的参数pos为当前窗口的坐标，并非屏幕坐标，右键菜单显示需要使用屏幕坐标</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QWidget::customContextMenuRequested</span><span class="params">(<span class="type">const</span> QPoint &amp;pos)</span></span></span><br></pre></td></tr></table></figure><p>代码实现也比较简单, 如下所示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.cpp</span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略 Qt::CustomContextMenu</span></span><br><span class="line">    <span class="comment">// 当在窗口中点击鼠标右键, 窗口会发出一个信号: QWidget::customContextMenuRequested()</span></span><br><span class="line">    <span class="comment">// 对应发射出的这个信号, 需要添加一个槽函数, 用来显示右键菜单</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setContextMenuPolicy</span>(Qt::CustomContextMenu);</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;MainWindow::customContextMenuRequested, <span class="keyword">this</span>, [=](<span class="type">const</span> QPoint &amp;pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 参数 pos 是鼠标按下的位置, 但是不能直接使用, 这个坐标不是屏幕坐标, 是当前窗口的坐标</span></span><br><span class="line">        <span class="comment">// 如果要使用这个坐标需要将其转换为屏幕坐标</span></span><br><span class="line">        QMenu menu;</span><br><span class="line">        QAction* act = menu.<span class="built_in">addAction</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        <span class="built_in">connect</span>(act, &amp;QAction::triggered, <span class="keyword">this</span>, [=]()</span><br><span class="line">        &#123;</span><br><span class="line">            QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;您选择的是C++...&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        menu.<span class="built_in">addAction</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        menu.<span class="built_in">addAction</span>(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">        <span class="comment">// menu.exec(QCursor::pos());</span></span><br><span class="line">        <span class="comment">// 将窗口坐标转换为屏幕坐标</span></span><br><span class="line">        QPoint newpt = <span class="keyword">this</span>-&gt;<span class="built_in">mapToGlobal</span>(pos);</span><br><span class="line">        menu.<span class="built_in">exec</span>(newpt);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上边的程序中, 我们通过窗口发射的信号得到了一个坐标类型的参数<br>注意<code>这个坐标是当前窗口的窗口坐标, 不是屏幕坐标,显示右键菜单需要使用屏幕坐标。</code></p></blockquote><p> 对应这个坐标的处理可以有两种方式：</p><ul><li><p>弃用，选择使用 <code>QCursor::pos()</code> 得到光标在屏幕的坐标位置</p></li><li><p>坐标转换, 将窗口坐标转换为屏幕坐标, 这里用到了一个函数 <code>mapToGlobal</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是当前窗口坐标, 返回值为屏幕坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QWidget::mapToGlobal</span><span class="params">(<span class="type">const</span> QPoint &amp;pos)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>不管使用以上哪种方式显示右键菜单, 显示出来之后的效果是一样的</p><p><img src="/img/9.85.png" alt="在这里插入图片描述"></p><p>最后如果想要让自己的右键菜单项显示图标, 可以调用这个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只显示文本字符串</span></span><br><span class="line"><span class="function">QAction *<span class="title">QMenu::addAction</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="comment">// 可以显示图标 + 文本字符串</span></span><br><span class="line"><span class="function">QAction *<span class="title">QMenu::addAction</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;text)</span></span>;</span><br></pre></td></tr></table></figure><hr><h1 id="2-窗口布局"><a href="#2-窗口布局" class="headerlink" title="2. 窗口布局"></a>2. 窗口布局</h1><h2 id="2-1-布局的样式"><a href="#2-1-布局的样式" class="headerlink" title="2.1 布局的样式"></a>2.1 布局的样式</h2><blockquote><p>Qt窗口布局是指将多个子窗口按照某种排列方式将其全部展示到对应的父窗口中的一种处理方式</p></blockquote><p>在Qt中常用的布局样式有三种，分别是：</p><table><thead><tr><th>布局样式</th><th>描述</th><th>行数</th><th>列数</th></tr></thead><tbody><tr><td>水平布局</td><td>布局中的所有的控件水平排列</td><td>1行</td><td>N列 (N&gt;&#x3D;1)</td></tr><tr><td>垂直布局</td><td>布局中的所有的控件垂直排列</td><td>N行 (N&gt;&#x3D;1)</td><td>1列</td></tr><tr><td>网格（栅格）布局</td><td>布局中的所有的控件垂直+水平排列</td><td>N行 (N&gt;&#x3D;1)</td><td>N列 (N&gt;&#x3D;1)</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">有问有答:</span><br><span class="line">    1. 控件的位置可以通过坐标指定, 为什么还要使用布局?</span><br><span class="line">    - 坐标指定的位置是固定的, 当窗口大小发生改变, 子窗口位置不会变化</span><br><span class="line">    - 使用坐标指定子窗口位置, 这个控件可能会被其他控件覆盖导致无法显示出来</span><br><span class="line">    - 使用布局的方式可以完美解决以上的问题</span><br><span class="line">    - 一般在制作窗口的过程中都是给子控件进行布局, 而不是指定固定坐标位置</span><br><span class="line">    2. 布局有局限性吗, 窗口结构复杂如何解决呢?</span><br><span class="line">        - 没有局限性, 并且布局的使用是非常灵活的</span><br><span class="line">    - 各种布局是可以无限嵌套使用的, 这样就可以制作成非常复杂的窗口了</span><br><span class="line">    - 思路是这样的: 给窗口设置布局, 在布局中添加窗口, 子窗口中再设置布局, </span><br><span class="line">      在子窗口布局中再次添加窗口, ......(无限循环)</span><br></pre></td></tr></table></figure><hr><h2 id="2-2-在UI窗口中设置布局"><a href="#2-2-在UI窗口中设置布局" class="headerlink" title="2.2 在UI窗口中设置布局"></a>2.2 在UI窗口中设置布局</h2><blockquote><p>在UI窗口中进行布局的设置一共有两种处理方式</p></blockquote><h3 id="2-2-1-方式1"><a href="#2-2-1-方式1" class="headerlink" title="2.2.1 方式1"></a>2.2.1 方式1</h3><blockquote><p>第一种方式是使用Qt提供的布局, 从工具箱中找到相关的布局, 然后将其拖拽到UI窗口中</p></blockquote><p><img src="/img/9.86.png" alt="在这里插入图片描述"></p><ul><li>将相应的控件放入到布局对应的红色框内部, 这些控件就按照布局的样式自动排列到一起了，是不是很方便，赶紧自己操作起来感受一下吧。</li></ul><p><img src="/img/9.87.png" alt="在这里插入图片描述"></p><ul><li>除此之外, 我们也可以修改当前布局, 需要先选中当前布局, 然后鼠标右键, 在右键菜单中找布局在其子菜单项中选择其他布局即可</li></ul><p><img src="/img/9.88.png" alt="在这里插入图片描述"></p><hr><h3 id="2-2-2-方式2"><a href="#2-2-2-方式2" class="headerlink" title="2.2.2 方式2"></a>2.2.2 方式2</h3><blockquote><p>第二种方式是直接在父窗口中对子部件进行布局, 如果窗口结构很复杂需要嵌套, 那么就需要先将这些子部件放到一个<code>容器类型</code>的窗口中,然后再对这个容器类型的窗口进行布局操作。</p></blockquote><ol><li>首先需要从工具栏中拖拽一个容器类型的窗口到UI界面上</li></ol><p><strong>一般首选QWidget原因是简单, 并且窗口显示之后看不到任何痕迹</strong></p><p><img src="/img/9.89.png" alt="在这里插入图片描述"></p><ol start="2"><li>将要布局的子控件放到这个QWidget中</li></ol><p><strong>控件拖放过程中无需在意位置和是否对齐, 没有布局之前显示杂乱无序是正常现象。</strong></p><p><img src="/img/9.90.png" alt="在这里插入图片描述"></p><ol start="3"><li>对这个QWidget进行布局</li></ol><p><strong>首选选中这个存储子部件的父容器窗口, 然后鼠标右键, 在右键菜单中找<code>布局</code>, 通过其子菜单就可以选择需要的布局方式了。布局之后所有的子部件就能够按照对应样式排列了(<code>如果是网格布局, 有时候需要使用鼠标调节一下</code>)</strong></p><p><img src="/img/9.91.png" alt="在这里插入图片描述"></p><blockquote><p>也可以通过窗口上方工具栏提供的布局按钮进行窗口布局</p></blockquote><p><img src="/img/9.92.png" alt="在这里插入图片描述"></p><hr><h3 id="2-2-3-弹簧的使用"><a href="#2-2-3-弹簧的使用" class="headerlink" title="2.2.3 弹簧的使用"></a>2.2.3 弹簧的使用</h3><p>弹簧也有对应的属性可以设置, 具体属性如下图所示:<br><img src="/img/9.93.png" alt="在这里插入图片描述"></p><blockquote><p>关于弹簧的sizeType属性, 有很多选项, 一般常用的只有两个:<br><code>Fixed</code>: 得到一个固定大小的弹簧<br><code>Expanding</code>: 得到一个可伸缩的弹簧, 默认弹簧撑到最大</p></blockquote><p><img src="/img/9.94.png" alt="在这里插入图片描述"></p><hr><h3 id="2-2-4-布局属性设置"><a href="#2-2-4-布局属性设置" class="headerlink" title="2.2.4 布局属性设置"></a>2.2.4 布局属性设置</h3><blockquote><p>当我们给窗口设置了布局之后, 选中当前窗口, 就可以看到在其对应的属性窗口中除了有窗口属性, 还有一个布局属性</p></blockquote><p>介绍一下这些属性:</p><p><img src="/img/9.95.png" alt="在这里插入图片描述"></p><hr><h3 id="2-2-5-布局的注意事项"><a href="#2-2-5-布局的注意事项" class="headerlink" title="2.2.5 布局的注意事项"></a>2.2.5 布局的注意事项</h3><blockquote><p>通过UI编辑窗口的树状列表我们可以对所有窗口的布局进行检查, 如果发现某个窗口没有布局, 一定要对其进行设置<br><code>如果某个窗口没有进行布局, 那么当这个窗口显示出来之后里边的子部件就可能无法被显示出来</code> </p></blockquote><p><img src="/img/9.96.png" alt="在这里插入图片描述"></p><blockquote><p>一个简单的登录窗口</p></blockquote><p><img src="/img/9.97.png" alt="在这里插入图片描述"></p><hr><h2 id="2-3-通过API设置布局"><a href="#2-3-通过API设置布局" class="headerlink" title="2.3 通过API设置布局"></a>2.3 通过API设置布局</h2><blockquote><p>在QT中, 布局也有对应的类, 布局类之间的关系如下:</p></blockquote><p><img src="/img/9.98.png" alt="在这里插入图片描述"></p><p>在上图中的布局类虽然很多, 常用的布局类有三个, 就前边给大家介绍的三种布局, 对应关系如下:</p><table><thead><tr><th>布局样式</th><th>类名</th></tr></thead><tbody><tr><td>水平布局</td><td>QHBoxLayout</td></tr><tr><td>垂直布局</td><td>QVBoxLayout</td></tr><tr><td>网格（栅格）布局</td><td>QGridLayout</td></tr></tbody></table><p>一般我们不使用这些布局类对窗口进行布局<br>但还是在这里介绍一下这些类中常用的一些API函数</p><h3 id="2-3-1-QLayout"><a href="#2-3-1-QLayout" class="headerlink" title="2.3.1 QLayout"></a>2.3.1 QLayout</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 在布局最后面添加一个窗口</span><br><span class="line">void QLayout::addWidget(QWidget *w);</span><br><span class="line">// 将某个窗口对象从布局中移除, 窗口对象如果不再使用需要自己析构</span><br><span class="line">void QLayout::removeWidget(QWidget *widget);</span><br><span class="line">// 设置布局的四个边界大小, 即: 左、上、右和下的边距。</span><br><span class="line">void QLayout::setContentsMargins(int left, int top, int right, int bottom);</span><br><span class="line">// 设置布局中各个窗口之间的间隙大小</span><br><span class="line">void setSpacing(int);</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-2-QHBoxLayout"><a href="#2-3-2-QHBoxLayout" class="headerlink" title="2.3.2 QHBoxLayout"></a>2.3.2 QHBoxLayout</h3><blockquote><p>这个类中的常用API都是从基类继承过来的</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 创建符窗口对象</span><br><span class="line">QWidget *window = new QWidget;</span><br><span class="line">// 创建若干个子窗口对象</span><br><span class="line">QPushButton *button1 = new QPushButton(<span class="string">&quot;One&quot;</span>);</span><br><span class="line">QPushButton *button2 = new QPushButton(<span class="string">&quot;Two&quot;</span>);</span><br><span class="line">QPushButton *button3 = new QPushButton(<span class="string">&quot;Three&quot;</span>);</span><br><span class="line">QPushButton *button4 = new QPushButton(<span class="string">&quot;Four&quot;</span>);</span><br><span class="line">QPushButton *button5 = new QPushButton(<span class="string">&quot;Five&quot;</span>);</span><br><span class="line"></span><br><span class="line">// 创建水平布局对象</span><br><span class="line">QHBoxLayout *layout = new QHBoxLayout;</span><br><span class="line">// 将子窗口添加到布局中</span><br><span class="line">layout-&gt;addWidget(button1);</span><br><span class="line">layout-&gt;addWidget(button2);</span><br><span class="line">layout-&gt;addWidget(button3);</span><br><span class="line">layout-&gt;addWidget(button4);</span><br><span class="line">layout-&gt;addWidget(button5);</span><br><span class="line"></span><br><span class="line">// 将水平布局设置给父窗口对象</span><br><span class="line">window-&gt;setLayout(layout);</span><br><span class="line">// 显示父窗口</span><br><span class="line">window-&gt;show();</span><br></pre></td></tr></table></figure><p>代码效果展示:</p><p><img src="/img/9.99.png" alt="在这里插入图片描述"></p><hr><h3 id="2-3-3-QVBoxLayout"><a href="#2-3-3-QVBoxLayout" class="headerlink" title="2.3.3 QVBoxLayout"></a>2.3.3 QVBoxLayout</h3><blockquote><p>这个类中的常用API都是从基类继承过来的</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 创建符窗口对象</span><br><span class="line">QWidget *window = new QWidget;</span><br><span class="line">// 创建若干个子窗口对象</span><br><span class="line">QPushButton *button1 = new QPushButton(<span class="string">&quot;One&quot;</span>);</span><br><span class="line">QPushButton *button2 = new QPushButton(<span class="string">&quot;Two&quot;</span>);</span><br><span class="line">QPushButton *button3 = new QPushButton(<span class="string">&quot;Three&quot;</span>);</span><br><span class="line">QPushButton *button4 = new QPushButton(<span class="string">&quot;Four&quot;</span>);</span><br><span class="line">QPushButton *button5 = new QPushButton(<span class="string">&quot;Five&quot;</span>);</span><br><span class="line"></span><br><span class="line">// 创建垂直布局对象</span><br><span class="line">QVBoxLayout *layout = new QVBoxLayout;</span><br><span class="line">// 将子窗口添加到布局中</span><br><span class="line">layout-&gt;addWidget(button1);</span><br><span class="line">layout-&gt;addWidget(button2);</span><br><span class="line">layout-&gt;addWidget(button3);</span><br><span class="line">layout-&gt;addWidget(button4);</span><br><span class="line">layout-&gt;addWidget(button5);</span><br><span class="line"></span><br><span class="line">// 将水平布局设置给父窗口对象</span><br><span class="line">window-&gt;setLayout(layout);</span><br><span class="line">// 显示父窗口</span><br><span class="line">window-&gt;show();</span><br></pre></td></tr></table></figure><p>代码效果展示:<br><img src="/img/9.100.png" alt="在这里插入图片描述"></p><hr><h3 id="2-3-4-QGridLayout"><a href="#2-3-4-QGridLayout" class="headerlink" title="2.3.4 QGridLayout"></a>2.3.4 QGridLayout</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 构造函数</span><br><span class="line">QGridLayout::QGridLayout();</span><br><span class="line">QGridLayout::QGridLayout(QWidget *parent);</span><br><span class="line"></span><br><span class="line">// 添加窗口对象到网格布局中</span><br><span class="line">/*</span><br><span class="line">参数:</span><br><span class="line">  - widget: 添加到布局中的窗口对象</span><br><span class="line">  - row: 添加到布局中的窗口对象位于第几行 (从0开始)</span><br><span class="line">  - column: 添加到布局中的窗口对象位于第几列 (从0开始)</span><br><span class="line">  - alignment: 窗口在布局中的对齐方式, 没有特殊需求使用默认值即可</span><br><span class="line">*/</span><br><span class="line">void QGridLayout::addWidget(</span><br><span class="line">QWidget *widget, int row, int column, </span><br><span class="line">Qt::Alignment alignment = Qt::Alignment());</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">参数:</span><br><span class="line">  - widget: 添加到布局中的窗口对象</span><br><span class="line">  - fromRow: 添加到布局中的窗口对象位于第几行 (从0开始)</span><br><span class="line">  - fromColumn: 添加到布局中的窗口对象位于第几列 (从0开始)</span><br><span class="line">  - rowSpan: 添加的窗口从 fromRow 行开始跨越的行数</span><br><span class="line">  - columnSpan: 添加的窗口从 fromColumn 列开始跨越的列数</span><br><span class="line">  - alignment: 窗口在布局中的对齐方式, 没有特殊需求使用默认值即可</span><br><span class="line">*/</span><br><span class="line">void QGridLayout::addWidget(</span><br><span class="line">QWidget *widget, int fromRow, int fromColumn, </span><br><span class="line">int rowSpan, int columnSpan, </span><br><span class="line">Qt::Alignment alignment = Qt::Alignment());</span><br><span class="line"></span><br><span class="line">// 设置 column 对应的列的最新宽度, 单位: 像素</span><br><span class="line">void QGridLayout::setColumnMinimumWidth(int column, int minSize);</span><br><span class="line"></span><br><span class="line">// 设置布局中水平方向窗口之间间隔的宽度</span><br><span class="line">void QGridLayout::setHorizontalSpacing(int spacing);</span><br><span class="line"></span><br><span class="line">// 设置布局中垂直方向窗口之间间隔的宽度</span><br><span class="line">void QGridLayout::setVerticalSpacing(int spacing);</span><br></pre></td></tr></table></figure><p>测试代码如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 创建父窗口对象</span><br><span class="line">QWidget* window = new QWidget;</span><br><span class="line">// 创建子窗口对象</span><br><span class="line">QPushButton *button1 = new QPushButton(<span class="string">&quot;One&quot;</span>);</span><br><span class="line">QPushButton *button2 = new QPushButton(<span class="string">&quot;Two&quot;</span>);</span><br><span class="line">QPushButton *button3 = new QPushButton(<span class="string">&quot;Three&quot;</span>);</span><br><span class="line">QPushButton *button4 = new QPushButton(<span class="string">&quot;Four&quot;</span>);</span><br><span class="line">QPushButton *button5 = new QPushButton(<span class="string">&quot;Five&quot;</span>);</span><br><span class="line">QPushButton *button6 = new QPushButton(<span class="string">&quot;Six&quot;</span>);</span><br><span class="line">// 多行文本编辑框</span><br><span class="line">QTextEdit* txedit = new QTextEdit;</span><br><span class="line">txedit-&gt;setText(<span class="string">&quot;我占用了两行两列的空间哦。&quot;</span>);</span><br><span class="line"></span><br><span class="line">QGridLayout* layout = new QGridLayout;</span><br><span class="line">// 按钮起始位置: 第1行, 第1列, 该按钮占用空间情况为1行1列</span><br><span class="line">layout-&gt;addWidget(button1, 0, 0);</span><br><span class="line">// 按钮起始位置: 第1行, 第2列, 该按钮占用空间情况为1行1列</span><br><span class="line">layout-&gt;addWidget(button2, 0, 1);</span><br><span class="line">// 按钮起始位置: 第1行, 第3列, 该按钮占用空间情况为1行1列</span><br><span class="line">layout-&gt;addWidget(button3, 0, 2);</span><br><span class="line">// 编辑框起始位置: 第2行, 第1列, 该按钮占用空间情况为2行2列</span><br><span class="line">layout-&gt;addWidget(txedit, 1, 0, 2, 2);</span><br><span class="line">// 按钮起始位置: 第2行, 第3列, 该按钮占用空间情况为1行1列</span><br><span class="line">layout-&gt;addWidget(button4, 1, 2);</span><br><span class="line">// 按钮起始位置: 第3行, 第3列, 该按钮占用空间情况为1行1列</span><br><span class="line">layout-&gt;addWidget(button5, 2, 2);</span><br><span class="line">// 按钮起始位置: 第4行, 第1列, 该按钮占用空间情况为1行3列</span><br><span class="line">layout-&gt;addWidget(button6, 3, 0, 1, 3);</span><br><span class="line"></span><br><span class="line">// 网格布局设置给父窗口对象</span><br><span class="line">window-&gt;setLayout(layout);</span><br><span class="line">// 显示父窗口</span><br><span class="line">window-&gt;show();  </span><br></pre></td></tr></table></figure><p>测试代码效果展示:</p><p><img src="/img/9.101.png" alt="在这里插入图片描述"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-基础窗口类&quot;&gt;&lt;a href=&quot;#1-基础窗口类&quot; class=&quot;headerlink&quot; title=&quot;1. 基础窗口类&quot;&gt;&lt;/a&gt;1. 基础窗口类&lt;/h1&gt;&lt;h2 id=&quot;1-1-QWidget&quot;&gt;&lt;a href=&quot;#1-1-QWidget&quot; class=&quot;</summary>
      
    
    
    
    <category term="Qt" scheme="http://example.com/categories/Qt/"/>
    
    
  </entry>
  
  <entry>
    <title>基础数据类型和信号槽</title>
    <link href="http://example.com/2023/10/22/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E4%BF%A1%E5%8F%B7%E6%A7%BD/"/>
    <id>http://example.com/2023/10/22/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E4%BF%A1%E5%8F%B7%E6%A7%BD/</id>
    <published>2023-10-22T01:53:50.000Z</published>
    <updated>2023-10-22T03:02:55.054Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-Qt基本结构"><a href="#1-Qt基本结构" class="headerlink" title="1. Qt基本结构"></a>1. Qt基本结构</h1><h2 id="1-1-Qt本有项目"><a href="#1-1-Qt本有项目" class="headerlink" title="1.1 Qt本有项目"></a>1.1 Qt本有项目</h2><h3 id="1-1-1-项目文件（-pro）"><a href="#1-1-1-项目文件（-pro）" class="headerlink" title="1.1.1 项目文件（.pro）"></a>1.1.1 项目文件（.pro）</h3><blockquote><p>在创建的Qt项目中自动生成了一个后缀为 .pro 的项目文件，该文件中记录着项目的一些属性信息，具体信息如下：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在项目文件中, 注释需要使用 井号(#)</span></span><br><span class="line"><span class="comment"># 项目编译的时候需要加载哪些底层模块</span></span><br><span class="line">QT       += core gui </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果当前Qt版本大于4, 会添加一个额外的模块: widgets</span></span><br><span class="line"><span class="comment"># Qt 5中对gui模块进行了拆分, 将 widgets 独立出来了</span></span><br><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 使用c++11新特性</span></span><br><span class="line">CONFIG += c++11</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果在项目中调用了废弃的函数, 项目编译的时候会有警告的提示    </span></span><br><span class="line">DEFINES += QT_DEPRECATED_WARNINGS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目中的源文件</span></span><br><span class="line">SOURCES += \</span><br><span class="line">        main.cpp \</span><br><span class="line">        mainwindow.cpp</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 项目中的头文件</span></span><br><span class="line">HEADERS += \</span><br><span class="line">        mainwindow.h</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 项目中的窗口界面文件</span></span><br><span class="line">FORMS += \</span><br><span class="line">        mainwindow.ui</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-2-main-cpp"><a href="#1-1-2-main-cpp" class="headerlink" title="1.1.2 main.cpp"></a>1.1.2 main.cpp</h3><blockquote><p>在这个源文件中有程序的入口函数 <code>main()</code>，介绍下这个文件中自动生成的几行代码：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span><span class="comment">// 生成的窗口类头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span><span class="comment">// 应用程序类头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建应用程序对象, 在一个Qt项目中实例对象有且仅有一个</span></span><br><span class="line">    <span class="comment">// 类的作用: 检测触发的事件, 进行事件循环并处理</span></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">// 创建窗口类对象</span></span><br><span class="line">    MainWindow w;</span><br><span class="line">    <span class="comment">// 显示窗口</span></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">// 应用程序对象开始事件循环, 保证应用程序不退出</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-3-mainwindow-ui"><a href="#1-1-3-mainwindow-ui" class="headerlink" title="1.1.3 mainwindow.ui"></a>1.1.3 mainwindow.ui</h3><blockquote><p>在Qt中每一个窗口都对应一个可编辑的可视化界面（*.ui）, 这个界面对应的是一个xml格式的文件,<br>一般情况下不需要在xml格式下对这个文件进行编辑, 关于这个文件结构了解即可。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 双击这个文件看到的是一个窗口界面, 如果使用文本编辑器打开看到的是一个XML格式的文件--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 看不懂这种格式没关系, 我们不需要在这种模式下操作这个文件。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里只是给大家介绍这个文件的本质 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ui</span> <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">class</span>&gt;</span>MainWindow<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QMainWindow&quot;</span> <span class="attr">name</span>=<span class="string">&quot;MainWindow&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">x</span>&gt;</span>0<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">y</span>&gt;</span>0<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">width</span>&gt;</span>800<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">height</span>&gt;</span>600<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;windowTitle&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">string</span>&gt;</span>MainWindow<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QWidget&quot;</span> <span class="attr">name</span>=<span class="string">&quot;centralwidget&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QMenuBar&quot;</span> <span class="attr">name</span>=<span class="string">&quot;menubar&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QStatusBar&quot;</span> <span class="attr">name</span>=<span class="string">&quot;statusbar&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">resources</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">connections</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ui</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="1-1-4-mainwindow-h"><a href="#1-1-4-mainwindow-h" class="headerlink" title="1.1.4 mainwindow.h"></a>1.1.4 mainwindow.h</h3><blockquote><p>这个文件是窗口界面对应的类的头文件。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span><span class="comment">// Qt标准窗口类头文件</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="comment">// mainwindow.ui 文件中也有一个类叫 MainWindow, 将这个类放到命名空间 Ui 中</span></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">MainWindow</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT<span class="comment">// 这个宏是为了能够使用Qt中的信号槽机制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;<span class="comment">// 定义指针指向窗口的 UI 对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><hr><h3 id="1-1-5-mainwindow-cpp"><a href="#1-1-5-mainwindow-cpp" class="headerlink" title="1.1.5 mainwindow.cpp"></a>1.1.5 mainwindow.cpp</h3><blockquote><p>这个文件是窗口界面对应的类的源文件。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)<span class="comment">// 基于mainwindow.ui创建一个实例对象</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将 mainwindow.ui 的实例对象和 当前类的对象进行关联</span></span><br><span class="line">    <span class="comment">// 这样同名的连个类对象就产生了关联, 合二为一了</span></span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-2-Qt中的窗口类"><a href="#1-2-Qt中的窗口类" class="headerlink" title="1.2 Qt中的窗口类"></a>1.2 Qt中的窗口类</h2><blockquote><p>在通过Qt向导窗口基于窗口的应用程序的项目过程中倒数第二步选择跟随项目创建的第一个窗口的基类, 下拉菜单有三个选项, 分别为:<br><code>QMainWindow</code>、<code>QDialog</code>、<code>QWidget</code>如下图：</p></blockquote><h3 id="1-2-1基础窗口类"><a href="#1-2-1基础窗口类" class="headerlink" title="1.2.1基础窗口类"></a>1.2.1基础窗口类</h3><p><img src="/img/9.49.png" alt="在这里插入图片描述"></p><ul><li>常用的窗口类有3个<ul><li>在创建Qt窗口的时候, 需要让自己的窗口类继承上述三个窗口类的其中一个</li></ul></li><li>QWidget<ul><li>所有窗口类的基类</li><li>Qt中的控件(按钮, 输入框, 单选框…)也属于窗口, 基类都是QWidget</li><li>可以内嵌到其他窗口中: 没有边框</li><li>可以不内嵌单独显示: 独立的窗口, 有边框</li></ul></li><li>QDialog<ul><li>对话框类, 后边的章节会具体介绍这个窗口</li><li>不能内嵌到其他窗口中</li></ul></li><li>QMainWindow<ul><li>有工具栏, 状态栏, 菜单栏, 后边的章节会具体介绍这个窗口</li><li>不能内嵌到其他窗口中</li></ul></li></ul><hr><h3 id="1-2-2-窗口的显示"><a href="#1-2-2-窗口的显示" class="headerlink" title="1.2.2 窗口的显示"></a>1.2.2 窗口的显示</h3><ul><li>内嵌窗口<ul><li>依附于某一个大的窗口, 作为了大窗口的一部分</li><li>大窗口就是这个内嵌窗口的父窗口</li><li>父窗口显示的时候, 内嵌的窗口也就被显示出来了</li></ul></li><li>不内嵌窗口<ul><li>这类窗口有边框, 有标题栏</li><li>需要调用函数才可以显示</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QWidget是所有窗口类的基类, 调用这个提供的 show() 方法就可以显示将任何窗口显示出来</span></span><br><span class="line"><span class="comment">// 非模态显示</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::show</span><span class="params">()</span></span>;<span class="comment">// 显示当前窗口和它的子窗口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对话框窗口的非模态显示: 还是调用show() 方法</span></span><br><span class="line"><span class="comment">// 对话框窗口的模态显示</span></span><br><span class="line">[<span class="keyword">virtual</span> slot] <span class="function"><span class="type">int</span> <span class="title">QDialog::exec</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="1-3-内存回收"><a href="#1-3-内存回收" class="headerlink" title="1.3 内存回收"></a>1.3 内存回收</h2><blockquote><p>在Qt中创建对象的时候会提供一个 <code>Parent对象指针</code>（可以查看类的构造函数），parent是干什么的?<br>.<br>QObject是以对象树的形式组织起来的。<code>当你创建一个QObject对象时，会看到QObject的构造函数接收一个QObject指针作为参数，这个参数就是parent，也就是父对象指针。</code><br>这相当于，在创建QObject对象时，可以提供一个其父对象，我们创建的这个QObject对象会自动添加到其父对象的children()列表。当父对象析构的时候，这个列表中的所有对象也会被析构。（<code>这里的父对象并不是继承意义上的父类</code>）</p><p>QWidget是能够在屏幕上显示的一切组件的父类。QWidget继承自QObject，因此也继承了这种对象树关系。一个孩子自动地成为父组件的一个子组件。因此，它会显示在父组件的坐标系统中，被父组件的边界剪裁。例如，当用户关闭一个对话框的时候，应用程序将其删除，那么，我们希望属于这个对话框的按钮、图标等应该一起被删除。事实就是如此，因为这些都是对话框的子组件。<br>Qt 引入对象树的概念，在一定程度上解决了内存问题。</p><ul><li>当一个QObject对象在堆上创建的时候，Qt会同时为其创建一个对象树。不过，对象树中对象的顺序是没有定义的。这意味着，销毁这些对象的顺序也是未定义的。</li><li>任何对象树中的 QObject对象 delete 的时候，如果这个对象有 parent，则自动将其从 parent<br>的children()列表中删除；如果有孩子，则自动 delete 每一个孩子。Qt 保证没有QObject会被 delete两次，这是由析构顺序决定的。</li></ul></blockquote><p><img src="/img/9.50.png" alt="在这里插入图片描述"></p><p>综上所述, 我们可以得到一个结论: <code>Qt中有内存回收机制, 但是不是所有被new出的对象被自动回收, 满足条件才可以回收</code>, 如果想要在Qt中实现内存的自动回收, 需要满足以下两个条件:</p><ul><li>创建的对象必须是QObject类的子类(间接子类也可以)<ul><li>QObject类是没有父类的, Qt中有很大一部分类都是从这个类派生出去的<ul><li>Qt中使用频率很高的窗口类和控件都是 QObject 的直接或间接的子类</li><li>其他的类可以自己查阅Qt帮助文档</li></ul></li></ul></li><li>创建出的类对象, 必须要指定其父对象是谁, 一般情况下有两种操作方式:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1: 通过构造函数</span></span><br><span class="line"><span class="comment">// parent: 当前窗口的父对象, 找构造函数中的 parent 参数即可</span></span><br><span class="line">QWidget::<span class="built_in">QWidget</span>(QWidget *parent = Q_NULLPTR, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line">QTimer::<span class="built_in">QTimer</span>(QObject *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2: 通过setParent()方法</span></span><br><span class="line"><span class="comment">// 假设这个控件没有在构造的时候指定符对象, 可以调用QWidget的api指定父窗口对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setParent</span><span class="params">(QWidget *parent)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QObject::setParent</span><span class="params">(QObject *parent)</span></span>;</span><br></pre></td></tr></table></figure><hr><h1 id="2-Qt中的基础数据类型"><a href="#2-Qt中的基础数据类型" class="headerlink" title="2. Qt中的基础数据类型"></a>2. Qt中的基础数据类型</h1><p>主要介绍Qt中常用数据类型, 主要内容包括: <code>基础数据类型</code>, <code>Log日志输出</code>, <code>字符串类型</code>, <code>QVariant</code>, <code>位置和尺寸相关类型</code>, <code>日期和时间相关类型</code>。 </p><h2 id="2-1-基础类型"><a href="#2-1-基础类型" class="headerlink" title="2.1 基础类型"></a>2.1 基础类型</h2><p>因为Qt是一个C++ 框架, 因此C++中所有的语法和数据类型在Qt中都是被支持的, 但是Qt中也定义了一些属于自己的数据类型, 介绍一下这些基础的数类型。</p><p>QT基本数据类型定义在<code>#include &lt;QtGlobal&gt;</code> 中，QT基本数据类型有：</p><table><thead><tr><th>类型名称</th><th>注释</th><th>备注</th></tr></thead><tbody><tr><td>qint8</td><td>signed char</td><td>有符号8位数据</td></tr><tr><td>qint16</td><td>signed short</td><td>16位数据类型</td></tr><tr><td>qint32</td><td>signed short</td><td>32位有符号数据类型</td></tr><tr><td>qint64</td><td>long long int 或 (__int64)</td><td>64位有符号数据类型，Windows中定义为__int64</td></tr><tr><td>qintptr</td><td>qint32 或 qint64</td><td>指针类型 根据系统类型不同而不同，32位系统为qint32、64位系统为qint64</td></tr><tr><td>qlonglong</td><td>long long int 或 (__int64)</td><td>Windows中定义为__int64</td></tr><tr><td>qptrdiff</td><td>qint32 或 qint64</td><td>根据系统类型不同而不同，32位系统为qint32、64位系统为qint64</td></tr><tr><td>qreal</td><td>double 或 float</td><td>除非配置了-qreal float选项，否则默认为double</td></tr><tr><td>quint8</td><td>unsigned char</td><td>无符号8位数据类型</td></tr><tr><td>quint16</td><td>unsigned short</td><td>无符号16位数据类型</td></tr><tr><td>quint32</td><td>unsigned int</td><td>无符号32位数据类型</td></tr><tr><td>quint64</td><td>unsigned long long int 或 (unsigned __int64)</td><td>无符号64比特数据类型，Windows中定义为unsigned __int64</td></tr><tr><td>quintptr</td><td>quint32 或 quint64</td><td>根据系统类型不同而不同，32位系统为quint32、64位系统为quint64</td></tr><tr><td>qulonglong</td><td>unsigned long long int 或 (unsigned __int64)</td><td>Windows中定义为__int64</td></tr><tr><td>uchar</td><td>unsigned char</td><td>无符号字符类型</td></tr><tr><td>uint</td><td>unsigned int</td><td>无符号整型</td></tr><tr><td>ulong</td><td>unsigned long</td><td>无符号长整型</td></tr><tr><td>ushort</td><td>unsigned short</td><td>无符号短整型</td></tr></tbody></table><p><code>虽然在Qt中有属于自己的整形或者浮点型, 但是在变成过程中这些一般不用, 常用的类型关键字还是 C/C++中的 int, float, double 等。</code></p><hr><h2 id="2-2-log输出"><a href="#2-2-log输出" class="headerlink" title="2.2 log输出"></a>2.2 log输出</h2><h3 id="2-2-1-在调试窗口中输入日志"><a href="#2-2-1-在调试窗口中输入日志" class="headerlink" title="2.2.1 在调试窗口中输入日志"></a>2.2.1 在调试窗口中输入日志</h3><blockquote><p>在Qt中进行log输出, 一般不使用c中的<code>printf</code>, 也不是使用C++中的<code>cout</code><br>Qt框架提供了专门用于日志输出的类, 头文件名为<code>QDebug</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含了QDebug头文件, 直接通过全局函数 qDebug() 就可以进行日志输出了</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Date:&quot;</span> &lt;&lt; QDate::<span class="built_in">currentDate</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Types:&quot;</span> &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;String&quot;</span>) &lt;&lt; <span class="built_in">QChar</span>(<span class="string">&#x27;x&#x27;</span>)&lt;&lt;<span class="built_in">QRect</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">40</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Custom coordinate type:&quot;</span> &lt;&lt; coordinate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和全局函数 qDebug() 类似的日志函数还有: qWarning(), qInfo(), qCritical()</span></span><br><span class="line"><span class="type">int</span> number = <span class="number">666</span>;</span><br><span class="line"><span class="type">float</span> i = <span class="number">11.11</span>;</span><br><span class="line"><span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;Number:&quot;</span> &lt;&lt; number &lt;&lt; <span class="string">&quot;Other value:&quot;</span> &lt;&lt; i;</span><br><span class="line"><span class="built_in">qInfo</span>() &lt;&lt; <span class="string">&quot;Number:&quot;</span> &lt;&lt; number &lt;&lt; <span class="string">&quot;Other value:&quot;</span> &lt;&lt; i;</span><br><span class="line"><span class="built_in">qCritical</span>() &lt;&lt; <span class="string">&quot;Number:&quot;</span> &lt;&lt; number &lt;&lt; <span class="string">&quot;Other value:&quot;</span> &lt;&lt; i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;我是要成为海贼王的男人!!!&quot;</span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;我是隔壁的二柱子...&quot;</span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;我是鸣人, 我擅长嘴遁!!!&quot;</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-2-2-在终端窗口中输出日志"><a href="#2-2-2-在终端窗口中输出日志" class="headerlink" title="2.2.2 在终端窗口中输出日志"></a>2.2.2 在终端窗口中输出日志</h3><blockquote><p>使用上面的方法只能在项目调试过程中进行日志输出, 如果不是通过IDE进行程序调试, 而是直接执行可执行程序在这种情况下是没有日志输出窗口的,因此也就看不到任何的日志输出。</p><p>默认情况下日志信息是不会打印到终端窗口的, 如果想要实现这样的效果, 必须在项目文件中添加相关的属性信息</p></blockquote><p>打开项目文件（*.pro）找到配置项 config, 添加 console 控制台属性:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG += c++11 console</span><br></pre></td></tr></table></figure><hr><h2 id="2-3-字符串类型"><a href="#2-3-字符串类型" class="headerlink" title="2.3 字符串类型"></a>2.3 字符串类型</h2><p>在Qt中不仅支持C, C++中的字符串类型, 而且还在框架中定义了专属的字符串类型,<br>必须要掌握在Qt中关于这些类型的使用和相互之间的转换。</p><table><thead><tr><th>语言类型</th><th>字符串类型</th></tr></thead><tbody><tr><td>C</td><td><code>char*</code></td></tr><tr><td>C++</td><td><code>std::string</code>, <code>char*</code></td></tr><tr><td>Qt</td><td><code>QByteArray</code>, <code>QString</code></td></tr></tbody></table><h3 id="2-3-1-QByteArray"><a href="#2-3-1-QByteArray" class="headerlink" title="2.3.1 QByteArray"></a>2.3.1 QByteArray</h3><blockquote><p>在Qt中<code>QByteArray</code>可以看做是c语言中<code>char*</code>的升级版本。我们在使用这种类型的时候可通过这个类的构造函数申请一块动态内存，用于存储我们需要处理的字符串数据。<br>介绍一下这个类中常用的一些API函数</p></blockquote><p><strong>构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造空对象, 里边没有数据</span></span><br><span class="line">QByteArray::<span class="built_in">QByteArray</span>();</span><br><span class="line"><span class="comment">// 将data中的size个字符进行构造, 得到一个字节数组对象</span></span><br><span class="line"><span class="comment">// 如果 size==-1 函数内部自动计算字符串长度, 计算方式为: strlen(data)</span></span><br><span class="line">QByteArray::<span class="built_in">QByteArray</span>(<span class="type">const</span> <span class="type">char</span> *data, <span class="type">int</span> size = <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 构造一个长度为size个字节, 并且每个字节值都为ch的字节数组</span></span><br><span class="line">QByteArray::<span class="built_in">QByteArray</span>(<span class="type">int</span> size, <span class="type">char</span> ch);</span><br></pre></td></tr></table></figure><p><strong>数据操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在尾部追加数据</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::append</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::push_back</span><span class="params">(<span class="type">const</span> QByteArray &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头部添加数据</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::prepend</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::push_front</span><span class="params">(<span class="type">const</span> QByteArray &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据, 将ba插入到数组第 i 个字节的位置(从0开始)</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="comment">// 从大字符串中删除len个字符, 从第pos个字符的位置开始删除</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::remove</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> len)</span></span>;</span><br><span class="line"><span class="comment">// 从字符数组的尾部删除 n 个字节</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::chop</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 从字节数组的 pos 位置将数组截断 (前边部分留下, 后边部分被删除)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::truncate</span><span class="params">(<span class="type">int</span> pos)</span></span>;</span><br><span class="line"><span class="comment">// 将对象中的数据清空, 使其为null</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换</span></span><br><span class="line"><span class="comment">// 将字节数组中的 子字符串 before 替换为 after</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::replace</span><span class="params">(<span class="type">const</span> QByteArray &amp;before, <span class="type">const</span> QByteArray &amp;after)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>子字符串查找和判断</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断字节数组中是否包含子字符串 ba, 包含返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::contains</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::contains</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断字节数组中是否包含子字符 ch, 包含返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::contains</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字节数组是否以字符串 ba 开始, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::startsWith</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::startsWith</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断字节数组是否以字符 ch 开始, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::startsWith</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字节数组是否以字符串 ba 结尾, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::endsWith</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::endsWith</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断字节数组是否以字符 ch 结尾, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::endsWith</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong>遍历</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">QByteArray::begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">QByteArray::end</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组的方式进行遍历</span></span><br><span class="line"><span class="comment">// i的取值范围 0 &lt;= i &lt; size()</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">QByteArray::at</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="type">char</span> QByteArray::<span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>;</span><br></pre></td></tr></table></figure><p><strong>查看字节数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字节数组对象中字符的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字节数组对象中 子字符串ba 出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回字节数组对象中 字符串ch 出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong>类型转换</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将QByteArray类型的字符串 转换为 char* 类型</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">QByteArray::data</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">QByteArray::data</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int, short, long, float, double -&gt; QByteArray</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">short</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(qlonglong n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">float</span> n, <span class="type">char</span> f = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> prec = <span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> f = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> prec = <span class="number">6</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::number</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::number</span><span class="params">(qlonglong n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::number</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> f = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> prec = <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QByteArray -&gt; int, short, long, float, double</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::toInt</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">QByteArray::toShort</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">QByteArray::toLong</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">QByteArray::toFloat</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">QByteArray::toDouble</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::string -&gt; QByteArray</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::fromStdString</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span>;</span><br><span class="line"><span class="comment">// QByteArray -&gt; std::string</span></span><br><span class="line"><span class="function">std::string <span class="title">QByteArray::toStdString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有字符转换为大写</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QByteArray::toUpper</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 所有字符转换为小写</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QByteArray::toLower</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-2-QString"><a href="#2-3-2-QString" class="headerlink" title="2.3.2 QString"></a>2.3.2 QString</h3><blockquote><p>QString也是封装了字符串, 但是内部的编码为<code>utf8</code>, UTF-8属于Unicode字符集,<code>它固定使用多个字节（window为2字节, linux为3字节）来表示一个字符</code>，这样可以将世界上几乎所有语言的常用字符收录其中。<br>介绍一下这个类中常用的一些API函数。</p></blockquote><p><strong>构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个空字符串对象</span></span><br><span class="line">QString::<span class="built_in">QString</span>();</span><br><span class="line"><span class="comment">// 将 char* 字符串 转换为 QString 类型</span></span><br><span class="line">QString::<span class="built_in">QString</span>(<span class="type">const</span> <span class="type">char</span> *str);</span><br><span class="line"><span class="comment">// 将 QByteArray 转换为 QString 类型</span></span><br><span class="line">QString::<span class="built_in">QString</span>(<span class="type">const</span> QByteArray &amp;ba);</span><br><span class="line"><span class="comment">// 其他重载的同名构造函数可参考Qt帮助文档, 此处略</span></span><br></pre></td></tr></table></figure><p><strong>数据操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾部追加数据</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::append</span><span class="params">(<span class="type">const</span> QString &amp;str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::append</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::push_back</span><span class="params">(<span class="type">const</span> QString &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头部添加数据</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::prepend</span><span class="params">(<span class="type">const</span> QString &amp;str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::prepend</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::prepend</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::push_front</span><span class="params">(<span class="type">const</span> QString &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据, 将 str 插入到字符串第 position 个字符的位置(从0开始)</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::insert</span><span class="params">(<span class="type">int</span> position, <span class="type">const</span> QString &amp;str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::insert</span><span class="params">(<span class="type">int</span> position, <span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::insert</span><span class="params">(<span class="type">int</span> position, <span class="type">const</span> QByteArray &amp;str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="comment">// 从大字符串中删除len个字符, 从第pos个字符的位置开始删除</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::remove</span><span class="params">(<span class="type">int</span> position, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串的尾部删除 n 个字符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::chop</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 从字节串的 position 位置将字符串截断 (前边部分留下, 后边部分被删除)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::truncate</span><span class="params">(<span class="type">int</span> position)</span></span>;</span><br><span class="line"><span class="comment">// 将对象中的数据清空, 使其为null</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换</span></span><br><span class="line"><span class="comment">// 将字节数组中的 子字符串 before 替换为 after</span></span><br><span class="line"><span class="comment">// 参数 cs 为是否区分大小写, 默认区分大小写</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::replace</span><span class="params">(<span class="type">const</span> QString &amp;before, <span class="type">const</span> QString &amp;after, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>子字符串查找和判断</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 cs 为是否区分大小写, 默认区分大小写</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串中是否包含子字符串 str, 包含返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QString::contains</span><span class="params">(<span class="type">const</span> QString &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串是否以字符串 ba 开始, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QString::startsWith</span><span class="params">(<span class="type">const</span> QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串是否以字符串 ba 结尾, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QString::endsWith</span><span class="params">(<span class="type">const</span> QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong>遍历</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">QString::begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">QString::end</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组的方式进行遍历</span></span><br><span class="line"><span class="comment">// i的取值范围 0 &lt;= position &lt; size()</span></span><br><span class="line"><span class="function"><span class="type">const</span> QChar <span class="title">QString::at</span><span class="params">(<span class="type">int</span> position)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> QChar QString::<span class="keyword">operator</span>[]<span class="params">(<span class="type">int</span> position)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong>查看字节数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字节数组对象中字符的个数 (字符个数和字节个数是不同的概念)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字节串对象中 子字符串 str 出现的次数</span></span><br><span class="line"><span class="comment">// 参数 cs 为是否区分大小写, 默认区分大小写</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::count</span><span class="params">(<span class="type">const</span> QStringRef &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong>类型转换</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将int, short, long, float, double 转换为 QString 类型</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">short</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">float</span> n, <span class="type">char</span> format = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> precision = <span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> format = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> precision = <span class="number">6</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::number</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::number</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::number</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> format = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> precision = <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 QString 转换为 int, short, long, float, double 类型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::toInt</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">QString::toShort</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">QString::toLong</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">QString::toFloat</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">QString::toDouble</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将标准C++中的 std::string 类型 转换为 QString 类型</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::fromStdString</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span>;</span><br><span class="line"><span class="comment">// 将 QString 转换为 标准C++中的 std::string 类型</span></span><br><span class="line"><span class="function">std::string <span class="title">QString::toStdString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QString -&gt; QByteArray</span></span><br><span class="line"><span class="comment">// 转换为本地编码, 跟随操作系统</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QString::toLocal8Bit</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 转换为 Latin-1 编码的字符串 不支持中文</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QString::toLatin1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 转换为 utf8 编码格式的字符串 (常用)</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QString::toUtf8</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有字符转换为大写</span></span><br><span class="line"><span class="function">QString <span class="title">QString::toUpper</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 所有字符转换为小写</span></span><br><span class="line"><span class="function">QString <span class="title">QString::toLower</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong>字符串格式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString <span class="title">QString::arg</span><span class="params">(<span class="type">const</span> QString &amp;a, </span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">int</span> fieldWidth = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">          QChar fillChar = QLatin1Char( <span class="string">&#x27; &#x27;</span> ))</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QString <span class="title">QString::arg</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> fieldWidth = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">int</span> base = <span class="number">10</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">          QChar fillChar = QLatin1Char( <span class="string">&#x27; &#x27;</span> ))</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例程序</span></span><br><span class="line"><span class="type">int</span> i;                <span class="comment">// 假设该变量表示当前文件的编号</span></span><br><span class="line"><span class="type">int</span> total;            <span class="comment">// 假设该变量表示文件的总个数</span></span><br><span class="line">QString fileName;     <span class="comment">// 假设该变量表示当前文件的名字</span></span><br><span class="line"><span class="comment">// 使用以上三个变量拼接一个动态字符串</span></span><br><span class="line">QString status = <span class="built_in">QString</span>(<span class="string">&quot;Processing file %1 of %2: %3&quot;</span>)</span><br><span class="line">                  .<span class="built_in">arg</span>(i).<span class="built_in">arg</span>(total).<span class="built_in">arg</span>(fileName);</span><br></pre></td></tr></table></figure><hr><h2 id="2-4-QVariant"><a href="#2-4-QVariant" class="headerlink" title="2.4 QVariant"></a>2.4 QVariant</h2><blockquote><p>QVariant这个类很神奇，或者说方便。很多时候，需要几种不同的数据类型需要传递，如果用结构体，又不大方便，容器保存的也只是一种数据类型，而QVariant则可以统统搞定。<br>QVariant 这个类型充当着最常见的数据类型的联合。QVariant可以保存很多Qt的数据类型，包括<code>QBrush、QColor、QCursor、QDateTime、QFont、QKeySequence、QPalette、QPen、QPixmap、QPoint、QRect、QRegion、QSize和QString</code>，并且还有C++基本类型，如<code>int、float</code>等。</p></blockquote><h3 id="2-4-1-标准类型"><a href="#2-4-1-标准类型" class="headerlink" title="2.4.1 标准类型"></a>2.4.1 标准类型</h3><ul><li>将标准类型转换为QVariant类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这类转换需要使用QVariant类的构造函数, 由于比较多, 大家可自行查阅Qt帮助文档, 在这里简单写几个</span></span><br><span class="line">QVariant::<span class="built_in">QVariant</span>(<span class="type">int</span> val);</span><br><span class="line">QVariant::<span class="built_in">QVariant</span>(<span class="type">bool</span> val);</span><br><span class="line">QVariant::<span class="built_in">QVariant</span>(<span class="type">double</span> val);</span><br><span class="line">QVariant::<span class="built_in">QVariant</span>(<span class="type">const</span> <span class="type">char</span> *val);</span><br><span class="line">QVariant::<span class="built_in">QVariant</span>(<span class="type">const</span> QByteArray &amp;val);</span><br><span class="line">QVariant::<span class="built_in">QVariant</span>(<span class="type">const</span> QString &amp;val);</span><br><span class="line">......</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用设置函数也可以将支持的类型的数据设置到QVariant对象中</span></span><br><span class="line"><span class="comment">// 这里的 T 类型, 就是QVariant支持的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QVariant::setValue</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span>;</span><br><span class="line"><span class="comment">// 该函数行为和 setValue() 函数完全相同</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QVariant <span class="title">QVariant::fromValue</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span>;</span><br><span class="line"><span class="comment">// 例子:</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">QVariant v;</span><br><span class="line">v.<span class="built_in">setValue</span>(<span class="number">5</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">QVariant v = QVariant::<span class="built_in">fromValue</span>(<span class="number">5</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = v.<span class="built_in">toInt</span>();          <span class="comment">// i is now 5</span></span><br><span class="line">QString s = v.<span class="built_in">toString</span>();   <span class="comment">// s is now &quot;5&quot;</span></span><br></pre></td></tr></table></figure><ul><li>判断 QVariant中封装的实际数据类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数的返回值是一个枚举类型, 可通过这个枚举判断出实际是什么类型的数据</span></span><br><span class="line"><span class="function">Type <span class="title">QVariant::type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>返回值Type的部分枚举定义, 全部信息可查阅Qt帮助文档</p></blockquote><p><img src="/img/9.5n.png" alt="在这里插入图片描述"></p><ul><li>将QVariant对象转换为实际的数据类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果要实现该操作, 可以使用QVariant类提供的 toxxx() 方法, 全部转换可以参考Qt帮助文档</span></span><br><span class="line"><span class="comment">// 在此举列举几个常用函数:</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QVariant::toBool</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QByteArray <span class="title">QVariant::toByteArray</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">QVariant::toDouble</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">QVariant::toFloat</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QVariant::toInt</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QString <span class="title">QVariant::toString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><hr><h3 id="2-4-2-自定义类型"><a href="#2-4-2-自定义类型" class="headerlink" title="2.4.2 自定义类型"></a>2.4.2 自定义类型</h3><blockquote><p>除标准类型, 自定义的类型也可以使用<code>QVariant</code>类进行封装,<code>被QVariant存储的数据类型需有一个默认的构造函数和一个拷贝构造函数</code>。为实现此功能，首先必须使用<code>Q_DECLARE_METATYPE()</code>宏。<br>通常会将这个宏放在类的声明所在头文件的下面，原型为<br><code>Q_DECLARE_METATYPE(Type)</code></p></blockquote><p>使用步骤如下:</p><ul><li>第一步: 在头文件中声明</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    QString name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 自定义类型注册</span></span><br><span class="line"><span class="built_in">Q_DECLARE_METATYPE</span>(MyTest)</span><br></pre></td></tr></table></figure><ul><li>第二步: 在源文件中定义</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MyTest t;</span><br><span class="line">t.name = <span class="string">&quot;张三丰&quot;</span>;</span><br><span class="line">t.num = <span class="number">666</span>;</span><br><span class="line"><span class="comment">// 值的封装</span></span><br><span class="line">QVariant vt = QVariant::<span class="built_in">fromValue</span>(t);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值的读取</span></span><br><span class="line"><span class="keyword">if</span>(vt.<span class="built_in">canConvert</span>&lt;MyTest&gt;())</span><br><span class="line">&#123;</span><br><span class="line">    MyTest t = vt.<span class="built_in">value</span>&lt;MyTest&gt;();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; t.name &lt;&lt; <span class="string">&quot;, num: &quot;</span> &lt;&lt; t.num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上操作用到的<code>QVariant</code>类的API如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果当前QVariant对象可用转换为对应的模板类型 T, 返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QVariant::canConvert</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 将当前QVariant对象转换为实际的 T 类型</span></span><br><span class="line"><span class="function">T <span class="title">QVariant::value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="2-5-位置和尺寸"><a href="#2-5-位置和尺寸" class="headerlink" title="2.5 位置和尺寸"></a>2.5 位置和尺寸</h2><h3 id="2-5-1-QPoint"><a href="#2-5-1-QPoint" class="headerlink" title="2.5.1 QPoint"></a>2.5.1 QPoint</h3><blockquote><p>QPoint类封装了我们常用用到的坐标点 (x, y), 常用的 API如下:</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 构造一个坐标原点, 即(0, 0)</span></span><br><span class="line">QPoint::<span class="built_in">QPoint</span>();</span><br><span class="line"><span class="comment">// 参数为 x轴坐标, y轴坐标</span></span><br><span class="line">QPoint::<span class="built_in">QPoint</span>(<span class="type">int</span> xpos, <span class="type">int</span> ypos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置x轴坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPoint::setX</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">// 设置y轴坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPoint::setY</span><span class="params">(<span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到x轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QPoint::x</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到x轴坐标的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QPoint::rx</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 得到y轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QPoint::y</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到y轴坐标的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QPoint::ry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接通过坐标对象进行算术运算: 加减乘除</span></span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>*=(<span class="type">float</span> factor);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>*=(<span class="type">double</span> factor);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>*=(<span class="type">int</span> factor);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>+=(<span class="type">const</span> QPoint &amp;point);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>-=(<span class="type">const</span> QPoint &amp;point);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>/=(qreal divisor);</span><br></pre></td></tr></table></figure><hr><h3 id="2-5-2-QLine"><a href="#2-5-2-QLine" class="headerlink" title="2.5.2 QLine"></a>2.5.2 QLine</h3><blockquote><p>QLine是一个直线类, 封装了两个坐标点 (两点确定一条直线)</p></blockquote><p>常用API如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 构造一个空对象</span></span><br><span class="line">QLine::<span class="built_in">QLine</span>();</span><br><span class="line"><span class="comment">// 构造一条直线, 通过两个坐标点</span></span><br><span class="line">QLine::<span class="built_in">QLine</span>(<span class="type">const</span> QPoint &amp;p1, <span class="type">const</span> QPoint &amp;p2);</span><br><span class="line"><span class="comment">// 从点 (x1, y1) 到 (x2, y2)</span></span><br><span class="line">QLine::<span class="built_in">QLine</span>(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给直线对象设置坐标点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setPoints</span><span class="params">(<span class="type">const</span> QPoint &amp;p1, <span class="type">const</span> QPoint &amp;p2)</span></span>;</span><br><span class="line"><span class="comment">// 起始点(x1, y1), 终点(x2, y2)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setLine</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span>;</span><br><span class="line"><span class="comment">// 设置直线的起点坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setP1</span><span class="params">(<span class="type">const</span> QPoint &amp;p1)</span></span>;</span><br><span class="line"><span class="comment">// 设置直线的终点坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setP2</span><span class="params">(<span class="type">const</span> QPoint &amp;p2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回直线的起始点坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QLine::p1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回直线的终点坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QLine::p2</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值直线的中心点坐标, (p1() + p2()) / 2</span></span><br><span class="line"><span class="function">QPoint <span class="title">QLine::center</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值直线起点的 x 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::x1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值直线终点的 x 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::x2</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值直线起点的 y 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::y1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值直线终点的 y 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::y2</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用给定的坐标点平移这条直线</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::translate</span><span class="params">(<span class="type">const</span> QPoint &amp;offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::translate</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy)</span></span>;</span><br><span class="line"><span class="comment">// 用给定的坐标点平移这条直线, 返回平移之后的坐标点</span></span><br><span class="line"><span class="function">QLine <span class="title">QLine::translated</span><span class="params">(<span class="type">const</span> QPoint &amp;offset)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QLine <span class="title">QLine::translated</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直线对象进行比较</span></span><br><span class="line"><span class="type">bool</span> QLine::<span class="keyword">operator</span>!=(<span class="type">const</span> QLine &amp;line) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QLine::<span class="keyword">operator</span>==(<span class="type">const</span> QLine &amp;line) <span class="type">const</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-5-3-QSize"><a href="#2-5-3-QSize" class="headerlink" title="2.5.3 QSize"></a>2.5.3 QSize</h3><blockquote><p>在QT中QSize类用来形容长度和宽度</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 构造空对象, 对象中的宽和高都是无效的</span></span><br><span class="line">QSize::<span class="built_in">QSize</span>();</span><br><span class="line"><span class="comment">// 使用宽和高构造一个有效对象</span></span><br><span class="line">QSize::<span class="built_in">QSize</span>(<span class="type">int</span> width, <span class="type">int</span> height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSize::setWidth</span><span class="params">(<span class="type">int</span> width)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置高度</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSize::setHeight</span><span class="params">(<span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QSize::width</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到宽度的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QSize::rwidth</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 得到高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QSize::height</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到高度的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QSize::rheight</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换高度和宽度的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSize::transpose</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 交换高度和宽度的值, 返回交换之后的尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">QSize::transposed</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行算法运算: 加减乘除</span></span><br><span class="line">QSize &amp;QSize::<span class="keyword">operator</span>*=(qreal factor);</span><br><span class="line">QSize &amp;QSize::<span class="keyword">operator</span>+=(<span class="type">const</span> QSize &amp;size);</span><br><span class="line">QSize &amp;QSize::<span class="keyword">operator</span>-=(<span class="type">const</span> QSize &amp;size);</span><br><span class="line">QSize &amp;QSize::<span class="keyword">operator</span>/=(qreal divisor);</span><br></pre></td></tr></table></figure><hr><h3 id="2-5-4-QRect"><a href="#2-5-4-QRect" class="headerlink" title="2.5.4 QRect"></a>2.5.4 QRect</h3><blockquote><p>在Qt中使用 QRect类来描述一个矩形</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 构造一个空对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>();</span><br><span class="line"><span class="comment">// 基于左上角坐标, 和右下角坐标构造一个矩形对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>(<span class="type">const</span> QPoint &amp;topLeft, <span class="type">const</span> QPoint &amp;bottomRight);</span><br><span class="line"><span class="comment">// 基于左上角坐标, 和 宽度, 高度构造一个矩形对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>(<span class="type">const</span> QPoint &amp;topLeft, <span class="type">const</span> QSize &amp;size);</span><br><span class="line"><span class="comment">// 通过 左上角坐标(x, y), 和 矩形尺寸(width, height) 构造一个矩形对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置矩形的尺寸信息, 左上角坐标不变</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setSize</span><span class="params">(<span class="type">const</span> QSize &amp;size)</span></span>;</span><br><span class="line"><span class="comment">// 设置矩形左上角坐标为(x,y), 大小为(width, height)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="comment">// 设置矩形宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setWidth</span><span class="params">(<span class="type">int</span> width)</span></span>;</span><br><span class="line"><span class="comment">// 设置矩形高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setHeight</span><span class="params">(<span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值矩形左上角坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::topLeft</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形右上角坐标</span></span><br><span class="line"><span class="comment">// 该坐标点值为: QPoint(left() + width() -1, top())</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::topRight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形左下角坐标</span></span><br><span class="line"><span class="comment">// 该坐标点值为: QPoint(left(), top() + height() - 1)</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::bottomLeft</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形右下角坐标</span></span><br><span class="line"><span class="comment">// 该坐标点值为: QPoint(left() + width() -1, top() + height() - 1)</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::bottomRight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形中心点坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::center</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回矩形上边缘y轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::top</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::y</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值矩形下边缘y轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::bottom</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形左边缘 x轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::x</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::left</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形右边缘x轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::right</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回矩形的高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::width</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形的宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::height</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形的尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">QRect::size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="2-6-日期和时间"><a href="#2-6-日期和时间" class="headerlink" title="2.6 日期和时间"></a>2.6 日期和时间</h2><h3 id="2-6-1-QDate"><a href="#2-6-1-QDate" class="headerlink" title="2.6.1 QDate"></a>2.6.1 QDate</h3><blockquote><p>QDate类可以封装日期信息也可以通过这个类得到日期相关的信息, 包括:<code>年, 月, 日</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QDate::<span class="built_in">QDate</span>();</span><br><span class="line">QDate::<span class="built_in">QDate</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 重新设置日期对象中的日期</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QDate::setDate</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span>;</span><br><span class="line"><span class="comment">// 给日期对象添加 ndays 天</span></span><br><span class="line"><span class="function">QDate <span class="title">QDate::addDays</span><span class="params">(qint64 ndays)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给日期对象添加 nmonths 月</span></span><br><span class="line"><span class="function">QDate <span class="title">QDate::addMonths</span><span class="params">(<span class="type">int</span> nmonths)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给日期对象添加 nyears 月</span></span><br><span class="line"><span class="function">QDate <span class="title">QDate::addYears</span><span class="params">(<span class="type">int</span> nyears)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到日期对象中的年/月/日</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QDate::year</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QDate::month</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QDate::day</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDate::getDate</span><span class="params">(<span class="type">int</span> *year, <span class="type">int</span> *month, <span class="type">int</span> *day)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期对象格式化</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    d    - The day as a number without a leading zero (1 to 31)</span></span><br><span class="line"><span class="comment">    dd   - The day as a number with a leading zero (01 to 31)</span></span><br><span class="line"><span class="comment">    ddd - The abbreviated localized day name (e.g. &#x27;Mon&#x27; to &#x27;Sun&#x27;). Uses the system locale to localize the name, i.e. QLocale::system().</span></span><br><span class="line"><span class="comment">    dddd - The long localized day name (e.g. &#x27;Monday&#x27; to &#x27;Sunday&#x27;). Uses the system locale to localize the name, i.e. QLocale::system().</span></span><br><span class="line"><span class="comment">    M    - The month as a number without a leading zero (1 to 12)</span></span><br><span class="line"><span class="comment">    MM   - The month as a number with a leading zero (01 to 12)</span></span><br><span class="line"><span class="comment">    MMM - The abbreviated localized month name (e.g. &#x27;Jan&#x27; to &#x27;Dec&#x27;). Uses the system locale to localize the name, i.e. QLocale::system().</span></span><br><span class="line"><span class="comment">    MMMM - The long localized month name (e.g. &#x27;January&#x27; to &#x27;December&#x27;). Uses the system locale to localize the name, i.e. QLocale::system().</span></span><br><span class="line"><span class="comment">    yy   - The year as a two digit number (00 to 99)</span></span><br><span class="line"><span class="comment">    yyyy - The year as a four digit number. If the year is negative, a minus sign is prepended, making five characters.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">QString <span class="title">QDate::toString</span><span class="params">(<span class="type">const</span> QString &amp;format)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符重载 ==&gt; 日期比较</span></span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>!=(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>&lt;(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="built_in">operator</span>&lt;=(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>==(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>&gt;(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态函数 -&gt; 得到本地的当前日期</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QDate <span class="title">QDate::currentDate</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-6-2-QTime"><a href="#2-6-2-QTime" class="headerlink" title="2.6.2 QTime"></a>2.6.2 QTime</h3><blockquote><p>QTime类可以封装时间信息也可以通过这个类得到时间相关的信息, 包括:<code>时, 分, 秒, 毫秒</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QTime::<span class="built_in">QTime</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    h ==&gt; 取值范围： 0 ~ 23</span></span><br><span class="line"><span class="comment">    m and s ==&gt; 取值范围： 0 ~ 59</span></span><br><span class="line"><span class="comment">    ms ==&gt; 取值范围： 0 ~ 999</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">QTime::<span class="built_in">QTime</span>(<span class="type">int</span> h, <span class="type">int</span> m, <span class="type">int</span> s = <span class="number">0</span>, <span class="type">int</span> ms = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// Returns true if the set time is valid; otherwise returns false.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTime::setHMS</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> m, <span class="type">int</span> s, <span class="type">int</span> ms = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">QTime <span class="title">QTime::addSecs</span><span class="params">(<span class="type">int</span> s)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QTime <span class="title">QTime::addMSecs</span><span class="params">(<span class="type">int</span> ms)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line">  <span class="function">QTime <span class="title">n</span><span class="params">(<span class="number">14</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;                <span class="comment">// n == 14:00:00</span></span><br><span class="line">  QTime t;</span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">70</span>);                <span class="comment">// t == 14:01:10</span></span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">-70</span>);               <span class="comment">// t == 13:58:50</span></span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">10</span> * <span class="number">60</span> * <span class="number">60</span> + <span class="number">5</span>);  <span class="comment">// t == 00:00:05</span></span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">-15</span> * <span class="number">60</span> * <span class="number">60</span>);     <span class="comment">// t == 23:00:00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从时间对象中取出 时/分/秒/毫秒</span></span><br><span class="line"><span class="comment">// Returns the hour part (0 to 23) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::hour</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// Returns the minute part (0 to 59) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::minute</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// Returns the second part (0 to 59) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::second</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// Returns the millisecond part (0 to 999) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::msec</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间格式化</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    -- 时 --</span></span><br><span class="line"><span class="comment">    h==&gt;The hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)</span></span><br><span class="line"><span class="comment">    hh==&gt;The hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)</span></span><br><span class="line"><span class="comment">    H==&gt;The hour without a leading zero (0 to 23, even with AM/PM display)</span></span><br><span class="line"><span class="comment">    HH==&gt;The hour with a leading zero (00 to 23, even with AM/PM display)</span></span><br><span class="line"><span class="comment">    -- 分 --</span></span><br><span class="line"><span class="comment">    m==&gt;The minute without a leading zero (0 to 59)</span></span><br><span class="line"><span class="comment">    mm==&gt;The minute with a leading zero (00 to 59)</span></span><br><span class="line"><span class="comment">    -- 秒 --</span></span><br><span class="line"><span class="comment">    s==&gt;The whole second, without any leading zero (0 to 59)</span></span><br><span class="line"><span class="comment">    ss==&gt;The whole second, with a leading zero where applicable (00 to 59)</span></span><br><span class="line"><span class="comment">    -- 毫秒 --</span></span><br><span class="line"><span class="comment">    zzz==&gt;The fractional part of the second, to millisecond precision, </span></span><br><span class="line"><span class="comment">including trailing zeroes where applicable (000 to 999).</span></span><br><span class="line"><span class="comment">    -- 上午或者下午</span></span><br><span class="line"><span class="comment">    AP or A==&gt;使用AM/PM(大写) 描述上下午, 中文系统显示汉字</span></span><br><span class="line"><span class="comment">    ap or a==&gt;使用am/pm(小写) 描述上下午, 中文系统显示汉字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">QString <span class="title">QTime::toString</span><span class="params">(<span class="type">const</span> QString &amp;format)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阶段性计时</span></span><br><span class="line"><span class="comment">// 过时的API函数</span></span><br><span class="line"><span class="comment">// 开始计时</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTime::start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 计时结束</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::elapsed</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 重新计时</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::restart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用的API函数</span></span><br><span class="line"><span class="comment">// QElapsedTimer 类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QElapsedTimer::start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">qint64 <span class="title">QElapsedTimer::restart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">qint64 <span class="title">QElapsedTimer::elapsed</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符重载 ==&gt; 时间比较</span></span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>!=(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>&lt;(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="built_in">operator</span>&lt;=(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>==(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>&gt;(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态函数 -&gt; 得到当前时间</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QTime <span class="title">QTime::currentTime</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-6-3-QDateTime"><a href="#2-6-3-QDateTime" class="headerlink" title="2.6.3 QDateTime"></a>2.6.3 QDateTime</h3><blockquote><p>QDateTime类可以封装日期和时间信息也可以通过这个类得到日期和时间相关的信息, 包括:<code>年, 月, 日, 时, 分, 秒,毫秒</code>。<br>其实这个类就是<code>QDate</code> 和 <code>QTime</code> 这两个类的结合体。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QDateTime::<span class="built_in">QDateTime</span>();</span><br><span class="line">QDateTime::<span class="built_in">QDateTime</span>(<span class="type">const</span> QDate &amp;date, <span class="type">const</span> QTime &amp;time, Qt::TimeSpec spec = Qt::LocalTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 设置日期</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDateTime::setDate</span><span class="params">(<span class="type">const</span> QDate &amp;date)</span></span>;</span><br><span class="line"><span class="comment">// 设置时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDateTime::setTime</span><span class="params">(<span class="type">const</span> QTime &amp;time)</span></span>;</span><br><span class="line"><span class="comment">// 给当前日期对象追加 年/月/日/秒/毫秒, 参数可以是负数</span></span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addYears</span><span class="params">(<span class="type">int</span> nyears)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addMonths</span><span class="params">(<span class="type">int</span> nmonths)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addDays</span><span class="params">(qint64 ndays)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addSecs</span><span class="params">(qint64 s)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addMSecs</span><span class="params">(qint64 msecs)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到对象中的日期</span></span><br><span class="line"><span class="function">QDate <span class="title">QDateTime::date</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到对象中的时间</span></span><br><span class="line"><span class="function">QTime <span class="title">QDateTime::time</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期和时间格式, 格式字符参考QDate 和 QTime 类的 toString() 函数</span></span><br><span class="line"><span class="function">QString <span class="title">QDateTime::toString</span><span class="params">(<span class="type">const</span> QString &amp;format)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符重载 ==&gt; 日期时间对象的比较</span></span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>!=(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>&lt;(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="built_in">operator</span>&lt;=(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>==(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>&gt;(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态函数</span></span><br><span class="line"><span class="comment">// 得到当前时区的日期和时间(本地设置的时区对应的日期和时间)</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QDateTime <span class="title">QDateTime::currentDateTime</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-6-4-定时器类QTimer"><a href="#2-6-4-定时器类QTimer" class="headerlink" title="2.6.4 定时器类QTimer"></a>2.6.4 定时器类QTimer</h3><p>在进行窗口程序的处理过程中, 经常要周期性的执行某些操作, 或者制作一些动画效果，看似比较复杂的问题使用定时器就可以完美的解决这些问题<br>Qt中提供了定时器方式,介绍一下Qt中的定时器类 <code>QTimer</code> 的使用方法。</p><p>要使用它，只需创建一个QTimer类对象，然后调用其 <code>start()</code> 函数开启定时器，此后QTimer对象就会周期性的发出 <code>timeout()</code> 信号。我们先来了解一下这个类的相关API。</p><h4 id="2-6-4-1-public-slot-function"><a href="#2-6-4-1-public-slot-function" class="headerlink" title="2.6.4.1 public&#x2F;slot function"></a>2.6.4.1 public&#x2F;slot function</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 如果指定了父对象, 创建的堆内存可以自动析构</span></span><br><span class="line">QTimer::<span class="built_in">QTimer</span>(QObject *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置定时器时间间隔为 msec 毫秒</span></span><br><span class="line"><span class="comment">// 默认值是0，一旦窗口系统事件队列中的所有事件都已经被处理完，一个时间间隔为0的QTimer就会触发</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::setInterval</span><span class="params">(<span class="type">int</span> msec)</span></span>;</span><br><span class="line"><span class="comment">// 获取定时器的时间间隔, 返回值单位: 毫秒</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTimer::interval</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定的时间间隔启动或者重启定时器, 需要调用 setInterval() 设置时间间隔</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QTimer::start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 启动或重新启动定时器，超时间隔为msec毫秒。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QTimer::start</span><span class="params">(<span class="type">int</span> msec)</span></span>;</span><br><span class="line"><span class="comment">// 停止定时器。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QTimer::stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置定时器精度</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数: </span></span><br><span class="line"><span class="comment">    - Qt::PreciseTimer -&gt; 精确的精度, 毫秒级</span></span><br><span class="line"><span class="comment">    - Qt::CoarseTimer  -&gt; 粗糙的精度, 和1毫秒的误差在5%的范围内, 默认精度</span></span><br><span class="line"><span class="comment">    - Qt::VeryCoarseTimer -&gt; 非常粗糙的精度, 精度在1秒左右</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::setTimerType</span><span class="params">(Qt::TimerType atype)</span></span>;</span><br><span class="line"><span class="function">Qt::TimerType <span class="title">QTimer::timerType</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">// 获取当前定时器的精度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果定时器正在运行，返回true; 否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTimer::isActive</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断定时器是否只触发一次</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTimer::isSingleShot</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置定时器是否只触发一次, 参数为true定时器只触发一次, 为false定时器重复触发, 默认为false</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::setSingleShot</span><span class="params">(<span class="type">bool</span> singleShot)</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="2-6-4-2-signals"><a href="#2-6-4-2-signals" class="headerlink" title="2.6.4.2 signals"></a>2.6.4.2 signals</h4><p>这个类的信号只有一个, 当定时器超时时，该信号就会被发射出来。<br>给这个信号通过<code>conect()</code>关联一个槽函数, 就可以在槽函数中处理超时事件了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QTimer::timeout</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="2-6-4-3-static-public-function"><a href="#2-6-4-3-static-public-function" class="headerlink" title="2.6.4.3 static public function"></a>2.6.4.3 static public function</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其他同名重载函数可以自己查阅帮助文档</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能: 在msec毫秒后发射一次信号, 并且只发射一次</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">- msec:     在msec毫秒后发射信号</span></span><br><span class="line"><span class="comment">- receiver: 接收信号的对象地址</span></span><br><span class="line"><span class="comment">- method:   槽函数地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QTimer::singleShot</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> msec, <span class="type">const</span> QObject *receiver, </span></span></span><br><span class="line"><span class="params"><span class="function">        PointerToMemberFunction method)</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="2-6-4-4-定时器使用举例"><a href="#2-6-4-4-定时器使用举例" class="headerlink" title="2.6.4.4 定时器使用举例"></a>2.6.4.4 定时器使用举例</h4><ul><li>周期性定时器</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建定时器对象</span></span><br><span class="line">QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改定时器对象的精度</span></span><br><span class="line">timer-&gt;<span class="built_in">setTimerType</span>(Qt::PreciseTimer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮 loopBtn 的点击事件</span></span><br><span class="line"><span class="comment">// 点击按钮启动或者关闭定时器, 定时器启动, 周期性得到当前时间</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;loopBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 启动定时器</span></span><br><span class="line">    <span class="keyword">if</span>(timer-&gt;<span class="built_in">isActive</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        timer-&gt;<span class="built_in">stop</span>();  <span class="comment">// 关闭定时器</span></span><br><span class="line">        ui-&gt;loopBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;loopBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;关闭&quot;</span>);</span><br><span class="line">        timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>); <span class="comment">// 1000ms == 1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, [=]()</span><br><span class="line">&#123;</span><br><span class="line">    QTime tm = QTime::<span class="built_in">currentTime</span>();</span><br><span class="line">    <span class="comment">// 格式化当前得到的系统时间</span></span><br><span class="line">    QString tmstr = tm.<span class="built_in">toString</span>(<span class="string">&quot;hh:mm:ss.zzz&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置要显示的时间</span></span><br><span class="line">    ui-&gt;curTime-&gt;<span class="built_in">setText</span>(tmstr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>一次性定时器</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击按钮 onceBtn 只发射一次信号</span></span><br><span class="line"><span class="comment">// 点击按钮一次, 发射一个信号, 得到某一个时间点的时间</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;onceBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 获取2s以后的系统时间, 不创建定时器对象, 直接使用类的静态方法</span></span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">2000</span>, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        QTime tm = QTime::<span class="built_in">currentTime</span>();</span><br><span class="line">        <span class="comment">// 格式化当前得到的系统时间</span></span><br><span class="line">        QString tmstr = tm.<span class="built_in">toString</span>(<span class="string">&quot;hh:mm:ss.zzz&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置要显示的时间</span></span><br><span class="line">        ui-&gt;onceTime-&gt;<span class="built_in">setText</span>(tmstr);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h1 id="3-信号槽"><a href="#3-信号槽" class="headerlink" title="3. 信号槽"></a>3. 信号槽</h1><p>介绍Qt中的信号槽, 主要内容包括: <code>信号槽的本质</code>, <code>信号槽的关系</code>, <code>标准信号槽的使用</code>, <code>自定义信号槽的使用</code>, <code>信号槽的拓展</code> 。 </p><h2 id="3-1-信号和槽概述"><a href="#3-1-信号和槽概述" class="headerlink" title="3.1 信号和槽概述"></a>3.1 信号和槽概述</h2><blockquote><p>信号槽是 Qt框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式(发布-订阅模式)。<br>当某个<code>事件</code>发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。<br>如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。<br>也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。</p></blockquote><h3 id="3-1-1-信号的本质"><a href="#3-1-1-信号的本质" class="headerlink" title="3.1.1 信号的本质"></a>3.1.1 信号的本质</h3><blockquote><p>信号是由于用户对窗口或控件进行了某些操作，导致窗口或控件产生了某个特定事件，这时候Qt对应的窗口类会发出某个信号，以此对用户的挑选做出反应。</p></blockquote><p>因此根据上述的描述我们得到一个结论 – <code>信号的本质就是事件</code>，比如：</p><ul><li><p>按钮单击、双击</p></li><li><p>窗口刷新</p></li><li><p>鼠标移动、鼠标按下、鼠标释放</p></li><li><p>键盘输入</p></li></ul><p>那么在Qt中信号是通过什么形式呈现给使用者的呢？</p><ul><li>我们对哪个窗口进行操作, 哪个窗口就可以捕捉到这些被触发的事件。</li><li>对于使用者来说触发了一个事件我们就可以得到Qt框架给我们发出的某个特定信号。</li><li><code>信号的呈现形式就是函数</code>， 也就是说某个事件产生了， Qt框架就会调用某个对应的信号函数， 通知使用者。</li></ul><p><code>在QT中信号的发出者是某个实例化的类对象，对象内部可以进行相关事件的检测。</code></p><hr><h3 id="3-1-2-槽的本质"><a href="#3-1-2-槽的本质" class="headerlink" title="3.1.2 槽的本质"></a>3.1.2 槽的本质</h3><p>在Qt中槽函数是一类特殊的功能的函数，在编码过程中也可以作为类的普通成员函数来使用。<br>之所以称之为槽函数是因为它们还有一个职责就是对Qt框架中产生的信号进行处理。</p><p>在Qt中槽函数的所有者也是某个类的实例对象。</p><hr><h3 id="3-1-3-信号和槽的关系"><a href="#3-1-3-信号和槽的关系" class="headerlink" title="3.1.3 信号和槽的关系"></a>3.1.3 信号和槽的关系</h3><p>在Qt中信号和槽函数都是独立的个体，本身没有任何联系，但是由于某种特性需求我们可以将二者连接到一起。在Qt中我们需要使用<code>QOjbect</code>类中的<code>connect</code>函数进二者的关联。</p><blockquote><p>连接信号和槽的<code>connect()</code>函数原型如下, 其中<code>PointerToMemberFunction</code>是一个指向函数地址的指针</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *sender, PointerToMemberFunction signal, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> QObject *receiver, PointerToMemberFunction method, </span></span></span><br><span class="line"><span class="params"><span class="function">Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br><span class="line">参数:</span><br><span class="line">  - sender:   发出信号的对象</span><br><span class="line">  - signal:   属于sender对象, 信号是一个函数, 这个参数的类型是函数</span><br><span class="line">              指针, 信号函数地址</span><br><span class="line">  - receiver: 信号接收者</span><br><span class="line">  - method:   属于receiver对象, 当检测到sender发出了signal信号, </span><br><span class="line">              receiver对象调用method方法，信号发出之后的处理动作</span><br><span class="line"> </span><br><span class="line"><span class="comment">//  参数 signal 和 method 都是函数地址, 因此简化之后的 connect() 如下:</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="type">const</span> QObject *sender, &amp;QObject::signal, </span><br><span class="line">        <span class="type">const</span> QObject *receiver, &amp;QObject::method);</span><br></pre></td></tr></table></figure><p>使用connect()进行信号槽连接的注意事项:</p><ul><li>connect函数相对于做了信号处理动作的注册</li><li>调用conenct函数的sender对象的信号并没有产生, 因此receiver对象的method也不会被调用</li><li>method槽函数本质是一个回调函数, 调用的时机是信号产生之后, 调用是Qt框架来执行的</li><li>connect中的sender和recever两个指针必须被实例化了, 否则conenct不会成功</li></ul><hr><h2 id="3-2-标准信号槽使用"><a href="#3-2-标准信号槽使用" class="headerlink" title="3.2 标准信号槽使用"></a>3.2 标准信号槽使用</h2><h3 id="3-2-1-标准信号-槽"><a href="#3-2-1-标准信号-槽" class="headerlink" title="3.2.1 标准信号&#x2F;槽"></a>3.2.1 标准信号&#x2F;槽</h3><blockquote><p>在Qt提供的很多标准类中都可以对用户触发的某些特定事件进行检测, 因此当用户做了这些操作之后, 事件被触发类的内部就会产生对应的信号,这些信号都是Qt类内部自带的, 因此称之为标准信号。<br>同样的，在Qt的很多类内部为我了提供了很多功能函数，并且这些函数也可以作为触发的信号的处理动作，有这类特性的函数在Qt中称之为标准槽函数。<br>系统自带的信号和槽通常如何查找呢，这个就需要利用帮助文档了，比如在帮助文档中查询按钮的点击信号，那么需要在帮助文档中输入<code>QPushButton</code><br>首先我们可以在<code>Contents</code>中寻找关键字<code>signals</code>，信号的意思，但是我们发现并没有找到，这时候我们应该看当前类从父类继承下来了哪些信号</p></blockquote><p><img src="/img/9.51.png" alt="在这里插入图片描述"></p><blockquote><p>因此我们去他的父类<code>QAbstractButton</code>中就可以找到该关键字，点击<code>signals</code>索引到系统自带的信号有如下几个</p></blockquote><p><img src="/img/9.52.png" alt="在这里插入图片描述"></p><hr><h3 id="3-2-2-使用"><a href="#3-2-2-使用" class="headerlink" title="3.2.2 使用"></a>3.2.2 使用</h3><blockquote><p>掌握标准信号、槽的查找方式之后以及<code>connect()</code>函数的作用之后, 一个简单的例子了解使用方式。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">功能实现： 点击窗口上的按钮, 关闭窗口</span><br><span class="line">功能分析:</span><br><span class="line">- 按钮: 信号发出者          -&gt; QPushButton 类型</span><br><span class="line">- 窗口: 信号的接收者和处理者  -&gt; QWidget 类型</span><br></pre></td></tr></table></figure><blockquote><p>需要使用的标准信号槽函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单击按钮发出的信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::clicked</span><span class="params">(<span class="type">bool</span> checked = <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 关闭窗口的槽函数</span></span></span><br><span class="line"><span class="function">[slot] <span class="type">bool</span> <span class="title">QWidget::close</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>对于上边的需求只需要一句代码, 只需要写一句代码就能实现了</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单击按钮关闭窗口</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;closewindow, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::close);</span><br></pre></td></tr></table></figure><p><code>connect()操作一般写在窗口的构造函数中, 相当于在事件产生之前在qt框架中先进行注册, 这样在程序运行过程中假设产生了按钮的点击事件, 框架就会调用信号接收者对象对应的槽函数了, 如果信号不产生, 槽函数也就一直不会被调用。</code></p><hr><h2 id="3-3-自定义信号槽使用"><a href="#3-3-自定义信号槽使用" class="headerlink" title="3.3 自定义信号槽使用"></a>3.3 自定义信号槽使用</h2><blockquote><p>Qt框架提供的信号槽在某些特定场景下是无法满足我们的项目需求的，因此我们还设计自己需要的的信号和槽，同样还是使用connect()对自定义的信号槽进行连接。</p></blockquote><p>如果想要在QT类中自定义信号槽, 需要满足一些条件, 并且有些事项也需要注意:</p><ul><li>要编写新的类并且让其继承Qt的某些标准类</li><li>这个新的子类必须从QObject类或者是QObject子类进行派生</li><li>在定义类的头文件中加入 Q_OBJECT 宏</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在头文件派生类的时候，首先像下面那样引入Q_OBJECT宏：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMainWindow</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-3-1-自定义信号"><a href="#3-3-1-自定义信号" class="headerlink" title="3.3.1 自定义信号"></a>3.3.1 自定义信号</h3><blockquote><p>在Qt中信号的本质是事件, 但是在框架中也是以函数的形式存在的, 只不过信号对应的函数只有声明,没有定义。如果Qt中的标准信号不能满足我们的需求，可以在程序中进行信号的自定义，当自定义信号对应的事件产生之后，认为的将这个信号发射出去即可（其实就是调用一下这个信号函数）。</p></blockquote><p>下边给大家阐述一下, 自定义信号的要求和注意事项:</p><ol><li>信号是类的成员函数</li><li>返回值必须是 void 类型</li><li>信号的名字可以根据实际情况进行指定</li><li>参数可以随意指定, 信号也支持重载</li><li>信号需要使用 signals 关键字进行声明, 使用方法类似于public等关键字</li><li>信号函数只需要声明, 不需要定义(没有函数体实现)</li><li>在程序中发射自定义信号: 发送信号的本质就是调用信号函数<ul><li>习惯性在信号函数前加关键字: emit, 但是可以省略不写</li><li>emit只是显示的声明一下信号要被发射了, 没有特殊含义</li><li>底层 emit &#x3D;&#x3D; #define emit</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 举例: 信号重载</span></span><br><span class="line"><span class="comment">// Qt中的类想要使用信号槽机制必须要从QObject类派生(直接或间接派生都可以)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testsignal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 参数的作用是数据传递, 谁调用信号函数谁就指定实参</span></span><br><span class="line"><span class="comment">// 实参最终会被传递给槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testsignal</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="3-3-2-自定义槽"><a href="#3-3-2-自定义槽" class="headerlink" title="3.3.2 自定义槽"></a>3.3.2 自定义槽</h3><blockquote><p>槽函数就是信号的处理动作，在Qt中槽函数可以作为普通的成员函数来使用。如果标准槽函数提供的功能满足不了需求，可以自己定义槽函数进行某些特殊功能的实现。自定义槽函数和自定义的普通函数写法是一样的。</p></blockquote><p>下边给大家阐述一下, 自定义槽的要求和注意事项:</p><ol><li><p>返回值必须是 void 类型</p></li><li><p>槽也是函数, 因此也支持重载</p></li><li><p>槽函数需要指定多少个参数, 需要看连接的信号的参数个数</p></li><li><p>槽函数的参数是用来接收信号传递的数据的, 信号传递的数据就是信号的参数</p><ul><li>举例:<ul><li>信号函数: void testsig(int a, double b);</li><li>槽函数: void testslot(int a, double b);</li></ul></li><li>总结:<ul><li>槽函数的参数应该和对应的信号的参数个数, 从左到右类型依次对应</li><li>信号的参数可以大于等于槽函数的参数个数 &#x3D;&#x3D; 信号传递的数据被忽略了<ul><li>信号函数: void testsig(int a, double b);</li><li>槽函数: void testslot(int a);</li></ul></li></ul></li></ul></li><li><p>Qt中槽函数的类型是多样的<br>Qt中的槽函数可以是类的成员函数、全局函数、静态函数、Lambda表达式（匿名函数）</p></li><li><p>槽函数可以使用关键字进行声明: slots (Qt5中slots可以省略不写)</p></li></ol><ul><li>public slots:</li><li>private slots: –&gt; 这样的槽函数不能在类外部被调用</li><li>protected slots: –&gt; 这样的槽函数不能在类外部被调用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 槽函数书写格式举例</span></span><br><span class="line"><span class="comment">// 类中的这三个函数都可以作为槽函数来使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testSlot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">testFunc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testSlot</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​</p><blockquote><p>根据特定场景自定义信号槽:</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class GirlFriend</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GirlFriend</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hungry</span><span class="params">()</span></span>;            <span class="comment">// 不能表达出想要吃什么</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hungry</span><span class="params">(QString msg)</span></span>;<span class="comment">// 可以通过参数表达想要吃什么</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class Me</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Me</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Me</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="comment">// 槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eatMeal</span><span class="params">()</span></span>;             <span class="comment">// 不能知道信号发出者要吃什么</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eatMeal</span><span class="params">(QString msg)</span></span>;  <span class="comment">// 可以知道信号发出者要吃什么</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-4-信号槽拓展"><a href="#3-4-信号槽拓展" class="headerlink" title="3.4 信号槽拓展"></a>3.4 信号槽拓展</h2><h3 id="3-4-1-信号槽使用拓展"><a href="#3-4-1-信号槽使用拓展" class="headerlink" title="3.4.1 信号槽使用拓展"></a>3.4.1 信号槽使用拓展</h3><ul><li>一个信号可以连接多个槽函数, 发送一个信号有多个处理动作<ul><li>需要写多个connect（）连接</li><li>槽函数的执行顺序是随机的, 和connect函数的调用顺序没有关系</li><li>信号的接收者可以是一个对象, 也可以是多个对象</li></ul></li><li>一个槽函数可以连接多个信号, 多个不同的信号, 处理动作是相同的<ul><li>需要写多个connect（）连接</li></ul></li><li>信号可以连接信号</li></ul><blockquote><p>信号接收者可不处理接收的信号, 而是继续发射新的信号，这相当于传递了数据, 并没有对数据进行处理</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(<span class="type">const</span> QObject *sender, &amp;QObject::signal, </span><br><span class="line">        <span class="type">const</span> QObject *receiver, &amp;QObject::siganl-<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><ul><li>信号槽是可以断开的</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(<span class="type">const</span> QObject *sender, &amp;QObject::signal, </span><br><span class="line">        <span class="type">const</span> QObject *receiver, &amp;QObject::method);</span><br></pre></td></tr></table></figure><hr><h3 id="3-4-2-信号槽的连接方式"><a href="#3-4-2-信号槽的连接方式" class="headerlink" title="3.4.2 信号槽的连接方式"></a>3.4.2 信号槽的连接方式</h3><ul><li>Qt5的连接方式</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法:</span></span><br><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *sender, PointerToMemberFunction signal, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> QObject *receiver, PointerToMemberFunction method, </span></span></span><br><span class="line"><span class="params"><span class="function">Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号和槽函数也就是第2,4个参数传递的是地址, 编译器在编译过程中会对数据的正确性进行检测</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="type">const</span> QObject *sender, &amp;QObject::signal, </span><br><span class="line">        <span class="type">const</span> QObject *receiver, &amp;QObject::method);</span><br></pre></td></tr></table></figure><ul><li>Qt4的连接方式</li></ul><blockquote><p>这种旧的信号槽连接方式在Qt5中是支持的, 但是不推荐使用, 因为这种方式在进行信号槽连接的时候,信号槽函数通过宏<code>SIGNAL</code>和<code>SLOT</code>转换为字符串类型。<br>因为信号槽函数的转换是通过宏来进行转换的，因此传递到宏函数内部的数据不会被进行检测，如果使用者传错了数据，编译器也不会报错，但实际上信号槽的连接已经不对了，只有在程序运行起来之后才能发现问题，而且问题不容易被定位。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Qt4的信号槽连接方式</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *sender, <span class="type">const</span> <span class="type">char</span> *signal, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *receiver, <span class="type">const</span> <span class="type">char</span> *method, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(<span class="type">const</span> QObject *sender,<span class="built_in">SIGNAL</span>(信号函数名(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...)),</span><br><span class="line">        <span class="type">const</span> QObject *receiver,<span class="built_in">SLOT</span>(槽函数名(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...)));</span><br></pre></td></tr></table></figure><p><code>Qt4中声明槽函数必须要使用 slots 关键字, 不能省略。</code></p><ul><li>应用举例</li></ul><blockquote><p>场景描述：<br>    - 我肚子饿了, 我要吃东西。  </p><p>分析：<br>     - 信号的发出者是我自己, 信号的接收者也是我自己</p></blockquote><blockquote><p>先定义出一个Qt的类。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Me</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    <span class="comment">// Qt4中的槽函数必须这样声明, qt5中的关键字 slots 可以被省略</span></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(QString somthing)</span></span>;</span><br><span class="line">    signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hungury</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hungury</span><span class="params">(QString somthing)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于上边的类写出解决方案</span></span><br><span class="line"><span class="comment">// 处理如下逻辑: 我饿了, 我要吃东西</span></span><br><span class="line"><span class="comment">// 分析: 信号的发出者是我自己, 信号的接收者也是我自己</span></span><br><span class="line">Me m;</span><br><span class="line"><span class="comment">// Qt4处理方式</span></span><br><span class="line"><span class="built_in">connect</span>(&amp;m, <span class="built_in">SIGNAL</span>(<span class="built_in">eat</span>()), &amp;m, <span class="built_in">SLOT</span>(<span class="built_in">hungury</span>()));</span><br><span class="line"><span class="built_in">connect</span>(&amp;m, <span class="built_in">SIGNAL</span>(<span class="built_in">eat</span>(QString)), &amp;m, <span class="built_in">SLOT</span>(<span class="built_in">hungury</span>(QString)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Qt5处理方式</span></span><br><span class="line"><span class="built_in">connect</span>(&amp;m, &amp;Me::eat, &amp;m, &amp;Me::hungury);<span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>Qt5处理方式错误原因分析：</p><p><code>上边的写法之所以错误是因为这个类中信号槽都是重载过的, 信号和槽都是通过函数名去关联函数的地址, 但是这个同名函数对应两块不同的地址, 一个带参, 一个不带参, 因此编译器就不知道去关联哪块地址了, 所以如果我们在这种时候通过以上方式进行信号槽连接, 编译器就会报错。</code></p><p>解决方案：</p><ul><li>可以通过定义函数指针的方式指定出函数的具体参数，这样就可以确定函数的具体地址了。</li><li>定义函数指针指向重载的某个信号或者槽函数，在connect（）函数中将函数指针名字作为实参就可以了。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 举例：</span></span><br><span class="line"><span class="built_in">void</span> (Me::*func1)(QString) = &amp;Me::eat;<span class="comment">// func1指向带参的信号</span></span><br><span class="line"><span class="built_in">void</span> (Me::*func2)() = &amp;Me::hungury;<span class="comment">// func2指向不带参的槽函数</span></span><br></pre></td></tr></table></figure><p>Qt正确的处理方式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数指针指向重载的某一个具体的信号地址</span></span><br><span class="line"><span class="built_in">void</span> (Me::*mysignal)(QString) = &amp;Me::eat;</span><br><span class="line"><span class="comment">// 定义函数指针指向重载的某一个具体的槽函数地址</span></span><br><span class="line"><span class="built_in">void</span> (Me::*myslot)(QString) = &amp;Me::hungury;</span><br><span class="line"><span class="comment">// 使用定义的函数指针完成信号槽的连接</span></span><br><span class="line"><span class="built_in">connect</span>(&amp;m, mysignal, &amp;m, myslot);</span><br></pre></td></tr></table></figure><p>总结</p><ul><li>Qt4的信号槽连接方式因为使用了宏函数, 宏函数对用户传递的信号槽不会做错误检测, 容易出bug</li><li>Qt5的信号槽连接方式, 传递的是信号槽函数的地址, 编译器会做错误检测, 减少了bug的产生</li><li>当信号槽函数被重载之后, Qt4的信号槽连接方式不受影响</li><li>当信号槽函数被重载之后, Qt5中需要给被重载的信号或者槽定义函数指针</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-Qt基本结构&quot;&gt;&lt;a href=&quot;#1-Qt基本结构&quot; class=&quot;headerlink&quot; title=&quot;1. Qt基本结构&quot;&gt;&lt;/a&gt;1. Qt基本结构&lt;/h1&gt;&lt;h2 id=&quot;1-1-Qt本有项目&quot;&gt;&lt;a href=&quot;#1-1-Qt本有项目&quot; </summary>
      
    
    
    
    <category term="Qt" scheme="http://example.com/categories/Qt/"/>
    
    
    <category term="信号槽" scheme="http://example.com/tags/%E4%BF%A1%E5%8F%B7%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>套接字通信</title>
    <link href="http://example.com/2023/10/22/%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/"/>
    <id>http://example.com/2023/10/22/%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/</id>
    <published>2023-10-22T01:53:35.000Z</published>
    <updated>2023-10-22T02:56:02.229Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-套接字-socket"><a href="#1-套接字-socket" class="headerlink" title="1. 套接字-socket"></a>1. 套接字-socket</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><ul><li>局域网和广域网<ul><li>局域网：局域网将一定区域内的各种计算机、外部设备和数据库连接起来形成计算机通信的私有网络。</li><li>广域网：又称<strong>广域网</strong>、<strong>外网</strong>、<strong>公网</strong>。<br>  是连接不同地区局域网或城域网计算机通信的远程公共网络。</li></ul></li><li>IP（Internet Protocol）：本质是一个整形数，用于表示计算机在网络中的地址。<br>IP协议版本有两个：IPv4和IPv6<ul><li>IPv4（Internet Protocol version4）：<ul><li>使用一个32位的整形数描述一个IP地址，4个字节，int型</li><li>也可以使用一个点分十进制字符串描述这个IP地址： <code>192.168.130.198</code></li><li>分成了4份，每份1字节，8bit（char），最大值为 255<ul><li>0.0.0.0 是最小的IP地址</li><li>255.255.255.255是最大的IP地址</li></ul></li><li>按照IPv4协议计算，可以使用的IP地址共有 2^32^ 个</li></ul></li><li>IPv6（Internet Protocol version6）：<ul><li>使用一个128位的整形数描述一个IP地址，16个字节</li><li>也可以使用一个字符串描述这个IP地址：2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b</li><li>分成了8份，每份2字节，每一部分以16进制的方式表示</li><li>按照IPv6协议计算，可以使用的IP地址共有 2^128^ 个</li></ul></li></ul></li><li>查看IP地址</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># linux</span></span><br><span class="line">$ ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># windows</span></span><br><span class="line">$ ipconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试网络是否畅通</span></span><br><span class="line"><span class="comment"># 主机a: 192.168.1.11</span></span><br><span class="line"><span class="comment"># 当前主机: 192.168.1.12</span></span><br><span class="line">$ ping 192.168.1.11     <span class="comment"># 测试是否可用连接局域网</span></span><br><span class="line">$ ping www.baidu.com    <span class="comment"># 测试是否可用连接外网</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 特殊的IP地址: 127.0.0.1  ==&gt; 和本地的IP地址是等价的</span></span><br><span class="line"><span class="comment"># 假设当前电脑没有联网, 就没有IP地址, 又要做网络测试, 可用使用 127.0.0.1 进行本地测试</span></span><br></pre></td></tr></table></figure><ul><li>端口<br>端口的作用是定位到主机上的某一个进程，通过这个端口进程就可接受到对应的网络数据。</li></ul><blockquote><p>比如: 在电脑上运行了微信和QQ, 小明通过客户端给我的的微信发消息, 电脑上的微信就收到了消息, 为什么?</p><p>运行在电脑上的微信和QQ都绑定了不同的端口 通过IP地址可以定位到某一台主机<br>通过端口就可以定位到主机上的某一个进程<br>通过指定的IP和端口，发送数据的时候对端就能接受到数据了</p></blockquote><p>端口也是一个整形数 <code>unsigned short</code> ，一个16位整形数，有效端口的取值范围是：<br><code>0 ~ 65535</code>(0 ~ 2^16^-1)</p><blockquote><p>计算机中所有的进程都需要关联一个端口吗?<br>不需要，如果这个进程不需要网络通信，那么这个进程就不需要绑定端口的<br>.<br>一个端口可以被重复使用吗?<br>一个端口只能给某一个进程使用，多个进程不能同时使用同一端口</p></blockquote><ul><li>OSI&#x2F;ISO 网络分层模型<br>OSI（Open System Interconnect），即开放式系统互联。<br>一般都叫OSI参考模型，是ISO（国际标准化组织组织）在1985年研究的网络互联模型。</li></ul><p><img src="/img/9.21.png" alt="在这里插入图片描述"></p><blockquote><ul><li>物理层：负责最后将信息编码成电流脉冲或其它信号用于网上传输 </li><li>数据链路层:<ul><li>数据链路层通过物理网络链路供数据传输。</li><li>规定了0和1的分包形式，确定了网络数据包的形式；</li></ul></li><li>网络层 <ul><li>网络层负责在源和终点之间建立连接;</li><li>此处需要确定计算机的位置，通过IPv4，IPv6格式的IP地址来找到对应的主机</li></ul></li><li>传输层 </li><li>传输层向高层提供可靠的端到端的网络数据流服务。<ul><li>每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信</li></ul></li><li>会话层 </li><li>会话层建立、管理和终止表示层与实体之间的通信会话；<ul><li>建立一个连接（自动的手机信息、自动的网络寻址）;</li></ul></li><li>表示层:<ul><li>对应用层数据编码和转化, 确保以一个系统应用层发送的信息 可以被另一个系统应用层识别;</li></ul></li></ul></blockquote><hr><h2 id="1-2-网络协议"><a href="#1-2-网络协议" class="headerlink" title="1.2 网络协议"></a>1.2 网络协议</h2><p>网络协议指的是计算机网络中互相通信的对等实体之间交换信息时所必须遵守的规则的集合。<br>一般系统网络协议包括五个部分：通信环境，传输服务，词汇表，信息的编码格式，时序、规则和过程。<br>通过几幅图了解下常用的网络协议的格式：</p><ul><li>TCP协议 -&gt; 传输层协议</li></ul><p><img src="/img/9.22.png" alt="在这里插入图片描述"></p><ul><li>UDP协议 -&gt; 传输层协议</li></ul><p><img src="/img/9.23.png" alt="在这里插入图片描述"></p><ul><li><p>IP协议(IPV4) -&gt; 网络层协议<br><img src="/img/9.24.png" alt="在这里插入图片描述"></p></li><li><p>以太网帧协议 -&gt; 网络接口层协议</p></li></ul><p><img src="/img/9.25.png" alt="在这里插入图片描述"></p><ul><li>数据的封装<br><img src="/img/9.26.png" alt="在这里插入图片描述"></li></ul><p>在网络通信的时候, 我们需负责的应用层数据的处理(最上层)</p><ul><li>应用层的数据可以使用某些协议进行封装, 也可以不封装</li><li>我们需要调用发送数据的接口函数，将数据发送出去</li><li>我们调用的API做底层数据处理<ul><li>传输层使用传输层协议打包数据</li><li>网络层使用网络层协议打包数据</li><li>网络接口层使用网络接口层协议打包数据</li><li>数据被发送到internet</li></ul></li><li>接收端接收到发送端的数据<ul><li>我们调用接收数据的函数接收数据</li><li>调用的API做相关的底层处理:<ul><li>网络接口层拆包 &#x3D;&#x3D;&gt; 网络层的包</li><li>网络层拆包 &#x3D;&#x3D;&gt; 网络层的包</li><li>传输层拆包 &#x3D;&#x3D;&gt; 传输层数据</li></ul></li><li>如果应用层也使用了协议对数据进行了封装，数据的包的解析需要我们做</li></ul></li></ul><hr><h2 id="1-3-socket编程"><a href="#1-3-socket编程" class="headerlink" title="1.3 socket编程"></a>1.3 socket编程</h2><p>Socket套接字由远景研究规划局（Advanced Research Projects Agency, ARPA）资助加里福尼亚大学伯克利分校的一个研究组研发。<br>其目的是将TCP&#x2F;IP协议相关软件移植到UNIX类系统中。设计者开发了一个接口，以便应用程序能简单地调用该接口通信。<br>这个接口不断完善，最终形成了Socket套接字。Linux系统采用了Socket套接字，因此，Socket接口就被广泛使用，到现在已经成为事实上的标准。<br>与套接字相关的函数被包含在头文件<code>sys/socket.h</code>中。</p><p>套接字对我们来说就是一套网络通信的接口，使用这套接口就可以完成网络通信。<br>网络通信的主体主要分为两部分：<code>客户端</code>和<code>服务器端</code>。<br>在客户端和服务器通信的时候需要频繁提到三个概念：<code>IP</code>、<code>端口</code>、<code>通信数据</code></p><h3 id="1-3-1-字节序"><a href="#1-3-1-字节序" class="headerlink" title="1.3.1 字节序"></a>1.3.1 字节序</h3><p>在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编&#x2F;译码从而导致通信失败。</p><p><code>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序 也就是说对于单字符来说是没有字节序问题的，字符串是单字符的集合，因此字符串也没有字节序问题。</code></p><p>目前在各种体系的计算机中通常采用的字节存储机制主要有两种：<code>Big-Endian</code> 和 <code>Little-Endian</code></p><p>下面先从字节序说起。</p><blockquote><p>大小端的这个名词最早出现在《格列佛游记》中，里边记载了两个征战的强国，你不会想到的是，他们打仗竟然和剥鸡蛋的顺序有关。很多人认为，剥鸡蛋时应该打破鸡蛋较大的一端，这群人被称作“大端（Big endian）派”。可是那时皇帝儿子小时候吃鸡蛋的时候碰巧将一个手指弄破了。所以，当时的皇帝就下令剥鸡蛋必须打破鸡蛋较小的一端，违令者重罚，由此产生了“小端（Little endian）派”。<br>老百姓们对这项命令极其反感，由此引发了6次叛乱，其中一个皇帝送了命，另一个丢了王位。据估计，先后几次有11000人情愿受死也不肯去打破鸡蛋较小的一端！</p></blockquote><ul><li><p>Little-Endian -&gt; 主机字节序 (小端)</p><ul><li>数据的<code>低位字节</code>存储到内存的<code>低地址位</code>, 数据的<code>高位字节</code>存储到内存的<code>高地址位</code></li><li>我们使用的PC机，数据的存储默认使用的是小端</li></ul></li><li><p>Big-Endian -&gt; 网络字节序 (大端)</p><ul><li>数据的<code>低位字节</code>存储到内存的<code>高地址位</code>, 数据的<code>高位字节</code>存储到内存的<code>低地址位</code></li><li>套接字通信过程中操作的数据都是大端存储的，包括：接收&#x2F;发送的数据,IP地址,端口</li></ul></li><li><p>字节序举例</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有一个16进制的数, 有32位 (int): 0xab5c01ff</span></span><br><span class="line"><span class="comment">// 字节序, 最小的单位: char 字节, int 有4个字节, 需要将其拆分为4份</span></span><br><span class="line"><span class="comment">// 一个字节 unsigned char, 最大值是 255(十进制) ==&gt; ff(16进制) </span></span><br><span class="line">                 内存低地址位                内存的高地址位</span><br><span class="line">---------------------------------------------------------------------------&gt;</span><br><span class="line">小端:         <span class="number">0xff</span>        <span class="number">0x01</span>        <span class="number">0x5c</span>        <span class="number">0xab</span></span><br><span class="line">大端:         <span class="number">0xab</span>        <span class="number">0x5c</span>        <span class="number">0x01</span>        <span class="number">0xff</span></span><br></pre></td></tr></table></figure><p><img src="/img/9.27.png" alt="在这里插入图片描述"></p><ul><li>函数</li></ul><blockquote><p>BSD Socket提供了封装好的转换接口，方便我们使用。<br>包括从主机字节序到网络字节序的转换函数：htons、htonl；<br>从网络字节序到主机字节序的转换函数：ntohs、ntohl。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// u:unsigned</span></span><br><span class="line"><span class="comment">// 16: 16位, 32:32位</span></span><br><span class="line"><span class="comment">// h: host, 主机字节序</span></span><br><span class="line"><span class="comment">// n: net, 网络字节序</span></span><br><span class="line"><span class="comment">// s: short</span></span><br><span class="line"><span class="comment">// l: int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这套api主要用于 网络通信过程中 IP 和 端口 的 转换</span></span><br><span class="line"><span class="comment">// 将一个短整形从主机字节序 -&gt; 网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;</span><br><span class="line"><span class="comment">// 将一个整形从主机字节序 -&gt; 网络字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个短整形从网络字节序 -&gt; 主机字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span></span><br><span class="line"><span class="comment">// 将一个整形从网络字节序 -&gt; 主机字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-3-2-IP地址转换"><a href="#1-3-2-IP地址转换" class="headerlink" title="1.3.2 IP地址转换"></a>1.3.2 IP地址转换</h3><p>虽然IP地址本质是一个整形数，但是在使用的过程中都是通过一个字符串来描述<br>下面的函数描述了如何将一个字符串类型的IP地址进行大小端转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主机字节序的IP地址转换为网络字节序</span></span><br><span class="line"><span class="comment">// 主机字节序的IP地址是字符串, 网络字节序IP地址是整形</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>; </span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>af: 地址族(IP地址的家族包括ipv4和ipv6)协议<ul><li>AF_INET: ipv4格式的ip地址</li><li>AF_INET6: ipv6格式的ip地址</li></ul></li><li>src: 传入参数, 对应要转换的点分十进制的ip地址: 192.168.1.100</li><li>dst: 传出参数, 函数调用完成, 转换得到的大端整形IP被写入到这块内存中</li></ul></li><li>返回值：成功返回1，失败返回0或者-1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将大端的整形数, 转换为小端的点分十进制的IP地址        </span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>af: 地址族协议<ul><li>AF_INET: ipv4格式的ip地址</li><li>AF_INET6: ipv6格式的ip地址</li></ul></li><li>src: 传入参数, 这个指针指向的内存中存储了大端的整形IP地址</li><li>dst: 传出参数, 存储转换得到的小端的点分十进制的IP地址</li><li>size: 修饰dst参数的, 标记dst指向的内存中最多可以存储多少个字节</li></ul></li><li>返回值:<ul><li>成功: 指针指向第三个参数对应的内存地址, 通过返回值也可以直接取出转换得到的IP字符串</li><li>失败: NULL</li></ul></li></ul><p>还有一组函数也能进程IP地址大小端的转换，但是只能处理ipv4的ip地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点分十进制IP -&gt; 大端整形</span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大端整形 -&gt; 点分十进制IP</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-3-3-sockaddr-数据结构"><a href="#1-3-3-sockaddr-数据结构" class="headerlink" title="1.3.3 sockaddr 数据结构"></a>1.3.3 sockaddr 数据结构</h3><p><img src="/img/9.28.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在写数据的时候不好用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sa_family;       <span class="comment">// 地址族协议, ipv4</span></span><br><span class="line"><span class="type">char</span>        sa_data[<span class="number">14</span>];     <span class="comment">// 端口(2字节) + IP地址(4字节) + 填充(8字节)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>  <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>    <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(struct sockaddr) == sizeof(struct sockaddr_in)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;<span class="comment">/* 地址族协议: AF_INET */</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;         <span class="comment">/* 端口, 2字节-&gt; 大端  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">/* IP地址, 4字节 -&gt; 大端  */</span></span><br><span class="line">    <span class="comment">/* 填充 8字节 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) - <span class="keyword">sizeof</span>(sin_family) -</span><br><span class="line">               <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><hr><h3 id="1-3-4-套接字函数"><a href="#1-3-4-套接字函数" class="headerlink" title="1.3.4 套接字函数"></a>1.3.4 套接字函数</h3><p>使用套接字通信函数需要包含头文件<code>&lt;arpa/inet.h&gt;</code>，包含了这个头文件<code>&lt;sys/socket.h&gt;</code>就不用在包含了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>domain: 使用的地址族协议<ul><li>AF_INET: 使用IPv4格式的ip地址</li><li>AF_INET6: 使用IPv4格式的ip地址</li></ul></li><li>type:<ul><li>SOCK_STREAM: 使用流式的传输协议</li><li>SOCK_DGRAM: 使用报式(报文)的传输协议</li></ul></li><li>protocol: 一般写0即可, 使用默认的协议<ul><li>SOCK_STREAM: 流式传输默认使用的是tcp</li><li>SOCK_DGRAM: 报式传输默认使用的udp</li></ul></li></ul></li><li>返回值:<ul><li>成功: 可用于套接字通信的文件描述符</li><li>失败: -1</li></ul></li></ul><p>函数的返回值是一个文件描述符，通过这个文件描述符可以操作内核中的某一块内存，网络通信是基于这个文件描述符来完成的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将文件描述符和本地的IP与端口进行绑定   </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd: 监听的文件描述符, 通过socket()调用得到的返回值</li><li>addr: 传入参数, 要绑定的IP和端口信息需要初始化到这个结构体中，IP和端口要转换为网络字节序</li><li>addrlen: 参数addr指向的内存大小, sizeof(struct sockaddr)</li></ul></li><li>返回值：成功返回0，失败返回-1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给监听的套接字设置监听</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd: 文件描述符, 可以通过调用socket()得到，在监听之前必须要绑定 bind()</li><li>backlog: 同时能处理的最大连接要求，最大值为128</li></ul></li><li>返回值：函数调用成功返回0，调用失败返回 -1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待并接受客户端的连接请求, 建立新的连接, 会得到一个新的文件描述符(通信的)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd: 监听的文件描述符</li><li>addr: 传出参数, 里边存储了建立连接的客户端的地址信息</li><li>addrlen: 传入传出参数，用于存储addr指向的内存大小</li></ul></li><li>返回值：函数调用成功，得到一个文件描述符, 用于和建立连接的这个客户端通信<br>  调用失败返回 -1</li></ul><p><code>这个函数是一个阻塞函数，当没有新的客户端连接请求的时候，该函数阻塞；当检测到有新的客户端连接请求时，阻塞解除，新连接就建立了，得到的返回值也是一个文件描述符，基于这个文件描述符就可以和客户端通信了。</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd: 用于通信的文件描述符, accept() 函数的返回值</li><li>buf: 指向一块有效内存, 用于存储接收是数据</li><li>size: 参数buf指向的内存的容量</li><li>flags: 特殊的属性, 一般不使用, 指定为 0</li></ul></li><li>返回值:<ul><li>大于0：实际接收的字节数</li><li>等于0：对方断开了连接</li><li>-1：接收数据失败了</li></ul></li></ul><p><code>如果连接没有断开，接收端接收不到数据，接收数据的函数会阻塞等待数据到达，数据到达后函数解除阻塞，开始接收数据， 当发送端断开连接，接收端无法接收到任何数据，但是这时候就不会阻塞了，函数直接返回0。</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送数据的函数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>fd: 通信的文件描述符, accept() 函数的返回值</li><li>buf: 传入参数, 要发送的字符串</li><li>len: 要发送的字符串的长度</li><li>flags: 特殊的属性, 一般不使用, 指定为 0</li></ul></li><li>返回值：<ul><li>大于0：实际发送的字节数，和参数len是相等的</li><li><pre><code>-1：发送数据失败了</code></pre></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功连接服务器之后, 客户端会自动随机绑定一个端口</span></span><br><span class="line"><span class="comment">// 服务器端调用accept()的函数, 第二个参数存储的就是客户端的IP和端口信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd: 通信的文件描述符, 通过调用socket()函数就得到了</li><li>addr: 存储了要连接的服务器端的地址信息: iP 和 端口，这个IP和端口也需要转换为大端然后再赋值</li><li>addrlen: addr指针指向的内存的大小 sizeof(struct sockaddr)</li></ul></li><li>返回值：连接成功返回0，连接失败返回-1</li></ul><hr><h2 id="1-4-TCP通信流程"><a href="#1-4-TCP通信流程" class="headerlink" title="1.4 TCP通信流程"></a>1.4 TCP通信流程</h2><p>TCP是一个面向连接的，安全的，流式传输协议，这个协议是一个传输层协议。</p><ul><li>面向连接：是一个双向连接，通过三次握手完成，断开连接需要通过四次挥手完成。</li><li>安全：tcp通信过程中,会对发送的每一数据包都会进行校验, 如果发现数据丢失, 会自动重传</li><li>流式传输：发送端和接收端处理数据的速度，数据的量都可以不一致<br><img src="/img/9.29.png" alt="在这里插入图片描述"></li></ul><h3 id="1-4-1-服务器端通信流程"><a href="#1-4-1-服务器端通信流程" class="headerlink" title="1.4.1 服务器端通信流程"></a>1.4.1 服务器端通信流程</h3><ol><li>创建用于监听的套接字, 这个套接字是一个文件描述符</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lfd = socket();</span><br></pre></td></tr></table></figure><ol start="2"><li>将得到的监听的文件描述符和本地的IP 端口进行绑定</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind();</span><br></pre></td></tr></table></figure><ol start="3"><li>设置监听(成功之后开始监听, 监听的是客户端的连接)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen();</span><br></pre></td></tr></table></figure><ol start="4"><li>等待并接受客户端的连接请求, 建立新的连接, 会得到一个新的文件描述符(通信的)，没有新连接请求就阻塞</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cfd = accept();</span><br></pre></td></tr></table></figure><ol start="5"><li>通信，读写操作默认都是阻塞的</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line">read(); / recv();</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">write(); / send();</span><br></pre></td></tr></table></figure><ol start="6"><li>断开连接, 关闭套接字</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close();</span><br></pre></td></tr></table></figure><blockquote><p>在tcp的服务器端, 有两类文件描述符</p><ul><li>监听的文件描述符 <ul><li>只需要有一个</li><li>不负责和客户端通信, 负责检测客户端的连接请求, 检测到之后调用accept就可以建立新的连接</li></ul></li><li>通信的文件描述符<ul><li>负责和建立连接的客户端通信</li><li>如果有N个客户端和服务器建立了新的连接,通信的文件描述符就有N个，每个客户端和服务器都对应一个通信的文件描述符</li></ul></li></ul></blockquote><p><img src="/img/9.30.png" alt="在这里插入图片描述"></p><ul><li>文件描述符对应的内存结构：<ul><li><code>一个文件文件描述符对应两块内存, 一块内存是读缓冲区, 一块内存是写缓冲区</code></li><li>读数据: <code>通过文件描述符将内存中的数据读出, 这块内存称之为读缓冲区</code></li><li>写数据: <code>通过文件描述符将数据写入到某块内存中, 这块内存称之为写缓冲区</code></li></ul></li><li>监听的文件描述符:<ul><li>客户端的连接请求会发送到服务器端监听的文件描述符的读缓冲区中</li><li>读缓冲区中有数据, 说明有新的客户端连接</li><li>调用accept()函数, 这个函数会检测监听文件描述符的读缓冲区<ul><li>检测不到数据, 该函数阻塞</li><li>如果检测到数据, 解除阻塞, 新的连接建立</li></ul></li></ul></li><li>通信的文件描述符:<ul><li>客户端和服务器端都有通信的文件描述符</li><li>发送数据：调用函数 write() &#x2F; send()，数据进入到内核中<ul><li>数据并没有被发送出去, 而是将数据写入到了通信的文件描述符对应的写缓冲区中</li><li>内核检测到通信的文件描述符写缓冲区中有数据, 内核会将数据发送到网络中</li></ul></li><li>接收数据: 调用的函数 read() &#x2F; recv(), 从内核读数据<ul><li>数据如何进入到内核我们不需要处理, 数据进入到通信的文件描述符的读缓冲区中</li><li>数据进入到内核, 必须使用通信的文件描述符, 将数据从读缓冲区中读出即可</li></ul></li></ul></li></ul><blockquote><p>基于tcp的服务器端通信代码:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将socket()返回值和本地的IP端口绑定到一起</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="comment">// INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏可以代表任意一个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏一般用于本地的绑定操作</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 这个宏的值为0 == 0.0.0.0</span></span><br><span class="line"><span class="comment">//    inet_pton(AF_INET, &quot;192.168.237.131&quot;, &amp;addr.sin_addr.s_addr);</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 阻塞等待并接受客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印客户端的地址信息</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">24</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP地址: %s, 端口: %d\n&quot;</span>,</span><br><span class="line">           inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, <span class="keyword">sizeof</span>(ip)),</span><br><span class="line">           ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 和客户端通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">            write(cfd, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-4-2-客户端的通信流程"><a href="#1-4-2-客户端的通信流程" class="headerlink" title="1.4.2 客户端的通信流程"></a>1.4.2 客户端的通信流程</h3><blockquote><p>在单线程的情况下客户端通信的文件描述符有一个, 没有监听的文件描述符</p></blockquote><ol><li>创建一个通信的套接字</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cfd = socket();</span><br></pre></td></tr></table></figure><ol start="2"><li>连接服务器, 需要知道服务器绑定的IP和端口</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect();</span><br></pre></td></tr></table></figure><ol start="3"><li>通信</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line">read(); / recv();</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">write(); / send();</span><br></pre></td></tr></table></figure><ol start="4"><li>断开连接, 关闭文件描述符(套接字)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close();</span><br></pre></td></tr></table></figure><blockquote><p>基于tcp通信的客户端通信代码:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.237.131&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 和服务器端通信</span></span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;你好, 服务器...%d\n&quot;</span>, number++);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器say: %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);   <span class="comment">// 每隔1s发送一条数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-5-扩展阅读"><a href="#1-5-扩展阅读" class="headerlink" title="1.5  扩展阅读"></a>1.5  扩展阅读</h2><p>在Window中也提供了套接字通信的API，这些API函数与Linux平台的API函数几乎相同，以至于很多人认为套接字通信的API函数库只有一套，看一下这些Windows平台的套接字函数：</p><h3 id="1-5-1-初始化套接字环境"><a href="#1-5-1-初始化套接字环境" class="headerlink" title="1.5.1 初始化套接字环境"></a>1.5.1 初始化套接字环境</h3><p>使用Windows中的套接字函数需要额外包含对应的头文件以及加载响应的动态库：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用包含的头文件 </span></span><br><span class="line">include &lt;winsock2.h&gt;</span><br><span class="line"><span class="comment">// 使用的套接字库 </span></span><br><span class="line">ws2_32.dll       </span><br></pre></td></tr></table></figure><p>在Windows中使用套接字需要先加载套接字库（套接字环境），最后需要释放套接字资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化Winsock库</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR。</span></span><br><span class="line">WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>wVersionRequested: 使用的Windows Socket的版本, 一般使用的版本是 2.2<ul><li>初始化这个 MAKEWORD(2, 2);参数</li></ul></li><li>lpWSAData：一个WSADATA结构指针, 这是一个传入参数<ul><li>创建一个 WSADATA 类型的变量, 将地址传递给该函数的第二个参数</li></ul></li></ul></li></ul><p>注销Winsock相关库，函数调用成功返回0，失败返回 SOCKET_ERROR。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">WSACleanup</span> <span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>使用举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WSAData wsa;</span><br><span class="line"><span class="comment">// 初始化套接字库</span></span><br><span class="line">WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .......</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注销Winsock相关库</span></span><br><span class="line">WSACleanup();</span><br></pre></td></tr></table></figure><hr><h3 id="1-5-2-套接字通信函数"><a href="#1-5-2-套接字通信函数" class="headerlink" title="1.5.2 套接字通信函数"></a>1.5.2 套接字通信函数</h3><p>基于Linux的套接字通信流程是最全面的一套通信流程，如果是在某个框架中进行套接字通信，通信流程只会更简单，直接使用window的套接字api进行套接字通信，和Linux平台上的通信流程完全相同。</p><h4 id="1-5-2-1-结构体"><a href="#1-5-2-1-结构体" class="headerlink" title="1.5.2.1 结构体"></a>1.5.2.1 结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/////////////////////////////// Windows ///////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">　　<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span>&#123;</span> <span class="type">unsigned</span> <span class="type">char</span> s_b1,s_b2, s_b3,s_b4;&#125; S_un_b;</span><br><span class="line">　　<span class="class"><span class="keyword">struct</span>&#123;</span> <span class="type">unsigned</span> <span class="type">short</span> s_w1, s_w2;&#125; S_un_w;</span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">long</span> S_addr;<span class="comment">// 存储IP地址</span></span><br><span class="line">　　&#125; S_un;</span><br><span class="line">&#125;IN_ADDR;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">　　<span class="type">short</span> <span class="type">int</span> sin_family; <span class="comment">/* Address family */</span></span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sin_port; <span class="comment">/* Port number */</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* Internet address */</span></span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">/* Same size as struct sockaddr */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////// Linux ////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>  <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>    <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(struct sockaddr) == sizeof(struct sockaddr_in)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;     <span class="comment">/* 地址族协议: AF_INET */</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;         <span class="comment">/* 端口, 2字节-&gt; 大端  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">/* IP地址, 4字节 -&gt; 大端  */</span></span><br><span class="line">    <span class="comment">/* 填充 8字节 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) - <span class="keyword">sizeof</span>(sin_family) -</span><br><span class="line">                      <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><hr><h4 id="1-5-2-2-大小端转换函数"><a href="#1-5-2-2-大小端转换函数" class="headerlink" title="1.5.2.2 大小端转换函数"></a>1.5.2.2 大小端转换函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主机字节序 -&gt; 网络字节序</span></span><br><span class="line">u_short <span class="title function_">htons</span> <span class="params">(u_short hostshort )</span>;</span><br><span class="line">u_long <span class="title function_">htonl</span> <span class="params">( u_long hostlong)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络字节序 -&gt; 主机字节序</span></span><br><span class="line">u_short <span class="title function_">ntohs</span> <span class="params">(u_short netshort )</span>;</span><br><span class="line">u_long <span class="title function_">ntohl</span> <span class="params">( u_long netlong)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// linux函数, window上没有这两个函数</span></span><br><span class="line">inet_ntop(); </span><br><span class="line">inet_pton();</span><br><span class="line"></span><br><span class="line"><span class="comment">// windows 和 linux 都使用, 只能处理ipv4的ip地址</span></span><br><span class="line"><span class="comment">// 点分十进制IP -&gt; 大端整形</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> FAR * cp)</span>;<span class="comment">// windows</span></span><br><span class="line"><span class="type">in_addr_t</span>     <span class="title function_">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;<span class="comment">// linux</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大端整形 -&gt; 点分十进制IP</span></span><br><span class="line"><span class="comment">// window, linux相同</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-5-2-3-套接字函数"><a href="#1-5-2-3-套接字函数" class="headerlink" title="1.5.2.3 套接字函数"></a>1.5.2.3 套接字函数</h4><blockquote><p>window的api中套接字对应的类型是 SOCKET 类型, linux中是 int 类型, 本质是一样的</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个套接字</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回套接字, 失败返回INVALID_SOCKET</span></span><br><span class="line">SOCKET <span class="title function_">socket</span><span class="params">(<span class="type">int</span> af,<span class="type">int</span> type,<span class="type">int</span> protocal)</span>;</span><br><span class="line">参数:</span><br><span class="line">    - af: 地址族协议</span><br><span class="line">        - ipv4: AF_INET (windows/linux)</span><br><span class="line">        - PF_INET (windows)</span><br><span class="line">        - AF_INET == PF_INET</span><br><span class="line">   - type: 和linux一样</span><br><span class="line">       - SOCK_STREAM</span><br><span class="line">        - SOCK_DGRAM</span><br><span class="line">   - protocal: 一般写<span class="number">0</span> 即可</span><br><span class="line">       - 在windows上的另一种写法</span><br><span class="line">           - IPPROTO_TCP, 使用指定的流式协议中的tcp协议</span><br><span class="line">           - IPPROTO_UDP, 使用指定的报式协议中的udp协议</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 关键字: FAR NEAR, 这两个关键字在32/64位机上是没有意义的, 指定的内存的寻址方式</span></span><br><span class="line"><span class="comment">// 套接字绑定本地IP和端口</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR</span></span><br><span class="line"><span class="type">int</span> bind(SOCKET s,<span class="type">const</span> <span class="keyword">struct</span> sockaddr FAR* name, <span class="type">int</span> namelen);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置监听</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(SOCKET s,<span class="type">int</span> backlog)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待并接受客户端连接</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回用于的套接字，失败返回INVALID_SOCKET。</span></span><br><span class="line">SOCKET <span class="title function_">accept</span> <span class="params">( SOCKET s, <span class="keyword">struct</span> sockaddr FAR* addr, <span class="type">int</span> FAR* addrlen )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接服务器</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span> <span class="params">(SOCKET s,<span class="type">const</span> <span class="keyword">struct</span> sockaddr FAR* name,<span class="type">int</span> namelen )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Qt中connect用户信号槽的连接, 如果要使用windows api 中的 connect 需要在函数名前加::</span></span><br><span class="line">::connect(sock, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="comment">// 返回值: 成功时返回接收的字节数，收到EOF时为0，失败时返回SOCKET_ERROR。</span></span><br><span class="line"><span class="comment">//==0 代表对方已经断开了连接</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recv</span> <span class="params">(SOCKET s,<span class="type">char</span> FAR* buf,<span class="type">int</span> len,<span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回传输字节数，失败返回SOCKET_ERROR。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">send</span> <span class="params">(SOCKET s,<span class="type">const</span> <span class="type">char</span> FAR * buf, <span class="type">int</span> len,<span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭套接字</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closesocket</span> <span class="params">(SOCKET s)</span>;<span class="comment">// 在linux中使用的函数是: int close(int fd);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------- udp 通信函数 -------------------------</span></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recvfrom</span><span class="params">(SOCKET s,<span class="type">char</span> FAR *buf,<span class="type">int</span> len,<span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">         <span class="keyword">struct</span> sockaddr FAR *from,<span class="type">int</span> FAR *fromlen)</span>;</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendto</span><span class="params">(SOCKET s,<span class="type">const</span> <span class="type">char</span> FAR *buf,<span class="type">int</span> len,<span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">       <span class="type">const</span> <span class="keyword">struct</span> sockaddr FAR *to,<span class="type">int</span> tolen)</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="2-三次握手-四次挥手"><a href="#2-三次握手-四次挥手" class="headerlink" title="2. 三次握手,四次挥手"></a>2. 三次握手,四次挥手</h1><p>TCP协议是一个安全的、面向连接的、流式传输协议，所谓的面向连接就是三次握手<br>对于我们来说只需要在客户端调用<code>connect()</code>函数，三次握手就自动进行了。<br>通过下图看TCP协议的格式</p><h2 id="2-1-tcp协议介绍"><a href="#2-1-tcp协议介绍" class="headerlink" title="2.1 tcp协议介绍"></a>2.1 tcp协议介绍</h2><p><img src="/img/9.31.png" alt="在这里插入图片描述"></p><p>在Tcp协议中，比较重要的字段有：</p><ul><li><p>源端口：表示发送端端口号，字段长 16 位，2个字节</p></li><li><p>目的端口：表示接收端端口号，字段长 16 位，2个字节</p></li><li><p>序号（sequence number）：字段长 32 位，占4个字节，序号的范围为 [0，4284967296]。</p><ul><li>由于TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按顺序编号</li><li>首部中的序号字段则是指本报文段所发送的数据的第一个字节的序号，这是随机生成的。</li><li>序号是循环使用的，当序号增加到最大值时，下一个序号就又回到了0</li></ul></li><li><p>确认序号（acknowledgement number）：占32位（4字节），表示收到的下一个报文段的第一个数据字节的序号，如果确认序号为N，序号为S，则表明到序号N-S为止的所有数据字节都已经被正确地接收到了。</p></li><li><p>8个标志位（Flag）:</p><ul><li>CWR：CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小；</li><li>ECE：若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1；</li><li>URG：该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关；</li><li><code>ACK</code>：该位设为 1，确认应答的字段有效，TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1；</li><li>PSH：该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存；</li><li>RST：该位设为 1，表示 TCP 连接出现异常必须强制断开连接；</li><li><code>SYN</code>：用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；</li><li><code>FIN</code>：该位设为 1，表示今后不再有数据发送，希望断开连接。</li></ul></li><li><p>窗口大小：该字段长 16 位，表示从确认序号所指位置开始能够接收的数据大小，TCP 不允许发送超过该窗口大小的数据。</p></li></ul><hr><h2 id="2-2-三次握手"><a href="#2-2-三次握手" class="headerlink" title="2.2 三次握手"></a>2.2 三次握手</h2><p>Tcp连接是双向连接，客户端和服务器需要分别向对方发送连接请求，并且建立连接，三次握手成功之后，二者之间的双向连接也就成功建立了。如果要保证三次握手顺利完成，必须要满足以下条件：</p><ul><li>服务器端：已经启动，并且启动了监听（被动接受连接的一端）</li><li>客户端：基于服务器端监听的IP和端口，向服务器端发起连接请求（主动发起连接的一端）<br><img src="/img/9.32.png" alt="在这里插入图片描述"></li></ul><p>三次握手具体过程如下：</p><p>第一次握手：</p><ul><li>客户端：客户端向服务器端发起连接请求将报文中的SYN字段置为1，生成随机序号x，seq&#x3D;x</li><li>服务器端：接收客户端发送的请求数据，解析tcp协议，校验SYN标志位是否为1，并得到序号 x</li></ul><p>第二次握手：</p><ul><li>服务器端：给客户端回复数据<ol><li>回复ACK, 将tcp协议ACK对应的标志位设置为1，表示同意了客户端建立连接的请求</li><li>回复了 ack&#x3D;x+1, 这是确认序号<ul><li>x: 客户端生成的随机序号</li><li>1: 客户端给服务器发送的数据的量, SYN标志位存储到某一个字节中, 因此按照一个字节计算，表示客户端给服务器发送的1个字节服务器收到了。</li></ul></li><li>将tcp协议中的SYN对应的标志位设置为 1, 服务器向客户端发起了连接请求</li><li>服务器端生成了一个随机序号 y, 发送给了客户端</li></ol></li><li>客户端：接收回复的数据，并解析tcp协议<ol><li>校验ACK标志位，为1表示服务器接收了客户端的连接请求</li><li>数据校验，确认发送给服务器的数据服务器收到了没有，计算公式如下：<br>发送的数据的量 &#x3D; 使用服务器回复的确认序号 - 客户端生成的随机序号 &#x3D;&#x3D;&#x3D;&gt; 1&#x3D;x+1-x</li><li>校验SYN标志位，为1表示服务器请求和客户端建立连接</li><li>得到服务器生成的随机序号: y</li></ol></li></ul><p>第三次握手：</p><ul><li>客户端：发送数据给服务器<ol><li>将tcp协议中ACK标志位设置为1，表示同意了服务器的连接请求</li><li>给服务器回复了一个确认序号 ack &#x3D; y+1<ul><li>y：服务器端生成的随机序号</li><li>1：服务器给客户端发送的数据量，服务器给客户端发送了ACK和SYN, 都存储在这一个字节中</li></ul></li><li>发送给服务器的序号就是上一次从服务器端收的确认序号因此 seq &#x3D; x+1</li></ol></li><li>服务器端：接收数据, 并解析tcp协议<ol><li>查看ACK对应的标志位是否为1, 如果是1代表, 客户端同意了服务器的连接请求</li><li>数据校验，确认发送给客户端的数据客户端收到了没有，计算公式如下：<br>给客户端发送的数据量 &#x3D; 确认序号 - 服务器生成的随机序号 &#x3D;&#x3D;&#x3D;&gt; 1&#x3D;y+1-y</li><li>得到客户端发送的序号：x+1</li></ol></li></ul><hr><h2 id="2-2-TCP四次挥手"><a href="#2-2-TCP四次挥手" class="headerlink" title="2.2 TCP四次挥手"></a>2.2 TCP四次挥手</h2><p>四次挥手是断开连接的过程，需要双向断开，关于由哪一端先断开连接是没有要求的。通信的两端如果想要断开连接就需要调用<code>close()</code>函数，当两端都调用了该函数，四次挥手也就完成了。</p><ul><li><p>客户端和服务器断开连接 -&gt; 单向断开</p></li><li><p>服务器和客户端断开连接 -&gt; 单向断开</p></li></ul><p>进行了两次单向断开，双向断开就完成了，每进行一次单向断开，就会完成两次挥手的动作。<br><img src="/img/9.33.png" alt="在这里插入图片描述"></p><p>基于上图的例子对四次挥手的具体过程进行阐述（实际上那端先断开连接都是允许的）：</p><p>第一次挥手:</p><ul><li>主动断开连接的一方：发送断开连接的请求<ol><li>将tcp协议中FIN标志位设置为1，表示请求断开连接</li><li>发送序号x给对端，seq&#x3D;x，基于这个序号用于客户端数据校验的计算</li></ol></li><li>被动断开连接的一方：接收请求数据, 并解析TCP协议<ol><li>校验FIN标志位是否为1</li><li>收到了序号 x，基于这个数据计算回复的确认序号 ack 的值</li></ol></li></ul><p>第二次挥手:</p><ul><li>被动断开连接的一方：回复数据<ol><li>同意了对方断开连接的请求，将ACK标志位设置为1</li><li>回复 ack&#x3D;x+1，表示成功接受了客户端发送的一个字节数据</li><li>向客户端发送序号 seq&#x3D;y，基于这个序号用于服务器端数据校验的计算</li></ol></li><li>主动断开连接的一方：接收回复数据, 并解析TCP协议<ol><li>校验ACK标志位，如果为1表示断开连接的请求对方已经同意了</li><li>校验 ack确认发送的数据服务器是否收到了，发送的数据 &#x3D; ack - x &#x3D; x + 1 -x &#x3D; 1</li></ol></li></ul><p>第三次挥手:</p><ul><li>被动断开连接的一方：将tcp协议中FIN标志位设置为1，表示请求断开连接</li><li>主动断开连接的一方：接收请求数据, 并解析TCP协议，校验FIN标志位是否为1</li></ul><p>第四次挥手:</p><ul><li>主动断开连接的一方：回复数据<ol><li>将tcp协议中ACK对应的标志位设置为1，表示同意了断开连接的请求</li><li>ack&#x3D;y+1，表示服务器发送给客户端的一个字节客户端接收到了</li><li>序号 seq&#x3D;h，此时的h应该等于 x+1，也就是第三次挥手时服务器回复的确认序号ack的值</li></ol></li><li>被动断开连接的一方：收到回复的ACK, 此时双向连接双向断开, 通信的两端没有任何关系了</li></ul><hr><h2 id="2-3-流量控制"><a href="#2-3-流量控制" class="headerlink" title="2.3 流量控制"></a>2.3 流量控制</h2><p>流量控制可以让发送端根据接收端的实际接受能力控制发送的数据量。<br>它的具体操作是，<code>接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不会超过该大小的数据，该限制大小即为窗口大小，即窗口大小由接收端主机决定。</code></p><p>TCP 首部中，专门有一个字段来通知窗口大小，接收主机将自己可以接收的缓冲区大小放在该字段中通知发送端。<br><code>当接收端的缓冲区面临数据溢出时，窗口大小的值也是随之改变，设置为一个更小的值通知发送端，从而控制数据的发送量，这样达到流量的控制</code>。这个控制流程的窗口也可以称作滑动窗口。</p><p>此图为一个单向的数据发送:<br><img src="/img/9.34.png" alt="在这里插入图片描述"></p><p>左侧是数据发送端：对应的是发送端的写缓冲区(内存)，通过一个环形队列进行数据管理</p><ul><li>白色格子: 空闲的内存, 可以写数据</li><li>粉色的格子: 被写入到内存, 但是还没有被发送出去的数据</li><li>灰色的格子: 代表已经被发送出去的数据</li></ul><p>右侧是数据接收端：对应的是接收端的读缓冲区，存储发送端发送过来的数据</p><ul><li>白色格子：空闲的内存, 可以继续接收数据, 滑动窗口的值记录的就是白色的格子的大小<ul><li>随着接收的数据越来越多, 白色格子越来越少, 滑动窗口的值越来越小</li><li>如果白色格子没有了, 滑动窗口变为0, 这时候, 发送端就被阻塞了</li></ul></li><li>粉色格子：接收的数据，但是这个数据还没有从内核中读走，使用read() &#x2F; recv()<ul><li>粉色格子变少了, 可用空间就变多了, 滑动窗口的值就变大了</li><li>如果滑动窗口的值从0变为大于0, 接收端又重新有容量接收数据了, 发送端的阻塞自动解除，继续发送数据</li></ul></li></ul><p>基于TCP通信的流程图，记录了从三次握手 -&gt; 数据通信 -&gt; 四次挥手的全过程：<br><img src="/img/9.35.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fast sender: 客户端</span></span><br><span class="line"><span class="comment"># slow recerver: 服务器</span></span><br><span class="line"><span class="comment"># win: 滑动窗口大小</span></span><br><span class="line"><span class="comment"># mss: maximum segment size, 单条数据的最大长度</span></span><br></pre></td></tr></table></figure><p>第1步：第一次握手，发送连接请求SYN到服务器端</p><ul><li>0(0)：0表示客户端生成的随机序号，(0)表示客户端没有额外给服务器发送数据, 因此数据的量为0</li><li>win4096: 客户端告诉服务器, 能接收的数据(缓存)的最大量为4k</li><li>mss1460: 客户端可以处理的单条最大字节数是1460字节</li></ul><p>第2步：第二次握手</p><ul><li>ACK: 服务器同意了客户端的连接请求<ul><li>SYN: 服务器请求和客户端建立连接</li></ul></li><li>8000(0)：8000是服务器端生成的随机序号，(0)表示服务器没有额外给客户端发送数据, 因此数据的量为0</li><li>1: 发送给客户端的确认序号<ul><li>确认序号 &#x3D; 客户端生成的随机序号 + 客户端给服务器发送的数据量(字节数) &#x3D;&#x3D;&#x3D;&gt; 1&#x3D;0+1</li><li>表示客户端给服务器发送的1个字节服务器收到了</li></ul></li><li>win6144: 服务器告诉客户端我能最多缓存 6k数据</li><li>mss1024: 服务器能处理的单条数据最大长度是 1k</li></ul><p>第3步: 第三次握手</p><ul><li>ACK: 客户端同意了服务器的连接请求</li><li>8001: 发送给服务器的确认序号<ul><li>确认序号 &#x3D; 服务器生成的随机序号 + 服务器给客户端发送的数据量 &#x3D;&#x3D;&#x3D;&gt; 8001 &#x3D; 8000 + 1</li><li>客户端告诉服务器, 你给我发送的1个字节的数据我收到了</li></ul></li><li>win4096: 告诉服务器客户端能缓存的最大数据量是4k</li></ul><p>第4~9步: 客户端给服务器发送数据</p><ul><li><p>1(1024)：1 （1-0）表示之前一共给服务器发送了1个字节，(1024)表示这次要发送的数据量为 1k</p></li><li><p>1025(1024)：1025（1025-0）表示之前一共给服务器发送了1025个字节，(1024)表示这次要发送的数据量为 1k</p></li><li><p>2049(1024)：2049（2049-0）表示之前一共给服务器发送了2049个字节，(1024)表示这次要发送的数据量为 1k</p></li><li><p>第9步完成之后，服务器的滑动窗口变为0，接收数据的缓存被写满了，发送端阻塞</p></li></ul><p>第10步:</p><ul><li><p>ack6145: 服务器给客户端回复数据，6145是确认序号, 代表实际接收的字节数<br>服务器实际接收的字节数 &#x3D; 确认序号 - 客户端生成的随机序号 &#x3D;&#x3D;&#x3D;&gt; 6145 &#x3D; 6145 - 0</p></li><li><p>win2048：服务器告诉客户端我的缓存还有2k，也就是还有4k还在缓存中没有被读走</p></li></ul><p>第11步：win4096表示滑动窗口变为4k，代表还可以接收4k数据，还有2k在缓存中</p><p>第12步：客户端又给服务器发送了1k数据</p><p>第13步: 第一次挥手，FIN表示客户端主动和服务器断开连接，并且发送了1k数据到服务器端</p><p>第14步: 第二次挥手，回复ACK, 同意断开连接</p><p>第15, 16步: 服务器端从读缓冲区中读数据, 第16步数据读完, 滑动窗口变成最大的6k</p><p>第17步: 第三次挥手</p><ul><li><p>FIN: 服务器请求和客户端断开连接</p></li><li><p>8001(0): 服务器一共给客户端发送的字节数 8001 - 8000 &#x3D; 1个字节，携带的数据量为0（FIN不计算在内）</p></li><li><p>ack8194: 服务器收到了客户端的多少个字节: 8194 - 0 &#x3D; 8194个字节</p></li></ul><p>第18步: 第四次挥手</p><ul><li>ACK: 客户端同意了服务器断开连接的请求</li><li>8002: 确认序号, 可以计算出服务器给客户端发送了多少数据，8002 - 8000 &#x3D; 2 个字节</li></ul><hr><h1 id="3-TCP状态转换"><a href="#3-TCP状态转换" class="headerlink" title="3. TCP状态转换"></a>3. TCP状态转换</h1><h2 id="3-1-TCP状态转换"><a href="#3-1-TCP状态转换" class="headerlink" title="3.1 TCP状态转换"></a>3.1 TCP状态转换</h2><p>在TCP进行三次握手，或者四次挥手的过程中，通信的服务器和客户端内部会发送状态上的变化，发生的状态变化在程序中是看不到的，这个状态的变化也不需要我们去维护，但在某些情况下进行程序的调试会去查看相关的状态信息，先来看三次握手过程中的状态转换。</p><p><img src="/img/9.36.png" alt="在这里插入图片描述"></p><h3 id="3-1-1-三次握手"><a href="#3-1-1-三次握手" class="headerlink" title="3.1.1 三次握手"></a>3.1.1 三次握手</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在第一次握手之前，服务器端必须先启动，并且已经开始了监听</span><br><span class="line">  - 服务器端先调用了 listen() 函数, 开始监听</span><br><span class="line">  - 服务器启动监听前后的状态变化: 没有状态 ---&gt; LISTEN</span><br></pre></td></tr></table></figure><p>当服务器监听启动之后，由客户端发起的三次握手过程中状态转换如下：</p><p>第一次握手:</p><ul><li>客户端：调用了<code>connect()</code> 函数，状态变化：<code>没有状态 -&gt; SYN_SENT</code></li><li>服务器：收到连接请求SYN，状态变化：<code>LISTEN -&gt; SYN_RCVD</code></li></ul><p>第二次握手:</p><ul><li>服务器：给客户端回复ACK，并且请求和客户端建立连接，状态无变化，依然是 SYN_RCVD</li><li>客户端：接收数据，收到了ACK，状态变化：<code>SYN_SENT -&gt; ESTABLISHED</code></li></ul><p>第三次握手:</p><ul><li>客户端：给服务器回复ACK，同意建立连接，状态没有变化，还是 ESTABLISHED</li><li>服务器：收到了ACK，状态变化：<code>SYN_RCVD -&gt; ESTABLISHED</code></li></ul><p><code>三次握手完成之后，客户端和服务器都变成了同一种状态，这种状态叫：ESTABLISHED，表示双向连接已经建立， 可以通信了。在通过过程中，正常的通信状态就是 ESTABLISHED。</code></p><hr><h3 id="3-1-2-四次挥手"><a href="#3-1-2-四次挥手" class="headerlink" title="3.1.2 四次挥手"></a>3.1.2 四次挥手</h3><p>关于四次挥手对于客户端和服务器哪段先断开连接没有要求，根据实际情况处理即可。下面根据上图中的实例描述一下四次挥手过程中TCP的状态转换（上图中主动断开连接的一方是客户端）：</p><p>第一次挥手:</p><ul><li><p>客户端：调用<code>close()</code> 函数，将tcp协议中的FIN设置为1，请求和服务器断开连接，<br>状态变化:<code>ESTABLISHED -&gt; FIN_WAIT_1</code></p></li><li><p>服务器：收到断开连接请求，状态变化: <code>ESTABLISHED -&gt; CLOSE_WAIT</code></p></li></ul><p>第二次挥手:</p><ul><li>服务器：回复ACK，同意断开连接的请求，状态没有变化，还是 CLOSE_WAIT</li><li>客户端：收到ACK，状态变化：<code>FIN_WAIT_1 -&gt; FIN_WAIT_2</code></li></ul><p>第三次挥手:</p><ul><li>服务器端：调用close() 函数，发送FIN给客户端，请求断开连接，状态变化：<code>CLOSE_WAIT -&gt; LAST_ACK</code></li><li>客户端：收到FIN，状态变化：<code>FIN_WAIT_2 -&gt; TIME_WAIT</code></li></ul><p>第四次挥手:</p><ul><li>客户端：回复ACK给服务器，状态是没有变化的，状态变化：<code>TIME_WAIT -&gt; 没有状态</code></li><li>服务器端：收到ACK，双向连接断开，状态变化：<code>LAST_ACK -&gt; 无状态(没有了)</code></li></ul><hr><h3 id="3-1-3-状态转换"><a href="#3-1-3-状态转换" class="headerlink" title="3.1.3 状态转换"></a>3.1.3 状态转换</h3><p>在下图中同样是描述TCP通信过程中的客户端和服务器端的状态转换<br>只需要看两条主线：红色实线和绿色虚线。关于黑色的实线对应的是一些特殊情况下的状态切换，在此不做任何分析。</p><p>因为三次握手是由客户端发起的，据此分析红色实线表示的客户端的状态，绿色虚线表示的是服务器端的状态。<br><img src="/img/9.37.png" alt="在这里插入图片描述"></p><ul><li>客户端：<ul><li>第一次握手：发送SYN，<code>没有状态 -&gt; SYN_SENT</code></li><li>第二次握手：收到回复的ACK，<code>SYN_SENT -&gt; ESTABLISHED</code></li><li>主动断开连接，第一次挥手发送FIN，状态<code>ESTABLISHED -&gt; FIN_WAIT_1</code></li><li>第二次挥手，收到ACK，状态<code>FIN_WAIT_1 -&gt; FIN_WAIT_2</code></li><li>第三次挥手，收到FIN，状态<code>FIN_WAIT_2 -&gt; TIME_WAIT</code></li><li>第四次挥手，回复ACK，等待2倍报文时长之后，状态<code>TIME_WAIT -&gt; 没有状态</code></li></ul></li><li>服务器端：<ul><li>启动监听，<code>没有状态 -&gt; LISTEN</code></li><li>第一次握手，收到SYN，状态<code>LISTEN -&gt; SYN_RCVD</code></li><li>第三次握手，收到ACK，状态<code>SYN_RCVD -&gt; ESTABLISHED</code></li><li>收到断开连接请求，第一次挥手状态 <code>ESTABLISHED -&gt; CLOSE_WAIT</code></li><li>第三次挥手，发送FIN请求和客户端断开连接，状态<code>CLOSE_WAIT -&gt; LAST_ACK</code></li><li>第四次挥手，收到ACK，状态<code>LAST_ACK -&gt; 无状态(没有了)</code></li></ul></li></ul><p>在TCP通信的时候，当主动断开连接的一方接收到被动断开连接的一方发送的FIN和最终的ACK后（第三次挥手完成），连接的主动关闭方必须处于<code>TIME_WAIT</code>状态并持续<code>2MSL(Maximum Segment Lifetime)</code>时间，这样就能够让TCP连接的主动关闭方在它发送的ACK丢失的情况下重新发送最终的ACK。</p><p>一倍报文寿命(MSL)大概时长为30s，因此两倍报文寿命一般在1分钟作用。</p><p><code>主动关闭方重新发送的最终ACK，是因为被动关闭方重传了它的FIN。事实上，被动关闭方总是重传FIN直到它收到一个最终的ACK。</code></p><hr><h3 id="3-1-4-相关命令"><a href="#3-1-4-相关命令" class="headerlink" title="3.1.4 相关命令"></a>3.1.4 相关命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ netstat 参数</span><br><span class="line">$ netstat -apn| grep 关键字</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li><code>-a</code> (all)显示所有选项</li><li><code>-p</code> 显示建立相关链接的程序名</li><li><code>-n</code> 拒绝显示别名，能显示数字的全部转化成数字。</li><li><code>-l</code> 仅列出有在 Listen (监听) 的服务状态</li><li><code>-t </code>(tcp)仅显示tcp相关选项</li><li><code>-u</code> (udp)仅显示udp相关选项</li></ul></li></ul><hr><h2 id="3-2-半关闭"><a href="#3-2-半关闭" class="headerlink" title="3.2 半关闭"></a>3.2 半关闭</h2><p>TCP连接只有一方发送了FIN，另一方没有发出FIN包，仍然可以在一个方向上正常发送数据，这中状态可以称之为半关闭或者半连接。当四次挥手完成两次的时候，就相当于实现了半关闭，在程序中只需要在某一端直接调用 close() 函数即可。套接字通信默认是双工的，也就是双向通信，如果进行了半关闭就变成了单工，数据只能单向流动了。比如下面的这个例子：</p><ul><li>服务器端:<ul><li>调用了close() 函数，因此不能发数据，只能接收数据</li><li>关闭了服务器端的写操作，现在只能进行读操作 –&gt; 变成了读端</li></ul></li><li>客户端:<ul><li>没有调用close()，客户端和服务器的连接还保持着</li><li>客户端可以给服务器发送数据，也可以接收服务器发送的数据 （但是，服务器已经丧失了发送数据的能力），因此客户端也只能发送数据，接收不到数据 –&gt; 变成了写端</li></ul></li></ul><p>按照上述流程做了半关闭之后，从双工变成了单工，数据单向流动的方向: 客户端 —–&gt; 服务器端。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 专门处理半关闭的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 可以有选择的关闭读/写, close()函数只能关闭写操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd: 要操作的文件描述符</li><li>how:<ul><li>SHUT_RD: 关闭文件描述符对应的读操作</li><li>SHUT_WR: 关闭文件描述符对应的写操作</li><li>SHUT_RDWR: 关闭文件描述符对应的读写操作</li></ul></li></ul></li><li>返回值：函数调用成功返回0，失败返回-1</li></ul><hr><h2 id="3-3-端口复用"><a href="#3-3-端口复用" class="headerlink" title="3.3 端口复用"></a>3.3 端口复用</h2><p>在网络通信中，一个端口只能被一个进程使用，不能多个进程共用同一个端口。我们在进行套接字通信的时候，如果按顺序执行如下操作：先启动服务器程序，再启动客户端程序，然后关闭服务器进程，再退出客户端进程，最后再启动服务器进程，就会出如下错误信息：<code>bind error: Address already in use</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二次启动服务器进程</span></span><br><span class="line">$ ./server </span><br><span class="line"><span class="built_in">bind</span> error: Address already <span class="keyword">in</span> use</span><br><span class="line"></span><br><span class="line">$ netstat -apn|grep 9999</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        0      0 127.0.0.1:9999          127.0.0.1:50178         TIME_WAIT   -   </span><br></pre></td></tr></table></figure><p>通过<code>netstat</code>查看TCP状态，发现上一个服务器进程其实还没有真正退出。<br>因为服务器进程是主动断开连接的进程, 最后状态变成了 <code>TIME_WAIT</code>状态，这个进程会等待<code>2msl(大约1分钟)</code>才会退出，如果该进程不退出，其绑定的端口就不会释放，再次启动新的进程还是使用这个未释放的端口，<code>端口被重复使用</code>，<code>bind error: Address already in use</code></p><p>如果想要解决上述问题，就必须要设置端口复用，使用的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数是一个多功能函数, 可以设置套接字选项</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd：用于监听的文件描述符</li><li>level：设置端口复用需要使用 SOL_SOCKET 宏</li><li>optname：要设置什么属性（下边的两个宏都可以设置端口复用）<ul><li>SO_REUSEADDR</li><li>SO_REUSEPORT</li></ul></li><li>optval：设置是去除端口复用属性还是设置端口复用属性，实际应该使用 int 型变量<ul><li>0：不设置</li><li>1：设置</li></ul></li><li>optlen：optval指针指向的内存大小 sizeof(int)</li></ul></li></ul><blockquote><p>这个函数应该添加到服务器端代码中，具体应放在绑定之前设置端口复用</p></blockquote><ol><li>创建监听的套接字</li><li>设置端口复用</li><li>绑定</li><li>设置监听</li><li>等待并接受客户端连接</li><li>通信</li><li>断开连接</li></ol><p>参考代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">// 本地多有的ＩＰ</span></span><br><span class="line">    <span class="comment">// 127.0.0.1</span></span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr.s_addr);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd_set reads, tmp;</span><br><span class="line">    FD_ZERO(&amp;reads);</span><br><span class="line">    FD_SET(lfd, &amp;reads);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = reads;</span><br><span class="line">        <span class="type">int</span> ret = select(maxfd+<span class="number">1</span>, &amp;tmp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(lfd, &amp;tmp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cfd = accept(lfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            FD_SET(cfd, &amp;reads);</span><br><span class="line">            maxfd = cfd &gt; maxfd ? cfd : maxfd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=lfd+<span class="number">1</span>; i&lt;=maxfd; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(i, &amp;tmp))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">int</span> len = read(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client say: %s\n&quot;</span>, buf);</span><br><span class="line">                    write(i, buf, len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接\n&quot;</span>);</span><br><span class="line">                    FD_CLR(i, &amp;reads);</span><br><span class="line">                    close(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="4-服务器并发"><a href="#4-服务器并发" class="headerlink" title="4. 服务器并发"></a>4. 服务器并发</h1><h2 id="4-1-单线程-进程"><a href="#4-1-单线程-进程" class="headerlink" title="4.1 单线程&#x2F;进程"></a>4.1 单线程&#x2F;进程</h2><p>在TCP通信过程中，服务器端启动之后可以同时和多个客户端建立连接，并进行网络通信，但是在介绍TCP通信流程的时候，提供的服务器代码却不能完成这样的需求<br>看之前的服务器代码的处理思路，分析弊端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 2. 将socket()返回值和本地的IP端口绑定到一起</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="comment">// INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏可以代表任意一个IP地址</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 这个宏的值为0 == 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="comment">// 4. 阻塞等待并接受客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">    <span class="comment">// 5. 和客户端通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">            write(cfd, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中用到了三个会引起程序阻塞的函数，分别是：</p><ul><li><code>accept()</code>：如果服务器端没有新客户端连接，阻塞当前进程&#x2F;线程，如果检测到新连接解除阻塞，建立连接</li><li><code>read()</code>：如果通信的套接字对应的读缓冲区没有数据，阻塞当前进程&#x2F;线程，检测到数据解除阻塞，接收数据</li><li><code>write()</code>：如果通信的套接字写缓冲区被写满了，阻塞当前进程&#x2F;线程（比较少见）</li></ul><p>如果需要和发起新的连接请求的客户端建立连接，那么就必须在服务器端通过一个循环调用<code>accept()</code>函数，另外已经和服务器建立连接的客户端需要和服务器通信，发送数据时的阻塞可以忽略，当接收不到数据时程序也会被阻塞，这时候就会非常矛盾，被<code>accept()</code>阻塞就无法通信，被<code>read()</code>阻塞就无法和客户端建立新连接。<br>基于上述处理方式，在单线程&#x2F;单进程场景下，服务器是无法处理多连接的<br>解决方案也有很多，常用的有三种：</p><ol><li>使用多线程实现</li><li>使用多进程实现</li><li>使用IO多路转接（复用）实现</li><li>使用IO多路转接 + 多线程实现</li></ol><hr><h2 id="4-2-多进程并发"><a href="#4-2-多进程并发" class="headerlink" title="4.2 多进程并发"></a>4.2 多进程并发</h2><p>如果要编写多进程版的并发服务器程序，首先要考虑，创建出的多个进程都是什么角色，这样就可以在程序中对号入座了。在Tcp服务器端一共有两个角色，分别是：监听和通信，监听是一个持续的动作，如果有新连接就建立连接，如果没有新连接就阻塞。关于通信是需要和多个客户端同时进行的，因此需要多个进程，这样才能达到互不影响的效果。进程也有两大类：父进程和子进程，通过分析我们可以这样分配进程：</p><ul><li>父进程：<ul><li>负责监听，处理客户端的连接请求，也就是在父进程中循环调用<code>accept()</code>函数</li><li>创建子进程：建立一个新的连接，就创建一个新的子进程，让这个子进程和对应的客户端通信</li><li>回收子进程资源：子进程退出回收其内核PCB资源，防止出现僵尸进程</li></ul></li><li>子进程：负责通信，基于父进程建立新连接之后得到的文件描述符，和对应的客户端完成数据的接收和发送。<ul><li>发送数据：<code>send() / write()</code></li><li>接收数据：<code>recv() / read()</code></li></ul></li></ul><p>在多进程版的服务器端程序中，多个进程是有血缘关系，对应有血缘关系的进程来说，还需要想明白他们有哪些资源是可以被继承的，哪些资源是独占的，以及一些其他细节：</p><ul><li><p>子进程是父进程的拷贝，在子进程的内核区PCB中，文件描述符也是可以被拷贝的，因此在父进程可以使用的文件描述符在子进程中也有一份，并且可以使用它们做和父进程一样的事情。</p></li><li><p>父子进程有用各自的独立的虚拟地址空间，因此所有的资源都是独占的</p></li><li><p>为了节省系统资源，对于只有在父进程才能用到的资源，可以在子进程中将其释放掉，父进程亦如此。</p></li><li><p>由于需要在父进程中做accept()操作，并且要释放子进程资源，如果想要更高效一下可以使用信号的方式处理<br><img src="/img/9.38.png" alt="在这里插入图片描述"></p></li></ul><p>多进程版并发TCP服务器示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">callback</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(pid &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程正在运行, 或者子进程被回收完毕了\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">childWork</span><span class="params">(<span class="type">int</span> cfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将socket()返回值和本地的IP端口绑定到一起</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="comment">// INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏可以代表任意一个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏一般用于本地的绑定操作</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 这个宏的值为0 == 0.0.0.0</span></span><br><span class="line">    <span class="comment">//    inet_pton(AF_INET, &quot;192.168.237.131&quot;, &amp;addr.sin_addr.s_addr);</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号的捕捉</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = callback;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受多个客户端连接, 对需要循环调用 accept</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 4. 阻塞等待并接受客户端连接</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// accept调用被信号中断了, 解除阻塞, 返回了-1</span></span><br><span class="line">                <span class="comment">// 重新调用一次accept</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印客户端的地址信息</span></span><br><span class="line">        <span class="type">char</span> ip[<span class="number">24</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP地址: %s, 端口: %d\n&quot;</span>,</span><br><span class="line">               inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, <span class="keyword">sizeof</span>(ip)),</span><br><span class="line">               ntohs(cliaddr.sin_port));</span><br><span class="line">        <span class="comment">// 新的连接已经建立了, 创建子进程, 让子进程和这个客户端通信</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 子进程 -&gt; 和客户端通信</span></span><br><span class="line">            <span class="comment">// 通信的文件描述符cfd被拷贝到子进程中</span></span><br><span class="line">            <span class="comment">// 子进程不负责监听</span></span><br><span class="line">            close(lfd);</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> ret = childWork(cfd);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt;=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 退出子进程</span></span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 父进程不和客户端通信</span></span><br><span class="line">            close(cfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 和客户端通信</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">childWork</span><span class="params">(<span class="type">int</span> cfd)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="type">int</span> len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">        write(cfd, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例代码中，父子进程中分别关掉了用不到的文件描述符（父进程不需要通信，子进程也不需要监听）。如果客户端主动断开连接，那么服务器端负责和客户端通信的子进程也就退出了，子进程退出之后会给父进程发送一个叫做<code>SIGCHLD</code>的信号，在父进程中通过<code>sigaction()</code>函数捕捉了该信号，通过回调函数<code>callback()</code>中的<code>waitpid()</code>对退出的子进程进行了资源回收。</p><p>还有一个细节，这是父进程的处理代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// accept调用被信号中断了, 解除阻塞, 返回了-1</span></span><br><span class="line">                <span class="comment">// 重新调用一次accept</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果父进程调用<code>accept()</code> 函数没有检测到新的客户端连接，父进程就阻塞在这儿了，这时候有子进程退出了，发送信号给父进程，父进程就捕捉到了这个信号<code>SIGCHLD</code><br>由于信号的优先级很高，会打断代码正常的执行流程，因此父进程的阻塞被中断，转而去处理这个信号对应的函数<code>callback()</code>，处理完毕<br>再次回到<code>accept()</code>位置，但是这是已经无法阻塞了，函数直接返回-1，此时函数调用失败，错误描述为<code>accept: Interrupted system call</code>，对应的错误号为<code>EINTR</code>，由于代码是被信号中断导致的错误，所以可以在程序中对这个错误号进行判断，让父进程重新调用<code>accept()</code>，继续阻塞或者接受客户端的新连接。</p><hr><h2 id="4-3-多线程并发"><a href="#4-3-多线程并发" class="headerlink" title="4.3 多线程并发"></a>4.3 多线程并发</h2><p>编写多线程版的并发服务器程序和多进程思路差不多，考虑明白了对号入座即可。多线程中的线程有两大类：主线程（父线程）和子线程，他们分别要在服务器端处理监听和通信流程。</p><ul><li>主线程：<ul><li>负责监听，处理客户端的连接请求，也就是在父进程中循环调用<code>accept()</code>函数</li><li>创建子线程：建立一个新的连接，就创建一个新的子进程，让这个子进程和对应的客户端通信</li><li>回收子线程资源：由于回收需要调用阻塞函数，这样就会影响<code>accept()</code>，直接做<code>线程分离</code>即可。</li></ul></li><li>子线程：负责通信，基于主线程建立新连接之后得到的文件描述符，和对应的客户端完成数据的接收和发送。<ul><li>发送数据：<code>send() / write()</code></li><li>接收数据：<code>recv() / read()</code></li></ul></li></ul><p>在多线程版的服务器端程序中，多个线程共用同一个地址空间，有些数据是共享的，有些数据的独占的，分析其中的一些细节：</p><ul><li>同一地址空间中的多个线程的栈空间是独占的</li><li>多个线程共享全局数据区，堆区，以及内核区的文件描述符等资源，因此<code>需要注意数据覆盖</code>问题，并且在多个线程访问共享资源的时候，还需要进行线程同步。<br><img src="/img/9.39.png" alt="在这里插入图片描述"></li></ul><p>多线程版Tcp服务器示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> fd;                      <span class="comment">// 通信</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;               <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span>     <span class="comment">// 地址信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span> <span class="title">infos</span>[128];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span>* <span class="title">info</span> =</span> (<span class="keyword">struct</span> SockInfo*)arg;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> ret = read(info-&gt;fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端已经关闭连接...\n&quot;</span>);</span><br><span class="line">            info-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;接收数据失败...\n&quot;</span>);</span><br><span class="line">            info-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            write(info-&gt;fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于监听的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;          <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">8989</span>);        <span class="comment">// 字节序应该是网络字节序</span></span><br><span class="line">    addr.sin_addr.s_addr =  INADDR_ANY; <span class="comment">// == 0, 获取IP的操作交给了内核</span></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.设置监听</span></span><br><span class="line">    ret = listen(fd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 等待, 接受连接请求</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据初始化</span></span><br><span class="line">    <span class="type">int</span> max = <span class="keyword">sizeof</span>(infos) / <span class="keyword">sizeof</span>(infos[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        bzero(&amp;infos[i], <span class="keyword">sizeof</span>(infos[i]));</span><br><span class="line">        infos[i].fd = <span class="number">-1</span>;</span><br><span class="line">        infos[i].tid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程监听, 子进程通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span>* <span class="title">pinfo</span>;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;max; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(infos[i].fd == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pinfo = &amp;infos[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == max<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> connfd = accept(fd, (<span class="keyword">struct</span> sockaddr*)&amp;pinfo-&gt;addr, &amp;len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent thread, connfd: %d\n&quot;</span>, connfd);</span><br><span class="line">        <span class="keyword">if</span>(connfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pinfo-&gt;fd = connfd;</span><br><span class="line">        pthread_create(&amp;pinfo-&gt;tid, <span class="literal">NULL</span>, working, pinfo);</span><br><span class="line">        pthread_detach(pinfo-&gt;tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd);  <span class="comment">// 监听</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编写多线程版并发服务器代码的时候，需要注意父子线程共用同一个地址空间中的文件描述符，因此每当在主线程中建立一个新的连接，都需要将得到文件描述符值保存起来，不能在同一变量上进行覆盖，这样做丢失了之前的文件描述符值也就不知道怎么和客户端通信了。</p><p>在上面示例代码中是将成功建立连接之后得到的用于通信的文件描述符值保存到了一个全局数组中，每个子线程需要和不同的客户端通信，需要的文件描述符值也就不一样，只要保证存储每个有效文件描述符值的变量对应不同的内存地址，在使用的时候就不会发生数据覆盖的现象，造成通信数据的混乱了。</p><hr><h1 id="5-TCP数据粘包的处理"><a href="#5-TCP数据粘包的处理" class="headerlink" title="5. TCP数据粘包的处理"></a>5. TCP数据粘包的处理</h1><h2 id="5-1-TCP"><a href="#5-1-TCP" class="headerlink" title="5.1 TCP"></a>5.1 TCP</h2><p>在前面介绍套接字通信的时候说到了<code>TCP</code>是传输层协议，它是一个面向连接的、安全的、流式传输协议。因为数据的传输是基于流的所以发送端和接收端每次处理的数据的量，处理数据的频率可以不是对等的，可以按照自身需求来进行决策。</p><p>TCP协议是优势非常明显，但假设我们有需求：</p><blockquote><p>客户端和服务器之间要进行基于TCP的套接字通信</p><ul><li>通信过程中客户端会每次会不定期给服务器发送一个不定长度的有特定含义的字符串。</li><li>通信的服务器端每次都需要接收到客户端这个不定长度的字符串，并对其进行解析</li></ul></blockquote><p>根据上面的描述，服务器在接收数据的时候有如下几种情况：</p><ol><li>一次接收到了客户端发送过来的一个完整的数据包</li><li>一次接收到了客户端发送过来的N个数据包，由于每个包的长度不定，无法将各个数据包拆开</li><li>一次接收到了一个或者N个数据包 + 下一个数据包的一部分，无法将数据包拆开</li><li>一次收到了半个数据包，下一次接收数据的时候收到了剩下的一部分+下个数据包的一部分</li><li>另外，还有一些不可抗拒的因素：比如客户端和服务器端的网速不一样，发送和接收的数据量也会不一致</li></ol><p>对于以上描述的现象很多时候我们将其称之为<code>TCP的粘包问题</code>，<code>本身TCP就是面向连接的流式传输协议，特性如此，我们却说是TCP这个协议出了问题，这是使用者的无知。多个数据包粘连到一起无法拆分是需求过于复杂造成的，是我们的问题而不是协议的问题。</code></p><p>服务器端如果想保证每次都能接收到客户端发送过来的这个不定长度的数据包，如何解决？</p><ol><li>使用标准的应用层协议（比如：http、https）来封装要传输的不定长的数据包</li><li>在每条数据的尾部添加特殊字符, 如果遇到特殊字符, 代表当条数据接收完毕了<ul><li>有缺陷: 效率低, 需要一个字节一个字节接收, 接收一个字节判断一次</li></ul></li><li>在发送数据块之前, 在数据块最前边添加一个固定大小的数据头, 这时候数据由两部分组成：数据头+数据块<ul><li>数据头：存储当前数据包的总字节数，接收端先接收数据头，然后在根据数据头接收对应大小的字节</li><li>数据块：当前数据包的内容</li></ul></li></ol><hr><h2 id="5-2-解决方案"><a href="#5-2-解决方案" class="headerlink" title="5.2 解决方案"></a>5.2 解决方案</h2><p>如果使用TCP进行套接字通信，如果发送的数据包粘连到一起导致接收端无法解析，我们通常使用添加包头的方式解决这个问题。<br>关于数据包的包头大小可以根据自己的实际需求进行设定，这里没特殊需求，因此规定包头的固定大小为4个字节，用于存储当前数据块的总字节数。<br><img src="/img/9.40.png" alt="在这里插入图片描述"></p><h3 id="5-2-1-发送端"><a href="#5-2-1-发送端" class="headerlink" title="5.2.1 发送端"></a>5.2.1 发送端</h3><p>对于发送端来说，数据的发送分为4步：</p><ol><li>根据待发送的数据长度N动态申请一块固定大小的内存：N+4（4是包头占用的字节数）</li><li>将待发送数据的总长度写入申请的内存的前四字节中，<code>此处需要将其转换为网络字节序(大端)</code></li><li>将待发送的数据拷贝到包头后边的地址空间中，将完整的数据包发送出去<code>（字符串没有字节序问题）</code></li><li>释放申请的堆内存。</li></ol><p>由于发送端每次都需要将这个数据包完整的发送出去，因此可以设计一个发送函数，如果当前数据包中的数据没有发送完就让它一直发送，处理代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数描述: 发送指定的字节数</span></span><br><span class="line"><span class="comment">函数参数:</span></span><br><span class="line"><span class="comment">    - fd: 通信的文件描述符(套接字)</span></span><br><span class="line"><span class="comment">    - msg: 待发送的原始数据</span></span><br><span class="line"><span class="comment">    - size: 待发送的原始数据的总字节数</span></span><br><span class="line"><span class="comment">函数返回值: 函数调用成功返回发送的字节数, 发送失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* buf = msg;</span><br><span class="line">    <span class="type">int</span> count = size;</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> len = send(fd, buf, count, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buf += len;</span><br><span class="line">        count -= len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个功能函数之后就可以发送带有包头的数据块了，具体处理动作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数描述: 发送带有数据头的数据包</span></span><br><span class="line"><span class="comment">函数参数:</span></span><br><span class="line"><span class="comment">    - cfd: 通信的文件描述符(套接字)</span></span><br><span class="line"><span class="comment">    - msg: 待发送的原始数据</span></span><br><span class="line"><span class="comment">    - len: 待发送的原始数据的总字节数</span></span><br><span class="line"><span class="comment">函数返回值: 函数调用成功返回发送的字节数, 发送失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendMsg</span><span class="params">(<span class="type">int</span> cfd, <span class="type">char</span>* msg, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(msg == <span class="literal">NULL</span> || len &lt;= <span class="number">0</span> || cfd &lt;=<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 申请内存空间: 数据长度 + 包头4字节(存储数据长度)</span></span><br><span class="line">   <span class="type">char</span>* data = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len+<span class="number">4</span>);</span><br><span class="line">   <span class="type">int</span> bigLen = htonl(len);</span><br><span class="line">   <span class="built_in">memcpy</span>(data, &amp;bigLen, <span class="number">4</span>);</span><br><span class="line">   <span class="built_in">memcpy</span>(data+<span class="number">4</span>, msg, len);</span><br><span class="line">   <span class="comment">// 发送数据</span></span><br><span class="line">   <span class="type">int</span> ret = writen(cfd, data, len+<span class="number">4</span>);</span><br><span class="line">   <span class="comment">// 释放内存</span></span><br><span class="line">   <span class="built_in">free</span>(data);</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>字符串没有字节序问题，但是数据头不是字符串是整形，因此需从主机字节序转换为网络字节序再发送。</code></p><hr><h3 id="5-2-2-接收端"><a href="#5-2-2-接收端" class="headerlink" title="5.2.2 接收端"></a>5.2.2 接收端</h3><p>了解了套接字的发送端如何发送数据，接收端的处理步骤也就清晰了，具体过程如下：</p><ol><li>首先接收4字节数据，并将其从网络字节序转换为主机字节序，这样就得到了即将要接收的数据的总长度</li><li>根据得到的长度申请固定大小的堆内存，用于存储待接收的数据</li><li>根据得到的数据块长度接收固定数目的数据保存到申请的堆内存中</li><li>处理接收的数据</li><li>释放存储数据的堆内存</li></ol><p>从数据包头解析出要接收的数据长度之后，还需要将这个数据块完整的接收到本地才能进行后续的数据处理，因此需要编写一个接收数据的功能函数，保证能够得到一个完整的数据包数据<br>处理函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数描述: 接收指定的字节数</span></span><br><span class="line"><span class="comment">函数参数:</span></span><br><span class="line"><span class="comment">    - fd: 通信的文件描述符(套接字)</span></span><br><span class="line"><span class="comment">    - buf: 存储待接收数据的内存的起始地址</span></span><br><span class="line"><span class="comment">    - size: 指定要接收的字节数</span></span><br><span class="line"><span class="comment">函数返回值: 函数调用成功返回发送的字节数, 发送失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* pt = buf;</span><br><span class="line">    <span class="type">int</span> count = size;</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> len = recv(fd, pt, count, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> size - count;</span><br><span class="line">        &#125;</span><br><span class="line">        pt += len;</span><br><span class="line">        count -= len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数搞定之后，就可以轻松地接收带包头的数据块了，接收函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数描述: 接收带数据头的数据包</span></span><br><span class="line"><span class="comment">函数参数:</span></span><br><span class="line"><span class="comment">    - cfd: 通信的文件描述符(套接字)</span></span><br><span class="line"><span class="comment">    - msg: 一级指针的地址，函数内部会给这个指针分配内存，用于存储待接收的数据，这块内存需要使用者释放</span></span><br><span class="line"><span class="comment">函数返回值: 函数调用成功返回接收的字节数, 发送失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recvMsg</span><span class="params">(<span class="type">int</span> cfd, <span class="type">char</span>** msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="comment">// 1. 读数据头</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    readn(cfd, (<span class="type">char</span>*)&amp;len, <span class="number">4</span>);</span><br><span class="line">    len = ntohl(len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据块大小: %d\n&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据读出的长度分配内存，+1 -&gt; 这个字节存储\0</span></span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ret = readn(cfd, buf, len);</span><br><span class="line">    <span class="keyword">if</span>(ret != len)</span><br><span class="line">    &#123;</span><br><span class="line">        close(cfd);</span><br><span class="line">        <span class="built_in">free</span>(buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    *msg = buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在进行套接字通信的时候通过调用封装的<code>sendMsg()</code>和<code>recvMsg()</code>就可以发送和接收带数据头的数据包了，而且完美地解决了粘包的问题。</p><hr><h1 id="6-套接字通信类的封装"><a href="#6-套接字通信类的封装" class="headerlink" title="6. 套接字通信类的封装"></a>6. 套接字通信类的封装</h1><p>在掌握了基于TCP的套接字通信流程之后，为了方便使用，提高编码效率，可以对通信操作进行封装，先基于C语言进行面向过程的函数封装，再基于C++进行面向对象的类封装。</p><h2 id="6-1-基于C语言的封装"><a href="#6-1-基于C语言的封装" class="headerlink" title="6.1 基于C语言的封装"></a>6.1 基于C语言的封装</h2><p>基于TCP的套接字通信分为两部分：服务器端通信和客户端通信。只要掌握了通信流程，封装出对应的功能函数也就不在话下了，回顾一下通信流程：</p><ul><li>服务器端<ol><li>创建用于监听的套接字</li><li>将用于监听的套接字和本地的IP以及端口进行绑定</li><li>启动监听</li><li>等待并接受新的客户端连接，连接建立得到用于通信的套接字和客户端的IP、端口信息</li><li>使用得到的通信的套接字和客户端通信（接收和发送数据）</li><li>通信结束，关闭套接字（监听 + 通信）</li></ol></li><li>客户端<ol><li>创建用于通信的套接字</li><li>使用服务器端绑定的IP和端口连接服务器</li><li>使用通信的套接字和服务器通信（发送和接收数据）</li><li>通信结束，关闭套接字（通信）</li></ol></li></ul><h3 id="6-1-1-函数声明"><a href="#6-1-1-函数声明" class="headerlink" title="6.1.1 函数声明"></a>6.1.1 函数声明</h3><p>通过通信流程可以看出服务器和客户端有些操作步骤是相同的，因此封装的功能函数是可以共用的，相关的通信函数声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////////////////////////// </span></span><br><span class="line"><span class="comment">//////////////////// 服务器 ///////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bindSocket</span><span class="params">(<span class="type">int</span> lfd, <span class="type">unsigned</span> <span class="type">short</span> port)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setListen</span><span class="params">(<span class="type">int</span> lfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">acceptConn</span><span class="params">(<span class="type">int</span> lfd, <span class="keyword">struct</span> sockaddr_in *addr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////// </span></span><br><span class="line"><span class="comment">//////////////////// 客户端 ///////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connectToHost</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////// </span></span><br><span class="line"><span class="comment">///////////////////// 共用 ////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">createSocket</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sendMsg</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* msg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">recvMsg</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* msg, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">closeSocket</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><p>关于函数readn()和writen()的作用 参考 TCP数据粘包处理</p><hr><h3 id="6-1-2-函数定义"><a href="#6-1-2-函数定义" class="headerlink" title="6.1.2 函数定义"></a>6.1.2 函数定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建监套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">createSocket</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;套接字创建成功, fd=%d\n&quot;</span>, fd);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定本地的IP和端口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bindSocket</span><span class="params">(<span class="type">int</span> lfd, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(port);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0 = 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;套接字绑定成功, ip: %s, port: %d\n&quot;</span>,</span><br><span class="line">           inet_ntoa(saddr.sin_addr), port);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置监听</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setListen</span><span class="params">(<span class="type">int</span> lfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;设置监听成功...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞并等待客户端的连接</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">acceptConn</span><span class="params">(<span class="type">int</span> lfd, <span class="keyword">struct</span> sockaddr_in *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cfd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(addr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cfd = accept(lfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">        cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)addr, &amp;addrlen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功和客户端建立连接...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> cfd; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recvMsg</span><span class="params">(<span class="type">int</span> cfd, <span class="type">char</span>** msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(msg == <span class="literal">NULL</span> || cfd &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="comment">// 1. 读数据头</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    readn(cfd, (<span class="type">char</span>*)&amp;len, <span class="number">4</span>);</span><br><span class="line">    len = ntohl(len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据块大小: %d\n&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据读出的长度分配内存</span></span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ret = readn(cfd, buf, len);</span><br><span class="line">    <span class="keyword">if</span>(ret != len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    *msg = buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendMsg</span><span class="params">(<span class="type">int</span> cfd, <span class="type">char</span>* msg, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(msg == <span class="literal">NULL</span> || len &lt;= <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 申请内存空间: 数据长度 + 包头4字节(存储数据长度)</span></span><br><span class="line">   <span class="type">char</span>* data = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len+<span class="number">4</span>);</span><br><span class="line">   <span class="type">int</span> bigLen = htonl(len);</span><br><span class="line">   <span class="built_in">memcpy</span>(data, &amp;bigLen, <span class="number">4</span>);</span><br><span class="line">   <span class="built_in">memcpy</span>(data+<span class="number">4</span>, msg, len);</span><br><span class="line">   <span class="comment">// 发送数据</span></span><br><span class="line">   <span class="type">int</span> ret = writen(cfd, data, len+<span class="number">4</span>);</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接服务器</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connectToHost</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2. 连接服务器IP port</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;saddr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功和服务器建立连接...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closeSocket</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = close(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收指定的字节数</span></span><br><span class="line"><span class="comment">// 函数调用成功返回 size</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nread = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = size;</span><br><span class="line">    <span class="type">char</span>* p = buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((nread = read(fd, p, left)) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p += nread;</span><br><span class="line">            left -= nread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nread == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送指定的字节数</span></span><br><span class="line"><span class="comment">// 函数调用成功返回 size</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> left = size;</span><br><span class="line">    <span class="type">int</span> nwrite = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p = msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((nwrite = write(fd, msg, left)) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p += nwrite;</span><br><span class="line">            left -= nwrite;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nwrite == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="6-2-基于C-的封装"><a href="#6-2-基于C-的封装" class="headerlink" title="6.2 基于C++的封装"></a>6.2 基于C++的封装</h2><p>编写C++程序应当遵循面向对象三要素：封装、继承、多态。简单地说就是封装之后的类可以隐藏掉某些属性使操作更简单并且类的功能要单一，如果要代码重用可以进行类之间的继承，如果要让函数的使用更加灵活可以使用多态。<br>因此，我们需要封装两个类：客户端类和服务器端的类。</p><h3 id="6-2-1-版本1"><a href="#6-2-1-版本1" class="headerlink" title="6.2.1 版本1"></a>6.2.1 版本1</h3><p>根据面向对象的思想，整个通信过程不管是监听还是通信的套接字都是可以封装到类的内部并且将其隐藏掉，这样相关操作函数的参数也就随之减少了，使用者用起来也更简便。</p><h4 id="6-2-1-1-客户端"><a href="#6-2-1-1-客户端" class="headerlink" title="6.2.1.1 客户端"></a>6.2.1.1 客户端</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TcpClient</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TcpClient</span>();</span><br><span class="line">    ~<span class="built_in">TcpClient</span>();</span><br><span class="line">    <span class="comment">// int connectToHost(int fd, const char* ip, unsigned short port);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">connectToHost</span><span class="params">(string ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int sendMsg(int fd, const char* msg);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sendMsg</span><span class="params">(string msg)</span></span>;</span><br><span class="line">    <span class="comment">// int recvMsg(int fd, char* msg, int size);</span></span><br><span class="line">    <span class="function">string <span class="title">recvMsg</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// int createSocket();</span></span><br><span class="line">    <span class="comment">// int closeSocket(int fd);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// int readn(int fd, char* buf, int size);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line">    <span class="comment">// int writen(int fd, const char* msg, int size);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">writen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cfd;<span class="comment">// 通信的套接字</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过对客户端的操作进行封装，我们可以看到有如下的变化：</p><ol><li>文件描述被隐藏了，封装到了类的内部已经无法进行外部访问</li><li>功能函数的参数变少了，因为类成员函数可以直接使用类内部的成员变量。</li><li>创建和销毁套接字的函数去掉了，这两个操作可以分别放到构造和析构函数内部进行处理。</li><li>在C++中可以适当的将char* 替换为 string 类，这样操作字符串就更简便一些。</li></ol><hr><h4 id="6-2-1-2-服务器端"><a href="#6-2-1-2-服务器端" class="headerlink" title="6.2.1.2 服务器端"></a>6.2.1.2 服务器端</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TcpServer</span>();</span><br><span class="line">    ~<span class="built_in">TcpServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int bindSocket(int lfd, unsigned short port) + int setListen(int lfd)</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">setListen</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line">    <span class="comment">// int acceptConn(int lfd, struct sockaddr_in *addr);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">acceptConn</span><span class="params">(<span class="keyword">struct</span> sockaddr_in *addr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int sendMsg(int fd, const char* msg);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sendMsg</span><span class="params">(string msg)</span></span>;</span><br><span class="line">    <span class="comment">// int recvMsg(int fd, char* msg, int size);</span></span><br><span class="line">    <span class="function">string <span class="title">recvMsg</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// int createSocket();</span></span><br><span class="line">    <span class="comment">// int closeSocket(int fd);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// int readn(int fd, char* buf, int size);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line">    <span class="comment">// int writen(int fd, const char* msg, int size);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">writen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> lfd;<span class="comment">// 监听的套接字</span></span><br><span class="line">    <span class="type">int</span> cfd;<span class="comment">// 通信的套接字</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过对服务器端的操作进行封装，我们可以看到这个类和客户端的类结构以及封装思路是差不多的，并且两个类的内部有些操作的重叠的：接收和发送通信数据的函数<code>recvMsg()</code>、<code>sendMsg()</code>，以及内部函数<code>readn()</code>、<code>writen()</code>。<br>不仅如此服务器端的类设计成这样样子是有缺陷的：<code>服务器端一般需要和多个客户端建立连接，因此通信的套接字就需要有N个，但是在上面封装的类里边只有一个。</code></p><p>如何解决服务器和客户端的代码冗余和服务器不能跟多客户端通信的问题？</p><p><code>减负。可以将服务器的通信功能去掉，只留下监听并建立新连接一个功能。将客户端类变成一个专门用于套接字通信的类即可。服务器端整个流程使用服务器类+通信类来处理；客户端整个流程通过通信的类来处理。</code></p><hr><h3 id="6-2-2-版本2"><a href="#6-2-2-版本2" class="headerlink" title="6.2.2 版本2"></a>6.2.2 版本2</h3><p>根据对第一个版本的分析，可以对以上代码做如下修改：</p><h4 id="6-2-2-1-通信类"><a href="#6-2-2-1-通信类" class="headerlink" title="6.2.2.1 通信类"></a>6.2.2.1 通信类</h4><p>套接字通信类既可以在客户端使用，也可以在服务器端使用，职责是接收和发送数据包。</p><p>类声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TcpSocket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TcpSocket</span>();</span><br><span class="line">    <span class="built_in">TcpSocket</span>(<span class="type">int</span> socket);</span><br><span class="line">    ~<span class="built_in">TcpSocket</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">connectToHost</span><span class="params">(string ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sendMsg</span><span class="params">(string msg)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">recvMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">writen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_fd;<span class="comment">// 通信的套接字</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>(<span class="type">int</span> socket)</span><br><span class="line">&#123;</span><br><span class="line">    m_fd = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::~<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_fd &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::connectToHost</span><span class="params">(string ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 连接服务器IP port</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip.<span class="built_in">data</span>(), &amp;saddr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(m_fd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;成功和服务器建立连接...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::sendMsg</span><span class="params">(string msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 申请内存空间: 数据长度 + 包头4字节(存储数据长度)</span></span><br><span class="line">    <span class="type">char</span>* data = <span class="keyword">new</span> <span class="type">char</span>[msg.<span class="built_in">size</span>() + <span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> bigLen = <span class="built_in">htonl</span>(msg.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">memcpy</span>(data, &amp;bigLen, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(data + <span class="number">4</span>, msg.<span class="built_in">data</span>(), msg.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">writen</span>(data, msg.<span class="built_in">size</span>() + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">delete</span>[]data;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">TcpSocket::recvMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="comment">// 1. 读数据头</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">readn</span>((<span class="type">char</span>*)&amp;len, <span class="number">4</span>);</span><br><span class="line">    len = <span class="built_in">ntohl</span>(len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;数据块大小: &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据读出的长度分配内存</span></span><br><span class="line">    <span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">readn</span>(buf, len);</span><br><span class="line">    <span class="keyword">if</span> (ret != len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="function">string <span class="title">retStr</span><span class="params">(buf)</span></span>;</span><br><span class="line">    <span class="keyword">delete</span>[]buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nread = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = size;</span><br><span class="line">    <span class="type">char</span>* p = buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = <span class="built_in">read</span>(m_fd, p, left)) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p += nread;</span><br><span class="line">            left -= nread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::writen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = size;</span><br><span class="line">    <span class="type">int</span> nwrite = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p = msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nwrite = <span class="built_in">write</span>(m_fd, msg, left)) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p += nwrite;</span><br><span class="line">            left -= nwrite;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nwrite == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第二个版本的套接字通信类中一共有两个构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>(<span class="type">int</span> socket)</span><br><span class="line">&#123;</span><br><span class="line">    m_fd = socket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>无参构造一般在客户端使用，通过这个套接字对象再和服务器进行连接，之后就可以通信了</code></li><li><code>有参构造主要在服务器端使用，当服务器端得到了一个用于通信的套接字对象之后，就可以基于这个套接字直接通信，因此不需要再次进行连接操作。</code></li></ul><hr><h4 id="6-2-2-2-服务器类"><a href="#6-2-2-2-服务器类" class="headerlink" title="6.2.2.2 服务器类"></a>6.2.2.2 服务器类</h4><p>服务器类主要用于套接字通信的服务器端，并且没有通信能力，当服务器和客户端的新连接建立之后，需要通过<code>TcpSocket</code>类的带参构造将通信的描述符包装成一个通信对象，这样就可以使用这个对象和客户端通信了。</p><p>类声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TcpServer</span>();</span><br><span class="line">    ~<span class="built_in">TcpServer</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">setListen</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line">    <span class="function">TcpSocket* <span class="title">acceptConn</span><span class="params">(<span class="keyword">struct</span> sockaddr_in* addr = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_fd;<span class="comment">// 监听的套接字</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">TcpServer::<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpServer::~<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(m_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpServer::setListen</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0 = 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(m_fd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;套接字绑定成功, ip: &quot;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">inet_ntoa</span>(saddr.sin_addr)</span><br><span class="line">        &lt;&lt; <span class="string">&quot;, port: &quot;</span> &lt;&lt; port &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(m_fd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;设置监听成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TcpSocket* <span class="title">TcpServer::acceptConn</span><span class="params">(sockaddr_in* addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">    <span class="type">int</span> cfd = <span class="built_in">accept</span>(m_fd, (<span class="keyword">struct</span> sockaddr*)addr, &amp;addrlen);</span><br><span class="line">    <span class="keyword">if</span> (cfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功和客户端建立连接...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TcpSocket</span>(cfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调整可以发现，套接字服务器类功能更加单一了，这样设计即解决了代码冗余问题，还能使这两个类更容易维护。</p><hr><h2 id="6-3-测试代码"><a href="#6-3-测试代码" class="headerlink" title="6.3 测试代码"></a>6.3 测试代码</h2><h3 id="6-3-1-客户端"><a href="#6-3-1-客户端" class="headerlink" title="6.3.1 客户端"></a>6.3.1 客户端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    TcpSocket tcp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器IP port</span></span><br><span class="line">    <span class="type">int</span> ret = tcp.<span class="built_in">connectToHost</span>(<span class="string">&quot;192.168.237.131&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="type">int</span> fd1 = <span class="built_in">open</span>(<span class="string">&quot;english.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="built_in">sizeof</span>(tmp));</span><br><span class="line">    <span class="keyword">while</span> ((length = <span class="built_in">read</span>(fd1, tmp, <span class="built_in">sizeof</span>(tmp))) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        tcp.<span class="built_in">sendMsg</span>(<span class="built_in">string</span>(tmp, length));</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;send Msg: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; tmp &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="built_in">sizeof</span>(tmp));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-2-服务器端"><a href="#6-3-2-服务器端" class="headerlink" title="6.3.2 服务器端"></a>6.3.2 服务器端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SockInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    TcpServer* s;</span><br><span class="line">    TcpSocket* tcp;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">working</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SockInfo</span>* pinfo = <span class="built_in">static_cast</span>&lt;<span class="keyword">struct</span> SockInfo*&gt;(arg);</span><br><span class="line">    <span class="comment">// 连接建立成功, 打印客户端的IP和端口信息</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP: %s, 端口: %d\n&quot;</span>,</span><br><span class="line">        <span class="built_in">inet_ntop</span>(AF_INET, &amp;pinfo-&gt;addr.sin_addr.s_addr, ip, <span class="built_in">sizeof</span>(ip)),</span><br><span class="line">        <span class="built_in">ntohs</span>(pinfo-&gt;addr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 通信</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收数据: .....\n&quot;</span>);</span><br><span class="line">        string msg = pinfo-&gt;tcp-&gt;<span class="built_in">recvMsg</span>();</span><br><span class="line">        <span class="keyword">if</span> (!msg.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; msg &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> pinfo-&gt;tcp;</span><br><span class="line">    <span class="keyword">delete</span> pinfo;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    TcpServer s;</span><br><span class="line">    <span class="comment">// 2. 绑定本地的IP port并设置监听</span></span><br><span class="line">    s.<span class="built_in">setListen</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="comment">// 3. 阻塞并等待客户端的连接</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        SockInfo* info = <span class="keyword">new</span> SockInfo;</span><br><span class="line">        TcpSocket* tcp = s.<span class="built_in">acceptConn</span>(&amp;info-&gt;addr);</span><br><span class="line">        <span class="keyword">if</span> (tcp == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;重试....&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        info-&gt;s = &amp;s;</span><br><span class="line">        info-&gt;tcp = tcp;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, working, info);</span><br><span class="line">        <span class="built_in">pthread_detach</span>(tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="6-4-测试代码-self"><a href="#6-4-测试代码-self" class="headerlink" title="6.4 测试代码(self)"></a>6.4 测试代码(self)</h2><h3 id="6-4-1-服务器端"><a href="#6-4-1-服务器端" class="headerlink" title="6.4.1 服务器端"></a>6.4.1 服务器端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpSocket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">TcpSocket</span>();</span><br><span class="line"><span class="built_in">TcpSocket</span>(<span class="type">int</span> socket);</span><br><span class="line">~<span class="built_in">TcpSocket</span>();</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ConnectToHost</span><span class="params">(string ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SendMsg</span><span class="params">(string msg)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">ReadMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">written</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="type">int</span> m_fd; <span class="comment">//通信的套接字</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>(<span class="type">int</span> socket)</span><br><span class="line">&#123;</span><br><span class="line">m_fd = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::~<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_fd &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">close</span>(m_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::ConnectToHost</span><span class="params">(string ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sockaddr_in addr;</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET, ip.<span class="built_in">data</span>(), &amp;addr.sin_addr.s_addr);</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">connect</span>(m_fd, (sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;connect sucessfully&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::written</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> readplace = <span class="number">0</span>; <span class="comment">//开始读取数据的坐标</span></span><br><span class="line"><span class="type">int</span> remain = size;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* space = buf;</span><br><span class="line"><span class="keyword">while</span> (remain &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((readplace = <span class="built_in">write</span>(m_fd, space, remain)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">space += readplace;</span><br><span class="line">remain -= readplace;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (readplace == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::SendMsg</span><span class="params">(string msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[msg.<span class="built_in">size</span>() + <span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> sizeflag = <span class="built_in">htonl</span>(msg.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">memcpy</span>(buf, &amp;sizeflag, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(buf + <span class="number">4</span>, msg.<span class="built_in">data</span>(), msg.<span class="built_in">size</span>());</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">written</span>(buf, msg.<span class="built_in">size</span>() + <span class="number">4</span>);</span><br><span class="line"><span class="keyword">delete</span>[] buf;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> readplace = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> remain = size;</span><br><span class="line"><span class="type">char</span>* space = buf;</span><br><span class="line"><span class="keyword">while</span> (remain &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((readplace = <span class="built_in">read</span>(m_fd, space, remain)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">space += readplace;   <span class="comment">//space指针后移,以下次读取</span></span><br><span class="line">remain -= readplace;  <span class="comment">//读取大小跟随减小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (readplace == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">TcpSocket::ReadMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">readn</span>((<span class="type">char</span>*)&amp;len, <span class="number">4</span>); <span class="comment">//从描述符里面读取前四位,将大端数据放入len</span></span><br><span class="line">len = <span class="built_in">ntohl</span>(len);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;the size of msg : &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始接受真正的数据</span></span><br><span class="line"><span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">readn</span>(buf, len);</span><br><span class="line"><span class="keyword">if</span> (ret != len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br><span class="line">buf[len] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//自行加入结束符,因此多开辟一字节空间</span></span><br><span class="line"><span class="function">string <span class="title">returnstr</span><span class="params">(buf)</span></span>;</span><br><span class="line"><span class="keyword">delete</span>[] buf;</span><br><span class="line"><span class="keyword">return</span> returnstr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">TcpServer</span>();</span><br><span class="line">~<span class="built_in">TcpServer</span>();</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SetListen</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"><span class="function">TcpSocket* <span class="title">AcceptConnect</span><span class="params">(sockaddr_in* addr = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> l_fd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TcpServer::<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">l_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpServer::~<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">close</span>(l_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpServer::SetListen</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sockaddr_in addr;</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY; </span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">bind</span>(l_fd, (sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bind sucessfully &quot;</span>&lt;&lt; endl</span><br><span class="line">&lt;&lt;<span class="string">&quot;ip : &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(addr.sin_addr) &lt;&lt; endl</span><br><span class="line">&lt;&lt; <span class="string">&quot;port : &quot;</span> &lt;&lt; port &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">listen</span>(l_fd, <span class="number">128</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;set listen sucessfully&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TcpSocket* <span class="title">TcpServer::AcceptConnect</span><span class="params">(sockaddr_in* addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (addr == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">socklen_t</span> addrlen = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line"><span class="type">int</span> m_fd = <span class="built_in">accept</span>(l_fd, (sockaddr*)addr, &amp;addrlen);</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (m_fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;accept sucessfully&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TcpSocket</span>(m_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SocketPackage</span></span><br><span class="line">&#123;</span><br><span class="line">TcpServer* lsntcp;</span><br><span class="line">TcpSocket* msgtcp;</span><br><span class="line">sockaddr_in addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Working</span><span class="params">(<span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SocketPackage* pkg = <span class="built_in">static_cast</span>&lt;SocketPackage*&gt;(args);</span><br><span class="line"><span class="type">char</span> ip[<span class="number">32</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;client ip : &quot;</span> &lt;&lt; <span class="built_in">inet_ntop</span>(AF_INET, &amp;pkg-&gt;addr.sin_addr.s_addr, ip, <span class="built_in">sizeof</span>(ip)) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;client port : &quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(pkg-&gt;addr.sin_port) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通信</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;client say :: &quot;</span>;</span><br><span class="line">string msg = pkg-&gt;msgtcp-&gt;<span class="built_in">ReadMsg</span>();</span><br><span class="line"><span class="keyword">if</span> (!msg.<span class="built_in">empty</span>())</span><br><span class="line">cout &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> pkg-&gt;msgtcp;</span><br><span class="line"><span class="keyword">delete</span> pkg;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TcpServer server;</span><br><span class="line">server.<span class="built_in">SetListen</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始通信</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">SocketPackage* pkg = <span class="keyword">new</span> SocketPackage;</span><br><span class="line">TcpSocket* msgret = server.<span class="built_in">AcceptConnect</span>(&amp;pkg-&gt;addr);</span><br><span class="line"><span class="keyword">if</span> (msgret == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;new fail again&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建线程</span></span><br><span class="line">pkg-&gt;lsntcp = &amp;server;</span><br><span class="line">pkg-&gt;msgtcp = msgret;</span><br><span class="line"><span class="function">thread <span class="title">child</span><span class="params">(Working,pkg)</span></span>;</span><br><span class="line">child.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-4-2-客户端"><a href="#6-4-2-客户端" class="headerlink" title="6.4.2 客户端"></a>6.4.2 客户端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpSocket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">TcpSocket</span>();</span><br><span class="line"><span class="built_in">TcpSocket</span>(<span class="type">int</span> socket);</span><br><span class="line">~<span class="built_in">TcpSocket</span>();</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ConnectToHost</span><span class="params">(string ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SendMsg</span><span class="params">(string msg)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">ReadMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">written</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="type">int</span> m_fd; <span class="comment">//通信的套接字</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>(<span class="type">int</span> socket)</span><br><span class="line">&#123;</span><br><span class="line">m_fd = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::~<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(m_fd &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">close</span>(m_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::ConnectToHost</span><span class="params">(string ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sockaddr_in addr;</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET, ip.<span class="built_in">data</span>(), &amp;addr.sin_addr.s_addr);</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">connect</span>(m_fd, (sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;connect sucessfully&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::written</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> readplace = <span class="number">0</span>; <span class="comment">//开始读取数据的坐标</span></span><br><span class="line"><span class="type">int</span> remain = size;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* space = buf;</span><br><span class="line"><span class="keyword">while</span> (remain &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((readplace = <span class="built_in">write</span>(m_fd, space, remain)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">space += readplace;</span><br><span class="line">remain -= readplace;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (readplace == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::SendMsg</span><span class="params">(string msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[msg.<span class="built_in">size</span>() + <span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> sizeflag = <span class="built_in">htonl</span>(msg.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">memcpy</span>(buf, &amp;sizeflag, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(buf + <span class="number">4</span>, msg.<span class="built_in">data</span>(), msg.<span class="built_in">size</span>());</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">written</span>(buf, msg.<span class="built_in">size</span>() + <span class="number">4</span>);</span><br><span class="line"><span class="keyword">delete</span>[] buf;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> readplace = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> remain = size;</span><br><span class="line"><span class="type">char</span>* space = buf;</span><br><span class="line"><span class="keyword">while</span> (remain &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (readplace = <span class="built_in">read</span>(m_fd, space, remain) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">space += readplace;   <span class="comment">//space指针后移,以下次读取</span></span><br><span class="line">remain -= readplace;  <span class="comment">//读取大小跟随减小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (readplace == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">TcpSocket::ReadMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">readn</span>((<span class="type">char</span>*)&amp;len,<span class="number">4</span>); <span class="comment">//从描述符里面读取前四位,将大端数据放入len</span></span><br><span class="line">len = <span class="built_in">ntohl</span>(len);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;the size of msg : &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始接受真正的数据</span></span><br><span class="line"><span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[len+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">readn</span>(buf, len);</span><br><span class="line"><span class="keyword">if</span> (ret != len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br><span class="line">buf[len] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//自行加入结束符,因此多开辟一字节空间</span></span><br><span class="line"><span class="function">string <span class="title">returnstr</span><span class="params">(buf)</span></span>;</span><br><span class="line"><span class="keyword">delete</span>[] buf;</span><br><span class="line"><span class="keyword">return</span> returnstr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TcpSocket client;</span><br><span class="line"><span class="type">int</span> ret = client.<span class="built_in">ConnectToHost</span>(<span class="string">&quot;192.168.200.129&quot;</span>, <span class="number">10000</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始发数据</span></span><br><span class="line"><span class="type">int</span> tmpfd = <span class="built_in">open</span>(<span class="string">&quot;english.txt&quot;</span>, O_RDWR);</span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = <span class="built_in">read</span>(tmpfd, buf, <span class="built_in">sizeof</span>(buf))) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">client.<span class="built_in">SendMsg</span>(<span class="built_in">string</span>(buf,len));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;client send msg : &quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">300</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="7-IO多路转接（复用）之select"><a href="#7-IO多路转接（复用）之select" class="headerlink" title="7. IO多路转接（复用）之select"></a>7. IO多路转接（复用）之select</h1><h2 id="7-1-IO多路转接-复用"><a href="#7-1-IO多路转接-复用" class="headerlink" title="7.1 IO多路转接(复用)"></a>7.1 IO多路转接(复用)</h2><p>IO多路转接也称为IO多路复用，它是一种网络通信的手段（机制）<br>通过这种方式可以<code>同时监测多个文件描述符并且这个过程是阻塞的，一旦检测到有文件描述符就绪（ 可以读数据或者可以写数据）程序的阻塞就会被解除，之后就可以基于这些（一个或多个）就绪的文件描述符进行通信了。</code><br>通过这种方式在单线程&#x2F;进程的场景下也可以在服务器端实现并发。<br>常见的IO多路转接方式有：<code>select</code>、<code>poll</code>、<code>epoll</code>。</p><p>下面先对多线程&#x2F;多进程并发和IO多路转接的并发处理流程进行对比（服务器端）：</p><ul><li>多线程&#x2F;多进程并发<ul><li>主线程&#x2F;父进程：调用 <code>accept()</code>监测客户端连接请求<ul><li>如果没有新的客户端的连接请求，当前线程&#x2F;进程会阻塞</li><li>如果有新的客户端连接请求解除阻塞，建立连接</li></ul></li><li>子线程&#x2F;子进程：和建立连接的客户端通信<ul><li>调用 <code>read() / recv()</code>接收客户端发送的通信数据，如果没有通信数据，当前线程&#x2F;进程会阻塞，数据到达之后阻塞自动解除</li><li>调用 <code>write() / send()</code> 给客户端发送数据，如果写缓冲区已满，当前线程&#x2F;进程会阻塞，否则将待发送数据写入写缓冲区中</li></ul></li></ul></li><li>IO多路转接并发<ul><li>使用IO多路转接函数委托内核检测服务器端所有的文件描述符（通信和监听两类），这个检测过程会导致进程&#x2F;线程的阻塞，如果检测到已就绪的文件描述符阻塞解除，并将这些已就绪的文件描述符传出</li><li>根据类型对传出的所有已就绪文件描述符进行判断，并做出不同的处理<ul><li>监听的文件描述符：和客户端建立连接<ul><li>此时调用<code>accept()</code>是不会导致程序阻塞的，因为监听的文件描述符是已就绪的（有新请求）</li></ul></li><li>通信的文件描述符：调用通信函数和已建立连接的客户端通信<ul><li>调用 <code>read() / recv()</code> 不会阻塞程序，因为通信的文件描述符是就绪的，读缓冲区内已有数据</li><li>调用 <code>write() / send()</code> 不会阻塞程序，因为通信的文件描述符是就绪的，写缓冲区不满，可以往里面写数据</li></ul></li><li>对这些文件描述符继续进行下一轮的检测（循环往复。。。）</li></ul></li></ul></li></ul><p><code>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</code></p><hr><h2 id="7-2-select"><a href="#7-2-select" class="headerlink" title="7.2  select"></a>7.2  select</h2><h3 id="7-2-1-函数原型"><a href="#7-2-1-函数原型" class="headerlink" title="7.2.1 函数原型"></a>7.2.1 函数原型</h3><p>使用select这种IO多路转接方式需要调用一个同名函数<code>select</code><br>这个函数是跨平台的，<code>Linux、Mac、Windows</code>都是支持的。通过调用这个函数可以委托内核帮助我们检测若干个文件描述符的状态，<code>其实就是检测这些文件描述符对应的读写缓冲区的状态</code>：</p><ul><li>读缓冲区：检测里边有没有数据，如果有数据该缓冲区对应的文件描述符就绪</li><li>写缓冲区：检测写缓冲区是否可以写(有没有容量)，如果有容量可以写，缓冲区对应的文件描述符就绪</li><li>读写异常：检测读写缓冲区是否有异常，如果有该缓冲区对应的文件描述符就绪</li></ul><p>委托检测的文件描述符被遍历检测完毕之后，已就绪的这些满足条件的文件描述符会通过<code>select()</code>的参数分3个集合传出,我们得到这几个集合之后就可以分情况依次处理了。</p><p>下面来看一下这个函数的函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span>      tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">           fd_set *exceptfds, <span class="keyword">struct</span> timeval * timeout)</span>;</span><br></pre></td></tr></table></figure><ul><li>函数参数：<ul><li>nfds：委托内核检测的这三个集合中最大的文件描述符 + 1<ul><li>内核需要线性遍历这些集合中的文件描述符，这个值是循环结束的条件</li><li>在Window中这个参数是无效的，指定为-1即可</li></ul></li><li>readfds：文件描述符的集合, 内核只检测这个集合中文件描述符对应的读缓冲区<ul><li>传入传出参数，读集合一般情况下都是需要检测的，这样才知道通过哪个文件描述符接收数据</li></ul></li><li>writefds：文件描述符的集合, 内核只检测这个集合中文件描述符对应的写缓冲区<ul><li>传入传出参数，如果不需要使用这个参数可以指定为NULL</li></ul></li><li>exceptfds：文件描述符的集合, 内核检测集合中文件描述符是否有异常状态<ul><li>传入传出参数，如果不需要使用这个参数可以指定为NULL</li></ul></li><li>timeout：超时时长，用来强制解除select()函数的阻塞的<ul><li>NULL：函数检测不到就绪的文件描述符会一直阻塞。</li><li>等待固定时长（秒）：函数检测不到就绪的文件描述符，在指定时长之后强制解除阻塞，函数返回0</li><li>不等待：函数不会阻塞，直接将该参数对应的结构体初始化为0即可。</li></ul></li></ul></li><li>函数返回值：<ul><li>大于0：成功，返回集合中已就绪的文件描述符的总个数</li><li>等于-1：函数调用失败</li><li>等于0：超时，没有检测到就绪的文件描述符</li></ul></li></ul><p>另外初始化<code>fd_set</code>类型的参数还需要使用相关的一些列操作函数，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将文件描述符fd从set集合中删除 == 将fd对应的标志位设置为0        </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 判断文件描述符fd是否在set集合中 == 读一下fd对应的标志位到底是0还是1</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将文件描述符fd添加到set集合中 == 将fd对应的标志位设置为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将set集合中, 所有文件文件描述符对应的标志位设置为0, 集合中没有添加任何文件描述符</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="7-2-2-细节描述"><a href="#7-2-2-细节描述" class="headerlink" title="7.2.2 细节描述"></a>7.2.2 细节描述</h3><p>在<code>select()</code>函数中第2、3、4个参数都是<code>fd_set</code>类型，它表示一个文件描述符的集合，类似于信号集 <code>sigset_t</code>，这个类型的数据有128个字节，也就是1024个标志位，和内核中文件描述符表中的文件描述符个数是一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(fd_set) = <span class="number">128</span> 字节 * <span class="number">8</span> = <span class="number">1024</span> bit      <span class="comment">// int [32]</span></span><br></pre></td></tr></table></figure><p>这不是巧合，是故意为之。这块内存中的每一个bit 和 文件描述符表中的每一个文件描述符是一一对应的关系，这样就可以使用最小的存储空间将要表达的意思描述出来了。</p><p>下图中的fd_set中存储了要委托内核检测读缓冲区的文件描述符集合。</p><ul><li>如果集合中的标志位为0代表不检测这个文件描述符状态</li><li>如果集合中的标志位为1代表检测这个文件描述符状态<br><img src="/img/9.41.png" alt="在这里插入图片描述"></li></ul><p>内核在遍历这个读集合的过程中，如果被检测的文件描述符对应的读缓冲区中没有数据，内核将修改这个文件描述符在读集合<code>fd_set</code>中对应的标志位，改为<code>0</code>，如果有数据那么这个标志位的值不变，还是<code>1</code>。</p><p><img src="/img/9.42.png" alt="在这里插入图片描述"></p><p>当<code>select()</code>函数解除阻塞之后，被内核修改过的读集合通过参数传出，此时集合中只要标志位的值为<code>1</code>，那么它对应的文件描述符肯定是就绪的，我们就可以基于这个文件描述符和客户端建立新连接或者通信了。</p><hr><h2 id="7-3-并发处理"><a href="#7-3-并发处理" class="headerlink" title="7.3  并发处理"></a>7.3  并发处理</h2><h3 id="7-3-1-处理流程"><a href="#7-3-1-处理流程" class="headerlink" title="7.3.1 处理流程"></a>7.3.1 处理流程</h3><p>如果在服务器基于select实现并发，其处理流程如下：</p><ol><li>创建监听的套接字 lfd &#x3D; socket();</li><li>将监听的套接字和本地的IP和端口绑定 bind()</li><li>给监听的套接字设置监听 listen()</li><li>创建一个文件描述符集合 fd_set，用于存储需要检测读事件的所有的文件描述符<ul><li>通过 FD_ZERO() 初始化</li><li>通过 FD_SET() 将监听的文件描述符放入检测的读集合中</li></ul></li><li>循环调用select()，周期性的对所有的文件描述符进行检测</li><li>select() 解除阻塞返回，得到内核传出的满足条件的就绪的文件描述符集合<ul><li>通过FD_ISSET() 判断集合中的标志位是否为 1<ul><li>如果这个文件描述符是监听的文件描述符，调用 accept() 和客户端建立连接<ul><li>将得到的新的通信的文件描述符，通过FD_SET() 放入到检测集合中</li></ul></li><li>如果这个文件描述符是通信的文件描述符，调用通信函数和客户端通信<ul><li>如果客户端和服务器断开了连接，使用FD_CLR()将这个文件描述符从检测集合中删除</li><li>如果没有断开连接，正常通信即可</li></ul></li></ul></li></ul></li><li>重复第6步<br><img src="/img/9.43.png" alt="在这里插入图片描述"></li></ol><hr><h3 id="7-3-2-通信代码"><a href="#7-3-2-通信代码" class="headerlink" title="7.3.2 通信代码"></a>7.3.2 通信代码</h3><blockquote><p>服务器端代码如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的fd</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    listen(lfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的fd的状态检测委托给内核检测</span></span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line">    <span class="comment">// 初始化检测的读集合</span></span><br><span class="line">    fd_set rdset;</span><br><span class="line">    fd_set rdtemp;</span><br><span class="line">    <span class="comment">// 清零</span></span><br><span class="line">    FD_ZERO(&amp;rdset);</span><br><span class="line">    <span class="comment">// 将监听的lfd设置到检测的读集合中</span></span><br><span class="line">    FD_SET(lfd, &amp;rdset);</span><br><span class="line">    <span class="comment">// 通过select委托内核检测读集合中的文件描述符状态, 检测read缓冲区有没有数据</span></span><br><span class="line">    <span class="comment">// 如果有数据, select解除阻塞返回</span></span><br><span class="line">    <span class="comment">// 应该让内核持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 默认阻塞</span></span><br><span class="line">        <span class="comment">// rdset 中是委托内核检测的所有的文件描述符</span></span><br><span class="line">        rdtemp = rdset;</span><br><span class="line">        <span class="type">int</span> num = select(maxfd+<span class="number">1</span>, &amp;rdtemp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// rdset中的数据被内核改写了, 只保留了发生变化的文件描述的标志位上的1, 没变化的改为0</span></span><br><span class="line">        <span class="comment">// 只要rdset中的fd对应的标志位为1 -&gt; 缓冲区有数据了</span></span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="comment">// 有没有新连接</span></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(lfd, &amp;rdtemp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 接受连接请求, 这个调用不阻塞</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">            <span class="type">int</span> cliLen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">            <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;cliLen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 得到了有效的文件描述符</span></span><br><span class="line">            <span class="comment">// 通信的文件描述符添加到读集合</span></span><br><span class="line">            <span class="comment">// 在下一轮select检测的时候, 就能得到缓冲区的状态</span></span><br><span class="line">            FD_SET(cfd, &amp;rdset);</span><br><span class="line">            <span class="comment">// 重置最大的文件描述符</span></span><br><span class="line">            maxfd = cfd &gt; maxfd ? cfd : maxfd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有新连接, 通信</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;maxfd+<span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">// 判断从监听的文件描述符之后到maxfd这个范围内的文件描述符是否读缓冲区有数据</span></span><br><span class="line">            <span class="keyword">if</span>(i != lfd &amp;&amp; FD_ISSET(i, &amp;rdtemp))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="comment">// 一次只能接收10个字节, 客户端一次发送100个字节</span></span><br><span class="line">                <span class="comment">// 一次是接收不完的, 文件描述符对应的读缓冲区中还有数据</span></span><br><span class="line">                <span class="comment">// 下一轮select检测的时候, 内核还会标记这个文件描述符缓冲区有数据 -&gt; 再读一次</span></span><br><span class="line">                <span class="comment">// 循环会一直持续, 知道缓冲区数据被读完位置</span></span><br><span class="line">                <span class="type">int</span> len = read(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端关闭了连接...\n&quot;</span>);</span><br><span class="line">                    <span class="comment">// 将检测的文件描述符从读集合中删除</span></span><br><span class="line">                    FD_CLR(i, &amp;rdset);</span><br><span class="line">                    close(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 收到了数据</span></span><br><span class="line">                    <span class="comment">// 发送数据</span></span><br><span class="line">                    write(i, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 异常</span></span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，创建了两个<code>fd_set</code>变量，用于保存要检测的读集合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化检测的读集合</span></span><br><span class="line">fd_set rdset;</span><br><span class="line">fd_set rdtemp;</span><br></pre></td></tr></table></figure><blockquote><p><code>rdset</code>用于保存要检测的原始数据，这个变量不能作为参数传递给select函数，因为在函数内部这个变量中的值会被内核修改，函数调用完毕返回之后，里边就不是原始数据了，大部分情况下是值为1的标志位变少了，不可能每一轮检测，所有的文件描述符都是就行的状态。因此需要通过&#96;rdtemp&#96;&#96;变量将原始数据传递给内核，select()<br>调用完毕之后再将内核数据传出，这两个变量的功能是不一样的。</p></blockquote><p>客户端代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;     <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);   <span class="comment">// 服务器监听的端口, 字节序应该是网络字节序</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        <span class="comment">// sprintf(recvBuf, &quot;data: %d\n&quot;, i++);</span></span><br><span class="line">        fgets(recvBuf, <span class="keyword">sizeof</span>(recvBuf), <span class="built_in">stdin</span>);</span><br><span class="line">        write(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果客户端没有发送数据, 默认阻塞</span></span><br><span class="line">        read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>, recvBuf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端不需要使用IO多路转接进行处理，因为客户端和服务器的对应关系是 1：N，也就是说客户端是比较专一的，只能和一个连接成功的服务器通信。</p><p>虽然使用select这种IO多路转接技术可以降低系统开销，提高程序效率，但是它也有局限性：</p><ol><li>待检测集合（第2、3、4个参数）需要频繁的在用户区和内核区之间进行数据的拷贝，效率低</li><li>内核对于select传递进来的待检测集合的检测方式是线性的<ul><li>如果集合内待检测的文件描述符很多，检测效率会比较低</li><li>如果集合内待检测的文件描述符相对较少，检测效率会比较高</li></ul></li><li><code>使用select能够检测的最大文件描述符个数有上限，默认是1024，这是在内核中被写死了的。</code></li></ol><hr><h1 id="8-IO多路转接（复用）之poll"><a href="#8-IO多路转接（复用）之poll" class="headerlink" title="8. IO多路转接（复用）之poll"></a>8. IO多路转接（复用）之poll</h1><h2 id="8-1-poll函数"><a href="#8-1-poll函数" class="headerlink" title="8.1 poll函数"></a>8.1 poll函数</h2><p>poll的机制与select类似，与select在本质上没有多大差别，使用方法也类似，下面的是对于二者的对比：</p><ul><li>内核对应文件描述符的检测也是以线性的方式进行轮询，根据描述符的状态进行处理</li><li>poll和select检测的文件描述符集合会在检测过程中频繁的进行用户区和内核区的拷贝，它的开销随着文件描述符数量的增加而线性增大，从而效率也会越来越低。</li><li>select检测的文件描述符个数上限是1024，poll没有最大文件描述符数量的限制</li><li>select可以跨平台使用，poll只能在Linux平台使用</li></ul><p>poll函数的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 每个委托poll检测的fd都对应这样一个结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* 文件描述符实际发生的事件 -&gt; 传出 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>[100];</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><ul><li>函数参数：<ul><li>fds: 这是一个struct pollfd类型的数组, 里边存储了待检测的文件描述符的信息，这个数组中有三个成员：<ul><li>fd：委托内核检测的文件描述符</li><li>events：委托内核检测的fd事件（输入、输出、错误），每一个事件有多个取值</li><li>revents：这是一个传出参数，数据由内核写入，存储内核检测之后的结果</li></ul></li><li>nfds: 这是第一个参数数组中最后一个有效元素的下标 + 1（也可以指定参数1数组的元素总个数）</li><li>timeout: 指定poll函数的阻塞时长<ul><li>-1：一直阻塞，直到检测的集合中有就绪的文件描述符（有事件产生）解除阻塞</li><li>0：不阻塞，不管检测集合中有没有已就绪的文件描述符，函数马上返回</li><li>大于0：阻塞指定的毫秒（ms）数之后，解除阻塞</li></ul></li></ul></li><li>函数返回值：<ul><li>失败： 返回-1</li><li>成功：返回一个大于0的整数，表示检测的集合中已就绪的文件描述符的总个数</li></ul></li></ul><p><img src="/img/9.44.png" alt="在这里插入图片描述"></p><hr><h2 id="8-2-测试代码"><a href="#8-2-测试代码" class="headerlink" title="8.2 测试代码"></a>8.2 测试代码</h2><p><strong>服务器端</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 绑定 ip, port</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 等待连接 -&gt; 循环</span></span><br><span class="line">    <span class="comment">// 检测 -&gt; 读缓冲区, 委托内核去处理</span></span><br><span class="line">    <span class="comment">// 数据初始化, 创建自定义的文件描述符集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1024];</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1024</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxfd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 委托内核检测</span></span><br><span class="line">        ret = poll(fds, maxfd+<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测的度缓冲区有变化</span></span><br><span class="line">        <span class="comment">// 有新连接</span></span><br><span class="line">        <span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 接收连接请求</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sockcli</span>;</span></span><br><span class="line">            <span class="type">int</span> len = <span class="keyword">sizeof</span>(sockcli);</span><br><span class="line">            <span class="comment">// 这个accept是不会阻塞的</span></span><br><span class="line">            <span class="type">int</span> connfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;sockcli, &amp;len);</span><br><span class="line">            <span class="comment">// 委托内核检测connfd的读缓冲区</span></span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1024</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(fds[i].fd == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    fds[i].fd = connfd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxfd = i &gt; maxfd ? i : maxfd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通信, 有客户端发送数据过来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=maxfd; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果在集合中, 说明读缓冲区有数据</span></span><br><span class="line">            <span class="keyword">if</span>(fds[i].revents &amp; POLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">                <span class="type">int</span> ret = read(fds[i].fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;对方已经关闭了连接...\n&quot;</span>);</span><br><span class="line">                    close(fds[i].fd);</span><br><span class="line">                    fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">                    write(fds[i].fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的测试代码可以得知，使用poll和select进行IO多路转接的处理思路是完全相同的，但是使用poll编写的代码看起来会更直观一些，select使用的位图的方式来标记要委托内核检测的文件描述符（每个比特位对应一个唯一的文件描述符），并且对这个<code>fd_set</code>类型的位图变量进行读写还需要借助一系列的宏函数，操作比较麻烦。而poll直接将要检测的文件描述符的相关信息封装到了一个结构体<code>struct pollfd</code>中，我们可以直接读写这个结构体变量。</p><p>另外poll的第二个参数有两种赋值方式，但是都和第一个参数的数组有关系：</p><ul><li>使用参数1数组的元素个数</li><li>使用参数1数组中存储的最后一个有效元素对应的下标值 + 1</li></ul><p>内核会根据第二个参数传递的值对参数1数组中的文件描述符进行线性遍历，这一点和select也是类似的。</p><p><strong>客户端</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;  <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);   <span class="comment">// 服务器监听的端口, 字节序应该是网络字节序</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        <span class="comment">// sprintf(recvBuf, &quot;data: %d\n&quot;, i++);</span></span><br><span class="line">        fgets(recvBuf, <span class="keyword">sizeof</span>(recvBuf), <span class="built_in">stdin</span>);</span><br><span class="line">        write(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果客户端没有发送数据, 默认阻塞</span></span><br><span class="line">        read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>, recvBuf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端不需要使用IO多路转接进行处理，因为客户端和服务器的对应关系是 1：N，也就是说客户端是比较专一的，只能和一个连接成功的服务器通信。</p><hr><h1 id="9-IO多路转接（复用）之epoll"><a href="#9-IO多路转接（复用）之epoll" class="headerlink" title="9. IO多路转接（复用）之epoll"></a>9. IO多路转接（复用）之epoll</h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><p>epoll 全称 eventpoll，是 linux 内核实现IO多路转接&#x2F;复用（IO multiplexing）的一个实现。IO多路转接的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。epoll是select和poll的升级版，相较于这两个前辈，epoll改进了工作方式，因此它更加高效。</p><ul><li>对于待检测集合select和poll是基于线性方式处理的，epoll是基于红黑树来管理待检测集合的。</li><li>select和poll每次都会线性扫描整个待检测集合，集合越大速度越慢，epoll使用的是回调机制，效率高，处理效率也不会随着检测集合的变大而下降</li><li>select和poll工作过程中存在内核&#x2F;用户空间数据的频繁拷贝问题，在epoll中内核和用户区使用的是共享内存（基于mmap内存映射区实现），省去了不必要的内存拷贝。</li><li>我们需要对select和poll返回的集合进行判断才能知道哪些文件描述符是就绪的，通过epoll可以直接得到已就绪的文件描述符集合，无需再次检测</li><li>使用epoll没有最大文件描述符的限制，仅受系统中进程能打开的最大文件数目限制</li></ul><p>当多路复用的文件数量庞大、IO流量频繁的时候，一般不太适合使用select()和poll()，这种情况下select()和poll()表现较差，推荐使用epoll()。</p><hr><h2 id="9-2-操作函数"><a href="#9-2-操作函数" class="headerlink" title="9.2 操作函数"></a>9.2 操作函数</h2><p>在epoll中一共提供是三个API函数，分别处理不同的操作，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建epoll实例，通过一棵红黑树管理待检测集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// 管理红黑树上的文件描述符(添加、修改、删除)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="comment">// 检测epoll树中是否有就绪的文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p>select&#x2F;poll低效的原因之一是将“添加&#x2F;维护待检测任务”和“阻塞进程&#x2F;线程”两个步骤合二为一。每次调用select都需要这两步操作，然而大多数应用场景中，需要监视的socket个数相对固定，并不需要每次都修改。epoll将这两个操作分开，先用<code>epoll_ctl()</code>维护等待队列，再调用<code>epoll_wait()</code>阻塞进程（解耦）。通过下图的对比显而易见，epoll的效率得到了提升。<br><img src="/img/9.45.png" alt="在这里插入图片描述"></p><p><code>epoll_create()</code>函数的作用是创建一个红黑树模型的实例，用于管理待检测的文件描述符的集合。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><ul><li>函数参数 size：在Linux内核2.6.8版本以后，这个参数是被忽略的，只需要指定一个大于0的数值就可以了。</li><li>函数返回值：<ul><li>失败：返回-1</li><li>成功：返回一个有效的文件描述符，通过这个文件描述符就可以访问创建的epoll实例了</li></ul></li></ul><p><code>epoll_ctl()</code>函数的作用是管理红黑树实例上的节点，可以进行添加、删除、修改操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联合体, 多个变量共用同一块内存        </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line"> <span class="type">void</span>        *ptr;</span><br><span class="line"><span class="type">int</span>          fd;<span class="comment">// 通常情况下使用这个成员, 和epoll_ctl的第三个参数相同即可</span></span><br><span class="line"><span class="type">uint32_t</span>     u32;</span><br><span class="line"><span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line"><span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure><ul><li>函数参数：<ul><li>epfd：epoll_create() 函数的返回值，通过这个参数找到epoll实例</li><li>op：这是一个枚举值，控制通过该函数执行什么操作<ul><li><code>EPOLL_CTL_ADD</code>：往epoll模型中添加新的节点</li><li><code>EPOLL_CTL_MOD</code>：修改epoll模型中已经存在的节点</li><li><code>EPOLL_CTL_DEL</code>：删除epoll模型中的指定的节点</li></ul></li><li>fd：文件描述符，即要添加&#x2F;修改&#x2F;删除的文件描述符</li><li>event：epoll事件，用来修饰第三个参数对应的文件描述符的，指定检测这个文件描述符的什么事件<ul><li><pre><code>events：委托epoll检测的事件</code></pre><ul><li><code>EPOLLIN</code>：读事件, 接收数据, 检测读缓冲区，如果有数据该文件描述符就绪</li><li><code>EPOLLOUT</code>：写事件, 发送数据, 检测写缓冲区，如果可写该文件描述符就绪</li><li><code>EPOLLERR</code>：异常事件</li></ul></li><li><pre><code>data：用户数据变量，这是一个联合体类型，通常情况下使用里边的`fd`成员，用于存储待检测的文件描述符的值，在调用`epoll_wait()`函数的时候这个值会被传出。</code></pre></li></ul></li></ul></li><li>函数返回值：<ul><li>失败：返回-1</li><li>成功：返回0<br><code>epoll_wait()</code>函数的作用是检测创建的epoll实例中有没有就绪的文件描述符。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><ul><li>函数参数：<ul><li>epfd：epoll_create() 函数的返回值, 通过这个参数找到epoll实例</li><li>events：传出参数, 这是一个结构体数组的地址, 里边存储了已就绪的文件描述符的信息</li><li>maxevents：修饰第二个参数, 结构体数组的容量（元素个数）</li><li>timeout：如果检测的epoll实例中没有已就绪的文件描述符，该函数阻塞的时长, 单位ms 毫秒<ul><li>0：函数不阻塞，不管epoll实例中有没有就绪的文件描述符，函数被调用后都直接返回</li><li>大于0：如果epoll实例中没有已就绪的文件描述符，函数阻塞对应的毫秒数再返回</li><li>-1：函数一直阻塞，直到epoll实例中有已就绪的文件描述符之后才解除阻塞</li></ul></li></ul></li><li>函数返回值：<ul><li>成功：<ul><li>等于0：函数是阻塞被强制解除了, 没有检测到满足条件的文件描述符</li><li>大于0：检测到的已就绪的文件描述符的总个数</li></ul></li><li>失败：返回-1</li></ul></li></ul><hr><h2 id="9-3-epoll的使用"><a href="#9-3-epoll的使用" class="headerlink" title="9.3 epoll的使用"></a>9.3 epoll的使用</h2><h3 id="9-3-1-操作步骤"><a href="#9-3-1-操作步骤" class="headerlink" title="9.3.1 操作步骤"></a>9.3.1 操作步骤</h3><p>在服务器端使用epoll进行IO多路转接的操作步骤如下：</p><ol><li>创建监听的套接字</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>设置端口复用（可选）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure><ol start="3"><li>使用本地的IP与端口和监听的套接字进行绑定</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br></pre></td></tr></table></figure><ol start="4"><li>给监听的套接字设置监听</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen(lfd, <span class="number">128</span>);</span><br></pre></td></tr></table></figure><ol start="5"><li>创建epoll实例对象</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><ol start="6"><li>将用于监听的套接字添加到epoll实例中</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">ev.events = EPOLLIN;    <span class="comment">// 检测lfd读读缓冲区是否有数据</span></span><br><span class="line">ev.data.fd = lfd;</span><br><span class="line"><span class="type">int</span> ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br></pre></td></tr></table></figure><ol start="7"><li>检测添加到epoll实例中的文件描述符是否已就绪，并将这些已就绪的文件描述符进行处理</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = epoll_wait(epfd, evs, size, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure><ul><li>如果是监听的文件描述符，和新客户端建立连接，将得到的文件描述符添加到epoll实例中</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cfd = accept(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line">ev.data.fd = cfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br></pre></td></tr></table></figure><ul><li>如果是通信的文件描述符，和对应的客户端通信，如果连接已断开，将该文件描述符从epoll实例中删除</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = recv(curfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">    close(curfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    send(curfd, buf, len, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>重复第7步的操作</li></ol><hr><h3 id="9-3-2-示例代码"><a href="#9-3-2-示例代码" class="headerlink" title="9.3.2 示例代码"></a>9.3.2 示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">// 本地多有的ＩＰ</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="comment">// 所有的文件描述符对应读写缓冲区状态都是委托内核进行检测的epoll</span></span><br><span class="line">    <span class="comment">// 创建一个epoll模型</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往epoll实例中添加需要检测的节点, 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = EPOLLIN;    <span class="comment">// 检测lfd读读缓冲区是否有数据</span></span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[1024];</span></span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(evs) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line">    <span class="comment">// 持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用一次, 检测一次</span></span><br><span class="line">        <span class="type">int</span> num = epoll_wait(epfd, evs, size, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出当前的文件描述符</span></span><br><span class="line">            <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line">            <span class="comment">// 判断这个文件描述符是不是用于监听的</span></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 建立新的连接</span></span><br><span class="line">                <span class="type">int</span> cfd = accept(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">                ev.events = EPOLLIN;    <span class="comment">// 读缓冲区是否有数据</span></span><br><span class="line">                ev.data.fd = cfd;</span><br><span class="line">                ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl-accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理通信的文件描述符</span></span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="type">int</span> len = recv(curfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端已经断开了连接\n&quot;</span>);</span><br><span class="line">                    <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">                    send(curfd, buf, len, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在服务器端循环调用<code>epoll_wait()</code>的时候，就会得到一个就绪列表，并通过该函数的第二个参数传出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[1024];</span></span><br><span class="line"><span class="type">int</span> num = epoll_wait(epfd, evs, size, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure><p>每当<code>epoll_wait()</code>函数返回一次，在<code>evs</code>中最多可以存储<code>size</code>个已就绪的文件描述符信息，但是在这个数组中实际存储的有效元素个数为<code>num</code>个，如果在这个epoll实例的红黑树中已就绪的文件描述符很多，并且<code>evs</code>数组无法将这些信息全部传出，那么这些信息会在下一次<code>epoll_wait()</code>函数返回的时候被传出。</p><p>通过<code>evs</code>数组被传递出的每一个有效元素里边都包含了已就绪的文件描述符的相关信息，这些信息并不是凭空得来的，这取决于我们在往epoll实例中添加节点的时候，往节点中初始化了哪些数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line"><span class="comment">// 节点初始化</span></span><br><span class="line">ev.events = EPOLLIN;    </span><br><span class="line">ev.data.fd = lfd;<span class="comment">// 使用了联合体中 fd 成员</span></span><br><span class="line"><span class="comment">// 添加待检测节点到epoll实例中</span></span><br><span class="line"><span class="type">int</span> ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br></pre></td></tr></table></figure><p>在添加节点的时候，需要对这个<code>struct epoll_event</code>类型的节点进行初始化，当这个节点对应的文件描述符变为已就绪状态，这些被传入的初始化信息就会被原样传出，这个对应关系必须要搞清楚。</p><hr><h2 id="9-4-epoll的工作模式"><a href="#9-4-epoll的工作模式" class="headerlink" title="9.4 epoll的工作模式"></a>9.4 epoll的工作模式</h2><h3 id="9-4-1-水平模式"><a href="#9-4-1-水平模式" class="headerlink" title="9.4.1 水平模式"></a>9.4.1 水平模式</h3><p>水平模式可以简称为LT模式，<code>LT（level triggered）是缺省的工作方式，并且同时支持block和no-block socket</code>。在这种做法中，内核通知使用者哪些文件描述符已经就绪，之后就可以对这些已就绪的文件描述符进行IO操作了。<code>如果我们不作任何操作，内核还是会继续通知使用者。</code></p><p><strong>水平模式的特点：</strong></p><ul><li>读事件：<code>如果文件描述符对应的读缓冲区还有数据，读事件就会被触发，epoll_wait()解除阻塞</code><ul><li>当读事件被触发，epoll_wait()解除阻塞，之后就可以接收数据了</li><li>如果接收数据的buf很小，不能全部将缓冲区数据读出，那么读事件会继续被触发，直到数据被全部读出，如果接收数据的内存相对较大，读数据的效率也会相对较高（减少了读数据的次数）</li><li><code>因为读数据是被动的，必须通过读事件才能知道有数据到达了，因此对于读事件的检测是必须的</code></li></ul></li><li>写事件：<code>如果文件描述符对应的写缓冲区可写，写事件就会被触发，epoll_wait()解除阻塞</code><ul><li>当写事件被触发，epoll_wait()解除阻塞，之后就可以将数据写入到写缓冲区了</li><li><code>写事件的触发发生在写数据之前而不是之后</code>，被写入到写缓冲区中的数据是由内核自动发送出去的</li><li>如果写缓冲区没有被写满，写事件会一直被触发</li><li><code>因为写数据是主动的，并且写缓冲区一般情况下都是可写的（缓冲区不满），因此对于写事件的检测不是必须的</code></li></ul></li></ul><hr><h3 id="9-4-2-边沿模式"><a href="#9-4-2-边沿模式" class="headerlink" title="9.4.2 边沿模式"></a>9.4.2 边沿模式</h3><p>边沿模式可简称为ET模式，<code>ET（edge-triggered）是高速工作方式，只支持no-block socket</code>。在这种模式下，<code>当文件描述符从未就绪变为就绪时，内核会通过epoll通知使用者。然后它会假设使用者知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知（only once）</code>。<br>如果我们对这个文件描述符做IO操作，从而导致它再次变成未就绪，当这个未就绪的文件描述符再次变成就绪状态，内核会再次进行通知，并且还是只通知一次。<br><code>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。</code></p><p><strong>边沿模式的特点:</strong></p><ul><li>读事件：<code>当读缓冲区有新的数据进入，读事件被触发一次，没有新数据不会触发该事件</code><ul><li>如果有新数据进入到读缓冲区，读事件被触发，epoll_wait()解除阻塞</li><li>读事件被触发，可以通过调用read()&#x2F;recv()函数将缓冲区数据读出<ul><li><code>如果数据没有被全部读走，并且没有新数据进入，读事件不会再次触发，只通知一次</code></li><li><code>如果数据被全部读走或只读走一部分，此时有新数据进入，读事件被触发，且只通知一次</code></li></ul></li></ul></li><li>写事件：<code>当写缓冲区状态可写，写事件只会触发一次</code><ul><li>如果写缓冲区被检测到可写，写事件被触发，epoll_wait()解除阻塞</li><li>写事件被触发，就可以通过调用write()&#x2F;send()函数，将数据写入到写缓冲区中<ul><li>写缓冲区从不满到被写满，期间写事件只会被触发一次</li><li>写缓冲区从满到不满，状态变为可写，写事件只会被触发一次</li></ul></li></ul></li></ul><p>综上所述：<code>epoll的边沿模式下 epoll_wait()检测到文件描述符有新事件才会通知，如果不是新的事件就不通知，通知的次数比水平模式少，效率比水平模式要高。</code></p><hr><h4 id="9-4-2-1-ET模式的设置"><a href="#9-4-2-1-ET模式的设置" class="headerlink" title="9.4.2.1 ET模式的设置"></a>9.4.2.1 ET模式的设置</h4><p>边沿模式不是默认的epoll模式，需要额外进行设置。epoll设置边沿模式是非常简单的，epoll管理的红黑树示例中每个节点都是<code>struct epoll_event</code>类型，只需要将<code>EPOLLET</code>添加到结构体的<code>events</code>成员中即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">ev.events = EPOLLIN | EPOLLET;<span class="comment">// 设置边沿模式</span></span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = epoll_wait(epfd, evs, size, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取出当前的文件描述符</span></span><br><span class="line">    <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line">    <span class="comment">// 判断这个文件描述符是不是用于监听的</span></span><br><span class="line">    <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 建立新的连接</span></span><br><span class="line">        <span class="type">int</span> cfd = accept(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">        <span class="comment">// 读缓冲区是否有数据, 并且将文件描述符设置为边沿模式</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">        ev.events = EPOLLIN | EPOLLET;   </span><br><span class="line">        ev.data.fd = cfd;</span><br><span class="line">        ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_ctl-accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="9-4-2-2-设置非阻塞"><a href="#9-4-2-2-设置非阻塞" class="headerlink" title="9.4.2.2 设置非阻塞"></a>9.4.2.2 设置非阻塞</h4><p>对于写事件的触发一般情况下是不需要进行检测的，因为写缓冲区大部分情况下都是有足够的空间可以进行数据的写入。对于读事件的触发就必须要检测了，因为服务器也不知道客户端什么时候发送数据，如果使用epoll的边沿模式进行读事件的检测，有新数据达到只会通知一次，那么必须要保证得到通知后将数据全部从读缓冲区中读出。那么，应该如何读这些数据呢？</p><ul><li>方式1：准备一块特别大的内存，用于存储从读缓冲区中读出的数据，但是这种方式有很大的弊端：<ul><li>内存的大小没有办法界定，太大浪费内存，太小又不够用</li><li>系统能够分配的最大堆内存也是有上限的，栈内存就更不必多言了</li></ul></li><li>方式2：循环接收数据</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = recv(curfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 数据处理...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做也是有弊端的，因为套接字操作默认是阻塞的，当读缓冲区数据被读完之后，读操作就阻塞了也就是调用的<code>read()/recv()</code>函数被阻塞了，当前进程&#x2F;线程被阻塞之后就无法处理其他操作了。</p><p>要解决阻塞问题，就将套接字默认的阻塞行为修改为非阻塞，需使用<code>fcntl()</code>函数进行处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置完成之后, 读写都变成了非阻塞模式</span></span><br><span class="line"><span class="type">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">flag |= O_NONBLOCK;                                                        </span><br><span class="line">fcntl(cfd, F_SETFL, flag);</span><br></pre></td></tr></table></figure><p>通过上述分析就可以得出一个结论：<code>epoll在边沿模式下，必须要将套接字设置为非阻塞模式</code>，但是，这样就会引发另外的一个bug，在非阻塞模式下，循环地将读缓冲区数据读到本地内存中，当缓冲区数据被读完了，调用的<code>read()/recv()</code>函数还会继续从缓冲区中读数据，此时函数调用就失败了，返回-1，对应的全局变量 errno 值为 <code>EAGAIN</code> 或者 <code>EWOULDBLOCK</code>如果打印错误信息会得到如下的信息：<code>Resource temporarily unavailable</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非阻塞模式下recv() / read()函数返回值 len == -1</span></span><br><span class="line"><span class="type">int</span> len = recv(curfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(errno == EAGAIN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数据读完了...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="9-4-2-3-示例代码"><a href="#9-4-2-3-示例代码" class="headerlink" title="9.4.2.3 示例代码"></a>9.4.2.3 示例代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">// 本地多有的ＩＰ</span></span><br><span class="line">    <span class="comment">// 127.0.0.1</span></span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr.s_addr);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="comment">// 所有的文件描述符对应读写缓冲区状态都是委托内核进行检测的epoll</span></span><br><span class="line">    <span class="comment">// 创建一个epoll模型</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往epoll实例中添加需要检测的节点, 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = EPOLLIN;    <span class="comment">// 检测lfd读读缓冲区是否有数据</span></span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[1024];</span></span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(evs) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line">    <span class="comment">// 持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用一次, 检测一次</span></span><br><span class="line">        <span class="type">int</span> num = epoll_wait(epfd, evs, size, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;==== num: %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出当前的文件描述符</span></span><br><span class="line">            <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line">            <span class="comment">// 判断这个文件描述符是不是用于监听的</span></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 建立新的连接</span></span><br><span class="line">                <span class="type">int</span> cfd = accept(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">// 将文件描述符设置为非阻塞</span></span><br><span class="line">                <span class="comment">// 得到文件描述符的属性</span></span><br><span class="line">                <span class="type">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">                flag |= O_NONBLOCK;</span><br><span class="line">                fcntl(cfd, F_SETFL, flag);</span><br><span class="line">                <span class="comment">// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">                <span class="comment">// 通信的文件描述符检测读缓冲区数据的时候设置为边沿模式</span></span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;    <span class="comment">// 读缓冲区是否有数据</span></span><br><span class="line">                ev.data.fd = cfd;</span><br><span class="line">                ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl-accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理通信的文件描述符</span></span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">5</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="comment">// 循环读数据</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> len = recv(curfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 非阻塞模式下和阻塞模式是一样的 =&gt; 判断对方是否断开连接</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">                        <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">                        epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                        close(curfd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 通信</span></span><br><span class="line">                        <span class="comment">// 接收的数据打印到终端</span></span><br><span class="line">                        write(STDOUT_FILENO, buf, len);</span><br><span class="line">                        <span class="comment">// 发送数据</span></span><br><span class="line">                        send(curfd, buf, len, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// len == -1</span></span><br><span class="line">                        <span class="keyword">if</span>(errno == EAGAIN)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;数据读完了...\n&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">                            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="10-基于UDP的套接字通信"><a href="#10-基于UDP的套接字通信" class="headerlink" title="10. 基于UDP的套接字通信"></a>10. 基于UDP的套接字通信</h1><p>udp是一个面向无连接的，不安全的，报式传输层协议，udp的通信过程默认也是阻塞的。</p><ul><li><p>UDP通信不需要建立连接 ，因此不需要进行connect()操作</p></li><li><p>UDP通信过程中，每次都需要指定数据接收端的IP和端口，和发快递差不多</p></li><li><p>UDP不对收到的数据进行排序，在UDP报文的首部中并没有关于数据顺序的信息</p></li><li><p>UDP对接收到的数据报不回复确认信息,发送端不知道数据是否被正确接收,也不会重发数据。</p></li><li><p>如果发生了数据丢失，不存在丢一半的情况，如果丢当前这个数据包就全部丢失了</p></li></ul><h2 id="10-1-通信流程"><a href="#10-1-通信流程" class="headerlink" title="10.1 通信流程"></a>10.1 通信流程</h2><p>使用UDP进行通信，服务器和客户端的处理步骤比TCP要简单很多，并且两端是对等的 （通信的处理流程几乎是一样的），也就是说并没有严格意义上的客户端和服务器端。UDP的通信流程如下：<br><img src="/img/9.46.png" alt="在这里插入图片描述"></p><h3 id="10-1-1-服务器端"><a href="#10-1-1-服务器端" class="headerlink" title="10.1.1 服务器端"></a>10.1.1 服务器端</h3><p><strong>假设服务器端是接收数据的角色：</strong></p><ol><li>创建通信的套接字</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>使用通信的套接字和本地的IP和端口绑定，IP和端口需要转换为大端(可选)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind();</span><br></pre></td></tr></table></figure><ol start="3"><li>通信</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line">recvfrom();</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">sendto();</span><br></pre></td></tr></table></figure><ol start="4"><li>关闭套接字（文件描述符）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure><hr><h3 id="10-1-2-客户端"><a href="#10-1-2-客户端" class="headerlink" title="10.1.2 客户端"></a>10.1.2 客户端</h3><p><strong>假设客户端是发送数据的角色：</strong></p><ol><li>创建通信的套接字</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>通信</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line">recvfrom();</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">sendto();</span><br></pre></td></tr></table></figure><ol start="3"><li>关闭套接字（文件描述符）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure><p>在UDP通信过程中，<code>哪一端是接收数据的角色，那么这个接收端就必须绑定一个固定的端口</code>，如果某一端不需要接收数据，这个绑定操作就可省略不写，通信的套接字会自动绑定一个随机端口。</p><hr><h2 id="10-2-通信函数"><a href="#10-2-通信函数" class="headerlink" title="10.2 通信函数"></a>10.2 通信函数</h2><p>基于UDP进行套接字通信，创建套接字的函数还是<code>socket()</code>但是第二个参数的值需要指定为<code>SOCK_DGRAM</code>，通过该参数指定要创建一个基于报式传输协议的套接字，最后一个参数指定为0表示使用报式协议中的UDP协议。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>domain：地址族协议，AF_INET -&gt; IPv4，AF_INET6-&gt; IPv6</li><li>type：使用的传输协议类型，报式传输协议需要指定为 SOCK_DGRAM</li><li>protocol：指定为0，表示使用的默认报式传输协议为 UDP</li></ul></li><li>返回值：函数调用成功返回一个可用的文件描述符（大于0），调用失败返回-1</li></ul><p>另外进行UDP通信，通信过程虽然默认还是阻塞的，但是通信函数和TCP不同<br>操作函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据, 如果没有数据,该函数阻塞</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd: 基于udp的通信的文件描述符</li><li>buf: 指针指向的地址用来存储接收的数据</li><li>len: buf指针指向的内存的容量, 最多能存储多少字节</li><li>flags: 设置套接字属性，一般使用默认属性，指定为0即可</li><li>src_addr: 发送数据的一端的地址信息，IP和端口都存储在这里边, 是大端存储的<ul><li>如果这个参数中的信息对当前业务处理没有用处, 可以指定为NULL, 不保存这些信息</li></ul></li><li>addrlen: 类似于accept() 函数的最后一个参数, 是一个传入传出参数<ul><li>传入的是src_addr参数指向的内存的大小, 传出的也是这块内存的大小</li><li>如果src_addr参数指定为NULL, 这个参数也指定为NULL即可</li></ul></li></ul></li><li>返回值：成功返回接收的字节数，失败返回-1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送数据函数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd: 基于udp的通信的文件描述符</li><li>buf: 这个指针指向的内存中存储了要发送的数据</li><li>len: 要发送的数据的实际长度</li><li>flags: 设置套接字属性，一般使用默认属性，指定为0即可</li><li>dest_addr: 接收数据的一端对应的地址信息, 大端的IP和端口</li><li>addrlen: 参数 dest_addr 指向的内存大小</li></ul></li><li>返回值：函数调用成功返回实际发送的字节数，调用失败返回-1</li></ul><hr><h2 id="10-3-通信代码"><a href="#10-3-通信代码" class="headerlink" title="10.3 通信代码"></a>10.3 通信代码</h2><p>在UDP通信过程中，服务器和客户端都可以作为数据的发送端和数据接收端，假设服务器端是被动接收数据，客户端是主动发送数据，那么在服务器端就必须绑定固定的端口了。</p><h3 id="10-3-1-服务器端"><a href="#10-3-1-服务器端" class="headerlink" title="10.3.1 服务器端"></a>10.3.1 服务器端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通信的套接字和本地的IP与端口绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);    <span class="comment">// 大端</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">char</span> ipbuf[<span class="number">64</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> rlen = recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP地址: %s, 端口: %d\n&quot;</span>,</span><br><span class="line">               inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ipbuf, <span class="keyword">sizeof</span>(ipbuf)),</span><br><span class="line">               ntohs(cliaddr.sin_port));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回复数据</span></span><br><span class="line">        <span class="comment">// 数据回复给了发送数据的客户端</span></span><br><span class="line">        sendto(fd, buf, rlen, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为数据接收端，服务器端通过<code>bind()</code>函数绑定了固定的端口，然后基于这个固定的端口通过<code>recvfrom()</code>函数接收客户端发送的数据，同时通过这个函数也得到了数据发送端的地址信息（recvfrom的第三个参数），这样就可以通过得到的地址信息通过<code>sendto()</code>函数给客户端回复数据了。</p><hr><h3 id="10-3-2-客户端"><a href="#10-3-2-客户端" class="headerlink" title="10.3.2 客户端"></a>10.3.2 客户端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化服务器地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);    <span class="comment">// 大端</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.1.100&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">char</span> ipbuf[<span class="number">64</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 2. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, udp %d....\n&quot;</span>, num++);</span><br><span class="line">        <span class="comment">// 发送数据, 数据发送给了服务器</span></span><br><span class="line">        sendto(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;服务器say: %s\n&quot;</span>, buf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为数据发送端，客户端不需要绑定固定端口，客户端使用的端口是随机绑定的（也可以调用bind()函数手动进行绑定）。客户端在接收服务器端回复的数据的时候需要调用<code>recvfrom()</code>函数，因为客户端在发送数据之前就已经知道服务器绑定的固定的IP和端口信息了，所以接收服务器数据的时候就可以不保存服务器端的地址信息，直接将函数的最后两个参数指定为NULL即可。</p><hr><h1 id="11-UDP特性之广播"><a href="#11-UDP特性之广播" class="headerlink" title="11. UDP特性之广播"></a>11. UDP特性之广播</h1><h2 id="11-1-广播的特点"><a href="#11-1-广播的特点" class="headerlink" title="11.1 广播的特点"></a>11.1 广播的特点</h2><p>广播的UDP的特性之一，<code>通过广播可以向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息</code>，每个广播消息都包含一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全部为1 （即点分十进制IP的最后一部分是255）。点分十进制的IP地址每一部分是1字节，最大值为255，比如：<code>192.168.1.100</code></p><ul><li>前两部分192.168表示当前网络是局域网</li><li>第三部分1表示局域网中的某一个网段，最大值为 255</li><li>第四部分100用于标记当前网段中的某一台主机，最大值为255</li><li>每个网段都有一个特殊的广播地址，即：192.168.xxx.255</li></ul><p>广播分为两端，即数据发送端和数据接收端，通过广播的方式发送数据，发送端和接收端的关系是 1:N</p><ul><li><p>发送广播消息的一端，通过广播地址，可以将消息同时发送到局域网的多台主机上（数据接收端）</p></li><li><p>在发送广播消息的时候，必须要把数据发送到广播地址上</p></li><li><p>广播只能在局域网内使用，广域网是无法使用UDP进行广播的</p></li><li><p>只要发送端在发送广播消息，数据接收端就能收到广播消息，消息的接收是无法拒绝的，除非将接收端的进程关闭，就接收不到了。</p></li></ul><p>UDP的广播和日常的广播是一样的，都是一种快速传播消息的方式，因此<code>广播的开销很小</code>，发送端使用一个广播地址，就可以将数据发送到多个接收数据的终端上，如果不使用广播，就需要进行多次发送才能将数据分别发送到不同的主机上。</p><hr><h2 id="11-2-设置广播属性"><a href="#11-2-设置广播属性" class="headerlink" title="11.2 设置广播属性"></a>11.2 设置广播属性</h2><p>基于UDP虽然可以进行数据的广播，但是这个属性默认是关闭的，如果需要对数据进行广播，那么需要在广播端代码中开启广播属性，需要通过套接字选项函数进行设置，该函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd：进行UDP通信的文件描述符</li><li>level: 套接字级别，需要设置为 SOL_SOCKET</li><li>optname：选项名，此处要设置udp的广播属性，该参数需要指定为：SO_BROADCAST</li><li>optval：如果是设置广播属性，该指针实际指向一块int类型的内存<ul><li>该整型值为0：关闭广播属性</li><li>该整形值为1：打开广播属性</li></ul></li><li>optlen：optval指针指向的内存大小，即：sizeof(int)</li></ul></li><li>返回值：函数调用成功返回0，失败返回-1</li></ul><hr><h2 id="11-3-广播通信流程"><a href="#11-3-广播通信流程" class="headerlink" title="11.3 广播通信流程"></a>11.3 广播通信流程</h2><p>如果使用UDP在局域网范围内进行消息的广播，一般情况下广播端只发送数据，接收端只接受广播消息。因此在数据接收端需要绑定固定的端口，广播端则不需要手动绑定固定端口，自动随机绑定即可。</p><p><img src="/img/9.47.png" alt="在这里插入图片描述"></p><p><strong>数据发送端</strong></p><ol><li>创建通信的套接字</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>主动发送数据不需要手动绑定固定端口（自动随机分配就可以了），因此直接设置广播属性</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt  = <span class="number">1</span>;</span><br><span class="line">setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure><ol start="3"><li>使用广播地址发送广播数据到接收端绑定的固定端口上</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendto();</span><br></pre></td></tr></table></figure><ol start="4"><li>关闭套接字（文件描述符）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure><p><strong>数据接收端</strong></p><ol><li>创建通信的套接字</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>因为是被动接收数据的一端，所以必须要绑定固定的端口和本地IP地址</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind();</span><br></pre></td></tr></table></figure><ol start="3"><li>接收广播消息</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recvfrom();</span><br></pre></td></tr></table></figure><ol start="4"><li>关闭套接字（文件描述符）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure><hr><h2 id="11-4-通信代码"><a href="#11-4-通信代码" class="headerlink" title="11.4 通信代码"></a>11.4 通信代码</h2><p><strong>广播端</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置广播属性</span></span><br><span class="line">    <span class="type">int</span> opt  = <span class="number">1</span>;</span><br><span class="line">    setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">9999</span>); <span class="comment">// 接收端需要绑定9999端口</span></span><br><span class="line">    <span class="comment">// 只要主机在237网段, 并且绑定了9999端口, 这个接收端就能收到广播消息</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.237.255&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, client...%d\n&quot;</span>, num++);</span><br><span class="line">        <span class="comment">// 数据广播</span></span><br><span class="line">        sendto(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发送的广播的数据: %s\n&quot;</span>, buf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：发送广播消息一端必须要开启UDP的广播属性，并且发送消息的地址必须是当前发送端所在网段的广播地址，这样才能通过调用一个消息发送函数将消息同时发送N台接收端主机上。</p></blockquote><p><strong>接收端</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通信的套接字和本地的IP与端口绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);    <span class="comment">// 大端</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收广播消息</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">// 阻塞等待数据达到</span></span><br><span class="line">        recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收到的广播消息: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于接收广播消息的一端，必须要绑定固定的端口，并由广播端将广播消息发送到这个端口上，因此所有接收端都应绑定相同的端口，这样才能同时收到广播数据。</p></blockquote><hr><h1 id="12-UDP特性之组播（多播）"><a href="#12-UDP特性之组播（多播）" class="headerlink" title="12. UDP特性之组播（多播）"></a>12. UDP特性之组播（多播）</h1><h2 id="12-1-组播的特点"><a href="#12-1-组播的特点" class="headerlink" title="12.1 组播的特点"></a>12.1 组播的特点</h2><p>组播也可以称之为多播这也是UDP的特性之一。<code>组播是主机间一对多的通讯模式，是一种允许一个或多个组播源发送同一报文到多个接收者的技术</code>。组播源将一份报文发送到特定的组播地址，组播地址不同于单播地址，它并不属于特定某个主机，而是属于一组主机。一个组播地址表示一个群组，需要接收组播报文的接收者都加入这个群组。</p><ul><li>广播只能在局域网访问内使用，组播既可以在局域网中使用，也可以用于广域网</li><li>在发送广播消息的时候，连接到局域网的客户端不管想不想都会接收到广播数据，组播可以控制发送端的消息能够被哪些接收端接收，更灵活和人性化。</li><li>广播使用的是广播地址，组播需要使用组播地址。</li><li>广播和组播属性默认都是关闭的，如果使用需要通过setsockopt()函数进行设置。</li></ul><p>组播需要使用组播地址，在 IPv4 中它的范围从 <code>224.0.0.0</code> 到 <code>239.255.255.255</code>，并被划分为局部链接多播地址、预留多播地址和管理权限多播地址三类:</p><table><thead><tr><th>IP地址</th><th>说明</th></tr></thead><tbody><tr><td>224.0.0.0~224.0.0.255</td><td>局部链接多播地址：是为路由协议和其它用途保留的地只能用于局域网中，路由器是不会转发的地址 224.0.0.0不能用，是保留地址</td></tr><tr><td>224.0.1.0~224.0.1.255</td><td>为用户可用的组播地址（临时组地址），可以用于 Internet 上的。</td></tr><tr><td>224.0.2.0~238.255.255.255</td><td>用户可用的组播地址（临时组地址），全网范围内有效</td></tr><tr><td>239.0.0.0~239.255.255.255</td><td>为本地管理组播地址，仅在特定的本地范围内有效</td></tr></tbody></table><p>组播地址不属于任何服务器或个人，它有点类似一个微信群号，任何成员（<strong>组播源</strong>）往微信群（<strong>组播IP</strong>）发送消息（<strong>组播数据</strong>），这个群里的成员（组播接收者）都会接收到此消息。</p><hr><h2 id="12-2-设置组播属性"><a href="#12-2-设置组播属性" class="headerlink" title="12.2 设置组播属性"></a>12.2 设置组播属性</h2><p>如果使用组播进行数据的传输，不管是消息发送端还是接收端，都需要进行相关的属性设置，设置函数使用的是同一个，即：<code>setsockopt()。</code></p><h3 id="12-2-1-发送端"><a href="#12-2-1-发送端" class="headerlink" title="12.2.1 发送端"></a>12.2.1 发送端</h3><p>发送组播消息的一端需要设置组播属性，具体的设置方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>sockfd：用于UDP通信的套接字</li><li>level：套接字级别，设置组播属性需要将该参数指定为：IPPTOTO_IP</li><li>optname: 套接字选项名，设置组播属性需要将该参数指定为：IP_MULTICAST_IF</li><li>optval：设置组播属性，这个指针需要指向一个struct in_addr{} 类型的结构体地址，这个结构体地址用于存储组播地址，并且组播IP地址的存储方式是大端的。</li><li>optlen：optval指针指向的内存大小，即：sizeof(struct in_addr)</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;<span class="comment">// unsigned int</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li>返回值：函数调用成功返回0，调用失败返回-1</li></ul><hr><h3 id="12-2-2-接收端"><a href="#12-2-2-接收端" class="headerlink" title="12.2.2 接收端"></a>12.2.2 接收端</h3><p>因为一个组播地址表示一个群组，所以需要接收组播报文的接收者都加入这个群组，和想要接收群消息就必须要先入群是一个道理。加入到这个组播群组的方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数:</p><ul><li><p>sockfd：基于udp的通信的套接字</p></li><li><p>level：套接字级别，加入到多播组该参数需要指定为：<code>IPPTOTO_IP</code></p></li><li><p>optname：套接字选项名，加入到多播组该参数需要指定为：<code>IP_ADD_MEMBERSHIP</code></p></li><li><p>optval：加入到多播组，这个指针应该指向一个<code>struct ip_mreqn&#123;&#125;</code>类型的结构体地址</p></li><li><p>optlen：optval指向的内存大小，即：<code>sizeof(struct ip_mreqn)</code></p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>  <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;<span class="comment">// unsigned int</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span>   <span class="comment">// 组播地址/多播地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_address</span>;</span>     <span class="comment">// 本地地址</span></span><br><span class="line">    <span class="type">int</span>   imr_ifindex;              <span class="comment">// 网卡的编号, 每个网卡都有一个编号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 必须通过网卡名字才能得到网卡的编号: 可以通过 ifconfig 命令查看网卡名字</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将网卡名转换为网卡的编号, 参数是网卡的名字, 比如: &quot;ens33&quot;</span></span><br><span class="line"><span class="comment">// 返回值就是网卡的编号</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">if_nametoindex</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ifname)</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="12-3-组播通信流程"><a href="#12-3-组播通信流程" class="headerlink" title="12.3 组播通信流程"></a>12.3 组播通信流程</h2><p>发送组播消息的一端需要将数据发送到组播地址和固定的端口上，想要接收组播消息的终端需要绑定对应的固定端口然后加入到组播的群组，最终就可以实现数据的共享。</p><p><img src="/img/9.48.png" alt="在这里插入图片描述"></p><h3 id="12-3-1-发送端"><a href="#12-3-1-发送端" class="headerlink" title="12.3.1 发送端"></a>12.3.1 发送端</h3><ol><li>创建通信的套接字</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>主动发送数据的一端不需要手动绑定端口（自动随机分配就可以了），设置UDP组播属性</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置组播属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">opt</span>;</span></span><br><span class="line"><span class="comment">// 将组播地址初始化到这个结构体成员中</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;239.0.1.10&quot;</span>, &amp;opt.s_addr);</span><br><span class="line">setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure><ol start="3"><li>使用组播地址发送组播消息到固定的端口（接收端需要绑定这个端口）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendto();</span><br></pre></td></tr></table></figure><ol start="4"><li>关闭套接字（文件描述符）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure><hr><h3 id="12-3-2-接收端"><a href="#12-3-2-接收端" class="headerlink" title="12.3.2 接收端"></a>12.3.2 接收端</h3><ol><li>创建通信的套接字</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>绑定固定的端口，发送端应该将数据发送到接收端绑定的端口上</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind();</span><br></pre></td></tr></table></figure><ol start="3"><li>加入到组播的群组中，入群之后就可以接受组播消息了。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入到多播组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">opt</span>;</span></span><br><span class="line"><span class="comment">// 要加入到哪个多播组, 通过组播地址来区分</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;239.0.1.10&quot;</span>, &amp;opt.imr_multiaddr.s_addr);</span><br><span class="line">opt.imr_address.s_addr = INADDR_ANY;</span><br><span class="line">opt.imr_ifindex = if_nametoindex(<span class="string">&quot;ens33&quot;</span>);</span><br><span class="line">setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure><ol start="4"><li>接收组播数据</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recvfrom();</span><br></pre></td></tr></table></figure><ol start="5"><li>关闭套接字（文件描述符）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure><hr><h2 id="12-4-通信代码"><a href="#12-4-通信代码" class="headerlink" title="12.4 通信代码"></a>12.4 通信代码</h2><h3 id="12-4-1-发送端"><a href="#12-4-1-发送端" class="headerlink" title="12.4.1 发送端"></a>12.4.1 发送端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置组播属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">opt</span>;</span></span><br><span class="line">    <span class="comment">// 将组播地址初始化到这个结构体成员中即可</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.1.10&quot;</span>, &amp;opt.s_addr);</span><br><span class="line">    setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">9999</span>); <span class="comment">// 接收端需要绑定9999端口</span></span><br><span class="line">    <span class="comment">// 发送组播消息, 需要使用组播地址, 和设置组播属性使用的组播地址一致就可以</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.1.10&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, client...%d\n&quot;</span>, num++);</span><br><span class="line">        <span class="comment">// 数据广播</span></span><br><span class="line">        sendto(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发送的组播的数据: %s\n&quot;</span>, buf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在组播数据的发送端，需要先设置组播属性，发送的数据是通过sendto()函数发送到某一个组播地址上，并且在程序中数据发送到了接收端的9999端口，因此接收端程序必须要绑定这个端口才能收到组播消息。</p></blockquote><hr><h3 id="12-4-2-接收端"><a href="#12-4-2-接收端" class="headerlink" title="12.4.2 接收端"></a>12.4.2 接收端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通信的套接字和本地的IP与端口绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);    <span class="comment">// 大端</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 加入到多播组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">opt</span>;</span></span><br><span class="line">    <span class="comment">// 要加入到哪个多播组, 通过组播地址来区分</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.1.10&quot;</span>, &amp;opt.imr_multiaddr.s_addr);</span><br><span class="line">    opt.imr_address.s_addr = INADDR_ANY;</span><br><span class="line">    opt.imr_ifindex = if_nametoindex(<span class="string">&quot;ens33&quot;</span>);</span><br><span class="line">    setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收广播消息</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">// 阻塞等待数据达到</span></span><br><span class="line">        recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收到的组播消息: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：作为组播消息的接收端，必须要先绑定一个固定端口（发送端就可以把数据发送到这个固定的端口上了），然后加入到组播的群组中（一个组播地址可以看做是一个群组），这样就可以接收到组播消息了。</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-套接字-socket&quot;&gt;&lt;a href=&quot;#1-套接字-socket&quot; class=&quot;headerlink&quot; title=&quot;1. 套接字-socket&quot;&gt;&lt;/a&gt;1. 套接字-socket&lt;/h1&gt;&lt;h2 id=&quot;1-1-概念&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="套接字通信" scheme="http://example.com/tags/%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/"/>
    
    <category term="socket" scheme="http://example.com/tags/socket/"/>
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
    <category term="IO多路转接复用" scheme="http://example.com/tags/IO%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E5%A4%8D%E7%94%A8/"/>
    
    <category term="UDP" scheme="http://example.com/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="http://example.com/2023/10/22/%E8%BF%9B%E7%A8%8B/"/>
    <id>http://example.com/2023/10/22/%E8%BF%9B%E7%A8%8B/</id>
    <published>2023-10-22T01:53:28.000Z</published>
    <updated>2023-10-22T02:41:37.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-进程控制"><a href="#1-进程控制" class="headerlink" title="1. 进程控制"></a>1. 进程控制</h1><h2 id="1-1-进程概述"><a href="#1-1-进程概述" class="headerlink" title="1.1 进程概述"></a>1.1 进程概述</h2><p>从严格意义上来讲，程序和进程是两个不同的概念，他们的状态，占用的系统资源都是不同的。</p><ul><li>程序：就是磁盘上的可执行文件文件, 并且只占用磁盘上的空间，是一个静态的概念。</li><li>进程：被执行之后的程序叫做进程，不占用磁盘空间，需要消耗系统的内存，CPU资源，每个运行的进程的都对应一个属于自己的虚拟地址空间，这是一个动态的概念。</li></ul><h3 id="1-1-1-并行和并发"><a href="#1-1-1-并行和并发" class="headerlink" title="1.1.1 并行和并发"></a>1.1.1 并行和并发</h3><ul><li><p>CPU时间片<br>CPU在某个时间点只能处理一个任务，但是操作系统都支持多任务的，那么在计算机CPU只有一个的情况下是怎么完成多任务处理的呢？每个人分一点，但是又不叫吃饱。<br>CPU会给每个进程被分配一个时间段，进程得到这个时间片之后才可以运行，使各个程序从表面上看是同时进行的。<br>如果在时间片结束时进程还在运行，CPU的使用权将被收回，该进程将会被中断挂起等待下一个时间片。<br>如果进程在时间片结束前阻塞或结束,则CPU当即进行切换,这样就可避免CPU资源的浪费。<br>因此可以得知，在我们使用的计算机中启动的多个程序，从宏观上看是同时运行的，从微观上看由于CPU一次只能处理一个进程，所有它们是轮流执行的，只不过切换速度太快，感觉不到，因此CPU的核数越多计算机的处理效率越高。</p></li><li><p>并发和并行<br>这两个概念都可笼统的解释为：多个进程同时运行. 但是他们两个的同时并不是一个概念。Erlang 之父 Joe Armstrong 用一张小孩能看懂的图解释了并发与并行的区别：<br><img src="/img/9.1.png" alt="在这里插入图片描述"></p></li></ul><blockquote><p>并发：第一幅图是并发。</p></blockquote><ul><li>并发的同时运行是一个假象，咖啡机也好CPU也好在某一个时间点只能为某一个个体来服务，因此不可能同时处理多任务，这是通过上图的咖啡机&#x2F;计算机的CPU快速的时间片切换实现的。</li><li>并发是针对某一个硬件资源而言的，在某个时间段之内处理的任务的总量，量越大效率越高。</li><li>并发也可以理解为是不断努力自我升华的结果。</li></ul><blockquote><p>并行：第二幅图是并行。</p></blockquote><ul><li>并行的多进程同时运行是真实存在的，可以在同一时刻同时运行多个进程</li><li>并行需要依赖多个硬件资源，单个是无法实现的（图中有两台咖啡机）。</li><li>并行可以理解为出生就有天然的硬件优势，资源多办事效率就高。</li></ul><hr><h3 id="1-1-2-PCB"><a href="#1-1-2-PCB" class="headerlink" title="1.1.2 PCB"></a>1.1.2 PCB</h3><blockquote><p><strong>PCB - 进程控制块（Processing Control Block）</strong>，Linux内核的进程控制块本质上是一个叫做 <code>task_struct</code> 的结构体。<br>在这个结构体中记录了进程运行相关的一些信息，介绍一些常用的信息：</p></blockquote><ul><li><p>进程id：每一个进程都一个唯一的进程ID，类型为 <code>pid_t</code>, 本质是一个整形数</p></li><li><p>进程的状态：进程有不同的状态, 状态是一直在变化的，有就绪,运行,挂起,停止等状态。</p></li><li><p>进程对应的虚拟地址空间的信息。</p></li><li><p>描述控制终端的信息，进程在哪个终端启动默认就和哪个终端绑定。</p></li><li><p>当前工作目录：默认情况下, 启动进程的目录就是当前的工作目录</p></li><li><p>umask掩码：在创建新文件的时候，通过这个掩码屏蔽某些用于对文件的操作权限。</p></li><li><p>文件描述符表：每个被分配的文件描述符都对应一个已经打开的磁盘文件</p></li><li><p>和信号相关的信息：在Linux中 调用函数, 键盘快捷键, 执行shell命令等操作都会产生信号。</p><ul><li>阻塞信号集：记录当前进程中阻塞哪些已产生的信号，使其不能被处理</li></ul></li><li><p>未决信号集：记录在当前进程中产生的哪些信号还没有被处理掉。</p></li><li><p>用户id和组id：当前进程属于哪个用户, 属于哪个用户组</p></li><li><p>会话（Session）和进程组：多个进程的集合叫进程组，多个进程组的集合叫会话。</p></li><li><p>进程可以使用的资源上限：可以使用shell命令<code>ulimit -a</code>查看详细信息。</p></li></ul><hr><h3 id="1-1-4-进程状态"><a href="#1-1-4-进程状态" class="headerlink" title="1.1.4 进程状态"></a>1.1.4 进程状态</h3><p>进程一共有五种状态分别为：<code>创建态</code>，<code>就绪态</code>，<code>运行态</code>，<code>阻塞态(挂起态)</code>，<code>退出态(终止态)</code><br>其中 创建态 和 退出态 维持的时间是非常 短 的，稍纵即逝。<br>我们需将就绪态, 运行态, 挂起态，三者之间的状态切换搞明白。<br><img src="/img/9.2.png" alt="在这里插入图片描述"></p><ul><li>就绪态: 等待CPU资源<ul><li>进程被创建出来了，有运行的资格但是还没有运行，需要抢CPU时间片</li><li>得到CPU时间片，进程开始运行，从就绪态转换为运行态。</li><li>进程的CPU时间片用完了, 再次失去CPU, 从运行态转换为就绪态。</li></ul></li><li>运行态：获取到CPU资源的进程，进程只有在这种状态下才能运行<ul><li>运行态不会一直持续，进程的CPU时间片用完之后, 再次失去CPU，从运行态转换为就绪态</li><li>只要进程还没有退出，就会在就绪态和运行态之间不停的切换。</li></ul></li><li>阻塞态：进程被强制放弃CPU，并且没有抢夺CPU时间片的资格<ul><li>比如: 在程序中调用了某些函数（比如: sleep()），进程又运行态转换为阻塞态（挂起态）</li><li>当某些条件被满足了（比如：slee() 睡醒了），进程的阻塞状态也就被解除了，进程从阻塞态转换为就绪态。</li></ul></li><li>退出态: 进程被销毁, 占用的系统资源被释放了<ul><li>任何状态的进程都可以直接转换为退出态。</li></ul></li></ul><hr><h3 id="1-1-5-进程命令"><a href="#1-1-5-进程命令" class="headerlink" title="1.1.5 进程命令"></a>1.1.5 进程命令</h3><p>在研究如何创建进程之前，先来看一下如何在终端中通过命令完成进程相关的操作。</p><ul><li>查看进程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux</span><br><span class="line">- a: 查看所有终端的信息</span><br><span class="line">- u: 查看用户相关的信息</span><br><span class="line">- x: 显示和终端无关的进程信息</span><br></pre></td></tr></table></figure><p><img src="/img/9.3.png" alt="在这里插入图片描述"></p><p>如果特别想知道每个参数控制着哪些信息, 可以通过 <code>ps a</code>, <code>ps u</code>, <code>ps x</code>分别查看。</p><ul><li>杀死进程</li></ul><p><code>kill</code>命令可以发送某个信号到对应的进程，进程收到某些信号之后默认的处理动作就是退出进程，如果要给进程发送信号，可以先查看一下Linux给我们提供了哪些标准信号。</p><blockquote><p>查看Linux中的标准信号:</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><blockquote><p>9号信号（SIGKILL）的行为是无条件杀死进程，想要杀死哪个进程就可以把这个信号发送给这个进程，操作如下：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无条件杀死进程, 进程ID通过 ps aux 可以查看(PID)</span></span><br><span class="line">$ <span class="built_in">kill</span> -9 进程ID</span><br><span class="line">$ <span class="built_in">kill</span> -SIGKILL 进程ID</span><br></pre></td></tr></table></figure><hr><h2 id="1-2-进程创建"><a href="#1-2-进程创建" class="headerlink" title="1.2 进程创建"></a>1.2 进程创建</h2><h3 id="1-2-1-函数"><a href="#1-2-1-函数" class="headerlink" title="1.2.1 函数"></a>1.2.1 函数</h3><blockquote><p>Linux中进程ID为 <code>pid_t</code> 类型，其本质是一个正整数<br>通过上边的ps aux命令已经得到了验证。PID为1的进程是Linux系统中创建的第一个进程。</p></blockquote><ul><li>获取当前进程的进程ID（PID）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>获取当前进程的父进程 ID（PPID）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>创建一个新的进程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Linux中看似创建一个新的进程非常简单，函数连参数都没有<br>实际上如果想要真正理解这个函数还是要下功夫。</p></blockquote><hr><h3 id="1-2-2-fork-剖析"><a href="#1-2-2-fork-剖析" class="headerlink" title="1.2.2 fork() 剖析"></a>1.2.2 fork() 剖析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>启动磁盘上的应用程序, 得到一个进程, 如果在这个启动的进程中调用<code>fork()</code>函数，就会得到一个新的进程，我们习惯将其称之为<code>子进程</code>。<br>前面说过每个进程都对应一个属于自己的虚拟地址空间，<code>子进程的地址空间是基于父进程的地址空间拷贝出来的</code>，虽然是拷贝但是两个地址空间中存储的信息不可能是完全相同的，下图是拷贝之后父子进程各自的虚拟地址空间：<br><img src="/img/9.4.png" alt="在这里插入图片描述"></p><ul><li>相同点：<br><code>拷贝完成之后（注意这个时间点），两个地址空间中的用户区数据是相同的</code>。<br>用户区数据主要数据包括：<ul><li>代码区：默认情况下父子进程地址空间中的源代码始终相同。</li><li>全局数据区：父进程中的全局变量和变量值全部被拷贝一份放到了子进程地址空间中</li><li>堆区：父进程中的堆区变量和变量值全部被拷贝一份放到了子进程地址空间中</li><li>动态库加载区（内存映射区）：父进程中数据信息被拷贝一份放到了子进程地址空间中</li><li>栈区：父进程中的栈区变量和变量值全部被拷贝一份放到了子进程地址空间中</li><li>环境变量：默认情况下，父子进程地址空间中的环境变量始终相同。</li><li>文件描述符表: <code>父进程中被分配的文件描述符都会拷贝到子进程中，在子进程中可以使用它们打开对应的文件</code></li></ul></li><li>区别：<ul><li>父子进程各自的虚拟地址空间是相互独立的，不会互相干扰和影响。</li><li>父子进程地址空间中代码区代码虽然相同，但是父子进程执行的代码逻辑可能是不同的。</li><li>由于父子进程可能执行不同的代码逻辑，因此地址空间拷贝完成之后，<code>全局数据区, 栈区, 堆区, 动态库加载区(内存映射区)</code>数据会各自发生变化，由于地址空间是相互独立的，因此不会互相覆盖数据。</li><li>由于每个进都有自己的进程ID，因此内核区存储的父子进程ID是不同的。</li><li>进程启动之后进入就绪态，运行需要争抢CPU时间片而且可能执行不同的业务逻辑，所以父子进程的状态可能是不同的。</li><li>fork() 调用成功之后，会返回两个值，父子进程的返回值是不同的。<ul><li><code>该函数调用成功之后，从一个虚拟地址空间变成了两个虚拟地址空间，每个地址空间中都会将 fork() 的返回值记录下来</code>这就是为什么会得到两个返回值的原因。</li><li>父进程的虚拟地址空间中将该返回值标记为一个大于0的数（其实记录的是子进程的进程ID）</li><li>子进程的虚拟地址空间中将该返回值标记 0</li><li>在程序中需要通过 fork() 的返回值来判断当前进程是子进程还是父进程。</li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在父进程中创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前进程fork()的返回值: %d\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程执行的逻辑</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程执行的逻辑</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid = %d, 我爹是: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// pid == -1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建子进程失败了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不加判断, 父子进程都会执行这个循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-3-父子进程"><a href="#1-3-父子进程" class="headerlink" title="1.3 父子进程"></a>1.3 父子进程</h2><h3 id="1-3-1-进程执行位置"><a href="#1-3-1-进程执行位置" class="headerlink" title="1.3.1 进程执行位置"></a>1.3.1 进程执行位置</h3><p>在父进程中成功创建了子进程，子进程就拥有父进程代码区的所有代码，那么子进程中的代码是在什么位置开始运行的呢？<br><code>父进程是从main()函数开始运行的，子进程是在父进程中调用fork()函数之后被创建, 子进程就从fork()之后开始向下执行代码。</code><br><img src="/img/9.5.png" alt="在这里插入图片描述"></p><p>上图中演示了父子进程中代码的执行流程，可以看到如果在程序中对fork()的返回值做了判断，就可以控制父子进程的行为，如果没有做任何判断这个代码块父子进程都可以执行。<br>在编写多进程程序的时候，一定要将代码想象成多份进行分析，因为直观上看代码就一份，但实际上数据都是多份，且多份数据中变量名都相同，但是他们的值却不一定相同。</p><hr><h3 id="1-3-2-循环创建子进程"><a href="#1-3-2-循环创建子进程" class="headerlink" title="1.3.2 循环创建子进程"></a>1.3.2 循环创建子进程</h3><p>掌握了进程创建函数之后，实现一个简单的功能，在一个父进程中循环创建3个子进程，也就是最后需要得到4个进程，1个父进程，3个子进程<br>为了方便验证程序的正确性，要求在程序中打印出每个进程的进程ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// process_loop.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前进程pid: %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行上面的代码，得到了如下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">$ gcc process_loop.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">$ ./a.out</span><br><span class="line"><span class="comment"># 最终得到了 8个进程</span></span><br><span class="line">当前进程pid: 18774     ------ 1</span><br><span class="line">当前进程pid: 18774     ------ 1</span><br><span class="line">当前进程pid: 18774     ------ 1</span><br><span class="line">当前进程pid: 18777     ------ 2</span><br><span class="line">当前进程pid: 18776     ------ 3</span><br><span class="line">当前进程pid: 18776     ------ 3</span><br><span class="line">当前进程pid: 18775     ------ 4</span><br><span class="line">当前进程pid: 18775     ------ 4</span><br><span class="line">当前进程pid: 18775     ------ 4</span><br><span class="line">当前进程pid: 18778     ------ 5</span><br><span class="line">当前进程pid: 18780     ------ 6</span><br><span class="line">当前进程pid: 18779     ------ 7</span><br><span class="line">当前进程pid: 18779     ------ 7</span><br><span class="line">当前进程pid: 18781     ------ 8</span><br></pre></td></tr></table></figure><p>通过程序打印的信息发现程序循环了三次，最终得到了8个进程，也就是创建出了7个子进程,没有在程序中加条件控制，所有的代码父子进程都是有资格执行的。<br><img src="/img/9.6.png" alt="在这里插入图片描述"></p><p>上图中的树状结构，蓝色节点代表父进程：</p><ul><li>循环第一次 i &#x3D; 0，创建出一个子进程，即红色节点，子进程变量值来自父进程拷贝，因此 i&#x3D;0</li><li>循环第二次 i &#x3D; 1，蓝色父进程和红色子进程都去创建子进程，得到两个紫色进程，子进程变量值来自父进程拷贝，因此 i&#x3D;1</li><li>循环第三次 i &#x3D; 2，蓝色父进程和红色、紫色子进程都去创建子进程，因此得到4个绿色子进程，子进程变量值来自父进程拷贝，因此 i&#x3D;2</li><li>循环第四次 i &#x3D; 3，所有进程都不满足条件 <code>for(int i=0; i&lt;3; ++i)</code>因此不进入循环，退出了。</li></ul><p>解决方案:可以只让父进程创建子进程，如果是子进程不让其继续创建子进程，只需在程序中添加关于父子进程的判断即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要在上边的程序中控制不让子进程, 再创建子进程即可</span></span><br><span class="line"><span class="comment">// process_loop.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 在循环中创建子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不让子进程执行循环, 直接跳出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前进程pid: %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后编译并执行程序，查看最终结果，可以看到最后确实得到了4个不同的进程<br>pid最小的为父进程，其余为子进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">$ gcc process_loop.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">$ ./a.out</span><br><span class="line">当前进程pid: 2727</span><br><span class="line">当前进程pid: 2730</span><br><span class="line">当前进程pid: 2729</span><br><span class="line">当前进程pid: 2728</span><br></pre></td></tr></table></figure><blockquote><p>在多进程序中，进程的执行顺序是没有规律的，因为所有的进程都需要在就绪态争抢CPU时间片，抢到了就执行，抢不到就不执行<br>默认进程的优先级是相同的，操作系统不会让某一个进程一直抢不到CPU时间片。</p></blockquote><hr><h3 id="1-3-3-终端显示问题"><a href="#1-3-3-终端显示问题" class="headerlink" title="1.3.3 终端显示问题"></a>1.3.3 终端显示问题</h3><p>在执行多进程程序的时候，经常会遇到下图中的问题<br>看似进程还没有执行完成，貌似因为什么被阻塞了，实际上终端是正常的，通过键盘输入一些命令，终端也能接受输入并输出相关信息，那为什么终端会显示成这样呢？<br><img src="/img/9.7.png" alt="在这里插入图片描述"></p><ol><li><p>a.out 进程启动之后，共创建了3个子进程，其实 a.out 也是有父进程的就是当前的终端</p></li><li><p>终端只能检测到 a.out 进程的状态，a.out执行期间终端切换到后台，a.out执行完毕之后终端切换回前台</p></li><li><p>当终端切换到前之后，a.out的子进程还没有执行完毕，当子进程输出的信息就显示到终端命令提示符的后边了，导致终端显示有问题，但是此时终端是可以接收键盘输入的，只是看起来不美观而已。</p></li><li><p>想要解决这个问题，需要让所有子进程退出之后再退出父进程，比如：在父进程代码中调用 sleep()</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sleep(<span class="number">3</span>);<span class="comment">// 让父进程睡一会儿</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-3-4-进程数数"><a href="#1-3-4-进程数数" class="headerlink" title="1.3.4 进程数数"></a>1.3.4 进程数数</h3><p>当父进程创建一个子进程，那么父子进程之间可以通过全局变量互动，实现交替数数的功能吗?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// number.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量</span></span><br><span class="line"><span class="type">int</span> number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建子进程之前 number = %d\n&quot;</span>, number);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="comment">// 父子进程都会执行这一行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前进程fork()的返回值: %d\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid = %d, number = %d\n&quot;</span>, getpid(), ++number);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程的父进程(终端进程), pid = %d\n&quot;</span>, getppid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        number += <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid = %d, number = %d\n&quot;</span>, getpid(), number);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程的父进程, pid = %d\n&quot;</span>, getppid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译程序并测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ gcc number.c</span><br><span class="line">$ ./a.out </span><br><span class="line">创建子进程之前 number = 10</span><br><span class="line">当前进程fork()的返回值: 3513</span><br><span class="line">当前进程fork()的返回值: 0</span><br><span class="line">我是子进程, pid = 3513, number = 110</span><br><span class="line">子进程的父进程, pid = 3512</span><br><span class="line"></span><br><span class="line">我是父进程, pid = 3512, number = 11</span><br><span class="line"><span class="comment">#没有接着子进程的110继续数,父子进程各玩各的,测试失败</span></span><br><span class="line">父进程的父进程(终端进程), pid = 2175</span><br></pre></td></tr></table></figure><blockquote><p>通过验证得到结论：两个进程中是不能通过全局变量实现数据交互的<br>因为每个进程都有自己的地址空间，两个同名全局变量存储在不同的虚拟地址空间中，二者没有任何关联性。<br>如果要进行进程间通信需要使用：管道，共享内存，本地套接字，内存映射区，消息队列等方式。</p></blockquote><hr><h2 id="1-4-execl和execlp函数"><a href="#1-4-execl和execlp函数" class="headerlink" title="1.4 execl和execlp函数"></a>1.4 execl和execlp函数</h2><p>在项目开发过程中，有时候有这种需求，需要通过现在运行的进程启动磁盘上的另一个可执行程序，也就是通过一个进程启动另一个进程，这种情况下我们可以使用 <code>exec族函数</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">          <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">           <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">           <span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">            <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure><p><code>这些函数执行成功后不会返回</code>，因为调用进程的实体，包括<code>代码段</code>，<code>数据段</code>和<code>堆栈</code>等都已经被新的内容取代（也就是说用户区数据基本全部被替换掉了），只留下进程ID等一些表面上的信息仍保持原样.<br>只有调用失败了，它们才会返回一个 -1，从原程序的调用点接着往下执行。</p><blockquote><p>也就是说exec族函数并没有创建新进程的能力<br>让启动的新进程寄生到自己虚拟地址空间之内，并挖空了自己的地址空间用户区，把新启动的进程数据填充进去。</p></blockquote><p>exec族函数中最常用的有两个<code>execl()</code>和<code>execlp()</code>，这两个函数是对其他4个函数做了进一步的封装，介绍一下。</p><hr><h3 id="1-4-1-execl"><a href="#1-4-1-execl" class="headerlink" title="1.4.1 execl()"></a>1.4.1 execl()</h3><p>该函数可用于执行任意一个可执行程序，<code>函数需要通过指定的文件路径才能找到这个可执行程序。</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 变参函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li><code>path</code>: 要启动的可执行程序的路径, 推荐使用绝对路径</li><li><code>arg</code>: ps aux 查看进程的时候, 启动的进程的名字, 可以随意指定, 一般和要启动的可执行程序名相同</li><li><code>...</code>: 要执行的命令需要的参数，可以写多个，最后以 NULL 结尾，表示参数指定完了。</li></ul></li><li>返回值：如果这个函数执行成功, 没有返回值，如果执行失败, 返回 -1</li></ul><hr><h3 id="1-4-2-execlp"><a href="#1-4-2-execlp" class="headerlink" title="1.4.2 execlp()"></a>1.4.2 execlp()</h3><p>该函数常用于执行已经设置了环境变量的可执行程序，函数中的 <code>p</code> 就是<code>path</code>，也是说这个函数会自动搜索系统的环境变量<code>PATH</code><br>因此使用这个函数执行可执行程序不需要指定路径，只需要指定出名字即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p == path</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li><code>file</code>: 可执行程序的名字<ul><li>在环境变量PATH中，可执行程序可以不加路径</li><li>没有在环境变量PATH中, 可执行程序需要指定绝对路径</li></ul></li><li><code>arg</code>: ps aux 查看进程的时候, 启动的进程的名字, 可以随意指定, 一般和要启动的可执行程序名相同</li><li><code>...</code>: 要执行的命令需要的参数，可以写多个，最后以 NULL 结尾，表示参数指定完了。</li></ul></li><li>返回值：如果这个函数执行成功, 没有返回值，如果执行失败, 返回 -1</li></ul><hr><h3 id="1-4-3-函数的使用"><a href="#1-4-3-函数的使用" class="headerlink" title="1.4.3 函数的使用"></a>1.4.3 函数的使用</h3><p>一般不会在进程中直接调用，如果直接调用这个进程的代码区代码被替换也就不能按照原来的流程工作了。<br><code>一般在调用这些函数的时候都会先创建一个子进程，在子进程中调用 exec 族函数，子进程的用户区数据被替换掉开始执行新的程序中的代码逻辑，但是父进程不受任何影响仍然可以继续正常工作。</code></p><p>execl() 或者 execlp() 函数的使用方法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="comment">// 在子进程中执行磁盘上的可执行程序</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 磁盘上的可执行程序 /bin/ps</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">        execl(<span class="string">&quot;/bin/ps&quot;</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 也可以这么写</span></span><br><span class="line">        <span class="comment">// execl(&quot;/bin/ps&quot;, &quot;title&quot;, &quot;a&quot;, &quot;u&quot;, &quot;x&quot;, NULL);  </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 也可以这么写</span></span><br><span class="line">        <span class="comment">// execl(&quot;ps&quot;, &quot;title&quot;, &quot;a&quot;, &quot;u&quot;, &quot;x&quot;, NULL);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 如果成功,当前子进程的代码区被ps中的代码区代码替换</span></span><br><span class="line">        <span class="comment">// 下面的所有代码都不会执行</span></span><br><span class="line">        <span class="comment">// 如果函数调用失败了,才会继续执行下面的代码</span></span><br><span class="line">        perror(<span class="string">&quot;execl&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++++++++++++++++++++++++\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++++++++++++++++++++++++\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++++++++++++++++++++++++\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++++++++++++++++++++++++\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++++++++++++++++++++++++\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++++++++++++++++++++++++\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程.....\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/9.8.png" alt="在这里插入图片描述"></p><hr><h2 id="1-5-进程控制"><a href="#1-5-进程控制" class="headerlink" title="1.5  进程控制"></a>1.5  进程控制</h2><p>进程控制主要是指<code>进程的退出</code>, <code>进程的回收</code>和进程的特殊状态 <code>孤儿进程</code>和<code>僵尸进程</code>。</p><h3 id="1-5-1-结束进程"><a href="#1-5-1-结束进程" class="headerlink" title="1.5.1 结束进程"></a>1.5.1 结束进程</h3><p>想要直接退出某个进程可以在程序的任何位置调用<code>exit()</code>或者<code>_exit()</code>函数。<br>函数的参数相当于退出码, 如果参数值为 0 程序退出之后的状态码就是0, 如果是100退出的状态码就是100。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 专门退出进程的函数, 在任何位置调用都可以</span></span><br><span class="line"><span class="comment">// 标准C库函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux的系统函数</span></span><br><span class="line"><span class="comment">// 可以这么理解, 在linux中 exit() 函数 封装了 _exit()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure><p>在 main 函数中直接使用 <code>return</code> 也可以退出进程,<br>假如是在一个普通函数中调用 return 只能返回到调用者的位置，而不能退出进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ***** return 必须要在main()函数中调用, 才能退出进程 *****</span></span><br><span class="line"><span class="comment">// 举例:</span></span><br><span class="line"><span class="comment">// 没有问题的例子</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 进程退出了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////// 不能退出的例子 //////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">666</span>;<span class="comment">// 返回到调用者调用该函数的位置, 返回到 main() 函数的第19行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用这个函数, 当前进程不能退出</span></span><br><span class="line">    <span class="type">int</span> ret = func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-5-2-孤儿进程"><a href="#1-5-2-孤儿进程" class="headerlink" title="1.5.2 孤儿进程"></a>1.5.2 孤儿进程</h3><p>在一个启动的进程中创建子进程，这时候父子进程同时运行，但是父进程由于某种原因先退出了，子进程还在运行，这时候这个子进程就可以被称之为孤儿进程。</p><p>操作系统是非常关爱运行的每一个进程的，当检测到某一个进程变成了孤儿进程，这时候系统中就会有一个固定的进程领养这个孤儿进程。<br>如果使用Linux没有桌面终端，这个领养孤儿进程的进程就是 init 进程（PID&#x3D;1）<br>如果有桌面终端，这个领养孤儿进程就是桌面进程。</p><p>那么问题来了，系统为什么要领养这个孤儿进程呢？<br><code>在子进程退出的时候, 进程中的用户区可以自己释放, 但是进程内核区的pcb资源自己无法释放，必须要由父进程来释放子进程的pcb资源，孤儿进程被领养之后，这件事爹就可以代劳，避免系统资源的浪费。</code></p><p>下面这段代码就可以得到一个孤儿进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);<span class="comment">// 强迫子进程睡眠1s, 这个期间, 父进程退出, 当前进程变成了孤儿进程</span></span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 程序输出的结果</span></span><br><span class="line">$ ./a.out </span><br><span class="line">我是父进程, pid=22459</span><br><span class="line">我是子进程, pid=22460, 父进程ID: 1<span class="comment"># 父进程向退出, 子进程变成孤儿进程, 子进程被1号进程回收</span></span><br></pre></td></tr></table></figure><hr><h3 id="1-5-3-僵尸进程"><a href="#1-5-3-僵尸进程" class="headerlink" title="1.5.3 僵尸进程"></a>1.5.3 僵尸进程</h3><p>在一个启动的进程中创建子进程，这时候就有了父子两个进程，父进程正常运行, 子进程先与父进程结束, 子进程无法释放自己的PCB资源, 需要父进程来做这个件事儿, 但是如果父进程也不管, 这时候子进程就变成了僵尸进程。</p><blockquote><p>僵尸进程不能将它看成是一个正常的进程，这个进程已经死亡，用户区资源已经被释放，只是还占用一些内核资源（PCB）。</p></blockquote><p>运行下面的代码就可以得到一个僵尸进程了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 需要保证父进程一直在运行</span></span><br><span class="line">        <span class="comment">// 一直运行不退出, 并且也做回收, 就会出现僵尸进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程, 执行这句代码之后, 子进程退出了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ps aux 查看进程信息</span></span><br><span class="line"><span class="comment"># Z+ --&gt; 这个进程是僵尸进程, defunct, 表示进程已经死亡</span></span><br><span class="line">robin     22598  0.0  0.0   4352   624 pts/2    S+   10:11   0:00 ./app</span><br><span class="line">robin     22599  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] &lt;defunct&gt; <span class="comment"># 子进程</span></span><br><span class="line">robin     22600  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] &lt;defunct&gt; <span class="comment"># 子进程</span></span><br><span class="line">robin     22601  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] &lt;defunct&gt; <span class="comment"># 子进程</span></span><br><span class="line">robin     22602  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] &lt;defunct&gt; <span class="comment"># 子进程</span></span><br><span class="line">robin     22603  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] &lt;defunct&gt; <span class="comment"># 子进程</span></span><br></pre></td></tr></table></figure><blockquote><p>消灭僵尸进程的方法是杀死这个僵尸进程的父进程，这样僵尸进程的资源就被系统回收了.<br><code>kill -9僵尸进程PID的方式是不能消灭僵尸进程的</code>，这个命令只对活着的进程有效，僵尸进程已经死了，鞭尸是不能解决问题的。</p></blockquote><hr><h3 id="1-5-4-进程回收"><a href="#1-5-4-进程回收" class="headerlink" title="1.5.4 进程回收"></a>1.5.4 进程回收</h3><p>为了避免僵尸进程的产生，一般我们会在父进程中进行子进程的资源回收<br>回收方式有两种，一种是阻塞方式<code>wait()</code>，一种是非阻塞方式<code>waitpid()</code>。</p><h4 id="1-5-4-1-wait"><a href="#1-5-4-1-wait" class="headerlink" title="1.5.4.1 wait()"></a>1.5.4.1 wait()</h4><p>这是个阻塞函数，如果没有子进程退出, 函数会一直阻塞等待<br>当检测到子进程退出了, 该函数阻塞解除回收子进程资源。<br>这个函数被调用一次, 只能回收一个子进程的资源，如有多个子进程需要资源回收, 函数需被调用多次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">// man 2 wait</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：传出参数，通过传递出的信息判断回收的进程是怎么退出的，如果不需要该信息可以指定为 NULL。取出整形变量中的数据需要使用一些宏函数，具体操作方式如下：<ul><li><code>WIFEXITED(status)</code>: 返回1, 进程是正常退出的</li><li><code>WEXITSTATUS(status)</code>：得到进程退出时候的状态码，相当于 return 后边的数值, 或者 exit()函数的参数</li><li><code>WIFSIGNALED(status)</code>: 返回1, 进程是被信号杀死了</li><li><code>WTERMSIG(status)</code>: 获得进程是被哪个信号杀死的，会得到信号的编号</li></ul></li><li>返回值:<ul><li>成功：返回被回收的子进程的进程ID</li><li>失败: -1<ul><li>没有子进程资源可以回收了, 函数的阻塞会自动解除, 返回-1</li><li>回收子进程资源的时候出现了异常</li></ul></li></ul></li></ul><p>下面代码演示了如何通过 wait()回收多个子进程资源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait 函数回收子进程资源</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 需要保证父进程一直在运行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 回收子进程的资源</span></span><br><span class="line">            <span class="comment">// 子进程由多个, 需要循环回收子进程资源</span></span><br><span class="line">            <span class="type">pid_t</span> ret = wait(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;成功回收了子进程资源, 子进程PID: %d\n&quot;</span>, ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;回收失败, 或者是已经没有子进程了...\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程, 执行这句代码之后, 子进程退出了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="1-5-4-2-waitpid"><a href="#1-5-4-2-waitpid" class="headerlink" title="1.5.4.2 waitpid()"></a>1.5.4.2 waitpid()</h4><p>waitpid() 函数可以看做是 wait() 函数的升级版，通过该函数可以控制回收子进程资源的方式是阻塞还是非阻塞，另外还可以通过该函数进行精准打击，可以精确指定回收某个或者某一类或者是全部子进程资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">// man 2 waitpid</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">// 这个函数可以设置阻塞, 也可以设置为非阻塞</span></span><br><span class="line"><span class="comment">// 这个函数可以指定回收哪些子进程的资源</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li><p>pid:</p><ul><li>-1：回收所有的子进程资源, 和wait()是一样的, 无差别回收，并不是一次性就可以回收多个, 也是需要循环回收的</li><li>大于0：指定回收某一个进程的资源 ，pid是要回收的子进程的进程ID</li><li>0：回收当前进程组的所有子进程ID</li><li>小于 -1：pid 的绝对值代表进程组ID，表示要回收这个进程组的所有子进程资源</li></ul></li><li><p>status: NULL, 和wait的参数是一样的</p></li><li><p>options: 控制函数是阻塞还是非阻塞</p><ul><li>0: 函数行为是阻塞的 &#x3D;&#x3D;&gt; 和wait一样</li><li>WNOHANG: 函数行为是非阻塞的</li></ul></li></ul></li><li>返回值<ul><li>如果函数是非阻塞的, 并且子进程还在运行, 返回0</li><li>成功: 得到子进程的进程ID</li><li>失败: -1<ul><li>没有子进程资源可以回收了, 函数如果是阻塞的, 阻塞会解除, 直接返回-1</li><li>回收子进程资源的时候出现了异常</li></ul></li></ul></li></ul><p>下面代码演示了如何通过 <code>waitpid()</code>阻塞回收多个子进程资源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和wait() 行为一样, 阻塞</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 需要保证父进程一直在运行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 回收子进程的资源</span></span><br><span class="line">            <span class="comment">// 子进程由多个, 需要循环回收子进程资源</span></span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="type">pid_t</span> ret = waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>);  <span class="comment">// == wait(NULL);</span></span><br><span class="line">            <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;成功回收了子进程资源, 子进程PID: %d\n&quot;</span>, ret);</span><br><span class="line">                                <span class="comment">// 判断进程是不是正常退出</span></span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;子进程退出时候的状态码: %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;子进程是被这个信号杀死的: %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;回收失败, 或者是已经没有子进程了...\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程, 执行这句代码之后, 子进程退出了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;===我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面代码演示了如何通过 <code>waitpid()</code>非阻塞回收多个子进程资源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非阻塞处理</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 需要保证父进程一直在运行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 回收子进程的资源</span></span><br><span class="line">            <span class="comment">// 子进程由多个, 需要循环回收子进程资源</span></span><br><span class="line">            <span class="comment">// 子进程退出了就回收, </span></span><br><span class="line">            <span class="comment">// 没退出就不回收, 返回0</span></span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="type">pid_t</span> ret = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG);  <span class="comment">// 非阻塞</span></span><br><span class="line">            <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;成功回收了子进程资源, 子进程PID: %d\n&quot;</span>, ret);</span><br><span class="line">                <span class="comment">// 判断进程是不是正常退出</span></span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;子进程退出时候的状态码: %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;子进程是被这个信号杀死的: %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;子进程还没有退出, 不做任何处理...\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;回收失败, 或者是已经没有子进程了...\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程, 执行这句代码之后, 子进程退出了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;===我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="2-管道"><a href="#2-管道" class="headerlink" title="2. 管道"></a>2. 管道</h1><h2 id="2-1-管道"><a href="#2-1-管道" class="headerlink" title="2.1 管道"></a>2.1 管道</h2><p>管道的是进程间通信（IPC - InterProcess Communication）的一种方式，管道的本质其实就是内核中的一块内存(或者叫内核缓冲区)<br>这块缓冲区中的数据存储在一个环形队列中，因为管道在内核里边，因此我们不能直接对其进行任何操作。<br><img src="/img/9.9.png" alt="在这里插入图片描述"></p><p>因为管道数据是通过队列来维护的，我们先来分析一个管道中数据的特点：</p><ul><li><p>管道对应的内核缓冲区大小是固定的，默认为4k（也就是队列最大能存储4k数据）</p></li><li><p>管道分为两部分：读端和写端（队列的两端），数据从写端进入管道，从读端流出管道。</p></li><li><p>管道中的数据只能读一次，做一次读操作之后数据也就没有了（读数据相当于出队列）。</p></li><li><p>管道是单工的：数据只能单向流动, 数据从写端流向读端。</p></li><li><p>对管道的操作（读、写）默认是阻塞的</p><ul><li>读管道：管道中没有数据，读操作被阻塞，当管道中有数据之后阻塞才能解除</li><li>写管道：管道被写满了，写数据的操作被阻塞，当管道变为不满的状态，写阻塞解除</li></ul></li></ul><p>管道在内核中, 不能直接对其进行操作，通过什么方式去读写管道呢？<br>其实管道操作就是文件IO操作，内核中管道的两端分别对应两个文件描述符<br>通过写端的文件描述符把数据写入到管道中，通过读端的文件描述符将数据从管道中读出来。<br>读写管道的函数就是Linux中的文件IO函数 read&#x2F;write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读管道</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="comment">// 写管道的函数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>分析一下为什么可以使用管道进行进程间通信，看一下图片：<br><img src="/img/9.10.png" alt="在这里插入图片描述"></p><p>在上图中假设父进程一系列操作:可以通过文件描述符表中的文件描述符fd3写管道，通过fd4读管道，然后再<code>通过 fork() 创建出子进程，那么在父进程中被分配的文件描述符 fd3， fd4也就被拷贝到子进程中，子进程通过 fd3可以将数据写入到内核的管道中，通过fd4将数据从管道中读出来。</code></p><p>也就是说管道是独立于任何进程的，并且充当了两个进程用于数据通信的载体，只要两个进程能够得到同一个管道的入口和出口（读端和写端的文件描述符），那么他们之间就可以通过管道进行数据的交互。</p><hr><h2 id="2-2-匿名管道"><a href="#2-2-匿名管道" class="headerlink" title="2.2 匿名管道"></a>2.2 匿名管道</h2><h3 id="2-2-1-创建匿名管道"><a href="#2-2-1-创建匿名管道" class="headerlink" title="2.2.1 创建匿名管道"></a>2.2.1 创建匿名管道</h3><p>匿名管道是管道的一种，既然是匿名也就是说这个管道没有名字，但其本质不变，就是位于内核中的一块内存，匿名管道拥有上面介绍的管道的所有特性<br>额外我们需知,匿名管道只能实现有血缘关系的进程间通信,如：父子进程，兄弟进程，爷孙进程，叔侄进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建匿名函数的函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个匿名的管道, 得到两个可用的文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：传出参数，需要传递一个整形数组的地址，数组大小为 2，也就是说最终会传出两个元素<ul><li><code>pipefd[0]: 对应管道读端的文件描述符，通过它可以将数据从管道中读出</code></li><li><code>pipefd[1]: 对应管道写端的文件描述符，通过它可以将数据写入到管道中</code></li></ul></li><li>返回值：成功返回 0，失败返回 -1</li></ul><hr><h3 id="2-2-2-进程间通信"><a href="#2-2-2-进程间通信" class="headerlink" title="2.2.2 进程间通信"></a>2.2.2 进程间通信</h3><p>使用匿名管道只能够实现有血缘关系的进程间通信，要求写一段程序完成下边的功能：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">需求描述:</span><br><span class="line">   在父进程中创建一个子进程, 父子进程分别执行不同的操作:</span><br><span class="line">     - 子进程: 执行一个shell命令 <span class="string">&quot;ps aux&quot;</span>, 将命令的结果传递给父进程</span><br><span class="line">     - 父进程: 将子进程命令的结果输出到终端</span><br></pre></td></tr></table></figure><p>需求分析:</p><ul><li>子进程中执行shell命令相当于启动一个磁盘程序，因此需要使用 execl()&#x2F;execlp()函数<ul><li>execlp(“ps”, “ps”, “aux”, NULL)</li></ul></li><li>子进程中执行完shell命令直接就可以在终端输出结果，如果将这些信息传递给父进程呢？<ul><li>数据传递需要使用管道，子进程需要将数据写入到管道中</li><li>将默认输出到终端的数据写入到管道就需要进行输出的重定向，需要使用 <code>dup2()</code> 做这件事情<ul><li><code>dup2(fd[1], STDOUT_FILENO);</code></li></ul></li></ul></li><li>父进程需要读管道，将从管道中读出的数据打印到终端</li><li>父进程最后需要释放子进程资源，防止出现僵尸进程</li></ul><p>在使用管道进行进程间通信的注意事项：<code>必须要保证数据在管道中的单向流动</code>。<br>这句话怎么理解呢，通过下面的图来分析一下：</p><blockquote><p>第一步: 在父进程中创建了匿名管道，得到了两个分配的文件描述符，fd3操作管道的读端，fd4操作管道的写端。</p></blockquote><p><img src="/img/9.11.png" alt="在这里插入图片描述"></p><blockquote><p>第二步：父进程创建子进程，父进程的文件描述符被拷贝，在子进程的文件描述符表中也得到了两个被分配的可以使用的文件描述符，通过fd3读管道，通过fd4写管道。通过下图可以看到管道中数据的流动不是单向的，有以下这么几种情况：</p><p>父进程通过fd4将数据写入管道，然后父进程再通过fd3将数据从管道中读出<br>父进程通过fd4将数据写入管道，然后子进程再通过fd3将数据从管道中读出<br>子进程通过fd4将数据写入管道，然后子进程再通过fd3将数据从管道中读出<br>子进程通过fd4将数据写入管道，然后父进程再通过fd3将数据从管道中读出<br>前边说到过，管道行为默认是阻塞的，假设子进程通过写端将数据写入管道，父进程的读端将数据读出，这样子进程的读端就读不到数据，导致子进程阻塞在读管道的操作上，这样就会给程序的执行造成一些不必要的影响。<br>如果我们本来也没有打算让进程读或者写管道，那么就可以将进程操作的读端或者写端关闭。</p></blockquote><p><img src="/img/9.12.png" alt="在这里插入图片描述"></p><blockquote><p>第三步：为了避免两个进程都读管道，但是可能其中某个进程由于读不到数据而阻塞的情况，我们可以关闭进程中用不到的那一端的文件描述符，这样数据就只能单向的从一端流向另外一端了，如下图，我们关闭了父进程的写端，关闭了子进程的读端：</p></blockquote><p><img src="/img/9.13.png" alt="在这里插入图片描述"></p><p>根据上面的分析，最终可以写出下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管道的数据是单向流动的:</span></span><br><span class="line"><span class="comment">// 操作管道的是两个进程, 进程A读管道, 需要关闭管道的写端, 进程B写管道, 需要关闭管道的读端</span></span><br><span class="line"><span class="comment">// 如果不做上述的操作, 会对程序的结果造成一些影响, 对管道的操作无法结束</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建匿名管道, 得到两个文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 创建子进程 -&gt; 能够操作管道的文件描述符被复制到子进程中</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 3. 在子进程中执行 execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL);</span></span><br><span class="line">        <span class="comment">// 在子进程中完成输出的重定向, 原来输出到终端现在要写管道</span></span><br><span class="line">        <span class="comment">// 进程打印数据默认输出到终端, 终端对应的文件描述符: stdout_fileno</span></span><br><span class="line">        <span class="comment">// 标准输出 重定向到 管道的写端</span></span><br><span class="line">        dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 父进程读管道</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 关闭管道的写端</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 5. 父进程打印读到的数据信息</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">        <span class="comment">// 读管道</span></span><br><span class="line">        <span class="comment">// 如果管道中没有数据, read会阻塞</span></span><br><span class="line">        <span class="comment">// 有数据之后, read解除阻塞, 直接读数据</span></span><br><span class="line">        <span class="comment">// 需要循环读数据, 管道是有容量的, 写满之后就不写了</span></span><br><span class="line">        <span class="comment">// 数据被读走之后, 继续写管道, 那么就需要再继续读数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="type">int</span> len = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 管道的写端关闭了, 如果管道中没有数据, 管道读端不会阻塞</span></span><br><span class="line">                <span class="comment">// 没数据直接返回0, 如果有数据, 将数据读出, 数据读完之后返回0</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s, len = %d\n&quot;</span>, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回收子进程资源</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-3-有名管道"><a href="#2-3-有名管道" class="headerlink" title="2.3 有名管道"></a>2.3 有名管道</h2><h3 id="2-3-1-创建有名管道"><a href="#2-3-1-创建有名管道" class="headerlink" title="2.3.1 创建有名管道"></a>2.3.1 创建有名管道</h3><p>有名管道拥有管道的所有特性，之所以称为有名是因管道在磁盘上有实体文件, 文件类型为<code>p</code> ，<code>有名管道文件大小永为0，因有名管道是将数据存储到内存的缓冲区中，打开这个磁盘上的管道文件就可以得到操作有名管道的文件描述符，通过文件描述符读写管道存储在内核中的数据。</code></p><p>有名管道也可称为 <code>fifo (first in first out)</code>，有名管道既可进行有血缘关系的进程间通信，也可进行没有血缘关系的进程间通信。<br>创建有名管道的方式有两种，一种是通过命令，一种是通过函数。</p><ul><li>通过命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkfifo</span> 有名管道的名字</span><br></pre></td></tr></table></figure><ul><li>通过函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="comment">// int open(const char *pathname, int flags, mode_t mode);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>pathname: 要创建的有名管道的名字</li><li>mode: 文件的操作权限, 和open()的第三个参数一个作用，最终权限: <code>(mode &amp; ~umask)</code></li></ul></li><li>返回值：创建成功返回 0，失败返回 -1</li></ul><hr><h3 id="2-3-2-进程间通信"><a href="#2-3-2-进程间通信" class="headerlink" title="2.3.2 进程间通信"></a>2.3.2 进程间通信</h3><p>不管有血缘关系还是没血缘关系，使用有名管道实现进程间通信的方式是相同的<br>就是在两个进程中分别以读、写的方式打开磁盘上的管道文件<br>得到用于读管道、写管道的文件描述符，就可调用对应的read()、write()函数进行读写操作了。</p><blockquote><p>有名管道操作需要通过 open() 操作得到读写管道的文件描述符，如果只是读端打开了或者只是写端打开了，进程会阻塞在这里不会向下执行<br>直到在另一个进程中将管道的对端打开，当前进程的阻塞也就解除了。<br>所以当发现进程阻塞在了open()函数上不要感到惊讶。·</p></blockquote><ul><li>写管道的进程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 创建有名管道文件 </span><br><span class="line">mkfifo()</span><br><span class="line"><span class="number">2.</span> 打开有名管道文件, 打开方式是 o_wronly</span><br><span class="line"><span class="type">int</span> wfd = open(<span class="string">&quot;xx&quot;</span>, O_WRONLY);</span><br><span class="line"><span class="number">3.</span> 调用write函数写文件 ==&gt; 数据被写入管道中</span><br><span class="line">write(wfd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line"><span class="number">4.</span> 写完之后关闭文件描述符</span><br><span class="line">close(wfd);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建有名管道文件</span></span><br><span class="line">    <span class="type">int</span> ret = mkfifo(<span class="string">&quot;./testfifo&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;管道文件创建成功...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 打开管道文件</span></span><br><span class="line">    <span class="comment">// 因为要写管道, 所有打开方式, 应该指定为 O_WRONLY</span></span><br><span class="line">    <span class="comment">// 如果先打开写端, 读端还没有打开, open函数会阻塞, 当读端也打开之后, open解除阻塞</span></span><br><span class="line">    <span class="type">int</span> wfd = open(<span class="string">&quot;./testfifo&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(wfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;以只写的方式打开文件成功...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 循环写管道</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, fifo, 我在写管道...%d\n&quot;</span>, i);</span><br><span class="line">        write(wfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        i++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(wfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>读管道的进程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 这两个进程需要操作相同的管道文件</span><br><span class="line"><span class="number">2.</span> 打开有名管道文件, 打开方式是 o_rdonly</span><br><span class="line"><span class="type">int</span> rfd = open(<span class="string">&quot;xx&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="number">3.</span> 调用read函数读文件 ==&gt; 读管道中的数据</span><br><span class="line"><span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">read(rfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="number">4.</span> 读完之后关闭文件描述符</span><br><span class="line">close(rfd);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开管道文件</span></span><br><span class="line">    <span class="comment">// 因为要read管道, so打开方式, 应该指定为 O_RDONLY</span></span><br><span class="line">    <span class="comment">// 如果只打开了读端, 写端还没有打开, open阻塞, 当写端被打开, 阻塞就解除了</span></span><br><span class="line">    <span class="type">int</span> rfd = open(<span class="string">&quot;./testfifo&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(rfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;以只读的方式打开文件成功...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 循环读管道</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">// 读是阻塞的, 如果管道中没有数据, read自动阻塞</span></span><br><span class="line">        <span class="comment">// 有数据解除阻塞, 继续读数据</span></span><br><span class="line">        <span class="type">int</span> len = read(rfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;读出的数据: %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 写端关闭了, read解除阻塞返回0</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;管道的写端已经关闭, 拜拜...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(rfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-4-管道的读写行为"><a href="#2-4-管道的读写行为" class="headerlink" title="2.4 管道的读写行为"></a>2.4 管道的读写行为</h2><p>关于管道不管是有名的还是匿名，在读写时，它们表现出的行为是一致的<br>下面是对其读写行为的总结:</p><ul><li>读管道，需要根据写端的状态进行分析：<ul><li>写端没有关闭 (操作管道写端的文件描述符没有被关闭)<ul><li>如果管道中没有数据 &#x3D;&#x3D;&gt; 读阻塞, 如果管道中被写入了数据, 阻塞解除</li><li>如果管道中有数据 &#x3D;&#x3D;&gt; 不阻塞，管道中的数据被读完了, 再继续读管道还会阻塞</li></ul></li><li>写端已经关闭了 (没有可用的文件描述符可以写管道了)<ul><li>管道中没有数据 &#x3D;&#x3D;&gt; 读端解除阻塞, read函数返回0</li><li>管道中有数据 &#x3D;&#x3D;&gt; read先将数据读出, 数据读完之后返回0, 不会阻塞了</li></ul></li></ul></li><li>写管道，需要根据读端的状态进行分析：<ul><li>读端没有关闭<ul><li>如果管道有存储的空间, 一直写数据</li><li>如果管道写满了, 写操作就阻塞, 当读端将管道数据读走了, 解除阻塞继续写</li></ul></li><li>读端关闭了，管道破裂(异常), 进程直接退出</li></ul></li></ul><blockquote><p>管道的两端默认是阻塞的，如何将管道设置为非阻塞呢？<br>管道的读写两端的非阻塞操作是相同的，下面的代码中将匿名的读端设置为了非阻塞：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过fcntl 修改就可以, 一般情况下不建议修改</span></span><br><span class="line"><span class="comment">// 管道操作对应两个文件描述符, 分别是管道的读端 和 写端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取读端的文件描述符的flag属性</span></span><br><span class="line"><span class="type">int</span> flag = fcntl(fd[<span class="number">0</span>], F_GETFL);</span><br><span class="line"><span class="comment">// 2. 添加非阻塞属性到 flag中</span></span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line"><span class="comment">// 3. 将新的flag属性设置给读端的文件描述符</span></span><br><span class="line">fcntl(fd[<span class="number">0</span>], F_SETFL, flag);</span><br><span class="line"><span class="comment">// 4. 非阻塞读管道</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br></pre></td></tr></table></figure><hr><h1 id="3-内存映射-mmap"><a href="#3-内存映射-mmap" class="headerlink" title="3. 内存映射(mmap)"></a>3. 内存映射(mmap)</h1><h2 id="3-1-创建内存映射区"><a href="#3-1-创建内存映射区" class="headerlink" title="3.1 创建内存映射区"></a>3.1 创建内存映射区</h2><p>想要实现进程间通信，可通过函数创建一块内存映射区<br>和管道不同的是管道对应的内存空间在<code>内核</code>中，而内存映射区对应的内存空间在进程的<code>用户区</code>（用于加载动态库的那个区域）<br>也就是说<code>进程间通信使用的内存映射区不是一块，而是在每个进程内部都有一块。</code></p><p>由于每个进程的地址空间是独立的，各个进程之间也不能直接访问对方的内存映射区，要通信的进程需将各自的内存映射区和同一个磁盘文件进行映射，这样进程之间就可以通过磁盘文件这个唯一的桥梁完成数据的交互了。<br><img src="/img/9.14.png" alt="在这里插入图片描述"></p><p>如上图所示：<br><code>磁盘文件数据可完全加载到进程的内存映射区也可部分加载到进程的内存映射区，当进程A中的内存映射区数据被修改了，数据会被自动同步到磁盘文件，同时和磁盘文件建立映射关系的其他进程内存映射区中的数据也会和磁盘文件进行数据的实时同步，这个同步机制保障了各进程间的数据共享。</code></p><p>使用内存映射区既可以进程有血缘关系的进程间通信也可以进程没有血缘关系的进程间通信。<br>创建内存映射区的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建内存映射区</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li><p>addr: 从动态库加载区的什么位置开始创建内存映射区，一般定为NULL, 委托内核分配</p></li><li><p>length: 创建的内存映射区的大小(byte)，实际上这个大小是按4k的整数倍去分配的</p></li><li><p>prot: 对内存映射区的操作权限</p><ul><li>PROT_READ: 读内存映射区</li><li>PROT_WRITE: 写内存映射区</li><li>如果要对映射区有读写权限: PROT_READ | PROT_WRITE</li></ul></li><li><p>flags:</p><ul><li>MAP_SHARED: 多个进程可以共享数据，进行映射区数据同步</li><li>MAP_PRIVATE: 映射区数据是私有的，不能同步给其他进程</li></ul></li><li><p>fd: 文件描述符, 对应一个打开的磁盘文件，内存映射区通过这个文件描述符和磁盘文件建立关联</p></li><li><p>offset: 磁盘文件的偏移量，文件从偏移到的位置开始进行数据映射<br>  使用这个参数需要注意两个问题：</p><ul><li>偏移量必须是4k的整数倍, 写0代表不偏移</li><li>这个参数必须大于 0</li></ul></li></ul></li><li>返回值:<ul><li>成功: 返回一个内存映射区的起始地址</li><li>失败: <code>MAP_FAILED</code>(that is, (void *) -1)</li></ul></li></ul><blockquote><p>mmap() 函数的参数较多，在使用该函数创建用于进程间通信的内存映射区的时候，各参数的指定有一些注意事项</p><ol><li>第一个参数 addr 指定为 <code>NULL</code> 即可</li><li>第二个参数 length 必须要 &gt; 0</li><li>第三个参数 prot，进程间通信需要对内存映射区有读写权限，因此需要指定为：<br>PROT_READ | PROT_WRITE</li><li>第四个参数 flags，如果要进行进程间通信, 需要指定 MAP_SHARED</li><li>第五个参数 fd，打开的文件必须大于0，进程间通信需要文件操作权限和映射区操作权限相同<ul><li>内存映射区创建成功之后, 关闭这个文件描述符不会影响进程间通信</li></ul></li><li>第六个参数 offset，不偏移指定为0，如果偏移必须是4k的整数倍</li></ol></blockquote><p>内存映射区使用完之后也需要释放，释放函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>addr: mmap()的返回值, 创建的内存映射区的起始地址</li><li>length: 和mmap()第二个参数相同即可</li></ul></li><li>返回值：函数调用成功返回 0，失败返回 -1</li></ul><hr><h2 id="3-2-进程间通信"><a href="#3-2-进程间通信" class="headerlink" title="3.2 进程间通信"></a>3.2 进程间通信</h2><p>操作内存映射区和操作管道是不一样的，<br>内存映射区是直接对内存地址进行操作,管道是通过文件描述符读写队列中的数据<br>管道的读写是阻塞的，内存映射区的读写是非阻塞的。</p><h3 id="3-2-1-有血缘关系"><a href="#3-2-1-有血缘关系" class="headerlink" title="3.2.1 有血缘关系"></a>3.2.1 有血缘关系</h3><p>由于创建子进程会发生虚拟地址空间的复制，那么在父进程中创建的内存映射区也会被复制到子进程中，这样在子进程里边就可以直接使用这块内存映射区了，所以对于有血缘关系的进程，进行进程间通信是非常简单的，处理代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  先创建内存映射区, 得到一个起始地址, 假设使用ptr指针保存这个地址</span><br><span class="line"><span class="number">2.</span>  通过fork()创建子进程-&gt;子进程中也就有一个内存映射区, 子进程中也有一个ptr指针指向这个地址</span><br><span class="line"><span class="number">3.</span>  父进程往自己的内存映射区写数据, 数据同步到了磁盘文件中</span><br><span class="line">磁盘文件数据又同步到子进程的映射区中</span><br><span class="line">子进程从自己的映射区往外读数据, 这个数据就是父进程写的</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开一个磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">// 2. 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span>* ptr = mmap(<span class="literal">NULL</span>, <span class="number">4000</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">                     MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程, 写数据</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* pt = <span class="string">&quot;我你爹, 你我儿?&quot;</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(ptr, pt, <span class="built_in">strlen</span>(pt)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程, 读数据</span></span><br><span class="line">        usleep(<span class="number">1</span>);<span class="comment">// 内存映射区不阻塞, 为了让子进程读出数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从映射区读出的数据: %s\n&quot;</span>, (<span class="type">char</span>*)ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存映射区</span></span><br><span class="line">    munmap(ptr, <span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-2-没有血缘关系"><a href="#3-2-2-没有血缘关系" class="headerlink" title="3.2.2 没有血缘关系"></a>3.2.2 没有血缘关系</h3><p>对于没有血缘关系的进程间通信，需要在每个进程中分别创建内存映射区，但是这些进程的内存映射区必须要关联相同的磁盘文件，这样才能实现进程间的数据同步。</p><blockquote><p>进程A的测试代码:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开一个磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">// 2. 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span>* ptr = mmap(<span class="literal">NULL</span>, <span class="number">4000</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">                     MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pt = <span class="string">&quot;我你爹, 你我儿?&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, pt, <span class="built_in">strlen</span>(pt)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存映射区</span></span><br><span class="line">    munmap(ptr, <span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>进程B的测试代码:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开一个磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">// 2. 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span>* ptr = mmap(<span class="literal">NULL</span>, <span class="number">4000</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">                     MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读内存映射区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从映射区读出的数据: %s\n&quot;</span>, (<span class="type">char</span>*)ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存映射区</span></span><br><span class="line">    munmap(ptr, <span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-3-拷贝文件"><a href="#3-3-拷贝文件" class="headerlink" title="3.3 拷贝文件"></a>3.3 拷贝文件</h2><p>用内存映射区除了可实现进程间通信，也可进行文件的拷贝，用这种方式拷贝文件可减少工作量，我们只需负责创建内存映射区和打开磁盘文件，关于文件中的数据读写就无需关心了。</p><blockquote><p>使用内存映射区拷贝文件思路：</p><ol><li>打开被拷贝文件，得到文件描述符 fd1，并计算出这个文件的大小 size</li><li>创建内存映射区A并且和被拷贝文件关联，也就是和fd1关联起来，得到映射区地址 ptrA</li><li>创建新文件，得到文件描述符fd2，用于存储被拷贝的数据，并且将这个文件大小拓展为 size</li><li>创建内存映射区B并且和新创建的文件关联，也就是和fd2关联起来，得到映射区地址 ptrB</li><li>进程地址空间之间的数据拷贝，memcpy（ptrB， ptrA，size），数据自动同步到新建文件中 </li><li>关闭内存映射区</li></ol></blockquote><p>文件拷贝示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开一个操盘文件english.txt得到文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">// 计算文件大小</span></span><br><span class="line">    <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建内存映射区和english.txt进行关联, 得到映射区起始地址</span></span><br><span class="line">    <span class="type">void</span>* ptrA = mmap(<span class="literal">NULL</span>, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptrA == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建一个新文件, 存储拷贝的数据</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;./copy.txt&quot;</span>, O_RDWR|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="comment">// 拓展这个新文件</span></span><br><span class="line">    ftruncate(fd1, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 创建一个映射区和新文件进行关联, 得到映射区的起始地址second</span></span><br><span class="line">    <span class="type">void</span>* ptrB = mmap(<span class="literal">NULL</span>, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd1, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptrB == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap----&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 使用memcpy拷贝映射区数据</span></span><br><span class="line">    <span class="comment">// 这两个指针指向两块内存, 都是内存映射区</span></span><br><span class="line">    <span class="comment">// 指针指向有效的内存, 拷贝的是内存中的数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptrB, ptrA, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 释放内存映射区</span></span><br><span class="line">    munmap(ptrA, size);</span><br><span class="line">    munmap(ptrB, size);</span><br><span class="line">    close(fd);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="4-共享内存"><a href="#4-共享内存" class="headerlink" title="4. 共享内存"></a>4. 共享内存</h1><p>共享内存不同于内存映射区，它不属于任何进程，并且不受进程生命周期的影响。<br>通过调用Linux提供的系统函数就可得到这块共享内存。<br>使用前需让进程和共享内存进行关联，得到共享内存的起始地址之后就可直接进行读写操作了，进程也可以和这块共享内存解除关联, 解除关联之后就不能操作这块共享内存了。<br><code>在所有进程间通信的方式中共享内存的效率是最高的。</code></p><blockquote><p>共享内存操作默认不阻塞，<code>如果多个进程同时读写共享内存，可能出现数据混乱</code>，共享内存需要借助其他机制来保证进程间的数据同步，比如：信号量.<br>共享内存内部没有提供这种机制。</p></blockquote><h2 id="4-1-创建-打开共享内存"><a href="#4-1-创建-打开共享内存" class="headerlink" title="4.1 创建&#x2F;打开共享内存"></a>4.1 创建&#x2F;打开共享内存</h2><h3 id="4-1-1-shmget"><a href="#4-1-1-shmget" class="headerlink" title="4.1.1 shmget"></a>4.1.1 shmget</h3><p>如共享内存不存在就需先创建出来，如已存在就需先打开这块共享内存。<br>不管是创建还是打开共享内存使用的函数是同一个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>key: 类型 key_t 是个整形数, 通过这个key可以创建或者打开一块共享内存，该参数的值一定要大于0</li><li>size: 创建共享内存的时候, 指定共享内存的大小，如果是打开一块存在的共享内存, size是没有意义的</li><li>shmflg：创建共享内存的时候指定的属性<ul><li>IPC_CREAT: 创建新的共享内存，如果创建共享内存, 需要指定对共享内存的操作权限，比如：IPC_CREAT | 0664</li><li>IPC_EXCL: 检测共享内存是否已经存在了，必须和 IPC_CREAT一起使用</li></ul></li></ul></li><li>返回值：共享内存创建或者打开成功返回标识共享内存的唯一的ID，失败返回-1</li></ul><p>函数使用举例:</p><blockquote><p>场景1：创建一块大小为4k的共享内存</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0664</span>);</span><br></pre></td></tr></table></figure><blockquote><p>场景2：创建一块大小为4k的共享内存, 并且检测是否存在</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果共享内存已经存在, 共享内存创建失败, 返回-1, 可以perror() 打印错误信息</span></span><br><span class="line">shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0664</span>|IPC_EXCL);</span><br></pre></td></tr></table></figure><blockquote><p>场景3：打开一块已经存在的共享内存</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数参数虽然指定了大小和IPC_CREAT, 但是都不起作用</span></span><br><span class="line"><span class="comment">// 因为共享内存已经存在, 只能打开, 参数4096也没有意义</span></span><br><span class="line">shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0664</span>);</span><br><span class="line">shmget(<span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>场景4：打开一块共享内存, 如果不存在就创建</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0664</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="4-1-2-ftok"><a href="#4-1-2-ftok" class="headerlink" title="4.1.2 ftok"></a>4.1.2 ftok</h3><p>shmget() 函数的第一个参数是一个大于0的正整数，如果不想自己指定可以通过 <code>ftok()</code>函数直接生成这个key值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ftok函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将两个参数作为种子, 生成一个 key_t 类型的数值</span></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数:</p><ul><li><p>pathname: 当前操作系统中一个存在的路径</p></li><li><p>proj_id: 这个参数只用到了int中的一个字节<br>  传参的时候要将其作为 char 进行操作，取值范围: 1-255</p></li></ul></li><li><p>返回值：函数调用成功返回一个可用于创建、打开共享内存的key值，调用失败返回-1</p></li></ul><p>使用举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据路径生成一个key_t</span></span><br><span class="line"><span class="type">key_t</span> key = ftok(<span class="string">&quot;/home/robin&quot;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建或打开共享内存</span></span><br><span class="line">shmget(key, <span class="number">4096</span>, IPC_CREATE|<span class="number">0664</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="4-2-关联和解除关联"><a href="#4-2-关联和解除关联" class="headerlink" title="4.2 关联和解除关联"></a>4.2 关联和解除关联</h2><h3 id="4-2-1-shmat"><a href="#4-2-1-shmat" class="headerlink" title="4.2.1 shmat"></a>4.2.1 shmat</h3><p>创建&#x2F;打开共享内存之后还必须和共享内存进行关联，这样才能得到共享内存的起始地址，通过得到的内存地址进行数据的读写操作<br>关联函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>shmid: 要操作的共享内存的ID, 是 shmget() 函数的返回值</li><li>shmaddr: 共享内存的起始地址, 用户不知道, 需要让内核指定, 写NULL</li><li>shmflg: 和共享内存关联的对共享内存的操作权限<ul><li>SHM_RDONLY: 读权限, 只能读共享内存中的数据</li><li>0: 读写权限，可以读写共享内存数据</li></ul></li></ul></li><li>返回值：关联成功，返回值共享内存的起始地址，关联失败返回 (void *) -1</li></ul><hr><h2 id="4-2-2-shmdt"><a href="#4-2-2-shmdt" class="headerlink" title="4.2.2 shmdt"></a>4.2.2 shmdt</h2><p>当进程不需要再操作共享内存，可以让进程和共享内存解除关联<br>另外如果没有执行该操作，进程退出之后，结束的进程和共享内存的关联也就自动解除了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：shmat() 函数的返回值, 共享内存的起始地址</li><li>返回值：关联解除成功返回0，失败返回-1</li></ul><hr><h2 id="4-3-删除共享内存"><a href="#4-3-删除共享内存" class="headerlink" title="4.3 删除共享内存"></a>4.3 删除共享内存</h2><h3 id="4-3-1-shmctl"><a href="#4-3-1-shmctl" class="headerlink" title="4.3.1 shmctl"></a>4.3.1 shmctl</h3><p><code>shmctl()</code> 函数是一个多功能函数,可设置、获取共享内存状态也可将共享内存标记为删除状态。<br><code>当共享内存被标记为删除状态之后，并不会马上被删除，直到所有的进程全部和共享内存解除关联，共享内存才会被删除。</code><br>因为通过shmctl()函数只是标记删除共享内存，所以在程序中多次调用该操作也没关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享内存控制函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数 struct shmid_ds 结构体原型          </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>    <span class="comment">/* Ownership and permissions */</span></span><br><span class="line"><span class="type">size_t</span>          shm_segsz;   <span class="comment">/* Size of segment (bytes) */</span></span><br><span class="line"><span class="type">time_t</span>          shm_atime;   <span class="comment">/* Last attach time */</span></span><br><span class="line"><span class="type">time_t</span>          shm_dtime;   <span class="comment">/* Last detach time */</span></span><br><span class="line"><span class="type">time_t</span>          shm_ctime;   <span class="comment">/* Last change time */</span></span><br><span class="line"><span class="type">pid_t</span>           shm_cpid;    <span class="comment">/* PID of creator */</span></span><br><span class="line"><span class="type">pid_t</span>           shm_lpid;    <span class="comment">/* PID of last shmat(2)/shmdt(2) */</span></span><br><span class="line">    <span class="comment">// 引用计数, 多少个进程和共享内存进行了关联</span></span><br><span class="line"><span class="type">shmatt_t</span>        shm_nattch;  <span class="comment">/* 记录了有多少个进程和当前共享内存进行了管联 */</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>shmid: 要操作的共享内存的ID, 是 shmget() 函数的返回值</li><li>cmd: 要做的操作<ul><li>IPC_STAT: 得到当前共享内存的状态</li><li>IPC_SET: 设置共享内存的状态</li><li>IPC_RMID: 标记共享内存要被删除了</li></ul></li><li>buf:<ul><li>cmd&#x3D;&#x3D;IPC_STAT, 作为传出参数, 会得到共享内存的相关属性信息</li><li>cmd&#x3D;&#x3D;IPC_SET, 作为传入参, 将用户的自定义属性设置到共享内存中</li><li>cmd&#x3D;&#x3D;IPC_RMID, buf就没意义了, 这时候buf指定为NULL即可</li></ul></li></ul></li><li>返回值：函数调用成功返回值大于等于0，调用失败返回-1</li></ul><hr><h3 id="4-3-2-相关shell命令"><a href="#4-3-2-相关shell命令" class="headerlink" title="4.3.2 相关shell命令"></a>4.3.2 相关shell命令</h3><p>使用<code>ipcs</code> 添加参数<code>-m</code>可以查看系统中共享内存的详细信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ipcs -m</span><br><span class="line"></span><br><span class="line">------------ 共享内存段 --------------</span><br><span class="line">key        shmid      拥有者  权限     字节     nattch     状态      </span><br><span class="line">0x00000000 425984     oracle     600        524288     2          目标       </span><br><span class="line">0x00000000 327681     oracle     600        524288     2          目标       </span><br><span class="line">0x00000000 458754     oracle     600        524288     2          目标 </span><br></pre></td></tr></table></figure><p>使用 <code>ipcrm</code> 命令可以标记删除某块共享内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key == shmget的第一个参数</span></span><br><span class="line">$ ipcrm -M shmkey  </span><br><span class="line"></span><br><span class="line"><span class="comment"># id == shmget的返回值</span></span><br><span class="line">$ ipcrm -m shmid</span><br></pre></td></tr></table></figure><hr><h3 id="4-3-3-共享内存状态"><a href="#4-3-3-共享内存状态" class="headerlink" title="4.3.3 共享内存状态"></a>4.3.3 共享内存状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 struct shmid_ds 结构体原型          </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>    <span class="comment">/* Ownership and permissions */</span></span><br><span class="line"><span class="type">size_t</span>          shm_segsz;   <span class="comment">/* Size of segment (bytes) */</span></span><br><span class="line"><span class="type">time_t</span>          shm_atime;   <span class="comment">/* Last attach time */</span></span><br><span class="line"><span class="type">time_t</span>          shm_dtime;   <span class="comment">/* Last detach time */</span></span><br><span class="line"><span class="type">time_t</span>          shm_ctime;   <span class="comment">/* Last change time */</span></span><br><span class="line"><span class="type">pid_t</span>           shm_cpid;    <span class="comment">/* PID of creator */</span></span><br><span class="line"><span class="type">pid_t</span>           shm_lpid;    <span class="comment">/* PID of last shmat(2)/shmdt(2) */</span></span><br><span class="line">    <span class="comment">// 引用计数, 多少个进程和共享内存进行了关联</span></span><br><span class="line"><span class="type">shmatt_t</span>        shm_nattch;  <span class="comment">/* 记录了有多少个进程和当前共享内存进行了管联 */</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过<code>shmctl()</code>我们可得知，共享内存的信息是存储到一个叫做<code>struct shmid_ds</code>的结构体中，其中有一个非常重要的成员叫做<code>shm_nattch</code>，在这个成员变量里边记录着当前共享内存关联的进程的个数，一般将其称为引用计数。<br>当共享内存被标记为删除状态，并且这个引用计数变为0之后共享内存才会被真正的被删除掉。</p><p>当共享内存被标记为删除状态之后，共享内存的状态也会发生变化，共享内存内部维护的key从一个正整数变为0，其属性从公共的变为私有。这里的私有指只有已经关联成功的进程才允许继续访问共享内存，不再允许新的进程和这块共享内存进行关联了。<br>下图演示了共享内存的状态变化：</p><p><img src="/img/9.15.png" alt="在这里插入图片描述"></p><hr><h2 id="4-4-进程间通信"><a href="#4-4-进程间通信" class="headerlink" title="4.4 进程间通信"></a>4.4 进程间通信</h2><p>使用共享内存实现进程间通信的操作流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 调用linux的系统API创建一块共享内存</span><br><span class="line">    - 这块内存不属于任何进程, 默认进程不能对其进行操作</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 准备好进程A, 和进程B, 这两个进程需要和创建的共享内存进行关联</span><br><span class="line">    - 关联操作: 调用linux的 api</span><br><span class="line">    - 关联成功之后, 得到了这块共享内存的起始地址</span><br><span class="line">        </span><br><span class="line"><span class="number">3.</span> 在进程A或者进程B中对共享内存进行读写操作</span><br><span class="line">    - 读内存: <span class="built_in">printf</span>() 等;</span><br><span class="line">- 写内存: <span class="built_in">memcpy</span>() 等;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 通信完成, 可以让进程A和B和共享内存解除关联</span><br><span class="line">    - 解除成功, 进程A和B不能再操作共享内存了</span><br><span class="line">    - 共享内存不受进程生命周期的影响的</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span> 共享内存不在使用之后, 将其删除</span><br><span class="line">    - 调用linux的api函数, 删除之后这块内存被内核回收了</span><br></pre></td></tr></table></figure><blockquote><p>写共享内存的进程代码:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建共享内存, 大小为4k</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">1000</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(shmid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 当前进程和共享内存关联</span></span><br><span class="line">    <span class="type">void</span>* ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == (<span class="type">void</span> *) <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 写共享内存</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p = <span class="string">&quot;hello 共享内存&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, p, <span class="built_in">strlen</span>(p)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞程序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续, 删除共享内存\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;共享内存已删除...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>读共享内存的进程代码:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建共享内存, 大小为4k</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">1000</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(shmid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 当前进程和共享内存关联</span></span><br><span class="line">    <span class="type">void</span>* ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == (<span class="type">void</span> *) <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 读共享内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;共享内存数据: %s\n&quot;</span>, (<span class="type">char</span>*)ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞程序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续, 删除共享内存\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;共享内存已经被删除...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-5-shm和mmap的区别"><a href="#4-5-shm和mmap的区别" class="headerlink" title="4.5 shm和mmap的区别"></a>4.5 shm和mmap的区别</h2><p><code>共享内存</code>和<code>内存映射区</code>都可以实现进程间通信，下面来分析一下二者的区别：</p><ul><li><p>实现进程间通信的方式</p><ul><li>shm: 多个进程只需要一块共享内存就够了，共享内存不属于进程，需要和进程关联才能使用</li><li>内存映射区: 位于每个进程的虚拟地址空间中, 并且需要关联同一个磁盘文件才能实现进程间数据通信</li></ul></li><li><p>效率:</p><ul><li>shm: 直接对内存操作，效率高</li><li>内存映射区: 需要内存和文件之间的数据同步，效率低</li></ul></li><li><p>生命周期</p><ul><li>shm：进程退出对共享内存没有影响，调用相关函数&#x2F;命令&#x2F; 关机才能删除共享内存</li><li>内存映射区：进程退出, 内存映射区也就没有了</li></ul></li><li><p>数据的完整性 -&gt; 突发状态下数据能不能被保存下来（比如: 突然断电）</p><ul><li>shm：数据存储在物理内存中, 断电之后系统关闭, 内存数据也就丢失了</li><li>内存映射区：可以完整的保存数据, 内存映射区数据会同步到磁盘文件</li></ul></li></ul><hr><h1 id="5-信号"><a href="#5-信号" class="headerlink" title="5. 信号"></a>5. 信号</h1><h2 id="5-1-信号概述"><a href="#5-1-信号概述" class="headerlink" title="5.1 信号概述"></a>5.1 信号概述</h2><p>Linux中的信号是一种消息处理机制, 它本质上是一个整数，不同的信号对应不同的值<br>由于信号的结构简单所以天生不能携带很大的信息量，但信号在系统中优先级非常高。</p><p>在Linux中的很多常规操作中都会有相关的信号产生，先从我们最熟悉的场景说起：</p><ul><li><code>通过键盘操作产生了信号</code>：用户按下Ctrl-C，这个键盘输入产生一个硬件中断，使用这个快捷键会产生信号, 这个信号会杀死对应的某个进程</li><li><code>通过shell命令产生了信号</code>：通过kill命令终止某一个进程，<code>kill -9 进程PID</code></li><li><code>通过函数调用产生了信号</code>：如果CPU当前正在执行这个进程的代码调用，比如函数 <code>sleep()</code>，进程收到相关的信号，被迫挂起</li><li><code>通过对硬件进行非法访问产生了信号</code>：正在运行的程序访问了非法内存，发生段错误，进程退出。</li></ul><p>信号也可以实现进程间通信，但是信号能传递的数据量很少，不满足大部分需求，另外信号的优先级很高，并且它对应的处理动作是回调完成的，它会打乱程序原有的处理流程，影响到最终的处理结果。<br>因此非常不建议使用信号进行进程间通信。</p><hr><h3 id="5-1-1-信号编号"><a href="#5-1-1-信号编号" class="headerlink" title="5.1.1 信号编号"></a>5.1.1 信号编号</h3><p>通过 <code>kill -l</code> 命令可以察看系统定义的信号列表:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行shell命令查看信号</span></span><br><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p>下表中详细阐述了信号产生的时机和对应的默认处理动作:</p><table><thead><tr><th>编号</th><th>信号</th><th>对应事件</th><th>默认动作</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>用户退出shell时，由该shell启动的所有进程将收到这个信号</td><td>终止进程</td></tr><tr><td>2</td><td>SIGINT</td><td>当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号</td><td>终止进程</td></tr><tr><td>3</td><td>SIGQUIT</td><td>用户按下&lt;ctrl+&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号</td><td>终止进程</td></tr><tr><td>4</td><td>SIGILL</td><td>CPU检测到某进程执行了非法指令</td><td>终止进程并产生core文件</td></tr><tr><td>5</td><td>SIGTRAP</td><td>该信号由断点指令或其他 trap指令产生</td><td>终止进程并产生core文件</td></tr><tr><td>6</td><td>SIGABRT</td><td>调用abort函数时产生该信号</td><td>终止进程并产生core文件</td></tr><tr><td>7</td><td>SIGBUS</td><td>非法访问内存地址，包括内存对齐出错</td><td>终止进程并产生core文件</td></tr><tr><td>8</td><td>SIGFPE</td><td>在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误</td><td>终止进程并产生core文件</td></tr><tr><td>9</td><td>SIGKILL</td><td>无条件终止进程。本信号不能被忽略，处理和阻塞</td><td>终止进程，可以杀死任何进程</td></tr><tr><td>10</td><td>SIGUSE1</td><td>用户定义的信号。即程序员可以在程序中定义并使用该信号</td><td>终止进程</td></tr><tr><td>11</td><td>SIGSEGV</td><td>指示进程进行了无效内存访问(段错误)</td><td>终止进程并产生core文件</td></tr><tr><td>12</td><td>SIGUSR2</td><td>另外一个用户自定义信号，程序员可以在程序中定义并使用该信号</td><td>终止进程</td></tr><tr><td>13</td><td>SIGPIPE</td><td>Broken pipe向一个没有读端的管道写数据</td><td>终止进程</td></tr><tr><td>14</td><td>SIGALRM</td><td>定时器超时，超时的时间由系统调用alarm设置</td><td>终止进程</td></tr><tr><td>15</td><td>SIGTERM</td><td>程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来示程序正常退出。执行shell命令Kill时，缺省产生这个信号</td><td>终止进程</td></tr><tr><td>16</td><td>SIGSTKFLT</td><td>Linux早期版本出现的信号，现仍保留向后兼容</td><td>终止进程</td></tr><tr><td>17</td><td>SIGCHLD</td><td>子进程结束时，父进程会收到这个信号</td><td>忽略这个信号</td></tr><tr><td>18</td><td>SIGCONT</td><td>如果进程已停止，则使其继续运行</td><td>继续&#x2F;忽略</td></tr><tr><td>19</td><td>SIGSTOP</td><td>停止进程的执行。信号不能被忽略，处理和阻塞</td><td>为终止进程</td></tr><tr><td>20</td><td>SIGTSTP</td><td>停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号</td><td>暂停进程</td></tr><tr><td>21</td><td>SIGTTIN</td><td>后台进程读终端控制台</td><td>暂停进程</td></tr><tr><td>22</td><td>SIGTTOU</td><td>该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生</td><td>暂停进程</td></tr><tr><td>23</td><td>SIGURG</td><td>套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络</td><td></td></tr><tr><td>24</td><td>SIGXCPU</td><td>进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程</td><td>终止进程</td></tr><tr><td>25</td><td>SIGXFSZ</td><td>超过文件的最大长度设置</td><td>终止进程</td></tr><tr><td>26</td><td>SIGVTALRM</td><td>虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间</td><td>终止进程</td></tr><tr><td>27</td><td>SGIPROF</td><td>类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间</td><td>终止进程</td></tr><tr><td>28</td><td>SIGWINCH</td><td>窗口变化大小时发出</td><td>忽略该信号</td></tr><tr><td>29</td><td>SIGIO</td><td>此信号向进程指示发出了一个异步IO事件</td><td>忽略该信号</td></tr><tr><td>30</td><td>SIGPWR</td><td>关机</td><td>终止进程</td></tr><tr><td>31</td><td>SIGSYS</td><td>无效的系统调用</td><td>终止进程并产生core文件</td></tr><tr><td>34~64</td><td>SIGRTMIN ~ SIGRTMAX</td><td>LINUX的实时信号，它们没有固定的含义（可以由用户自定义）</td><td>终止进程</td></tr></tbody></table><hr><h3 id="5-1-2-查看信号信息"><a href="#5-1-2-查看信号信息" class="headerlink" title="5.1.2 查看信号信息"></a>5.1.2 查看信号信息</h3><p>通过Linux提供的 man 文档可以查询所有信号的详细信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看man文档的信号描述</span></span><br><span class="line">$ man 7 signal</span><br></pre></td></tr></table></figure><p>在信号描述中介绍了对产生的信号的五种默认处理动作，分别是：</p><ol><li><code>Term</code>：信号将进程终止</li><li><code>Ign</code>：信号产生之后默认被忽略了</li><li><code>Core</code>：信号将进程终止, 并且生成一个core文件(一般用于gdb调试)</li><li><code>Stop</code>：信号会暂停进程的运行</li><li><code>Cont</code>：信号会让暂停的进程继续运行</li></ol><blockquote><p>关于对信号的介绍有一句非常重要的描述:<br>The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.<br>9号信号和19号信号不能被 捕捉, 阻塞, 和 忽略<br>9号信号: 无条件杀死进程<br>19号信号: 无条件暂停进程</p></blockquote><p>有些信号在不同的平台对应的值是不一样的，对应我们使用PC机来说，需要看中间一列的值：</p><p><img src="/img/9.16.png" alt="在这里插入图片描述"></p><hr><h3 id="5-1-3-信号的状态"><a href="#5-1-3-信号的状态" class="headerlink" title="5.1.3 信号的状态"></a>5.1.3 信号的状态</h3><p>Linux中的信号有三种状态，分别为：产生，未决，递达。</p><ol><li><code>产生</code>：键盘输入, 函数调用, 执行shell命令, 对硬件进行非法访问都会产生信号</li><li><code>未决</code>：信号产生了, 但是这个信号还没有被处理掉, 这个期间信号的状态称之为未决状态</li><li><code>递达</code>：信号被处理了(被某个进程处理掉)</li></ol><p><img src="/img/9.17.png" alt="在这里插入图片描述"></p><hr><h2 id="5-2-信号相关函数"><a href="#5-2-信号相关函数" class="headerlink" title="5.2 信号相关函数"></a>5.2 信号相关函数</h2><p>Linux中能够产生信号的函数有很多，下面介绍几个常用函数：</p><h3 id="5-2-1-kill-raise-abort"><a href="#5-2-1-kill-raise-abort" class="headerlink" title="5.2.1 kill&#x2F;raise&#x2F;abort"></a>5.2.1 kill&#x2F;raise&#x2F;abort</h3><p>这三个函数的功能比较类似，可以发送相关的信号给到对应的进程。</p><ul><li>kill 发送指定的信号到指定的进程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 给某一个进程发送一个信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>pid: 进程ID（man 文档里边写的比较详细）</li><li>sig: 要发送的信号</li></ul></li></ul><p>函数使用举例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己杀死自己</span></span><br><span class="line">kill(getpid(), <span class="number">9</span>);</span><br><span class="line"><span class="comment">// 子进程杀死自己的父进程</span></span><br><span class="line">kill(getppid(), <span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li>raise：给当前进程发送指定的信号</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">// 给自己发送某一个信号</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;<span class="comment">// 参数就是要给当前进程发送的信号</span></span><br></pre></td></tr></table></figure><ul><li>abort：给当前进程发送一个固定信号 (SIGABRT)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">// 这是一个中断函数, 调用这个函数, 发送一个固定信号 (SIGABRT), 杀死当前进程</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="5-2-2-定时器"><a href="#5-2-2-定时器" class="headerlink" title="5.2.2 定时器"></a>5.2.2 定时器</h3><h4 id="5-2-2-1-alarm"><a href="#5-2-2-1-alarm" class="headerlink" title="5.2.2.1 alarm"></a>5.2.2.1 alarm</h4><p>alarm() 函数只能进行单次定时，定时完成发射出一个信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数: 倒计时seconds秒, 倒计时完成发送一个信号 SIGALRM , 当前进程会收到这个信号，这个信号默认的处理动作是中断当前进程</li><li>返回值: 大于0表示倒计时还剩多少秒，返回值为0表示倒计时完成, 信号被发出</li></ul><blockquote><p>使用这个定时器函数, 检测一下当前计算机1s钟之内能数多少个数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 设置一个定时器, 定时1s</span></span><br><span class="line">    alarm(<span class="number">1</span>);<span class="comment">// 1s之后会发出一个信号, 这个信号将中断当前进程</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述程序的时候, 计算一下时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接通过终端输出</span></span><br><span class="line">$ time ./a.out</span><br><span class="line">real    0m1.013s<span class="comment"># 实际数数用的总时间</span></span><br><span class="line">user    0m0.060s<span class="comment"># 用户区代码使用的时间</span></span><br><span class="line">sys     0m0.324s<span class="comment"># 内核区使用的时间</span></span><br><span class="line"></span><br><span class="line">real = user + sys + 消耗的时间(频率的从用户区到内核区进程切换)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不直接写终端, 将数据重定向到磁盘文件中</span></span><br><span class="line">$ time ./a.out &gt; a.txt</span><br><span class="line">Alarm clock</span><br><span class="line"></span><br><span class="line">real    0m1.002s    <span class="comment"># 用户实际数数的时间变长了</span></span><br><span class="line">user    0m0.740s</span><br><span class="line">sys     0m0.236s</span><br></pre></td></tr></table></figure><blockquote><p>文件IO操作需要进行用户区到内核区的切换，处理方式不同，二者之间切换的频率也不同。<br>也就是说对文件IO操作进行优化是可以提供程序的执行效率的。</p></blockquote><hr><h4 id="5-2-2-2-setitimer"><a href="#5-2-2-2-setitimer" class="headerlink" title="5.2.2.2 setitimer"></a>5.2.2.2 setitimer</h4><p><code>setitimer ()</code> 函数可以进行周期性定时，每触发一次定时器就会发射出一个信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可以实现周期性定时, 每个一段固定的时间, 发出一个特定的定时器信号</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span> <span class="comment">/* 时间间隔 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>    <span class="comment">/* 第一次触发定时器的时长 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 举例: luffy有一个闹钟, 并且使用这个闹钟定时:</span></span><br><span class="line"><span class="comment">// 早晨7点中起床, 第一次闹钟响起时可能起不来, 之后每隔5分钟再响一次</span></span><br><span class="line"><span class="comment">//  - it_value: 当前设置闹钟的时间点 到 明天早晨7点 对应的总秒数</span></span><br><span class="line"><span class="comment">//  - it_interval: 闹钟第一次响过之后, 每隔5分钟响一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个结构体表示的是一个时间段: tv_sec + tv_usec</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span>      tv_sec;         <span class="comment">/* 秒 */</span></span><br><span class="line"><span class="type">suseconds_t</span> tv_usec;        <span class="comment">/* 微妙 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_value, </span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> itimerval *old_value)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>which: 定时器使用什么样的计时法则, 不同的计时法则发出的信号不同<ul><li><code>ITIMER_REAL</code>: 自然计时法, 最常用, 发出的信号为SIGALRM, 一般使用这个宏值，自然计时法时间 &#x3D; 用户区 + 内核 + 消耗的时间(从进程的用户区到内核区切换使用的总时间)</li><li><code>ITIMER_VIRTUAL</code>: 只计算程序在用户区运行使用的时间，发射的信号为 SIGVTALRM</li><li><code>ITIMER_PROF</code>: 只计算内核运行使用的时间, 发出的信号为SIGPROF</li></ul></li><li>new_value: 给定时器设置的定时信息, 传入参数</li><li>old_value: 上一次给定时器设置的定时信息, 传出参数，如果不需要这个信息, 指定为NULL</li></ul></li></ul><hr><h2 id="5-3-信号集"><a href="#5-3-信号集" class="headerlink" title="5.3 信号集"></a>5.3 信号集</h2><h3 id="5-3-1-阻塞-未决信号集"><a href="#5-3-1-阻塞-未决信号集" class="headerlink" title="5.3.1 阻塞&#x2F;未决信号集"></a>5.3.1 阻塞&#x2F;未决信号集</h3><p>在PCB中有两个非常重要的信号集。一个称之为“阻塞信号集”，另一个称之为“未决信号集”。<br>这两个信号集 体现在内核中就是两张表。<br>但是<code>操作系统不允许我们直接对这两个信号集进行任何操作，而是需要自定义另外一个集合，借助信号集操作函数来对PCB中的这两个信号集进行修改。</code></p><ul><li><p>信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。</p></li><li><p>信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。</p></li></ul><p><code>信号的阻塞就是让系统暂时保留信号留待以后发送。</code><br>由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了 防止信号打断某些敏感的操作。<br><img src="/img/9.18.png" alt="在这里插入图片描述"></p><p>阻塞信号集和未决信号集在内核中的结构是相同的<br>它们都是一个整形数组(被封装过的), 一共 128 字节 （int [32] &#x3D;&#x3D; 1024 bit），1024个标志位，其中前31个标志位，每一个都对应一个Linux中的标准信号，通过标志位的值来标记当前信号在信号集中的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上图对信号集在内核中存储的状态的描述</span></span><br><span class="line"><span class="comment"># 前31个信号: 1-31 , 对应 1024个标志位的前31个标志位</span></span><br><span class="line">信号标志位(从低地址位 到 高地址位)</span><br><span class="line">   1      -&gt;  0</span><br><span class="line">  2             1</span><br><span class="line">  3             2</span><br><span class="line">  4             3</span><br><span class="line"> 31            30</span><br></pre></td></tr></table></figure><ul><li>在阻塞信号集中，描述这个信号有没有被阻塞<ul><li>默认情况下没有信号是被阻塞的, 因此信号对应的标志位的值为 0</li><li>如果某个信号被设置为了阻塞状态, 这个信号对应的标志位 被设置为 1</li></ul></li><li>在未决信号集中, 描述信号是否处于未决状态<ul><li>如果这个信号被阻塞了, 不能处理, 这个信号对应的标志位被设置为1</li><li>如果这个信号的阻塞被解除了, 未决信号集中的这个信号马上就被处理了, 这个信号对应的标志位值变为0</li><li>如果这个信号没有阻塞, 信号产生之后直接被处理, 因此不会在未决信号集中做任何记录</li></ul></li></ul><hr><h3 id="5-3-2-信号集函数"><a href="#5-3-2-信号集函数" class="headerlink" title="5.3.2 信号集函数"></a>5.3.2 信号集函数</h3><p>因为用户是不能直接操作内核中的阻塞信号集和未决信号集的，必须要调用系统函数<br>阻塞信号集可通过系统函数进行读写操作，未决信号集只能对其进行读操作。</p><p>先来看一下读&#x2F;写阻塞信号集的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 使用这个函数修改内核中的阻塞信号集</span></span><br><span class="line"><span class="comment">// sigset_t 被封装之后得到的数据类型, 原型:int[32], 里边一共有1024给标志位, 每一个信号对应一个标志位</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>how:<ul><li><code>SIG_BLOCK</code>: 将参数 set 集合中的数据追加到阻塞信号集中</li><li><code>SIG_UNBLOCK</code>: 将参数 set 集合中的信号在阻塞信号集中解除阻塞</li><li><code>SIG_SETMASK</code>: 使用参 set 结合中的数据覆盖内核的阻塞信号集数据</li></ul></li><li><code>oldset</code>: 通过这个参数将设置之前的阻塞信号集数据传出，如果不需要可以指定为NULL</li></ul></li><li>返回值：函数调用成功返回0，调用失败返回-1</li></ul><p>sigprocmask() 函数有一个 sigset_t 类型的参数，对这种类型的数据进行初始化<br>需要调用一些相关的操作函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 如果在程序中读写 sigset_t 类型的变量</span></span><br><span class="line"><span class="comment">// 阻塞信号集和未决信号集都存储在 sigset_t 类型的变量中, 这个变量对应一块内存</span></span><br><span class="line"><span class="comment">// 阻塞信号集和未决信号集, 对应的内存中有1024bit = 128字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将set集合中所有的标志位设置为0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将set集合中所有的标志位设置为1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将set集合中某一个信号(signum)对应的标志位设置为1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">// 将set集合中某一个信号(signum)对应的标志位设置为0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">// 判断某个信号在集合中对应的标志位到底是0还是1, 如果是0返回0, 如果是1返回1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br></pre></td></tr></table></figure><p><img src="/img/9.19.png" alt="在这里插入图片描述"></p><p>未决信号集不需要我们修改, 如果设置了某个信号阻塞, 当这个信号产生之后, 内核会将这个信号的未决状态记录到未决信号集中，当阻塞的信号被解除阻塞, 未决信号集中的信号随之被处理, 内核再次修改未决信号集将该信号的状态修改为递达状态（标志位置0）。<br>因此，写未决信号集的动作都是内核做的，这是一个读未决信号集的操作函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 这个函数的参数是传出参数, 传出的内核未决信号集的拷贝</span></span><br><span class="line"><span class="comment">// 读一下这个集合就指定哪个信号是未决状态</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure><p>下面举一个简单的例子，演示一下信号集操作函数的使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">需求: </span><br><span class="line">在阻塞信号集中设置某些信号阻塞, 通过一些操作产生这些信号,</span><br><span class="line">然后读未决信号集, 最后再解除这些信号的阻塞</span><br><span class="line">假设阻塞这些信号: </span><br><span class="line">  - 2号信号: SIGINT: ctrl+c</span><br><span class="line">  - 3号信号: SIGQUIT: ctrl+\</span><br><span class="line">  - 9号信号: SIGKILL: 通过shell命令给进程发送这个信号 <span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化信号集</span></span><br><span class="line">    <span class="type">sigset_t</span> myset;</span><br><span class="line">    sigemptyset(&amp;myset);</span><br><span class="line">    <span class="comment">// 设置阻塞的信号</span></span><br><span class="line">    sigaddset(&amp;myset, SIGINT);  <span class="comment">// 2</span></span><br><span class="line">    sigaddset(&amp;myset, SIGQUIT); <span class="comment">// 3</span></span><br><span class="line">    sigaddset(&amp;myset, SIGKILL); <span class="comment">// 9 测试不能被阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将初始化的信号集中的数据设置给内核</span></span><br><span class="line">    <span class="type">sigset_t</span> old;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;myset, &amp;old);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 让进程一直运行, 在当前进程中产生对应的信号</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 4. 读内核的未决信号集</span></span><br><span class="line">        <span class="type">sigset_t</span> curset;</span><br><span class="line">        sigpending(&amp;curset);</span><br><span class="line">        <span class="comment">// 遍历这个信号集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ret = sigismember(&amp;curset, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 解除阻塞, 重新设置阻塞信号集</span></span><br><span class="line">            <span class="comment">//sigprocmask(SIG_UNBLOCK, &amp;myset, NULL);</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;old, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结论：程序中对 9 号信号的阻塞是无效的，因为它无法被阻塞。</p></blockquote><p>一张图总结这些信号集操作函数之间的关系:<br><img src="/img/9.20.png" alt="在这里插入图片描述"></p><hr><h2 id="5-4-信号捕捉"><a href="#5-4-信号捕捉" class="headerlink" title="5.4 信号捕捉"></a>5.4 信号捕捉</h2><p>Linux中的每个信号产生后都会有对应的默认处理行为，如果想要忽略这个信号或修改某些信号的默认行为就需要在程序中捕捉该信号。<br>程序中进行信号捕捉可看做一个注册的动作，提前告诉应用程序信号产生后做什么处理，当进程中对应的信号产生了，这个处理动作也就被调用了。</p><h3 id="5-4-1-signal"><a href="#5-4-1-signal" class="headerlink" title="5.4.1 signal"></a>5.4.1 signal</h3><p>使用 signal() 函数可以捕捉进程中产生的信号，并且修改捕捉到的函数的行为，这个信号的自定义处理动作是一个回调函数，内核通过 signal() 得到这个回调函数的地址，在信号产生之后该函数会被内核调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 在程序中什么时候产生信号, 程序猿是不知道的, 因此不能在信号产生之后再去处理</span></span><br><span class="line"><span class="comment">// 在信号产生之前, 提供一个注册函数, 用来捕捉信号</span></span><br><span class="line"><span class="comment">//  - 假设在将来这个信号产生了, 就委托内核进行捕捉, 这个信号的默认动作就不能被执行</span></span><br><span class="line"><span class="comment">//  - 执行什么样的处理动作 ==&gt; 在signal函数中指定的处理动作</span></span><br><span class="line"><span class="comment">//  - 如果这个信号不产生, 回调函数永远不会被调用</span></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;   </span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>signum: 需要捕捉的信号</li><li>handler: 信号捕捉到之后的处理动作, 这是一个函数指针, 函数原型</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure><p>这个回调函数是需要我们写的, 若我们不调用, 由内核调用，<br>内核调用回调函数的时候, 会给它传递一个实参，这个实参的值就是捕捉的那个信号值。</p><p>下面的测试程序中使用 signal() 函数来捕捉定时器产生的信号 SIGALRM：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器信号的处理动作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">doing</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前捕捉到的信号是: %d\n&quot;</span>, arg);</span><br><span class="line">    <span class="comment">// 打印当前的时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注册要捕捉哪一个信号, 执行什么样的处理动作</span></span><br><span class="line">    signal(SIGALRM, doing);</span><br><span class="line">    <span class="comment">// 1. 调用定时器函数设置定时器函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">newact</span>;</span></span><br><span class="line">    <span class="comment">// 3s之后发出第一个定时器信号, 之后每隔1s发出一个定时器信号</span></span><br><span class="line">    newact.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    newact.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    newact.it_interval.tv_sec = <span class="number">1</span>;</span><br><span class="line">    newact.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这个函数也不是阻塞函数, 函数调用成功, 倒计时开始</span></span><br><span class="line">    <span class="comment">// 倒计时过程中程序是继续运行的</span></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;newact, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写一个业务处理, 阻止当前进程自己结束, 让当前进程被发出的信号杀死</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-4-2-sigaction"><a href="#5-4-2-sigaction" class="headerlink" title="5.4.2 sigaction"></a>5.4.2 sigaction</h3><p>sigaction() 函数和 signal() 函数的功能是一样的，用于捕捉进程中产生的信号，并将用户自定义的信号行为函数（回调函数）注册给内核，内核在信号产生之后调用这个处理动作。<br>sigaction() 可以看做是 signal() 函数是加强版，函数参数更多更复杂，函数功能也更强一些。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>signum: 要捕捉的信号</li><li>act: 捕捉到信号之后的处理动作</li><li>oldact: 上一次调用该函数进行信号捕捉设置的信号处理动作, 该参数一般指定为NULL</li></ul></li><li>返回值：函数调用成功返回0，失败返回-1</li></ul><p>该函数的参数是一个结构体类型，结构体原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line"><span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);    <span class="comment">// 指向一个函数(回调函数)</span></span><br><span class="line"><span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line"><span class="type">sigset_t</span>   sa_mask;             <span class="comment">// 初始化为空即可, 处理函数执行期间不屏蔽任何信号</span></span><br><span class="line"><span class="type">int</span>        sa_flags;        <span class="comment">// 0</span></span><br><span class="line"><span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);  <span class="comment">//不用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体成员介绍：</p><ul><li><p>sa_handler: 函数指针，指向的函数就是捕捉到的信号的处理动作</p></li><li><p>sa_sigaction: 函数指针，指向的函数就是捕捉到的信号的处理动作</p></li><li><p>sa_mask: <code>在信号处理函数执行期间, 临时屏蔽某些信号</code>, 将要屏蔽的信号设置到集合中即可</p><ul><li>当前处理函数执行完毕, 临时屏蔽自动解除</li><li>假设在这个集合中不屏蔽任何信号, 默认也会屏蔽一个（捕捉的信号是谁, 就临时屏蔽谁）</li></ul></li><li><p>sa_flags：使用哪个函数指针指向的函数处理捕捉到的信号</p><ul><li><code>0</code>：使用 <code>sa_handler</code> (一般情况下使用这个)</li><li><code>SA_SIGINFO</code>：使用 sa_sigaction (使用信号传递数据&#x3D;&#x3D;进程间通信)</li></ul></li><li><p>sa_restorer: 被废弃的成员</p></li></ul><p>示例代码，通过sigaction()捕捉阻塞信号集中解除阻塞的信号，如果捕捉多个信号，可以给不同的信号添加不同的处理动作，代码中的处理动作只有一个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号的处理动作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">callback</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前捕捉的信号: %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化信号集</span></span><br><span class="line">    <span class="type">sigset_t</span> myset;</span><br><span class="line">    sigemptyset(&amp;myset);</span><br><span class="line">    <span class="comment">// 设置阻塞的信号</span></span><br><span class="line">    sigaddset(&amp;myset, SIGINT);  <span class="comment">// 2</span></span><br><span class="line">    sigaddset(&amp;myset, SIGQUIT); <span class="comment">// 3</span></span><br><span class="line">    sigaddset(&amp;myset, SIGKILL); <span class="comment">// 9 测试不能被阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当阻塞的信号被解除阻塞, 该信号就可以被捕捉到了</span></span><br><span class="line">    <span class="comment">// 如果信号被捕捉到之后, 马上就被处理掉了 --&gt; 递达状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = callback;</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 和sigint的处理动作相同</span></span><br><span class="line">    sigaction(SIGQUIT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGKILL, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将初始化的信号集中的数据设置给内核</span></span><br><span class="line">    <span class="type">sigset_t</span> old;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;myset, &amp;old);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 让进程一直运行, 在当前进程中产生对应的信号</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 4. 读内核的未决信号集</span></span><br><span class="line">        <span class="type">sigset_t</span> curset;</span><br><span class="line">        sigpending(&amp;curset);</span><br><span class="line">        <span class="comment">// 遍历这个信号集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ret = sigismember(&amp;curset, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 解除阻塞, 重新设置阻塞信号集</span></span><br><span class="line">            <span class="comment">//sigprocmask(SIG_UNBLOCK, &amp;myset, NULL);</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;old, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结论：程序中对 9 号信号的捕捉是无效的，因为它无法被捕捉。</p></blockquote><hr><h2 id="5-5-SIGCHLD-信号"><a href="#5-5-SIGCHLD-信号" class="headerlink" title="5.5 SIGCHLD 信号"></a>5.5 SIGCHLD 信号</h2><p>当子进程退出、暂停、从暂停回复运行的时候，在子进程中会产生一个SIGCHLD信号，并将其发送给父进程，但是父进程收到这个信号后默认忽略。<br>我们可以在父进程中对这个信号加以利用，基于这个信号来回收子进程的资源，因此需要在父进程中捕捉子进程发送过来的这个信号。</p><p>下面是基于信号回收子进程资源的示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收子进程处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">recycle</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到的信号是: %d\n&quot;</span>, num);</span><br><span class="line">    <span class="comment">// 子进程的资源回收, 非阻塞</span></span><br><span class="line">    <span class="comment">// SIGCHLD信号17号信号, 1-31号信号不支持排队</span></span><br><span class="line">    <span class="comment">// 如果这些信号同时产生多个, 最终处理的时候只处理一次</span></span><br><span class="line">    <span class="comment">// 假设多个子进程同时退出, 父进程同时收到了多个sigchld信号</span></span><br><span class="line">    <span class="comment">// 父进程只会处理一次这个信号, 因此当前函数被调用了一次, waitpid被调用一次</span></span><br><span class="line">    <span class="comment">// 相当于只回收了一个子进程, 但是是同时死了多个子进程, 因此就出现了僵尸进程</span></span><br><span class="line">    <span class="comment">// 解决方案: 循环回收即可</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是阻塞回收, 就回不到另外一个处理逻辑上去了</span></span><br><span class="line">        <span class="type">pid_t</span> pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child died, pid = %d\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 没有死亡的子进程, 直接退出当前循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;所有子进程都回收完毕了, 拜拜...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置sigchld信号阻塞</span></span><br><span class="line">    <span class="type">sigset_t</span> myset;</span><br><span class="line">    sigemptyset(&amp;myset);</span><br><span class="line">    sigaddset(&amp;myset, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;myset, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环创建多个子进程 - 20</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 注册信号捕捉, 捕捉sigchld</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_flags  =<span class="number">0</span>;</span><br><span class="line">        act.sa_handler = recycle;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        <span class="comment">// 注册信号捕捉, 委托内核处理将来产生的信号</span></span><br><span class="line">        <span class="comment">// 当信号产生之后, 当前进程优先处理信号, 之前的处理动作会暂停</span></span><br><span class="line">        <span class="comment">// 信号处理完毕之后, 回到原来的暂停的位置继续运行</span></span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解除sigcld信号的阻塞</span></span><br><span class="line">        <span class="comment">// 信号被阻塞之后,就捕捉不到了, 解除阻塞之后才能捕捉到这个信号</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;myset, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父进程执行其他业务逻辑就可以了</span></span><br><span class="line">        <span class="comment">// 默认父进程执行这个while循环, 但是信号产生了, 这个执行逻辑或强迫暂停</span></span><br><span class="line">        <span class="comment">// 父进程去处理信号的处理函数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="6-守护进程"><a href="#6-守护进程" class="headerlink" title="6. 守护进程"></a>6. 守护进程</h1><p>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。</p><h2 id="6-1-进程组"><a href="#6-1-进程组" class="headerlink" title="6.1 进程组"></a>6.1 进程组</h2><p>多个进程的集合就是进程组, 这个组中必须有一个组长, 组长就是进程组中的第一个进程，组长以外的都是普通的成员，每个进程组都有一个唯一的组ID，进程组的ID和组长的PID是一样的。</p><p>进程组中的成员是可以转移的，如果当前进程组中的成员被转移到了其他的组，或者进制中的所有进程都退出了，那么这个进程组也就不存在了。<br>如果进程组中组长死了, 但是当前进程组中有其他进程，这个进程组还是继续存在的。<br>下面介绍几个常用的进程组函数：</p><blockquote><p>得到当前进程所在的进程组的组ID</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>获取指定的进程所在的进程组的组ID，参数 pid 就是指定的进程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>将某个进程移动到其他进程组中或者创建新的进程组</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>pid: 某个进程的进程ID</li><li>pgid: 某个进程组的组ID<ul><li>如果pgid对应的进程组存在，pid对应的进程会移动到这个组中, pid !&#x3D; pgid</li><li>如果pgid对应的进程组不存在，会创建一个新的进程组, 因此要求 pid &#x3D;&#x3D; pgid, 当前进程就是组长了</li></ul></li></ul></li><li>返回值：函数调用成功返回0，失败返回-1</li></ul><hr><h2 id="6-2-会话"><a href="#6-2-会话" class="headerlink" title="6.2 会话"></a>6.2 会话</h2><p>会话(session)是由一个或多个进程组组成的，一个会话可以对应一个控制终端, 也可以没有。<br>一个普通的进程可以调用 <code>setsid()</code> 函数使自己成为新 session 的领头进程（会长），并且这个 session 领头进程还会被放入到一个新的进程组中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某个进程所属的会话ID</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将某个进程变成会话 =&gt;&gt; 得到一个守护进程</span></span><br><span class="line"><span class="comment">// 使用哪个进程调用这个函数, 这个进程就会变成一个会话</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>使用这个函数的注意事项:</p><ol><li>调用这个函数的进程不能是组长进程, 如果是,该函数调用失败，如何保证这个函数能调用成功呢?<br>先fork()创建子进程, 终止父进程,</li><li>让子进程调用这个函数 如果调用这个函数的进程不是进程组长, 会话创建成功<br>这个进程会变成当前会话中的第一个进程，同时也会变成新的进程组的组长<br>该函数调用成功之后, 当前进程就脱离了控制终端，因此不会阻塞终端</li></ol></blockquote><hr><h2 id="6-3-创建守护进程"><a href="#6-3-创建守护进程" class="headerlink" title="6.3 创建守护进程"></a>6.3 创建守护进程</h2><p>如果要创建一个守护进程，标准步骤如下，部分操作可以根据实际需求进行取舍：</p><ol><li><p>创建子进程, 让父进程退出</p><ul><li>因为父进程有可能是组长进程，不符合条件，也没有什么利用价值，退出即可</li><li>子进程没有任何职务, 目的是让子进程最终变成一个会话, 最终就会得到守护进程</li></ul></li><li><p>通过子进程创建新的会话，调用函数 setsid()，脱离控制终端, 变成守护进程</p></li><li><p>改变当前进程的工作目录 (可选项)</p><ul><li>某些文件系统可以被卸载, 比如: U盘, 移动硬盘<br> 进程如果在这些目录中运行，运行期间这些设备被卸载了，运行的进程也就不能正常工作了。</li><li>修改当前进程的工作目录需要调用函数 <code>chdir()</code></li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>重新设置文件的掩码 (可选项,)<ul><li>掩码: umask, 在创建新文件的时候需要和这个掩码进行运算, 去掉文件的某些权限</li><li>设置掩码需要使用函数 <code>umask()</code></li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mode_t</span> <span class="title function_">umask</span><span class="params">(<span class="type">mode_t</span> mask)</span>;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>关闭&#x2F;重定向文件描述符 (建议做)</p><ul><li><p>启动一个进程, 文件描述符表中默认有三个被打开了, 对应的都是当前的终端文件</p></li><li><p>因为进程通过调用 setsid() 已经脱离了当前终端, 因此关联的文件描述符也就没用了, 可以关闭.如下第一代码部分</p></li><li><p>重定向文件描述符(和关闭二选一): 改变文件描述符关联的默认文件, 让他们指向一个特殊的文件<code>/dev/null</code>，只要把数据扔到这个特殊的设备文件中, 数据被被销毁了</p></li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">close(STDIN_FILENO);</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">close(STDERR_FILENO);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line"><span class="comment">// 重定向之后, 这三个文件描述符就和当前终端没有任何关系了</span></span><br><span class="line">dup2(fd, STDIN_FILENO);</span><br><span class="line">dup2(fd, STDOUT_FILENO);</span><br><span class="line">dup2(fd, STDERR_FILENO);</span><br></pre></td></tr></table></figure><ol start="6"><li>根据实际需求在守护进程中执行某些特定的操作</li></ol><hr><h2 id="6-4-守护进程的应用"><a href="#6-4-守护进程的应用" class="headerlink" title="6.4 守护进程的应用"></a>6.4 守护进程的应用</h2><p>写一个守护进程, 每隔2s获取一次系统时间, 并将得到的时间写入到磁盘文件中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号的处理动作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">writeFile</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 得到系统时间</span></span><br><span class="line">    <span class="type">time_t</span> seconds = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 时间转换, 总秒数 -&gt; 可以识别的时间字符串</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">loc</span> =</span> localtime(&amp;seconds);</span><br><span class="line">    <span class="comment">// sprintf();</span></span><br><span class="line">    <span class="type">char</span>* curtime = asctime(loc); <span class="comment">// 自带换行</span></span><br><span class="line">    <span class="comment">// 打开一个文件, 如果文件不存在, 就创建, 文件需要有追加属性</span></span><br><span class="line">    <span class="comment">// ./对应的是哪个目录? /home/robin</span></span><br><span class="line">    <span class="comment">// 0664 &amp; ~022</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./time+++++++.log&quot;</span>, O_WRONLY|O_CREAT|O_APPEND, <span class="number">0664</span>);</span><br><span class="line">    write(fd, curtime, <span class="built_in">strlen</span>(curtime));</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建子进程, 杀死父进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// kill(getpid(), 9); raise(9); abort();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 子进程, 将其变成会话, 脱离当前终端</span></span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 修改进程的工作目录, 修改到一个不能被修改和删除的目录中 /home/robin</span></span><br><span class="line">    chdir(<span class="string">&quot;/home/robin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 设置掩码, 在进程中创建文件的时候这个掩码就起作用了</span></span><br><span class="line">    umask(<span class="number">022</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 重定向和终端关联的文件描述符 -&gt; /dev/null</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    dup2(fd, STDIN_FILENO);</span><br><span class="line">    dup2(fd, STDOUT_FILENO);</span><br><span class="line">    dup2(fd, STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 委托内核捕捉并处理将来发生的信号-SIGALRM(14)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = writeFile;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 设置定时器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">val</span>;</span></span><br><span class="line">    val.it_value.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    val.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    setitimer(ITIMER_REAL, &amp;val, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-进程控制&quot;&gt;&lt;a href=&quot;#1-进程控制&quot; class=&quot;headerlink&quot; title=&quot;1. 进程控制&quot;&gt;&lt;/a&gt;1. 进程控制&lt;/h1&gt;&lt;h2 id=&quot;1-1-进程概述&quot;&gt;&lt;a href=&quot;#1-1-进程概述&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="进程" scheme="http://example.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>文件IO</title>
    <link href="http://example.com/2023/10/22/%E6%96%87%E4%BB%B6IO/"/>
    <id>http://example.com/2023/10/22/%E6%96%87%E4%BB%B6IO/</id>
    <published>2023-10-22T01:53:22.000Z</published>
    <updated>2023-10-22T12:11:22.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-文件描述符"><a href="#1-文件描述符" class="headerlink" title="1. 文件描述符"></a>1. 文件描述符</h1><h2 id="1-1-虚拟地址空间"><a href="#1-1-虚拟地址空间" class="headerlink" title="1.1 虚拟地址空间"></a>1.1 虚拟地址空间</h2><p>虚拟地址空间是一个非常抽象的概念，先根据字面意思进行解释：</p><blockquote><p>它可以用来加载程序数据（数据可能被加载到物理内存上，空间不够就加载到虚拟内存中）<br> 它对应着一段连续的内存地址，起始位置为 0。<br>之所以说虚拟是因为这个起始的0地址是被虚拟出来的， 不是物理内存的0地址。</p></blockquote><p>虚拟地址空间的大小也由操作系统决定，32位的操作系统虚拟地址空间的大小为 2^32^ 字节，也就是4G，64位的操作系统虚拟地址空间大小为2^64^ 字节，也就是16777216T。</p><p><code>当我们运行磁盘上一个可执行程序, 就会得到一个进程，内核会给每一个运行的进程创建一块属于自己的虚拟地址空间，并将应用程序数据装载到虚拟地址空间对应的地址上。</code></p><p>进程在运行过程中，程序内部所有的指令都是通过CPU处理完成的，CPU只进行数据运算并不具备数据存储的能力，其处理的数据都加载自物理内存<br>那么进程中的数据是如何进出入到物理内存中的呢？<br>其实是通过CPU中的内存管理单元MMU（Memory Management Unit）从进程的虚拟地址空间中映射过去的。</p><p><img src="/img/8.26.png" alt="在这里插入图片描述"></p><hr><h3 id="1-1-1-存在的意义"><a href="#1-1-1-存在的意义" class="headerlink" title="1.1.1 存在的意义"></a>1.1.1 存在的意义</h3><p>为什么操作系统不直接将数据加载到物理内存中而是将数据加载到虚拟地址空间中，在通过CPU的MMU映射到物理内存中呢？</p><p>看一下如果直接将数据加载到物理内存会发生什么事情：</p><p><img src="/img/8.27.png" alt="在这里插入图片描述"></p><blockquote><p>假设计算机的物理内存大小为1G, 进程A需要100M内存因此直接在物理内存上从0地址开始分配100M, 进程B启动需要250M内存,因此继续在物理内存上为其分配250M内存<br>并且进程A和进程B占用的内存是连续的。之后再启动其他进程继续按照这种方法进行物理内存的分配…</p></blockquote><p>使用这种方式分配内存会有如下几个问题：</p><ol><li><code>每个进程的地址不隔离，有安全风险。</code></li></ol><p>由于程序都是直接访问物理内存，所以恶意程序可以通过内存寻址随意修改别的进程对应的内存数据，以达到破坏的目的。虽然有些时候是非恶意的，但是有些存在 bug 的程序可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。</p><ol start="2"><li><code>内存效率低。</code></li></ol><p>如果直接使用物理内存的话，一个进程对应的内存块就是作为一个整体操作的<br>如果出现物理内存不够用的时候，我们一般的办法是将不常用的进程拷贝到磁盘的交换分区（虚拟内存）中，以便腾出内存，因此就需要将整个进程一起拷走，如果数据量大，在内存和磁盘之间拷贝时间就会很长，效率低下。</p><ol start="3"><li><code>进程中数据的地址不确定，每次都会发生变化。</code></li></ol><p>由于物理内存的使用情况一直在动态的变化，我们无法确定内存现在使用到哪里了，如果直接将程序数据加载到物理内存，内存中每次存储数据的起始地址都是不一样的，这样数据的加载都需要使用相对地址，加载效率低（静态库是使用绝对地址加载的）。</p><blockquote><p>有了虚拟地址空间之后就可以完美的解决上边提到的所有问题了，虚拟地址空间就是一个中间层，相当于在程序和物理内存之间设置了一个屏障，将二者隔离开来。<br>程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上。这样，只要操作系统处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果。</p></blockquote><hr><h3 id="1-1-2-分区"><a href="#1-1-2-分区" class="headerlink" title="1.1.2 分区"></a>1.1.2 分区</h3><p>从操作系统层级上看，虚拟地址空间主要分为两个部分<code>内核区</code>和<code>用户区</code>。</p><ul><li><strong>内核区</strong>：<ul><li>内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。</li><li>内核总是驻留在内存中，是操作系统的一部分。</li><li>系统中所有进程对应的虚拟地址空间的内核区都会映射到同一块物理内存上（系统内核只有一个）。</li></ul></li><li><strong>用户区</strong>：存储用户程序运行中用到的各种数据。</li></ul><p>先看进程对应的虚拟地址空间的各个分区，再来详细介绍用户区的组成（以32位系统的虚拟地址空间为例）。<br><img src="/img/8.28.png" alt="在这里插入图片描述"></p><p><em>每个进程的虚拟地址空间都是从0地址开始的，我们在程序中打印的变量地址也其在虚拟地址空间中的地址，程序是无法直接访问物理内存的。</em></p><p>虚拟地址空间中用户区地址范围是 0~3G，里边分为多个区块：</p><ul><li><code>保留区</code>: 位于虚拟地址空间的最底部，未赋予物理地址。任何对它的引用都是非法的，程序中的空指针（NULL）指向的就是这块内存地址。</li><li><code>.text段</code>: 代码段也称正文段或文本段，通常用于存放程序的执行代码(即CPU执行的机器指令)，代码段一般情况下是只读的，这是对执行代码的一种保护机制。</li><li><code>.data段</code>: 数据段通常用于存放程序中已初始化且初值不为0的全局变量和静态变量。数据段属于静态内存分配(静态存储区)，可读可写。</li><li><code>.bss段</code>: 未初始化以及初始为0的全局变量和静态变量，操作系统会将这些未初始化变量初始化为0</li><li><code>堆(heap)</code>：用于存放进程运行时动态分配的内存。<ul><li>堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。</li><li>堆向高地址扩展(即“向上生长”)，是不连续的内存区域。<br>  这是由于系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历。</li></ul></li><li><code>内存映射区(mmap)</code>：作为内存映射区加载磁盘文件，或者加载程序运作过程中需要调用的动态库。</li><li><code>栈(stack)</code>: 存储函数内部声明的非静态局部变量，函数参数，函数返回地址等信息，栈内存由编译器自动分配释放。栈和堆相反地址“向下生长”，分配的内存是连续的。</li><li><code>命令行参数</code>：存储进程执行的时候传递给<code>main()</code>函数的参数，argc，argv[]</li><li><code>环境变量</code>: 存储和进程相关的环境变量, 比如: 工作路径, 进程所有者等信息</li></ul><hr><h2 id="1-2-文件描述符"><a href="#1-2-文件描述符" class="headerlink" title="1.2  文件描述符"></a>1.2  文件描述符</h2><h3 id="1-2-1-文件描述符"><a href="#1-2-1-文件描述符" class="headerlink" title="1.2.1 文件描述符"></a>1.2.1 文件描述符</h3><p>在Linux操作系统中的一切都被抽象为文件,那么一个打开的文件是如何与应用程序进行对应呢？<br>解决方案是使用<code>文件描述符（file descriptor，简称fd）</code>，当在进程中打开一个现有文件或者创建一个新文件时，内核向该进程返回一个文件描述符，用于对应这个打开&#x2F;新建的文件。<br>这些文件描述符都存储在内核为每个进程维护的一个文件描述符表中。</p><p>在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><blockquote><p>在Linux系统中一切皆文件，系统中一切都被抽象成了文件。对这些文件的读写都需要通过文件描述符来完成。<br>标准C库的文件IO函数使用的文件指针<code>FILE*</code>在Linux中也需要通过文件描述符的辅助才能完成读写操作。<code>FILE</code>其实是一个结构体，其内部有一个成员就是文件描述符（下面结构体的第25行）。</p></blockquote><p>FILE结构体在Linux头文件中的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux c FILE结构体定义： /usr/include/libio.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> _fileno;<span class="comment">// 文件描述符</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"> </span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在文件: /usr/include/stdio.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> <span class="title">FILE</span>;</span></span><br></pre></td></tr></table></figure><hr><h3 id="1-2-2-文件描述符表"><a href="#1-2-2-文件描述符表" class="headerlink" title="1.2.2 文件描述符表"></a>1.2.2 文件描述符表</h3><p>前面讲到启动一个进程就会得到一个对应的虚拟地址空间，这个虚拟地址空间分为两大部分，在内核区有专门用于进程管理的模块。Linux的进程控制块<code>PCB（process control block）</code>本质是一个叫做<code>task_struct</code>的结构体，里边包括管理进程所需的各种信息，其中有一个结构体叫做<code>file</code> ，我们将它叫做文件描述符表，里边有一个整形索引表,用于存储文件描述符。</p><p>内核为每一个进程维护了一个文件描述符表，索引表中的值都是从0开始的，所以在不同的进程中你会看到相同的文件描述符，但是它们指向的不一定是同一个磁盘文件。<br><img src="/img/8.29.png" alt="在这里插入图片描述"></p><blockquote><p>Linux中用户操作的每个终端都被视作一个设备文件, 当前操作的终端文件可以使用 &#x2F;dev&#x2F;tty表示。</p></blockquote><ul><li><code>打开的最大文件数</code></li></ul><p>每一个进程对应的文件描述符表能够存储的打开的文件数是有限制的, 默认为1024个，这个默认值是可以修改的，支持打开的最大文件数据取决于操作系统的硬件配置。</p><ul><li><code>默认分配的文件描述符</code><br>当一个进程被启动之后，内核PCB的文件描述符表中就已经分配了三个文件描述符，这三个文件描述符对应的都是当前启动这个进程的终端文件（Linux中一切皆文件，终端就是一个设备文件，在 &#x2F;dev 目录中）<ul><li><code>STDIN_FILENO</code>：标准输入，可以通过这个文件描述符将数据输入到终端文件中，宏值为0。</li><li><code>STDOUT_FILENO</code>：标准输出，可以通过这个文件描述符将数据通过终端输出出来，宏值为1。</li><li><code>STDERR_FILENO</code>：标准错误，可以通过这个文件描述符将错误信息通过终端输出出来，宏值为2。</li></ul></li></ul><p>这三个默认分配的文件描述符是可以通过<code>close()</code>函数关闭掉，但是关闭之后当前进程也就不能和当前终端进行输入或者输出的信息交互了。</p><ul><li><code>给新打开的文件分配文件描述符</code><ul><li>因为进程启动之后，文件描述符表中的0,1,2就被分配出去了，因此<code>从3开始分配</code></li><li>在进程中每打开一个文件，就会给这个文件分配一个新的文件描述符，比如：<ul><li>通过<code>open()</code>函数打开 <code>/hello.txt</code>，文件描述符 3 被分配给了这个文件，保持这个打开状态，再次通过<code>open()</code>函数打开 <code>/hello.txt</code>，文件描述符 4 被分配给了这个文件，也就是说一个进程中不同的文件描述符打开的磁盘文件可能是同一个。</li><li>通过<code>open()</code>函数打开 <code>/hello.txt</code> ，文件描述符 3 被分配给了这个文件，将打开的文件关闭，此时文件描述符3就被释放了。再次通过<code>open()</code>函数打开 <code>/hello.txt</code>，文件描述符 3 被分配给了这个文件，也就是说打开的新文件会关联文件描述符表中最小的没有被占用的文件描述符。</li></ul></li></ul></li></ul><p>总结:</p><ol><li>每个进程对应的文件描述符表默认支持打开的最大文件数为 1024，可以修改</li><li>每个进程的文件描述符表中都已经默认分配了三个文件描述符，对应的都是当前终端文件（&#x2F;dev&#x2F;tty）</li><li>每打开新的文件，内核会从进程的文件描述符表中找到一个空闲的没有别占用的文件描述符与其进行关联</li><li>文件描述符表中不同的文件描述符可以对应同一个磁盘文件</li><li>每个进程文件描述符表中的文件描述符值是唯一的，不会重复</li></ol><hr><h1 id="2-Linux系统文件IO"><a href="#2-Linux系统文件IO" class="headerlink" title="2. Linux系统文件IO"></a>2. Linux系统文件IO</h1><p>每个系统都有自己的专属函数，我们习惯称其为系统函数。<br><code>系统函数并不是内核函数</code>，因为内核函数是不允许用户使用的，系统函数就充当了二者之间的桥梁，这样用户就可以间接的完成某些内核操作了。</p><p>在前面介绍了文件描述符，在Linux系统中必须要使用系统提供的IO函数才能基于这些文件描述符完成对相关文件的读写操作。这些Linux系统IO函数和标准C库的IO函数使用方法类似，函数名称也类似</p><hr><h2 id="2-1-open-close"><a href="#2-1-open-close" class="headerlink" title="2.1 open&#x2F;close"></a>2.1 open&#x2F;close</h2><h3 id="2-1-1-函数原型"><a href="#2-1-1-函数原型" class="headerlink" title="2.1.1 函数原型"></a>2.1.1 函数原型</h3><blockquote><p>通过open函数我们即可打开一个磁盘文件，如果磁盘文件不存在还可以创建一个新的的文件</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">open是一个系统函数, 只能在linux系统中使用, windows不支持</span></span><br><span class="line"><span class="comment">fopen 是标准c库函数, 一般都可以跨平台使用, 可以这样理解:</span></span><br><span class="line"><span class="comment">- 在linux中 fopen底层封装了Linux的系统API open</span></span><br><span class="line"><span class="comment">- 在window中, fopen底层封装的是 window 的 api</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 打开一个已经存在的磁盘文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">// 打开磁盘文件, 如果文件不存在, 就会自动创建</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>参数介绍:</p><ul><li><p>pathname: 被打开的文件的文件名</p></li><li><p>flags: 使用什么方式打开指定的文件，这个参数对应一些宏值，需要根据实际需求指定</p><ul><li><code>必须要指定的属性</code>, 以下三个属性不能同时使用, 只能任选其一<ul><li><code>O_RDONLY</code>: 以只读方式打开文件</li><li><code>O_WRONLY</code>: 以只写方式打开文件</li><li><code>O_RDWR</code>: 以读写方式打开文件</li></ul></li><li><code>可选属性</code>, 和上边的属性一起使用<ul><li><code>O_APPEND</code>: 新数据追加到文件尾部, 不会覆盖文件的原来内容</li><li><code>O_CREAT</code>: 如果文件不存在, 创建该文件, 如果文件存在什么也不做</li><li><code>O_EXCL</code>: 检测文件是否存在, 必须要和 <code>O_CREAT</code> 一起使用, 不能单独使用: <code>O_CREAT</code> | <code>O_EXCL</code><ul><li>检测到文件不存在, 创建新文件</li><li>检测到文件已经存在, 创建失败, 函数直接返回-1（如果不添加这个属性，不会返回-1）</li></ul></li></ul></li></ul></li><li><p>mode: 在创建新文件的时候才需要指定这个参数的值，用于指定新文件的权限，这是一个八进制的整数</p><ul><li>这个参数的最大值为：0777</li><li>创建的新文件对应的最终实际权限, 计算公式: <code>(mode &amp; ~umask)</code><ul><li>umask 掩码可以通过 umask 命令查看</li></ul></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">umask</span></span><br><span class="line">0002</span><br></pre></td></tr></table></figure><p>假设 mode 参数的值为 0777, 通过计算得到的文件权限为 0775</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># umask(文件掩码):  002(八进制)  = 000000010 (二进制)  </span></span><br><span class="line"><span class="comment"># ~umask(掩码取反): ~000000010 (二进制) = 111111101 (二进制)  </span></span><br><span class="line"><span class="comment"># 参数mode指定的权限为: 0777(八进制) = 111111111(二进制)</span></span><br><span class="line"><span class="comment"># 计算公式: mode &amp; ~umask</span></span><br><span class="line">             111111111</span><br><span class="line">       &amp;     111111101</span><br><span class="line">            ------------------</span><br><span class="line">             111111101    二进制</span><br><span class="line">            ------------------</span><br><span class="line">             mod=0775     八进制  </span><br></pre></td></tr></table></figure><ul><li>返回值:<ul><li>成功: 返回内核分配的文件描述符, 这个值被记录在内核的文件描述符表中，这是一个大于0的整数</li><li>失败: -1</li></ul></li></ul><hr><h3 id="2-1-2-close函数原型"><a href="#2-1-2-close函数原型" class="headerlink" title="2.1.2 close函数原型"></a>2.1.2 close函数原型</h3><blockquote><p>通过open函数可以让内核给文件分配一个文件描述符, 如果需要释放这个文件描述符就需要关闭文件。对应的这个系统函数叫做 close</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><ul><li>函数参数: fd 是文件描述符, 是open() 函数的返回值</li><li>函数返回值: 函数调用成功返回值 0, 调用失败返回 -1</li></ul><hr><h3 id="2-1-3-打开已存在文件"><a href="#2-1-3-打开已存在文件" class="headerlink" title="2.1.3 打开已存在文件"></a>2.1.3 打开已存在文件</h3><blockquote><p>我们可以使用<code>open()</code>函数打开一个本地已经存在的文件, 假设我们想要读写这个文件, 操作代码如下:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;abc.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd: %d\n&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc open.c </span><br><span class="line">$ ./a.out </span><br><span class="line">fd: 3<span class="comment"># 打开的文件对应的文件描述符值为 3</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-1-4-创建新文件"><a href="#2-1-4-创建新文件" class="headerlink" title="2.1.4 创建新文件"></a>2.1.4 创建新文件</h3><blockquote><p>如果要创建一个新的文件，还是使用 <code>open</code> 函数，只不过需要添加 <code>O_CREAT</code> 属性, 并且给新文件指定操作权限。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建新文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./new.txt&quot;</span>, O_CREAT|O_RDWR, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建新文件成功, fd: %d\n&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc open1.c </span><br><span class="line">$ ./a.out </span><br><span class="line">创建新文件成功, fd: 3</span><br></pre></td></tr></table></figure><p>假设在创建新文件的时候, 给 open 指定第三个参数指定新文件的操作权限, 文件也是会被创建出来的, 只不过新的文件的权限可能会有点奇怪, 这个权限会随机分配而且还会出现一些特殊的权限位, 如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ $ ll new.txt </span><br><span class="line">-r-x--s--T 1 robin robin 0 Jan 30 16:17 new.txt*   <span class="comment"># T 就是一个特殊权限</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-1-5-文件状态判断"><a href="#2-1-5-文件状态判断" class="headerlink" title="2.1.5 文件状态判断"></a>2.1.5 文件状态判断</h3><blockquote><p>在创建新文件的时候我们还可以通过 <code>O_EXCL</code>进行文件的检测, 具体处理方式如下:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建新文件之前, 先检测是否存在</span></span><br><span class="line">    <span class="comment">// 文件存在创建失败, 返回-1, 文件不存在创建成功, 返回分配的文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./new.txt&quot;</span>, O_CREAT|O_EXCL|O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建文件失败, 已经存在了, fd: %d\n&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建新文件成功, fd: %d\n&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行程序:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc open1.c </span><br><span class="line">$ ./a.out </span><br><span class="line">创建文件失败, 已经存在了, fd: -1</span><br></pre></td></tr></table></figure><hr><h2 id="2-2-read-write"><a href="#2-2-read-write" class="headerlink" title="2.2 read&#x2F;write"></a>2.2 read&#x2F;write</h2><h3 id="2-2-1-read"><a href="#2-2-1-read" class="headerlink" title="2.2.1 read"></a>2.2.1 read</h3><blockquote><p>read 函数用于读取文件内部数据，在通过 open 打开文件的时候需要指定读权限</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li><code>fd</code>: 文件描述符, open() 函数的返回值, 通过这个参数定位打开的磁盘文件</li><li><code>buf</code>: 是一个传出参数, 指向一块有效的内存, 用于存储从文件中读出的数据<ul><li><code>传出参数</code>: 类似于返回值, 将变量地址传递给函数, 函数调用完毕, 地址中就有数据了</li></ul></li><li><code>count</code>: buf指针指向的内存的大小, 指定可以存储的最大字节数</li></ul></li><li>返回值:<ul><li>大于0: 从文件中读出的字节数，读文件成功</li><li>等于0: 代表文件读完了，读文件成功</li><li>-1: 读文件失败了</li></ul></li></ul><hr><h3 id="2-2-2-write"><a href="#2-2-2-write" class="headerlink" title="2.2.2 write"></a>2.2.2 write</h3><blockquote><p>write 函数用于将数据写入到文件内部，在通过 open 打开文件的时候需要指定写权限</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li><code>fd</code>: 文件描述符, open() 函数的返回值, 通过这个参数定位打开的磁盘文件</li><li><code>buf</code>: 指向一块有效的内存地址, 里边有要写入到磁盘文件中的数据</li><li><code>count</code>: 要往磁盘文件中写入的字节数, 一般情况下是buf字符串的长度, <code>strlen(buf)</code></li></ul></li><li>返回值:<ul><li>大于0: 成功写入到磁盘文件中的字节数</li><li>-1: 写文件失败了</li></ul></li></ul><hr><h3 id="2-2-3-文件拷贝"><a href="#2-2-3-文件拷贝" class="headerlink" title="2.2.3 文件拷贝"></a>2.2.3 文件拷贝</h3><blockquote><p>假设有一个比较大的磁盘文件, 打开这个文件得到文件描述符<code>fd1</code>，然后在创建一个新的磁盘文件得到文件描述符<code>fd2</code>, 在程序中通过 <code>fd1</code>将文件内容读出，并通过<code>fd2</code>将读出的数据写入到新文件中。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件的拷贝</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开存在的文件english.txt, 读这个文件</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;./english.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open-readfile&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 打开不存在的文件, 将其创建出来, 将从english.txt读出的内容写入这个文件中</span></span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;copy.txt&quot;</span>, O_WRONLY|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd2 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open-writefile&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 循环读文件, 循环写文件</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>( (len = read(fd1, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将读到的数据写入到另一个文件中</span></span><br><span class="line">        write(fd2, buf, len); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 关闭文件</span></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-3-lseek"><a href="#2-3-lseek" class="headerlink" title="2.3 lseek"></a>2.3 lseek</h2><blockquote><p>系统函数 lseek 的功能是比较强大的, 我们既可以通过这个函数移动文件指针, 也可以通过这个函数进行文件的拓展。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>fd: 文件描述符, open() 函数的返回值, 通过这个参数定位打开的磁盘文件</li><li>offset: 偏移量，需要和第三个参数配合使用</li><li>whence: 通过这个参数指定函数实现什么样的功能<ul><li>SEEK_SET: 从文件头部开始偏移 offset 个字节</li><li>SEEK_CUR: 从当前文件指针的位置向后偏移offset个字节</li><li>SEEK_END: 从文件尾部向后偏移offset个字节</li></ul></li></ul></li><li>返回值:<ul><li>成功: 文件指针从头部开始计算总的偏移量</li><li>失败: -1</li></ul></li></ul><hr><h3 id="2-3-1-移动文件指针"><a href="#2-3-1-移动文件指针" class="headerlink" title="2.3.1 移动文件指针"></a>2.3.1 移动文件指针</h3><blockquote><p>通过对 lseek 函数第三个参数的设置, 经常使用该函数实现如下几个功能</p></blockquote><ul><li>文件指针移动到文件头部</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br></pre></td></tr></table></figure><ul><li>得到当前文件指针的位置</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd, <span class="number">0</span>, SEEK_CUR); </span><br></pre></td></tr></table></figure><ul><li>得到文件总大小</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd, <span class="number">0</span>, SEEK_END);</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-2-文件拓展"><a href="#2-3-2-文件拓展" class="headerlink" title="2.3.2 文件拓展"></a>2.3.2 文件拓展</h3><p>假设使用一个下载软件进行一个大文件下载，但是磁盘很紧张，如果不能马上将文件下载到本地，磁盘空间就可能被其他文件占用了，导致下载软件下载的文件无处存放。那么这个文件怎么解决呢？</p><p>我们可以在开始下载的时候先进行文件拓展，将一些字符写入到目标文件中，让拓展的文件和即将被下载的文件一样大，这样磁盘空间就被成功抢到手，软件就可以下载对应的文件了。</p><p>使用 lseek 函数进行文件拓展必须要满足一下条件：</p><blockquote><p>文件指针必须要偏移到文件尾部之后， 多出来的就需要被填充的部分。<br>文件拓展之后，必须要使用 write()函数进行一次写操作（写什么都可以，没有字节数要求）。</p></blockquote><p>文件拓展举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lseek.c</span></span><br><span class="line"><span class="comment">// 拓展文件大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件拓展, 一共增加了 1001 个字节</span></span><br><span class="line">    lseek(fd, <span class="number">1000</span>, SEEK_END);</span><br><span class="line">    write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看执行执行的效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译程序 </span></span><br><span class="line">$ gcc lseek.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目录文件信息</span></span><br><span class="line">$ ll</span><br><span class="line">-rwxrwxr-x 1 robin robin 8808 May  6  2019 a.out*</span><br><span class="line">-rwxrwxr-x 1 robin robin 1013 May  6  2019 hello.txt*</span><br><span class="line">-rw-rw-r-- 1 robin robin  299 May  6  2019 lseek.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行程序, 拓展文件</span></span><br><span class="line">$ ./a.out </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在查看目录文件信息</span></span><br><span class="line">$ ll</span><br><span class="line">-rwxrwxr-x 1 robin robin 8808 May  6  2019 a.out*</span><br><span class="line">-rwxrwxr-x 1 robin robin 2014 Jan 30 17:39 hello.txt*   <span class="comment"># 大小从 1013 -&gt; 2014, 拓展了1001字节</span></span><br><span class="line">-rw-rw-r-- 1 robin robin  299 May  6  2019 lseek.c</span><br></pre></td></tr></table></figure><hr><h2 id="2-4-truncate-ftruncate"><a href="#2-4-truncate-ftruncate" class="headerlink" title="2.4 truncate&#x2F;ftruncate"></a>2.4 truncate&#x2F;ftruncate</h2><blockquote><p>truncate&#x2F;ftruncate 这两个函数的功能是一样的，可以对文件进行拓展也可以截断文件。<br>使用这两个函数拓展文件比使用lseek要简单</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">// 拓展文件或截断文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>path: 要拓展&#x2F;截断的文件的文件名</li><li>fd: 文件描述符, open() 得到的</li><li>length: 文件的最终大小<ul><li>文件原来size &gt; length，文件被截断, 尾部多余的部分被删除, 文件最终长度为length</li><li>文件原来size &lt; length，文件被拓展, 文件最终长度为length</li></ul></li></ul></li><li>返回值: 成功返回0; 失败返回值-1</li></ul><blockquote><p>truncate() 和 ftruncate() 两个函数的区别在于一个使用文件名一个使用文件描述符操作文件, 功能相同。<br>不管是使用这两个函数还是使用 lseek() 函数拓展文件，文件尾部填充的字符都是 0。</p></blockquote><hr><h2 id="2-5-perror"><a href="#2-5-perror" class="headerlink" title="2.5 perror"></a>2.5 perror</h2><blockquote><p>在查看Linux系统函数的时候, 我们可以发现一个规律:<br>大部分系统函数的返回值都是整形，并且通过这个返回值来描述系统函数的状态（调用是否成功了）<br>在man文档中关于系统函数的返回值大部分时候都是这样描述的：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">       On  success,  zero is returned.  On error, -1 is returned, and errno is <span class="built_in">set</span></span><br><span class="line">       appropriately.</span><br><span class="line">       </span><br><span class="line">       如果成功，则返回0。出现错误时，返回-1，并给errno设置一个适当的值。</span><br></pre></td></tr></table></figure><blockquote><p><code>errno</code>是一个全局变量，只要调用的Linux系统函数有异常（返回-1)错误对应的错误号就会被设置给这个全局变量。<br>这个错误号存储在系统的两个头文件中：<br><code> /usr/include/asm-generic/errno-base.h</code><br><code>/usr/include/asm-generic/errno.h</code></p></blockquote><p>得到错误号，去查询对应的头文件是非常不方便的，我们可以通过 perror 函数将错误号对应的描述信息打印出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数, 自己指定这个字符串的值就可以, 指定什么就会原样输出, 除此之外还会输出错误号对应的描述信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure><p>举例: 使用 perrno 打印错误信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR|O_EXCL|O_CREAT, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc open.c</span><br><span class="line">$ ./a.out </span><br><span class="line">open: File exists<span class="comment"># 通过 perror 输出的错误信息</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-6-错误号"><a href="#2-6-错误号" class="headerlink" title="2.6 错误号"></a>2.6 错误号</h2><p>为了方便查询, 特将全局变量 errno 和错误信息描述的对照关系贴出:</p><h3 id="2-6-1-Part1"><a href="#2-6-1-Part1" class="headerlink" title="2.6.1 Part1"></a>2.6.1 Part1</h3><p>信息来自头文件: &#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno-base.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EPERM            1      <span class="comment">/* Operation not permitted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOENT           2      <span class="comment">/* No such file or directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESRCH            3      <span class="comment">/* No such process */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EINTR            4      <span class="comment">/* Interrupted system call */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EIO              5      <span class="comment">/* I/O error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENXIO            6      <span class="comment">/* No such device or address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E2BIG            7      <span class="comment">/* Argument list too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOEXEC          8      <span class="comment">/* Exec format error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADF            9      <span class="comment">/* Bad file number */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECHILD          10      <span class="comment">/* No child processes */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EAGAIN          11      <span class="comment">/* Try again */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOMEM          12      <span class="comment">/* Out of memory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EACCES          13      <span class="comment">/* Permission denied */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFAULT          14      <span class="comment">/* Bad address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTBLK         15      <span class="comment">/* Block device required */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBUSY           16      <span class="comment">/* Device or resource busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEXIST          17      <span class="comment">/* File exists */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXDEV           18      <span class="comment">/* Cross-device link */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENODEV          19      <span class="comment">/* No such device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTDIR         20      <span class="comment">/* Not a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EISDIR          21      <span class="comment">/* Is a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EINVAL          22      <span class="comment">/* Invalid argument */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENFILE          23      <span class="comment">/* File table overflow */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMFILE          24      <span class="comment">/* Too many open files */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTTY          25      <span class="comment">/* Not a typewriter */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETXTBSY         26      <span class="comment">/* Text file busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFBIG           27      <span class="comment">/* File too large */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSPC          28      <span class="comment">/* No space left on device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESPIPE          29      <span class="comment">/* Illegal seek */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EROFS           30      <span class="comment">/* Read-only file system */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMLINK          31      <span class="comment">/* Too many links */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPIPE           32      <span class="comment">/* Broken pipe */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDOM            33      <span class="comment">/* Math argument out of domain of func */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERANGE          34      <span class="comment">/* Math result not representable */</span></span></span><br></pre></td></tr></table></figure><hr><h3 id="2-6-2-Part2"><a href="#2-6-2-Part2" class="headerlink" title="2.6.2 Part2"></a>2.6.2 Part2</h3><p>信息来自头文件: &#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EDEADLK         35      <span class="comment">/* Resource deadlock would occur */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENAMETOOLONG    36      <span class="comment">/* File name too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOLCK          37      <span class="comment">/* No record locks available */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This error code is special: arch syscall entry code will return</span></span><br><span class="line"><span class="comment"> * -ENOSYS if users try to call a syscall that doesn&#x27;t exist.  To keep</span></span><br><span class="line"><span class="comment"> * failures of syscalls that really do exist distinguishable from</span></span><br><span class="line"><span class="comment"> * failures due to attempts to use a nonexistent syscall, syscall</span></span><br><span class="line"><span class="comment"> * implementations should refrain from returning -ENOSYS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSYS          38      <span class="comment">/* Invalid system call number */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTEMPTY       39      <span class="comment">/* Directory not empty */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELOOP           40      <span class="comment">/* Too many symbolic links encountered */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EWOULDBLOCK     EAGAIN  <span class="comment">/* Operation would block */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOMSG          42      <span class="comment">/* No message of desired type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EIDRM           43      <span class="comment">/* Identifier removed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECHRNG          44      <span class="comment">/* Channel number out of range */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL2NSYNC        45      <span class="comment">/* Level 2 not synchronized */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL3HLT          46      <span class="comment">/* Level 3 halted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL3RST          47      <span class="comment">/* Level 3 reset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELNRNG          48      <span class="comment">/* Link number out of range */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EUNATCH         49      <span class="comment">/* Protocol driver not attached */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOCSI          50      <span class="comment">/* No CSI structure available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL2HLT          51      <span class="comment">/* Level 2 halted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADE           52      <span class="comment">/* Invalid exchange */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADR           53      <span class="comment">/* Invalid request descriptor */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXFULL          54      <span class="comment">/* Exchange full */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOANO          55      <span class="comment">/* No anode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADRQC         56      <span class="comment">/* Invalid request code */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADSLT         57      <span class="comment">/* Invalid slot */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDEADLOCK       EDEADLK</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBFONT          59      <span class="comment">/* Bad font file format */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSTR          60      <span class="comment">/* Device not a stream */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENODATA         61      <span class="comment">/* No data available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETIME           62      <span class="comment">/* Timer expired */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSR           63      <span class="comment">/* Out of streams resources */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENONET          64      <span class="comment">/* Machine is not on the network */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOPKG          65      <span class="comment">/* Package not installed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EREMOTE         66      <span class="comment">/* Object is remote */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOLINK         67      <span class="comment">/* Link has been severed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EADV            68      <span class="comment">/* Advertise error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESRMNT          69      <span class="comment">/* Srmount error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECOMM           70      <span class="comment">/* Communication error on send */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROTO          71      <span class="comment">/* Protocol error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMULTIHOP       72      <span class="comment">/* Multihop attempted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDOTDOT         73      <span class="comment">/* RFS specific error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADMSG         74      <span class="comment">/* Not a data message */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOVERFLOW       75      <span class="comment">/* Value too large for defined data type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTUNIQ        76      <span class="comment">/* Name not unique on network */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADFD          77      <span class="comment">/* File descriptor in bad state */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EREMCHG         78      <span class="comment">/* Remote address changed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBACC         79      <span class="comment">/* Can not access a needed shared library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBBAD         80      <span class="comment">/* Accessing a corrupted shared library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBSCN         81      <span class="comment">/* .lib section in a.out corrupted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBMAX         82      <span class="comment">/* Attempting to link in too many shared libraries */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBEXEC        83      <span class="comment">/* Cannot exec a shared library directly */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EILSEQ          84      <span class="comment">/* Illegal byte sequence */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERESTART        85      <span class="comment">/* Interrupted system call should be restarted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESTRPIPE        86      <span class="comment">/* Streams pipe error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EUSERS          87      <span class="comment">/* Too many users */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTSOCK        88      <span class="comment">/* Socket operation on non-socket */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDESTADDRREQ    89      <span class="comment">/* Destination address required */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMSGSIZE        90      <span class="comment">/* Message too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROTOTYPE      91      <span class="comment">/* Protocol wrong type for socket */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOPROTOOPT     92      <span class="comment">/* Protocol not available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROTONOSUPPORT 93      <span class="comment">/* Protocol not supported */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESOCKTNOSUPPORT 94      <span class="comment">/* Socket type not supported */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOPNOTSUPP      95      <span class="comment">/* Operation not supported on transport endpoint */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPFNOSUPPORT    96      <span class="comment">/* Protocol family not supported */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EAFNOSUPPORT    97      <span class="comment">/* Address family not supported by protocol */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EADDRINUSE      98      <span class="comment">/* Address already in use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EADDRNOTAVAIL   99      <span class="comment">/* Cannot assign requested address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENETDOWN        100     <span class="comment">/* Network is down */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENETUNREACH     101     <span class="comment">/* Network is unreachable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENETRESET       102     <span class="comment">/* Network dropped connection because of reset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECONNABORTED    103     <span class="comment">/* Software caused connection abort */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECONNRESET      104     <span class="comment">/* Connection reset by peer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOBUFS         105     <span class="comment">/* No buffer space available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EISCONN         106     <span class="comment">/* Transport endpoint is already connected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTCONN        107     <span class="comment">/* Transport endpoint is not connected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESHUTDOWN       108     <span class="comment">/* Cannot send after transport endpoint shutdown */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETOOMANYREFS    109     <span class="comment">/* Too many references: cannot splice */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETIMEDOUT       110     <span class="comment">/* Connection timed out */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECONNREFUSED    111     <span class="comment">/* Connection refused */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EHOSTDOWN       112     <span class="comment">/* Host is down */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EHOSTUNREACH    113     <span class="comment">/* No route to host */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EALREADY        114     <span class="comment">/* Operation already in progress */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EINPROGRESS     115     <span class="comment">/* Operation now in progress */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESTALE          116     <span class="comment">/* Stale file handle */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EUCLEAN         117     <span class="comment">/* Structure needs cleaning */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTNAM         118     <span class="comment">/* Not a XENIX named type file */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENAVAIL         119     <span class="comment">/* No XENIX semaphores available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EISNAM          120     <span class="comment">/* Is a named type file */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EREMOTEIO       121     <span class="comment">/* Remote I/O error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDQUOT          122     <span class="comment">/* Quota exceeded */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOMEDIUM       123     <span class="comment">/* No medium found */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMEDIUMTYPE     124     <span class="comment">/* Wrong medium type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECANCELED       125     <span class="comment">/* Operation Canceled */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOKEY          126     <span class="comment">/* Required key not available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EKEYEXPIRED     127     <span class="comment">/* Key has expired */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EKEYREVOKED     128     <span class="comment">/* Key has been revoked */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EKEYREJECTED    129     <span class="comment">/* Key was rejected by service */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* for robust mutexes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOWNERDEAD      130     <span class="comment">/* Owner died */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTRECOVERABLE 131     <span class="comment">/* State not recoverable */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERFKILL         132     <span class="comment">/* Operation not possible due to RF-kill */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EHWPOISON       133     <span class="comment">/* Memory page has hardware error */</span></span></span><br></pre></td></tr></table></figure><hr><h1 id="3-文件的属性信息"><a href="#3-文件的属性信息" class="headerlink" title="3. 文件的属性信息"></a>3. 文件的属性信息</h1><p>众所周知，Linux是一个基于文件的操作系统，因此作为文件本身也就有很多属性，如果想要查看某一个文件的属性有两种方式：<code>命令</code>和<code>函数</code>。<br>虽然有两种方式但是它们对应的名字是相同的，叫做<code>stat</code>。另外使用<code>file</code>命令也可以查看文件的一些属性信息。</p><h2 id="3-1-file-命令"><a href="#3-1-file-命令" class="headerlink" title="3.1 file 命令"></a>3.1 file 命令</h2><blockquote><p>该命令用来识别文件类型，也可用来辨别一些文件的编码格式。它是通过查看文件的<code>头部信息</code>来获取文件类型，而不是像Windows通过扩展名来确定文件类型的。</p></blockquote><p>命令语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数在命令中的位置没有限制</span></span><br><span class="line">$ file 文件名 [参数] </span><br></pre></td></tr></table></figure><p>file 命令的参数是可选项, 可以不加, 常用的参数如下表:</p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>-b</td><td>只显示文件类型和文件编码, 不显示文件名</td></tr><tr><td>-i</td><td>显示文件的 MIME 类型</td></tr><tr><td>-F</td><td>设置输出字符串的分隔符</td></tr><tr><td>-L</td><td>查看软连接文件自身文件属性</td></tr></tbody></table><hr><h3 id="3-1-1-查看文件类型和编码格式"><a href="#3-1-1-查看文件类型和编码格式" class="headerlink" title="3.1.1 查看文件类型和编码格式"></a>3.1.1 查看文件类型和编码格式</h3><p>使用不带任何选项的 file 命令，即可查看指定文件的类型和文件编码信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空文件</span></span><br><span class="line">$ file 11.txt </span><br><span class="line">11.txt: empty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件, 编码格式为: ASCII</span></span><br><span class="line">$ file b.cpp</span><br><span class="line">b.cpp: C <span class="built_in">source</span>, ASCII text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件, 编码格式为: UTF-8 </span></span><br><span class="line">robin@OS:~$ file test.cpp </span><br><span class="line">test.cpp: C <span class="built_in">source</span>, UTF-8 Unicode (with BOM) text, with CRLF line terminators</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可执行程序, Linux中的可执行程序为 ELF 格式</span></span><br><span class="line">robin@OS:~$ file a.out </span><br><span class="line">a.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=5317ae9fba592bf583c4f680d8cc48a8b58c96a5, not stripped</span><br></pre></td></tr></table></figure><hr><h3 id="3-1-2-只显示文件格式以及编码"><a href="#3-1-2-只显示文件格式以及编码" class="headerlink" title="3.1.2 只显示文件格式以及编码"></a>3.1.2 只显示文件格式以及编码</h3><p>使用<code>-b</code>参数，可以使 file 命令的输出不出现文件名，只显示文件格式以及编码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空文件</span></span><br><span class="line">$ file 11.txt -b</span><br><span class="line">empty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件, 编码格式为: ASCII</span></span><br><span class="line">$ file b.cpp -b</span><br><span class="line">C <span class="built_in">source</span>, ASCII text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件, 编码格式为: UTF-8 </span></span><br><span class="line">robin@OS:~$ file test.cpp  -b</span><br><span class="line">C <span class="built_in">source</span>, UTF-8 Unicode (with BOM) text, with CRLF line terminators</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可执行程序, Linux中的可执行程序为 ELF 格式</span></span><br><span class="line">robin@OS:~$ file a.out  -b</span><br><span class="line">ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=5317ae9fba592bf583c4f680d8cc48a8b58c96a5, not stripped</span><br></pre></td></tr></table></figure><hr><h3 id="3-1-3-显示文件的-MIME-类型"><a href="#3-1-3-显示文件的-MIME-类型" class="headerlink" title="3.1.3 显示文件的 MIME 类型"></a>3.1.3 显示文件的 MIME 类型</h3><p>给file命令添加<code>-i</code>参数，可以输出文件对应的 MIME 类型的字符串。</p><blockquote><p><code>MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型</code>。<br>是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，<code>浏览器会自动使用指定应用程序来打开</code>。<br>多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># charset 为该文件的字符编码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件, MIME类型: text/x-c, 字符编码: utf-8</span></span><br><span class="line">$ file occi.cpp -i</span><br><span class="line">occi.cpp: text/x-c; charset=utf-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩文件, MIME类型: application/gzip, 字符编码: binary</span></span><br><span class="line">$ file fcgi.tar.gz -i</span><br><span class="line">fcgi.tar.gz: application/gzip; charset=binary</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文本文件, MIME类型: text/plain, 字符编码: utf-8</span></span><br><span class="line">$ file english.txt -i</span><br><span class="line">english.txt: text/plain; charset=utf-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># html文件, MIME类型: text/html, 字符编码: us-ascii</span></span><br><span class="line">$ file demo.html -i</span><br><span class="line">demo.html: text/html; charset=us-ascii</span><br></pre></td></tr></table></figure><hr><h3 id="3-1-4-设置输出分隔符"><a href="#3-1-4-设置输出分隔符" class="headerlink" title="3.1.4 设置输出分隔符"></a>3.1.4 设置输出分隔符</h3><p>在 file 命令中，文件名和后边的属性信息默认使用冒号（:）分隔，我们可以通过 <code>-F</code> 参数修改分隔符<br>分隔符可以是单字符也可以是一个字符串，如果分隔符是字符串需要将这个参数值写到引号中（单&#x2F;双引号都可以）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认格式输出</span></span><br><span class="line">$ file english.txt </span><br><span class="line">english.txt: UTF-8 Unicode text, with very long lines, with CRLF line terminators</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改分隔符为字符串 “==&gt;&quot;</span></span><br><span class="line">$ file english.txt -F <span class="string">&quot;==&gt;&quot;</span></span><br><span class="line">english.txt==&gt; UTF-8 Unicode text, with very long lines, with CRLF line terminators</span><br><span class="line"></span><br><span class="line">$ file english.txt -F <span class="string">&#x27;==&gt;&#x27;</span></span><br><span class="line">english.txt==&gt; UTF-8 Unicode text, with very long lines, with CRLF line terminators</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改分隔符为单字符 &#x27;=&#x27;</span></span><br><span class="line">$ file english.txt -F = </span><br><span class="line">english.txt= UTF-8 Unicode text, with very long lines, with CRLF line terminators</span><br></pre></td></tr></table></figure><hr><h3 id="3-1-5-查看软连接文件"><a href="#3-1-5-查看软连接文件" class="headerlink" title="3.1.5 查看软连接文件"></a>3.1.5 查看软连接文件</h3><blockquote><p>软连接文件是一个特殊格式的文件, 查看这种格式的文件可以得到两种结果: 第一种是软连接文件本身的属性信息,另一种是链接文件指向的那个文件的属性信息。<br>直接通过 <code>file</code> 查看文件属性得到的是链接文件指向的文件的信息<br>如果添加参数 <code>-L</code>得到的链接文件自身的属性信息。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 ls 查看链接文件属性信息</span></span><br><span class="line">$ ll link.lnk </span><br><span class="line">lrwxrwxrwx 1 root root 24 Jan 25 17:27 link.lnk -&gt; /root/luffy/onepiece.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用file直接查看链接文件信息: 得到的是链接文件指向的那个文件的名字</span></span><br><span class="line">$ file link.lnk </span><br><span class="line">link.lnk: symbolic <span class="built_in">link</span> to `/root/luffy/onepiece.txt<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 使用 file 查看链接文件自身属性信息, 添加参数 -L</span></span><br><span class="line"><span class="string">$ file link.lnk -L</span></span><br><span class="line"><span class="string">link.lnk: UTF-8 Unicode text</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-2-stat-命令"><a href="#3-2-stat-命令" class="headerlink" title="3.2 stat 命令"></a>3.2 stat 命令</h2><p>stat命令显示文件或目录的详细属性信息包括文件系统状态，比ls命令输出的信息更详细。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法格式</span></span><br><span class="line"><span class="comment"># 参数在命令中的位置没有限制</span></span><br><span class="line">$ <span class="built_in">stat</span> [参数] 文件或者目录名</span><br></pre></td></tr></table></figure><p>关于这个命令的可选参数如下表:</p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>-f</td><td>不显示文件本身的信息，显示文件所在文件系统的信息</td></tr><tr><td>-L</td><td>查看软链接文件关联的文件的属性信息</td></tr><tr><td>-c</td><td>查看文件某个单个的属性信息</td></tr><tr><td>-t</td><td>简洁模式，只显示摘要信息，不显示属性描述</td></tr></tbody></table><hr><h3 id="3-2-1-显示所有属性"><a href="#3-2-1-显示所有属性" class="headerlink" title="3.2.1 显示所有属性"></a>3.2.1 显示所有属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">stat</span> english.txt </span><br><span class="line">  File: <span class="string">&#x27;english.txt&#x27;</span></span><br><span class="line">  Size: 129567          Blocks: 256        IO Block: 4096   regular file</span><br><span class="line">Device: 801h/2049d      Inode: 526273      Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: ( 1001/   robin)   Gid: ( 1001/   robin)</span><br><span class="line">Access: 2021-01-31 00:00:36.791490304 +0800</span><br><span class="line">Modify: 2021-01-31 00:00:36.791490304 +0800</span><br><span class="line">Change: 2021-01-31 00:00:36.791490304 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><p>在输出的信息中我们可以看到很多属性,</p><ul><li><code>File</code>: 文件名</li><li><code>Size</code>: 文件大小, 单位是字节</li><li><code>Blocks</code>: 文件使用的数据块总数</li><li><code>IO Block</code>：IO块大小</li><li><code>regular file</code>：文件的实际类型，文件类型不同，该关键字也会变化</li><li><code>Device</code>：设备编号</li><li><code>Inode</code>：Inode号，操作系统用inode编号来识别不同的文件，找到文件数据所在的block，读出数据。</li><li><code>Links</code>：硬链接计数</li><li><code>Access</code>：文件所有者+所属组用户+其他人对文件的访问权限</li><li><code>Uid</code>： 文件所有者名字和所有者ID</li><li><code>Gid</code>：文件所有数组名字已经组ID</li><li><code>Access Time</code>：表示文件的访问时间。当文件内容被访问时，这个时间被更新</li><li><code>Modify Time</code>：表示文件内容的修改时间，当文件的数据内容被修改时，这个时间被更新</li><li><code>Change Time</code>：表示文件的状态时间，当文件的状态被修改时，这个时间被更新，例如：文件的硬链接链接数，大小，权限，Blocks数等。</li><li><code>Birth</code>: 文件生成的日期</li></ul><hr><h3 id="3-2-2-只显示系统信息"><a href="#3-2-2-只显示系统信息" class="headerlink" title="3.2.2 只显示系统信息"></a>3.2.2 只显示系统信息</h3><p>给 stat 命令添加 <code>-f</code>参数将只显示文件在文件系统中的相关属性信息, 文件自身属性不显示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">stat</span> luffy/ -f</span><br><span class="line">  File: <span class="string">&quot;luffy/&quot;</span></span><br><span class="line">    ID: 47d795d8889d00d3 Namelen: 255     Type: ext2/ext3</span><br><span class="line">Block size: 4096       Fundamental block size: 4096</span><br><span class="line">Blocks: Total: 10288179   Free: 8991208    Available: 8546752</span><br><span class="line">Inodes: Total: 2621440    Free: 2515927</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-3-软连接文件"><a href="#3-2-3-软连接文件" class="headerlink" title="3.2.3 软连接文件"></a>3.2.3 软连接文件</h3><p>使用 stat 查看软链接类型的文件, 默认显示的是这个软链接文件的属性信息, 添加参数 <code>-L</code> 就可以查看这个软连接文件关联的文件的属性信息了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看软件文件属性 -&gt; 使用 ls -l</span></span><br><span class="line"><span class="built_in">ls</span> -l link.lnk </span><br><span class="line">lrwxrwxrwx 1 root root 24 Jan 25 17:27 link.lnk -&gt; /root/luffy/onepiece.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 stat 查看软连接文件属性信息</span></span><br><span class="line">$ <span class="built_in">stat</span> link.lnk </span><br><span class="line">  File: ‘link.lnk’ -&gt; ‘/root/luffy/onepiece.txt’</span><br><span class="line">  Size: 24              Blocks: 0          IO Block: 4096   symbolic <span class="built_in">link</span></span><br><span class="line">Device: fd01h/64769d    Inode: 393832      Links: 1</span><br><span class="line">Access: (0777/lrwxrwxrwx)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2021-01-30 23:46:29.922760178 +0800</span><br><span class="line">Modify: 2021-01-25 17:27:12.057386837 +0800</span><br><span class="line">Change: 2021-01-25 17:27:12.057386837 +0800</span><br><span class="line"> Birth: -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 stat 查看软连接文件关联的文件的属性信息</span></span><br><span class="line">$ <span class="built_in">stat</span> link.lnk -L</span><br><span class="line">  File: ‘link.lnk’</span><br><span class="line">  Size: 3700              Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 660353      Links: 2</span><br><span class="line">Access: (0444/-r--r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2021-01-30 23:46:53.696723182 +0800</span><br><span class="line">Modify: 2021-01-25 17:54:47.000000000 +0800</span><br><span class="line">Change: 2021-01-26 11:57:00.587658977 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-4-简洁输出"><a href="#3-2-4-简洁输出" class="headerlink" title="3.2.4 简洁输出"></a>3.2.4 简洁输出</h3><p>使用 stat 进行简洁信息输出的可读性不是太好, 所有的属性描述都别忽略了, 如果只想得到属性值, 可以给该命令添加<code>-t</code>参数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">stat</span> luffy/ -t</span><br><span class="line">luffy/ 4096 8 41fd 1001 1001 801 662325 8 0 0 1611659086 1580893020 1580893020 0 4096</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-5-单个属性输出"><a href="#3-2-5-单个属性输出" class="headerlink" title="3.2.5 单个属性输出"></a>3.2.5 单个属性输出</h3><p>如果每次只想通过 stat 命令得到某一个文件属性, 可以给名添加 <code>-c</code> 参数。<br>不同的文件属性分别对应一些定义好的特殊符号，想得到哪个属性值，将其指定到参数 <code>-c</code> 后边即可。</p><p>属性对应的字符如下表：</p><table><thead><tr><th>格式化字符</th><th>功能</th></tr></thead><tbody><tr><td>%a</td><td>文件的八进制访问权限（#和0是输出标准）</td></tr><tr><td>%A</td><td>人类可读形式的文件访问权限（rwx）</td></tr><tr><td>%b</td><td>已分配的块数量</td></tr><tr><td>%B</td><td>报告的每个块的大小(以字节为单位)</td></tr><tr><td>%C</td><td>SELinux 安全上下文字符串</td></tr><tr><td>%d</td><td>设备编号 （十进制）</td></tr><tr><td>%D</td><td>设备编号 （十六进制）</td></tr><tr><td>%F</td><td>文件类型</td></tr><tr><td>%g</td><td>文件所属组组ID</td></tr><tr><td>%G</td><td>文件所属组名字</td></tr><tr><td>%h</td><td>用连接计数</td></tr><tr><td>%i</td><td>inode编号</td></tr><tr><td>%m</td><td>挂载点</td></tr><tr><td>%n</td><td>文件名</td></tr><tr><td>%N</td><td>用引号括起来的文件名，并且会显示软连接文件引用的文件路径</td></tr><tr><td>%o</td><td>最佳I&#x2F;O传输大小提示</td></tr><tr><td>%s</td><td>文件总大小, 单位为字节</td></tr><tr><td>%t</td><td>十六进制的主要设备类型，用于字符&#x2F;块设备特殊文件</td></tr><tr><td>%T</td><td>十六进制的次要设备类型，用于字符&#x2F;块设备特殊文件</td></tr><tr><td>%u</td><td>文件所有者ID</td></tr><tr><td>%U</td><td>文件所有者名字</td></tr><tr><td>%w</td><td>文件生成的日期 ，人类可识别的时间字符串 – 获取不到信息不显示</td></tr><tr><td>%W</td><td>文件生成的日期 ，自纪元以来的秒数 （参考 %X ）– 获取不到信息不显示</td></tr><tr><td>%x</td><td>最后访问文件的时间, 人类可识别的时间字符串</td></tr><tr><td>%X</td><td>最后访问文件的时间, 自纪元以来的秒数（从1970.1.1开始到最后一次文件访问的总秒数）</td></tr><tr><td>%y</td><td>最后修改文件内容的时间, 人类可识别的时间字符串</td></tr><tr><td>%Y</td><td>最后修改文件内容的时间, 自纪元以来的秒数（参考 %X ）</td></tr><tr><td>%z</td><td>最后修改文件状态的时间, 人类可识别的时间字符串</td></tr><tr><td>%Z</td><td>最后修改文件状态的时间, 自纪元以来的秒数（参考 %X ）</td></tr></tbody></table><p>仔细阅读上表可以知道：文件的每一个属性都有一个或者多个与之对应的格式化字符，这样就可以精确定位所需要的属性信息了，举几个例子作为参考：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">stat</span> occi.cpp -c %a</span><br><span class="line">644</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">stat</span> occi.cpp -c %A           </span><br><span class="line">-rw-r--r--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 ls -l 验证权限</span></span><br><span class="line">$ ll occi.cpp </span><br><span class="line">-rw-r--r-- 1 robin robin 1406 Jan 31 00:00 occi.cpp<span class="comment"># 0664</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">stat</span> link.lnk -c %N</span><br><span class="line"><span class="string">&#x27;link.lnk&#x27;</span> -&gt; <span class="string">&#x27;/home/robin/english.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">stat</span> link.lnk -c %y</span><br><span class="line">2021-01-31 10:48:52.317846411 +0800</span><br></pre></td></tr></table></figure><hr><h2 id="3-3-stat-lstat-函数"><a href="#3-3-stat-lstat-函数" class="headerlink" title="3.3 stat&#x2F;lstat 函数"></a>3.3 stat&#x2F;lstat 函数</h2><p><code>stat</code>&#x2F;<code>lstat</code> 函数的功能和 stat 命令的功能是一样的, 只不过是应用场景不同。<br>这两个函数的区别在于处理软链接文件的方式上</p><ul><li><code>lstat()</code>: 得到的是软连接文件本身的属性信息</li><li><code>stat()</code>: 得到的是软链接文件关联的文件的属性信息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>pathname: 文件名, 要获取这个文件的属性信息</li><li>buf: 传出参数, 文件的信息被写入到了这块内存中</li></ul></li><li>返回值: 函数调用成功返回 0，调用失败返回 -1</li></ul><p>这个函数的第二个参数是一个结构体类型, 这个结构体相对复杂, 通过这个结构体可以存储得到的文件的所有属性信息, 结构体原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>          st_dev;        <span class="comment">// 文件的设备编号</span></span><br><span class="line">    <span class="type">ino_t</span>           st_ino;        <span class="comment">// inode节点</span></span><br><span class="line">    <span class="type">mode_t</span>      st_mode;      <span class="comment">// 文件的类型和存取的权限, 16位整形数  -&gt; 常用</span></span><br><span class="line">    <span class="type">nlink_t</span>        st_nlink;     <span class="comment">// 连到该文件的硬连接数目，刚建立的文件值为1</span></span><br><span class="line">    <span class="type">uid_t</span>           st_uid;       <span class="comment">// 用户ID</span></span><br><span class="line">    <span class="type">gid_t</span>           st_gid;       <span class="comment">// 组ID</span></span><br><span class="line">    <span class="type">dev_t</span>          st_rdev;      <span class="comment">// (设备类型)若此文件为设备文件，则为其设备编号</span></span><br><span class="line">    <span class="type">off_t</span>            st_size;      <span class="comment">// 文件字节数(文件大小)   --&gt; 常用</span></span><br><span class="line">    <span class="type">blksize_t</span>     st_blksize;   <span class="comment">// 块大小(文件系统的I/O 缓冲区大小)</span></span><br><span class="line">    <span class="type">blkcnt_t</span>      st_blocks;    <span class="comment">// block的块数</span></span><br><span class="line">    <span class="type">time_t</span>         st_atime;     <span class="comment">// 最后一次访问时间</span></span><br><span class="line">    <span class="type">time_t</span>         st_mtime;     <span class="comment">// 最后一次修改时间(文件内容)</span></span><br><span class="line">    <span class="type">time_t</span>         st_ctime;     <span class="comment">// 最后一次改变时间(指属性)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="3-3-1-获取文件大小"><a href="#3-3-1-获取文件大小" class="headerlink" title="3.3.1 获取文件大小"></a>3.3.1 获取文件大小</h3><p>下面调用 <code>stat()</code> 函数, 以代码的方式演示一下如何得到某个文件的大小:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 定义结构体, 存储文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">myst</span>;</span></span><br><span class="line">    <span class="comment">// 2. 获取文件属性 english.txt</span></span><br><span class="line">    <span class="type">int</span> ret = stat(<span class="string">&quot;./english.txt&quot;</span>, &amp;myst);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件大小: %d\n&quot;</span>, (<span class="type">int</span>)myst.st_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-3-2-获取文件类型"><a href="#3-3-2-获取文件类型" class="headerlink" title="3.3.2 获取文件类型"></a>3.3.2 获取文件类型</h3><p>文件的类型信息存储在 <code>struct stat</code> 结构体的<code>st_mode</code>成员中, 它是一个 <code>mode_t</code> 类型, 本质上是一个16位的整数。<br>Linux API中为我们提供了相关的宏函数，通过对应的宏函数可以直接判断出文件是不是某种类型，这些信息都可以通过 man 文档（<code>man 2 stat</code>）查询到。</p><p>相关的宏函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型是存储在结构体的这个成员中: mode_t  st_mode;  </span></span><br><span class="line"><span class="comment">// 这些宏函数中的  m 对应的就是结构体成员  st_mode</span></span><br><span class="line"><span class="comment">// 宏函数返回值: 是对应的类型返回-&gt; 1, 不是对应类型返回0</span></span><br><span class="line"></span><br><span class="line">S_ISREG(m)  is it a regular file?  </span><br><span class="line">- 普通文件</span><br><span class="line">S_ISDIR(m)  directory?</span><br><span class="line">- 目录</span><br><span class="line">S_ISCHR(m)  character device?</span><br><span class="line">- 字符设备</span><br><span class="line">S_ISBLK(m)  block device?</span><br><span class="line">- 块设备</span><br><span class="line">S_ISFIFO(m) FIFO (named pipe)?</span><br><span class="line">- 管道</span><br><span class="line">S_ISLNK(m)  symbolic link?  (Not in POSIX<span class="number">.1</span><span class="number">-1996.</span>)</span><br><span class="line">- 软连接</span><br><span class="line">S_ISSOCK(m) socket?  (Not in POSIX<span class="number">.1</span><span class="number">-1996.</span>)</span><br><span class="line">    - 本地套接字文件</span><br></pre></td></tr></table></figure><p>在程序中通过宏函数判断文件类型, 实例代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 定义结构体, 存储文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">myst</span>;</span></span><br><span class="line">    <span class="comment">// 2. 获取文件属性 english.txt</span></span><br><span class="line">    <span class="type">int</span> ret = stat(<span class="string">&quot;./hello&quot;</span>, &amp;myst);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断文件类型</span></span><br><span class="line">    <span class="keyword">if</span>(S_ISREG(myst.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这个文件是一个普通文件...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(myst.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这个文件是一个目录...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S_ISLNK(myst.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这个文件是一个软连接文件...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-3-2-获取文件权限"><a href="#3-3-2-获取文件权限" class="headerlink" title="3.3.2 获取文件权限"></a>3.3.2 获取文件权限</h3><p>用户对文件的操作权限也存储在 <code>struct stat</code> 结构体的<code>st_mode</code>成员中, 在这个16位的整数中不同用户的权限存储位置如下图<br>如果想知道有没有相关权限可以通过按位与(&amp;)操作将这个标志位值取出判断即可。</p><p><img src="/img/8.30.png" alt="在这里插入图片描述"></p><p>Linux 中为我们提供了用于不同用户不同权限判定使用的宏，具体信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">关于变量 st_mode: </span><br><span class="line">- st_mode -- 16位整数</span><br><span class="line">○ 0-2 bit -- 其他人权限</span><br><span class="line">- S_IROTH    00004  读权限   100</span><br><span class="line">- S_IWOTH    00002  写权限   010</span><br><span class="line">- S_IXOTH    00001  执行权限  001</span><br><span class="line">- S_IRWXO    00007  掩码, 过滤 st_mode中除其他人权限以外的信息</span><br><span class="line">○ 3-5 bit -- 所属组权限</span><br><span class="line">- S_IRGRP    00040  读权限</span><br><span class="line">- S_IWGRP    00020  写权限</span><br><span class="line">- S_IXGRP    00010  执行权限</span><br><span class="line">- S_IRWXG    00070  掩码, 过滤 st_mode中除所属组权限以外的信息</span><br><span class="line">○ 6-8 bit -- 文件所有者权限</span><br><span class="line">- S_IRUSR    00400    读权限</span><br><span class="line">- S_IWUSR    00200    写权限</span><br><span class="line">- S_IXUSR    00100    执行权限</span><br><span class="line">- S_IRWXU    00700    掩码, 过滤 st_mode中除文件所有者权限以外的信息</span><br><span class="line">○ 12-15 bit -- 文件类型</span><br><span class="line">- S_IFSOCK   0140000 套接字</span><br><span class="line">- S_IFLNK    0120000 符号链接（软链接）</span><br><span class="line">- S_IFREG    0100000 普通文件</span><br><span class="line">- S_IFBLK    0060000 块设备</span><br><span class="line">- S_IFDIR    0040000 目录</span><br><span class="line">- S_IFCHR    0020000 字符设备</span><br><span class="line">- S_IFIFO    0010000 管道</span><br><span class="line">- S_IFMT     0170000 掩码,过滤 st_mode中除文件类型以外的信息</span><br><span class="line"></span><br><span class="line"><span class="comment">############### 按位与操作举例 ###############</span></span><br><span class="line">    1111 1111 1111 1011   <span class="comment"># st_mode</span></span><br><span class="line">    0000 0000 0000 0100   <span class="comment"># S_IROTH</span></span><br><span class="line">&amp;</span><br><span class="line">----------------------------------------</span><br><span class="line">    0000 0000 0000 0000   <span class="comment"># 没有任何权限</span></span><br></pre></td></tr></table></figure><p>通过仔细阅读上边提供的宏信息, 我们可以知道处理使用它们得到用户对文件的操作权限, 还可以用于判断文件的类型（判断文件类型的第二种方式），具体操作方式可以参考如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 定义结构体, 存储文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">myst</span>;</span></span><br><span class="line">    <span class="comment">// 2. 获取文件属性 english.txt</span></span><br><span class="line">    <span class="type">int</span> ret = stat(<span class="string">&quot;./hello&quot;</span>, &amp;myst);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件大小: %d\n&quot;</span>, (<span class="type">int</span>)myst.st_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断文件类型</span></span><br><span class="line">    <span class="keyword">if</span>(S_ISREG(myst.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这个文件是一个普通文件...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(myst.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这个文件是一个目录...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S_ISLNK(myst.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这个文件是一个软连接文件...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所有者对文件的操作权限</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件所有者对文件的操作权限: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(myst.st_mode &amp; S_IRUSR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(myst.st_mode &amp; S_IWUSR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(myst.st_mode &amp; S_IXUSR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-4-练习"><a href="#3-4-练习" class="headerlink" title="3.4 练习"></a>3.4 练习</h2><p>掌握了如何通过 stat &#x2F; lstat 函数获取文件相关属性之后,<br>我们就可以使用这两个函数来模拟执行命令 ls -l 的效果，具体代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out filename\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = stat(argv[<span class="number">1</span>], &amp;st);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储文件类型和访问权限</span></span><br><span class="line">    <span class="type">char</span> perms[<span class="number">11</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 判断文件类型</span></span><br><span class="line">    <span class="keyword">switch</span>(st.st_mode &amp; S_IFMT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> S_IFLNK:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFDIR:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFREG:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFCHR:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFSOCK:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFIFO:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断文件的访问权限</span></span><br><span class="line">    <span class="comment">// 文件所有者</span></span><br><span class="line">    perms[<span class="number">1</span>] = (st.st_mode &amp; S_IRUSR) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">2</span>] = (st.st_mode &amp; S_IWUSR) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">3</span>] = (st.st_mode &amp; S_IXUSR) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="comment">// 文件所属组</span></span><br><span class="line">    perms[<span class="number">4</span>] = (st.st_mode &amp; S_IRGRP) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">5</span>] = (st.st_mode &amp; S_IWGRP) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">6</span>] = (st.st_mode &amp; S_IXGRP) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="comment">// 其他人</span></span><br><span class="line">    perms[<span class="number">7</span>] = (st.st_mode &amp; S_IROTH) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">8</span>] = (st.st_mode &amp; S_IWOTH) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">9</span>] = (st.st_mode &amp; S_IXOTH) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 硬链接计数</span></span><br><span class="line">    <span class="type">int</span> linkNum = st.st_nlink;</span><br><span class="line">    <span class="comment">// 文件所有者</span></span><br><span class="line">    <span class="type">char</span>* fileUser = getpwuid(st.st_uid)-&gt;pw_name;</span><br><span class="line">    <span class="comment">// 文件所属组</span></span><br><span class="line">    <span class="type">char</span>* fileGrp = getgrgid(st.st_gid)-&gt;gr_name;</span><br><span class="line">    <span class="comment">// 文件大小</span></span><br><span class="line">    <span class="type">int</span> fileSize = (<span class="type">int</span>)st.st_size;</span><br><span class="line">    <span class="comment">// 修改时间</span></span><br><span class="line">    <span class="type">char</span>* time = ctime(&amp;st.st_mtime);</span><br><span class="line">    <span class="type">char</span> mtime[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strncpy</span>(mtime, time, <span class="built_in">strlen</span>(time)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s  %d  %s  %s  %d  %s  %s&quot;</span>, </span><br><span class="line">            perms, linkNum, fileUser, fileGrp, fileSize, mtime, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="4-文件描述符复制和重定向"><a href="#4-文件描述符复制和重定向" class="headerlink" title="4. 文件描述符复制和重定向"></a>4. 文件描述符复制和重定向</h1><p>在Linux中只要调用<code>open()</code>函数就可以给被操作的文件分配一个文件描述符<br>除了使用这种方式Linux系统还提供了一些其他的 API 用于文件描述符的分配<br>相关函数有三个：<code>dup</code>, <code>dup2</code>, <code>fcntl</code>。</p><h2 id="4-1-dup"><a href="#4-1-dup" class="headerlink" title="4.1 dup"></a>4.1 dup</h2><h3 id="4-1-1-函数详解"><a href="#4-1-1-函数详解" class="headerlink" title="4.1.1 函数详解"></a>4.1.1 函数详解</h3><p>dup函数的作用是复制文件描述符，这样就有多个文件描述符可以指向同一个文件了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数： oldfd 是要被复制的文件描述符</p></li><li><p>返回值：函数调用成功返回被复制出的文件描述符，调用失败返回 -1</p></li></ul><p>下图展示了 dup()函数具体行为, 这样不管使用 fd1还是使用fd2都可以对磁盘文件A进行操作了。<br><img src="/img/8.31.png" alt="在这里插入图片描述"></p><blockquote><p>被复制出的新文件描述符是独立于旧的文件描述符的，二者没有连带关系。也就是说当旧的文件描述符被关闭了，复制出的新文件描述符还是可以继续使用的。</p></blockquote><hr><h3 id="4-1-2-示例代码"><a href="#4-1-2-示例代码" class="headerlink" title="4.1.2 示例代码"></a>4.1.2 示例代码</h3><p>下面的代码中演示了通过<code>dup()</code>函数进行文件描述符复制<br>并验证了复制之后两个新、旧文件描述符是独立的，二者没有连带关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个新的磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./mytest.txt&quot;</span>, O_RDWR|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d\n&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pt = <span class="string">&quot;你好, 世界......&quot;</span>;</span><br><span class="line">    <span class="comment">// 写成功之后, 文件指针在文件尾部</span></span><br><span class="line">    write(fd, pt, <span class="built_in">strlen</span>(pt));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制这个文件描述符 fd</span></span><br><span class="line">    <span class="type">int</span> newfd = dup(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;newfd: %d\n&quot;</span>, newfd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭旧的文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用新的文件描述符继续写文件</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ppt = <span class="string">&quot;((((((((((((((((你要相信光！！！))))))))))))))))&quot;</span>;</span><br><span class="line">    write(newfd, ppt, <span class="built_in">strlen</span>(ppt));</span><br><span class="line">    close(newfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-2-dup2"><a href="#4-2-dup2" class="headerlink" title="4.2 dup2"></a>4.2 dup2</h2><h3 id="4-2-1-函数详解"><a href="#4-2-1-函数详解" class="headerlink" title="4.2.1 函数详解"></a>4.2.1 函数详解</h3><p>dup2() 函数是 dup() 函数的加强版，基于dup2() 既可以进行文件描述符的复制, 也可以进行文件描述符的重定向。<br>文件描述符重定向就是改变已经分配的文件描述符关联的磁盘文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 1. 文件描述符的复制, 和dup是一样的</span></span><br><span class="line"><span class="comment">// 2. 能够重定向文件描述符</span></span><br><span class="line"><span class="comment">// - 重定向: 改变文件描述符和文件的关联关系, 和新的文件建立关联关系, 和原来的文件断开关联关系</span></span><br><span class="line"><span class="comment">//1. 首先通过open()打开文件 a.txt , 得到文件描述符 fd</span></span><br><span class="line"><span class="comment">//2. 然后通过open()打开文件 b.txt , 得到文件描述符 fd1</span></span><br><span class="line"><span class="comment">//3. 将fd1从定向 到fd上:</span></span><br><span class="line"><span class="comment">//fd1和b.txt这磁盘文件断开关联, 关联到a.txt上, 以后fd和fd1都对用同一个磁盘文件 a.txt</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数: oldfd和&#96;&#96;newfd&#96; 都是文件描述符</li><li>返回值: 函数调用成功返回新的文件描述符, 调用失败返回 -1</li></ul><p>关于这个函数的两个参数虽然都是文件描述符，但是在使用过程中又对应了不同的场景，具体如下：</p><ul><li><p>场景1:<br>假设参数 <code>oldfd</code> 对应磁盘文件 <code>a.txt</code>, <code>newfd</code>对应磁盘文件<code>b.txt</code>。<br>在这种情况下调用dup2函数, 是给<code>newfd做了重定向</code>，newfd 和文件 b.txt <code>断开关联, 相当于关闭了这个文件, 同时 newfd 指向了磁盘上的a.txt文件</code>，最终 oldfd 和 newfd 都指向了磁盘文件 a.txt。<br><img src="/img/8.32.png" alt="在这里插入图片描述"></p></li><li><p>场景2:<br>假设参数 oldfd 对应磁盘文件 a.txt, newfd不对应任何的磁盘文件（newfd 必须是一个大于等于0的整数）。<br>在这种情况下调用dup2函数, 在这种情况下会进行文件描述符的<code>复制</code>，newfd 指向了磁盘上的a.txt文件，最终 oldfd 和 newfd 都指向了磁盘文件 a.txt。<br><img src="/img/8.33.png" alt="在这里插入图片描述"></p></li><li><p>场景3:<br>假设参数 oldfd 和newfd两个文件描述符对应的是同一个磁盘文件 a.txt,<br>在这种情况下调用dup2函数, 什么也不会发生。<br><img src="/img/8.34.png" alt="在这里插入图片描述"></p></li></ul><hr><h3 id="4-2-2-示例代码"><a href="#4-2-2-示例代码" class="headerlink" title="4.2.2 示例代码"></a>4.2.2 示例代码</h3><blockquote><p>给dup2() 的第二个参数指定一个空闲的没被占用的文件描述符就可以进行文件描述符的复制了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用dup2 复制文件描述符</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个新的磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./111.txt&quot;</span>, O_RDWR|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d\n&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pt = <span class="string">&quot;你好, 世界......&quot;</span>;</span><br><span class="line">    <span class="comment">// 写成功之后, 文件指针在文件尾部</span></span><br><span class="line">    write(fd, pt, <span class="built_in">strlen</span>(pt));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. fd1没有对应任何的磁盘文件, fd1 必须要 &gt;=0</span></span><br><span class="line">    <span class="type">int</span> fd1 = <span class="number">1023</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fd -&gt; 111.txt</span></span><br><span class="line">    <span class="comment">// 文件描述符复制, fd1指向fd对应的文件 111.txt</span></span><br><span class="line">    dup2(fd, fd1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭旧的文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用fd1写文件</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ppt = <span class="string">&quot;(((((((((((((((你要相信光！！！)))))))))))))))))&quot;</span>;</span><br><span class="line">    write(fd1, ppt, <span class="built_in">strlen</span>(ppt));</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将两个有效的文件描述符分别传递给 dup2()函数，就可以实现文件描述符的重定向了。<br>将第二个参数的文件描述符重定向到参数1文件描述符指向的文件上。 </p></blockquote><p>如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用dup2 文件描述符重定向</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个新的磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./111.txt&quot;</span>, O_RDWR|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d\n&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pt = <span class="string">&quot;你好, 世界......&quot;</span>;</span><br><span class="line">    <span class="comment">// 写成功之后, 文件指针在文件尾部</span></span><br><span class="line">    write(fd, pt, <span class="built_in">strlen</span>(pt));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建第二个磁盘文件 222.txt</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;./222.txt&quot;</span>, O_RDWR|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open1&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fd -&gt; 111.txt, fd1-&gt;222.txt</span></span><br><span class="line">    <span class="comment">// 从定向, 将fd1指向fd对应的文件 111.txt</span></span><br><span class="line">    dup2(fd, fd1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭旧的文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用fd1写文件</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ppt = <span class="string">&quot;(((((((((((((((你要相信光！！！)))))))))))))))&quot;</span>;</span><br><span class="line">    write(fd1, ppt, <span class="built_in">strlen</span>(ppt));</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-3-fcntl"><a href="#4-3-fcntl" class="headerlink" title="4.3  fcntl"></a>4.3  fcntl</h2><h3 id="4-3-1-函数详解"><a href="#4-3-1-函数详解" class="headerlink" title="4.3.1 函数详解"></a>4.3.1 函数详解</h3><p>fcntl() 是一个变参函数, 并且是多功能函数<br>在这里只介绍如何通过这个函数实现<code>文件描述符的复制</code>和<code>获取/设置已打开的文件属性</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span><span class="comment">// 主要的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>fd: 要操作的文件描述符</li><li>cmd: 通过该参数控制函数要实现什么功能</li></ul></li><li>返回值：函数调用失败返回 -1，调用成功，返回正确的值：<ul><li>参数 cmd &#x3D; F_DUPFD：返回新的被分配的文件描述符</li><li>参数 cmd &#x3D; F_GETFL：返回文件的flag属性信息</li></ul></li></ul><p>fcntl() 函数的 cmd 可使用的参数列表:</p><table><thead><tr><th>参数 cmd 的取值</th><th>功能描述</th></tr></thead><tbody><tr><td>F_DUPFD</td><td>复制一个已经存在的文件描述符</td></tr><tr><td>F_GETFL</td><td>获取文件的状态标志</td></tr><tr><td>F_SETFL</td><td>设置文件的状态标志</td></tr></tbody></table><p>文件的状态标志指的是在使用 open() 函数打开文件的时候指定的 flags 属性, 也就是第二个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>下表中列出了一些常用的文件状态标志：</p><table><thead><tr><th>文件状态标志</th><th>说明</th></tr></thead><tbody><tr><td>O_RDONLY</td><td>只读打开</td></tr><tr><td>O_WRONLY</td><td>只写打开</td></tr><tr><td>O_RDWR</td><td>读、写打开</td></tr><tr><td>O_APPEND</td><td>追加写</td></tr><tr><td>O_NONBLOCK</td><td>非阻塞模式</td></tr><tr><td>O_SYNC</td><td>等待写完成（数据和属性）</td></tr><tr><td>O_ASYNC</td><td>异步I&#x2F;O</td></tr><tr><td>O_RSYNC</td><td>同步读和写</td></tr></tbody></table><hr><h3 id="4-3-2-复制文件描述符"><a href="#4-3-2-复制文件描述符" class="headerlink" title="4.3.2 复制文件描述符"></a>4.3.2 复制文件描述符</h3><p>使用 fcntl() 函数进行文件描述符复制, 第二个参数 <code>cmd</code> 需要指定为 <code>F_DUPFD</code>（这是个变参函数其他参数不需要指定）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> newfd = fcntl(fd, F_DUPFD);</span><br></pre></td></tr></table></figure><p>使用 fcntl() 复制文件描述符, 函数返回值为新分配的文件描述符，示例代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个新的磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./mytest.txt&quot;</span>, O_RDWR|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d\n&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pt = <span class="string">&quot;你好, 世界......&quot;</span>;</span><br><span class="line">    <span class="comment">// 写成功之后, 文件指针在文件尾部</span></span><br><span class="line">    write(fd, pt, <span class="built_in">strlen</span>(pt));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制这个文件描述符 fd</span></span><br><span class="line">    <span class="type">int</span> newfd = fcntl(fd, F_DUPFD);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;newfd: %d\n&quot;</span>, newfd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭旧的文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用新的文件描述符继续写文件</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ppt = <span class="string">&quot;((((((((((((((((((((((骚年，你要相信光！！！))))))))))))))))))))))&quot;</span>;</span><br><span class="line">    write(newfd, ppt, <span class="built_in">strlen</span>(ppt));</span><br><span class="line">    close(newfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-3-3-设置文件状态标志"><a href="#4-3-3-设置文件状态标志" class="headerlink" title="4.3.3 设置文件状态标志"></a>4.3.3 设置文件状态标志</h3><p>通过 <code>open()</code>函数打开文件之后, 文件的flag属性就已经被确定下来了<br>如果想在打开状态下修改这些属性，可以使用 <code>fcntl()</code>函数实现<br><code>注意</code>: 不是所有的flag 属性都能被动态修改, 只能修改如下状态标志: <code>O_APPEND</code>, <code>O_NONBLOCK</code>, <code>O_SYNC</code>, <code>O_ASYNC</code>, <code>O_RSYNC</code>等。</p><p>得到已打开的文件的状态标志，需要将 cmd 设置为 F_GETFL，得到的信息在函数的返回值中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag = fcntl(fd, F_GETFL);</span><br></pre></td></tr></table></figure><p>设置已打开的文件的状态标志，需要将 cmd 设置为 F_SETFL，新的flag需要通过第三个参数传递给 fcntl() 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到文件的flag属性</span></span><br><span class="line"><span class="type">int</span> flag = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="comment">// 添加新的flag 标志</span></span><br><span class="line">flag = flag | O_APPEND;</span><br><span class="line"><span class="comment">// 将更新后的falg设置给文件</span></span><br><span class="line">fcntl(fd, F_SETFL, flag);</span><br></pre></td></tr></table></figure><blockquote><p>举例： 通过<code>fcntl()</code>函数获取&#x2F;设置已打开的文件属性，先来描述一下场景：<br>如果要往当前文件中写数据, 打开一个新文件, 文件的写指针在文件头部，数据默认也是写到文件开头，如果不想将数据写到文件头部,可以给文件追加一个O_APPEND属性。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写实例程序, 给文件描述符追加 O_APPEND</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开一个已经存在的磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./111.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d\n&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不想将数据写到文件头部, 可以给文件描述符追加一个O_APPEND属性</span></span><br><span class="line">    <span class="comment">// 通过fcntl获取文件描述符的 flag属性</span></span><br><span class="line">    <span class="type">int</span> flag = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="comment">// 给得到的flag追加 O_APPEND属性</span></span><br><span class="line">    flag = flag | O_APPEND; <span class="comment">// flag |= O_APPEND;</span></span><br><span class="line">    <span class="comment">// 重新将flag属性设置给文件描述符</span></span><br><span class="line">    fcntl(fd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用fd写文件, 添加的数据应该写到文件尾部</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ppp = <span class="string">&quot;((((((((((((((你要相信光！！！)))))))))))))))&quot;</span>;</span><br><span class="line">    write(fd, ppp, <span class="built_in">strlen</span>(ppp));</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="5-目录遍历"><a href="#5-目录遍历" class="headerlink" title="5. 目录遍历"></a>5. 目录遍历</h1><p>Linux的目录是一个树状结构，了解数据结构的都明白，遍历一棵树最简单的方式是递归。<br>掌握递归的使用方法，遍历树状目录也不难。</p><p>Linux给我们提供了相关的目录遍历的函数，分别为：<code>opendir()</code>, <code>readdir()</code>, <code>closedir()</code>。<br>目录的操作方式和标准C库提供的文件操作步骤是类似的。</p><h2 id="5-1-目录三剑客"><a href="#5-1-目录三剑客" class="headerlink" title="5.1 目录三剑客"></a>5.1 目录三剑客</h2><h3 id="5-1-1-opendir"><a href="#5-1-1-opendir" class="headerlink" title="5.1.1 opendir"></a>5.1.1 opendir</h3><p>在目录操作之前必须要先通过 <code>opendir()</code> 函数打开这个目录</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="comment">// 打开目录</span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数: name -&gt; 要打开的目录的名字</li><li>返回值: DIR*, 结构体类型指针。打开成功返回目录的实例，打开失败返回 NULL</li></ul><hr><h3 id="5-1-2-readdir"><a href="#5-1-2-readdir" class="headerlink" title="5.1.2 readdir"></a>5.1.2 readdir</h3><p>目录打开之后，就可以通过 <code>readdir()</code> 函数遍历目录中的文件信息了。<br>每调用一次这个函数就可以得到目录中的一个文件信息<br>当目录中的文件信息被全部遍历完毕会得到一个空对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">// 读目录</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：dirp -&gt; opendir() 函数的返回值</li><li>返回值：函数调用成功，返回读到的文件的信息,<br>目录文件被读完了或者函数调用失败返回 NULL</li></ul><p>函数返回值 <code>struct dirent</code> 结构体原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    <span class="type">ino_t</span>          d_ino;       <span class="comment">/* 文件对应的inode编号, 定位文件存储在磁盘的那个数据块上 */</span></span><br><span class="line">    <span class="type">off_t</span>          d_off;       <span class="comment">/* 文件在当前目录中的偏移量 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> d_reclen;    <span class="comment">/* 文件名字的实际长度 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  d_type;      <span class="comment">/* 文件的类型, linux中有7中文件类型 */</span></span><br><span class="line">    <span class="type">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* 文件的名字 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于结构体中的文件类型<code>d_type</code>，可使用的宏值如下：</p><ul><li><code>DT_BLK</code>：块设备文件</li><li><code>DT_CHR</code>：字符设备文件</li><li><code>DT_DIR</code>：目录文件</li><li><code>DT_FIFO</code> ：管道文件</li><li><code>DT_LNK</code>：软连接文件</li><li><code>DT_REG</code>：普通文件</li><li><code>DT_SOCK</code>：本地套接字文件</li><li><code>DT_UNKNOWN</code>：无法识别的文件类型</li></ul><p>那么，如何通过 readdir() 函数遍历某一个目录中的文件呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开目录</span></span><br><span class="line">DIR* dir = opendir(<span class="string">&quot;/home/test&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">ptr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 遍历目录</span></span><br><span class="line"><span class="keyword">while</span>( (ptr=readdir(dir)) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-1-3-closedir"><a href="#5-1-3-closedir" class="headerlink" title="5.1.3 closedir"></a>5.1.3 closedir</h3><p>目录操作完毕之后, 需要通过 <code>closedir()</code>关闭通过<code>opendir()</code>得到的实例，释放资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">// 关闭目录, 参数是 opendir() 的返回值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：dirp-&gt; opendir() 函数的返回值</li><li>返回值: 目录关闭成功返回0, 失败返回 -1</li></ul><hr><h2 id="5-2-遍历目录"><a href="#5-2-遍历目录" class="headerlink" title="5.2 遍历目录"></a>5.2 遍历目录</h2><h3 id="5-2-1-遍历单层目录"><a href="#5-2-1-遍历单层目录" class="headerlink" title="5.2.1 遍历单层目录"></a>5.2.1 遍历单层目录</h3><p>如果只遍历单层目录是不需要递归的，按照上边介绍的函数的使用方法，依次继续调用即可。<br>假设我们需要得到某个指定目录下 mp3 格式文件的个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filenum.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开目录</span></span><br><span class="line">    DIR* dir = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 遍历当前目录中的文件</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">ptr</span> =</span> readdir(dir);</span><br><span class="line">        <span class="keyword">if</span>(ptr == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;目录读完了...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读到了一个文件</span></span><br><span class="line">        <span class="comment">// 判断文件类型</span></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_REG)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span>* p = <span class="built_in">strstr</span>(ptr-&gt;d_name, <span class="string">&quot;.mp3&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(p != <span class="literal">NULL</span> &amp;&amp; *(p+<span class="number">4</span>) == <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//+4 判断是否真的是后缀</span></span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;file %d: %s\n&quot;</span>, count, ptr-&gt;d_name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s目录中mp3文件的个数: %d\n&quot;</span>, argv[<span class="number">1</span>], count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭目录</span></span><br><span class="line">    closedir(dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译名执行程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ gcc filenum.c</span><br><span class="line"><span class="comment"># 读当前目录中mp3文件个数</span></span><br><span class="line">$ ./a.out .</span><br><span class="line">file 1: 1.mp3</span><br><span class="line">目录读完了...</span><br><span class="line">.目录中mp3文件的个数: 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读 ./sub 目录中mp3文件个数</span></span><br><span class="line">$ ./a.out ./sub/</span><br><span class="line">file 1: 3.mp3</span><br><span class="line">file 2: 1.mp3</span><br><span class="line">file 3: 5.mp3</span><br><span class="line">file 4: 4.mp3</span><br><span class="line">file 5: 2.mp3</span><br><span class="line">目录读完了...</span><br><span class="line">./sub/目录中mp3文件的个数: 5</span><br></pre></td></tr></table></figure><hr><h3 id="5-2-2-遍历多层目录"><a href="#5-2-2-遍历多层目录" class="headerlink" title="5.2.2 遍历多层目录"></a>5.2.2 遍历多层目录</h3><p>Linux 的目录是树状结构，遍历每层目录的方式是一样的，也就是说最简单的遍历方式是递归。<br>程序的重点就是确定递归结束的条件：遍历的文件如果不是目录类型就结束递归。</p><p>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filenum.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getMp3Num</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开目录</span></span><br><span class="line">    DIR* dir = opendir(path);</span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 遍历当前目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">ptr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((ptr = readdir(dir)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是目录 . .. 跳过不处理</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(ptr-&gt;d_name, <span class="string">&quot;.&quot;</span>)==<span class="number">0</span> ||</span><br><span class="line">           <span class="built_in">strcmp</span>(ptr-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 假设读到的当前文件是目录</span></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_DIR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 目录</span></span><br><span class="line">            <span class="type">char</span> newPath[<span class="number">1024</span>];</span><br><span class="line">            <span class="built_in">sprintf</span>(newPath, <span class="string">&quot;%s/%s&quot;</span>, path, ptr-&gt;d_name);</span><br><span class="line">            <span class="comment">// 读当前目录的子目录</span></span><br><span class="line">            count += getMp3Num(newPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ptr-&gt;d_type == DT_REG)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 普通文件</span></span><br><span class="line">            <span class="type">char</span>* p = <span class="built_in">strstr</span>(ptr-&gt;d_name, <span class="string">&quot;.mp3&quot;</span>);</span><br><span class="line">            <span class="comment">// 判断文件后缀是不是 .mp3</span></span><br><span class="line">            <span class="keyword">if</span>(p != <span class="literal">NULL</span> &amp;&amp; *(p+<span class="number">4</span>) == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s/%s\n&quot;</span>, path, ptr-&gt;d_name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ./a.out path</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out path\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = getMp3Num(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s 目录中mp3文件个数: %d\n&quot;</span>, argv[<span class="number">1</span>], num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ gcc filenum.c</span><br><span class="line"><span class="comment"># 查看 abc 目录中mp3 文件个数</span></span><br><span class="line">$ ./a.out abc</span><br><span class="line">abc/sub/3.mp3</span><br><span class="line">abc/sub/1.mp3</span><br><span class="line">abc/sub/5.mp3</span><br><span class="line">abc/sub/4.mp3</span><br><span class="line">abc/sub/2.mp3</span><br><span class="line">abc/sub/music/test2.mp3</span><br><span class="line">abc/sub/music/test3.mp3</span><br><span class="line">abc/sub/music/test1.mp3</span><br><span class="line">abc/hello.mp3</span><br><span class="line">abc 目录中mp3文件个数: 9</span><br></pre></td></tr></table></figure><hr><h2 id="5-3-scandir函数"><a href="#5-3-scandir函数" class="headerlink" title="5.3 scandir函数"></a>5.3 scandir函数</h2><p>也可使用<code>scandir()</code>函数进行目录的遍历（只遍历指定目录，不进入到子目录中进行递归遍历）<br>它的参数并不简单，涉及到三级指针和回调函数的使用。</p><p>&#x2F;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ 函数原型</span><br><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">scandir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dirp, <span class="keyword">struct</span> dirent ***namelist,</span></span><br><span class="line"><span class="params">              <span class="type">int</span> (*filter)(<span class="type">const</span> <span class="keyword">struct</span> dirent *),</span></span><br><span class="line"><span class="params">              <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="keyword">struct</span> dirent **, <span class="type">const</span> <span class="keyword">struct</span> dirent **))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">alphasort</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dirent **a, <span class="type">const</span> <span class="keyword">struct</span> dirent **b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">versionsort</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dirent **a, <span class="type">const</span> <span class="keyword">struct</span> dirent **b)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>dirp: 需要遍历的目录的名字</li><li>namelist: 三级指针, 传出参数, 需要在指向的地址中存储遍历目录得到的所有文件的信息<ul><li><code>在函数内部会给这个指针指向的地址分配内存，要注意在程序中释放内存</code></li></ul></li><li>filter: 函数指针, 指针指向的函数就是回调函数, 需要在自定义函数中指定如果过滤目录中的文件<ul><li>如果不对目录中的文件进行过滤, 该函数指针指定为NULL即可</li><li>如果自己指定过滤函数, 满足条件要返回1, 否则返回 0</li></ul></li><li>compar: 函数指针, 对过滤得到的文件进行排序, 可以使用提供的两种排序方式:<ul><li>alphasort: 根据文件名进行排序</li><li>versionsort: 根据版本进行排序</li></ul></li></ul></li><li>返回值: 函数执行成功返回找到的匹配成功的文件的个数，如果失败返回-1。</li></ul><hr><h3 id="5-3-1-文件过滤"><a href="#5-3-1-文件过滤" class="headerlink" title="5.3.1 文件过滤"></a>5.3.1 文件过滤</h3><p><code>scandir()</code> 可以让使用者自定义文件的过滤方式, 然后将过滤函数的地址传递给 <code>scandir()</code> 的第三个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 过滤函数的原型</span></span><br><span class="line"><span class="comment">// 函数的参数就是遍历的目录中的子文件对应的结构体</span></span><br><span class="line"><span class="type">int</span> (*filter)(<span class="type">const</span> <span class="keyword">struct</span> dirent *);</span><br></pre></td></tr></table></figure><blockquote><p>基于这个函数指针定义的函数就可以称之为回调函数,<br>这个函数不是由我们调用, 而是通过 <code>scandir()</code> 调用，因此这个函数的实参也是由 <code>scandir()</code> 函数提供的，作为回调函数的编写人员，只需搞清这个参数的含义是什么，然后在函数体中直接使用即可。</p></blockquote><p>假设判断目录中某一个文件是否为Mp3格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isMp3</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dirent *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr-&gt;d_type == DT_REG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* p = <span class="built_in">strstr</span>(ptr-&gt;d_name, <span class="string">&quot;.mp3&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">NULL</span> &amp;&amp; *(p+<span class="number">4</span>) == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-3-2-遍历目录"><a href="#5-3-2-遍历目录" class="headerlink" title="5.3.2 遍历目录"></a>5.3.2 遍历目录</h3><p>了解了 <code>scandir()</code> 函数的使用后,<br>写一个程序, 搜索指定目录下的 mp3格式文件个数和文件名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件过滤函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isMp3</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dirent *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr-&gt;d_type == DT_REG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* p = <span class="built_in">strstr</span>(ptr-&gt;d_name, <span class="string">&quot;.mp3&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">NULL</span> &amp;&amp; *(p+<span class="number">4</span>) == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out path\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> **<span class="title">namelist</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> num = scandir(argv[<span class="number">1</span>], &amp;namelist, isMp3, alphasort);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file %d: %s\n&quot;</span>, i, namelist[i]-&gt;d_name);</span><br><span class="line">        <span class="built_in">free</span>(namelist[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(namelist);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再解析一下 scandir() 的第二个参数，传递的是一个二级指针的地址:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> **<span class="title">namelist</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> num = scandir(argv[<span class="number">1</span>], &amp;namelist, isMp3, alphasort);</span><br></pre></td></tr></table></figure><p>那么在这个 <code>namelist</code> 中存储的什么类型的数据呢？<br>也就是 <code>struct dirent **namelist</code> 指向的什么类型的数据?</p><p>答案: 指向的是一个指针数组 <code>struct dirent *namelist[]</code></p><ul><li>数组元素的个数就是遍历的目录中的文件个数</li><li>数组的每个元素都是指针类型: <code>struct dirent *</code><br>指针指向的地址是由 <code>scandir()</code> 函数分配的, 因此在使用完毕之后需要释放内存</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-文件描述符&quot;&gt;&lt;a href=&quot;#1-文件描述符&quot; class=&quot;headerlink&quot; title=&quot;1. 文件描述符&quot;&gt;&lt;/a&gt;1. 文件描述符&lt;/h1&gt;&lt;h2 id=&quot;1-1-虚拟地址空间&quot;&gt;&lt;a href=&quot;#1-1-虚拟地址空间&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="文件IO" scheme="http://example.com/tags/%E6%96%87%E4%BB%B6IO/"/>
    
  </entry>
  
  <entry>
    <title>线程同步异步和原子变量</title>
    <link href="http://example.com/2023/10/22/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/"/>
    <id>http://example.com/2023/10/22/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/</id>
    <published>2023-10-22T01:53:07.000Z</published>
    <updated>2023-10-22T02:27:08.859Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-线程的使用"><a href="#1-线程的使用" class="headerlink" title="1.线程的使用"></a>1.线程的使用</h1><blockquote><p>C++11中增加了线程以及线程相关的类，支持了并发编程，提高了编写的多线程程序的可移植性<br>C++11中提供的线程类叫做<code>std::thread</code>，基于这个类创建一个新的线程非常的简单，只需要提供线程函数或者函数对象即可，并且可以同时指定线程函数的参数。<br>以下了解以下常用API</p></blockquote><h2 id="1-1-函数构造"><a href="#1-1-函数构造" class="headerlink" title="1.1 函数构造"></a>1.1 函数构造</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">thread</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">thread</span>(thread&amp;&amp; other) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Function, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span><span class="params">( Function&amp;&amp; f, Args&amp;&amp;... args )</span></span>;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="built_in">thread</span>( <span class="type">const</span> thread&amp; ) = <span class="keyword">delete</span>;。</span><br></pre></td></tr></table></figure><ul><li><p>构造函数①：默认构造函数，构造一个线程对象，在这个线程中不执行任何处理动作</p></li><li><p>构造函数②：移动构造函数，将 other 的线程所有权转移给新的thread 对象。<br>之后 other 不再表示执行线程。</p></li><li><p>构造函数③：创建线程对象，并在该线程中执行函数f中的业务逻辑，args是要传递给函数f的参数</p><ul><li><p>任务函数f的可选类型有很多，具体如下：</p><ul><li>普通函数，类成员函数，匿名函数，仿函数（这些都是可调用对象类型）</li><li>可以是可调用对象包装器类型，也可是使用绑定器绑定之后得到的类型（仿函数）</li></ul></li></ul></li><li><p>构造函数④：使用&#x3D;delete显示删除拷贝构造, 不允许线程对象之间的拷贝</p></li></ul><hr><h2 id="1-2-公共成员函数"><a href="#1-2-公共成员函数" class="headerlink" title="1.2 公共成员函数"></a>1.2 公共成员函数</h2><h3 id="1-2-1-get-id"><a href="#1-2-1-get-id" class="headerlink" title="1.2.1 get_id()"></a>1.2.1 get_id()</h3><blockquote><p>应用程序启动之后默认只有一个线程，这个线程一般称之为<code>主线程或父线程</code>，通过线程类创建出的线程一般称之为<code>子线程</code>，每个被创建出的线程实例都对应一个线程ID，这个ID是唯一的，可以通过这个ID来区分和识别各个已经存在的线程实例，这个获取线程ID的函数叫做<code>get_id()</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line">std::<span class="function">thread::id <span class="title">get_id</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> num, string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;num: &quot;</span> </span><br><span class="line">             &lt;&lt; num &lt;&lt; <span class="string">&quot;, str: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程的线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func, <span class="number">520</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t 的线程ID: &quot;</span> &lt;&lt; t.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t1的线程ID: &quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>thread t(func, 520, “i love you”);</p><ul><li>线程类的构造函数③是一个<code>变参函数</code>，因此无需担心线程任务函数的参数个数问题</li><li>任务函数func()一般返回值为void，因为子线程在调用这个函数的时候<code>不会处理其返回值</code></li></ul></li><li><p>thread t1(func1);</p><ul><li>子线程对象t1中的任务函数func1()，没有参数，因此在线程构造函数中就无需指定了</li></ul></li><li><p>通过线程对象调用<code>get_id()</code>就可以知道这个子线程的线程ID:<code>t.get_id()</code>,<code>t1.get_id()</code></p></li></ul><blockquote><p>但在上面的示例程序中有bug<br>有可能子线程中的任务还没有执行完毕，主线程就结束了,最后也得不到我们想要的结果。</p></blockquote><p>当启动了一个线程（创建了一个thread对象）之后，在这个线程结束的时候（std::terminate()），我们如何去回收线程所使用的资源呢？thread库给我们两种选择：</p><ul><li><code>加入式（join()）</code></li><li><code>分离式（detach()）</code></li></ul><p>我们必须要在线程对象销毁之前在二者之间作出选择，否则程序运行期间会有bug产生。</p><hr><h3 id="1-2-2-join"><a href="#1-2-2-join" class="headerlink" title="1.2.2 join()"></a>1.2.2 join()</h3><blockquote><p>join()字面意思是连接一个线程，意味着主动地等待线程的终止（线程阻塞）。<br>在某个线程中通过子线程对象调用join()函数，调用这个函数的线程被阻塞<br>子线程对象中的任务函数会继续执行，当任务执行完毕之后join()会清理当前子线程中的相关资源然后返回，同时，调用该函数的线程解除阻塞继续向下执行。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>解决后如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程的线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func, <span class="number">520</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t 的线程ID: &quot;</span> &lt;&lt; t.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t1的线程ID: &quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为了更好的理解join()的使用，再举一个例子，场景如下：<br>程序中一共有三个线程，其中两个子线程负责分段处理函数，完毕之后，由主线程对这个文件进行下一步处理</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(download1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(download2)</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞主线程，等待所有子线程任务执行完毕再继续向下执行</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-2-3-detach"><a href="#2-2-3-detach" class="headerlink" title="2.2.3 detach()"></a>2.2.3 detach()</h3><blockquote><p><code>detach()</code>函数的作用是进行线程分离，分离主线程和创建出的子线程。<br>在线程分离之后，主线程退出也会一并销毁创建出的所有子线程<br>在主线程退出之前，它可以脱离主线程继续独立的运行<br>任务执行完毕之后，这个子线程会自动释放自己占用的系统资源。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>线程分离函数没有参数也没有返回值，只需要在线程成功之后，通过线程对象调用该函数即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程的线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func, <span class="number">520</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t 的线程ID: &quot;</span> &lt;&lt; t.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t1的线程ID: &quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="comment">// 让主线程休眠, 等待子线程执行完毕</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>注意</code>：detach()不会阻塞线程<br>子线程和主线程分离之后，<code>主线程就不能再对这个子线程做任何控制</code><br>比如：通过join()阻塞主线程等待子线程中的任务执行完毕，或调用get_id()获取子线程的线程ID。</p><hr><h3 id="2-2-5-joinable"><a href="#2-2-5-joinable" class="headerlink" title="2.2.5 joinable()"></a>2.2.5 joinable()</h3><p><code>joinable()</code>函数用于判断主线程和子线程是否处理关联（连接）状态</p><ul><li>返回值为<code>true</code>：主线程和子线程之间有关联（连接）关系</li><li>返回值为<code>false</code>：主线程和子线程之间没有关联（连接）关系</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread t;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before starting, joinable: &quot;</span> &lt;&lt; t.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t = <span class="built_in">thread</span>(foo);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after starting, joinable: &quot;</span> &lt;&lt; t.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after joining, joinable: &quot;</span> &lt;&lt; t.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(foo)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after starting, joinable: &quot;</span> &lt;&lt; t1.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after detaching, joinable: &quot;</span> &lt;&lt; t1.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">before starting, joinable: <span class="number">0</span></span><br><span class="line">after starting, joinable: <span class="number">1</span></span><br><span class="line">after joining, joinable: <span class="number">0</span></span><br><span class="line">after starting, joinable: <span class="number">1</span></span><br><span class="line">after detaching, joinable: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>给予结果我们可以得到如下结论</p><ul><li>在创建的子线程对象的时候，如果没有指定任务函数，那么子线程不会启动，主线程和这个子线程也不会进行连接</li><li>在创建的子线程对象的时候，如果指定了任务函数，子线程启动并执行任务，主线程和这个子线程自动连接成功</li><li>子线程调用了detach()函数之后，父子线程分离，同时二者的连接断开，调用joinable()返回false</li><li>在子线程调用了join()函数，子线程中的任务函数继续执行，直到任务处理完毕<br>这时join()会清理（回收）当前子线程的相关资源，所以这个子线程和主线程的连接也就断开了，因此，调用join()之后再调用joinable()会返回false。</li></ul><hr><h3 id="2-2-6-operator"><a href="#2-2-6-operator" class="headerlink" title="2.2.6 operator&#x3D;"></a>2.2.6 operator&#x3D;</h3><blockquote><p>线程中的资源是不能被复制的，因此通过&#x3D;操作符进行赋值操作最终并不会得到两个完全相同的对象。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// move (1)</span></span><br><span class="line">thread&amp; <span class="keyword">operator</span>= (thread&amp;&amp; other) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// copy [deleted] (2)</span></span><br><span class="line">thread&amp; <span class="keyword">operator</span>= (<span class="type">const</span> other&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><p>通过以上&#x3D;操作符的重载声明可以得知：</p><ul><li>如果other是一个右值，会进行资源所有权的转移</li><li>如果other不是右值，禁止拷贝，该函数被显示删除（&#x3D;delete），不可用</li></ul><hr><h2 id="1-3-静态函数"><a href="#1-3-静态函数" class="headerlink" title="1.3 静态函数"></a>1.3 静态函数</h2><blockquote><p>thread线程类还提供了一个静态方法，用于获取当前计算机的CPU核心数<br> 根据这个结果可以在程序中创建出数量相等的线程<br><code>每个线程独占一个CPU核心，这些线程就不用分时复用CPU时间片，此时程序的并发效率是最高的。</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="title">hardware_concurrency</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;CPU number: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-4-call-once"><a href="#1-4-call-once" class="headerlink" title="1.4 call_once"></a>1.4 call_once</h2><blockquote><p>在某些特定情况下，某些函数只能在多线程环境下调用一次，比如：要初始化某个对象，而这个对象只能被初始化一次<br>可以使用<code>std::call_once()</code>来保证函数在多线程环境下只能被调用一次。使用call_once()的时候，需要一个<code>once_flag</code>作为call_once()的传入参数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="comment">// 定义于头文件 &lt;mutex&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Callable, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_once</span><span class="params">( std::once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>flag</code>：once_flag类型的对象，要保证这个对象能够被多个线程同时访问到</li><li><code>f</code>：回调函数，可以传递一个有名函数地址，也可以指定一个匿名函数</li><li><code>args</code>：作为实参传递给回调函数</li></ul><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">once_flag g_flag;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_once</span><span class="params">(<span class="type">int</span> a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">(<span class="type">int</span> age, string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">call_once</span>(g_flag, do_once, <span class="number">19</span>, <span class="string">&quot;luffy&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;do_something() function num = &quot;</span> &lt;&lt; num++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(do_something, <span class="number">20</span>, <span class="string">&quot;ace&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(do_something, <span class="number">20</span>, <span class="string">&quot;sabo&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(do_something, <span class="number">19</span>, <span class="string">&quot;luffy&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name: luffy, age: <span class="number">19</span></span><br><span class="line"><span class="built_in">do_something</span>() function num = <span class="number">1</span></span><br><span class="line"><span class="built_in">do_something</span>() function num = <span class="number">2</span></span><br><span class="line"><span class="built_in">do_something</span>() function num = <span class="number">3</span></span><br></pre></td></tr></table></figure><hr><h1 id="2-this-thread-命名空间"><a href="#2-this-thread-命名空间" class="headerlink" title="2. this_thread 命名空间"></a>2. this_thread 命名空间</h1><blockquote><p>在C++11中不仅添加了线程类，还添加了一个关于线程的命名空间<code>std::this_thread</code><br>在这个命名空间中提供了四个公共的成员函数</p></blockquote><h2 id="2-1-get-id"><a href="#2-1-get-id" class="headerlink" title="2.1 get_id()"></a>2.1 get_id()</h2><blockquote><p>所说曾相识,但还是有所不同<br>调用命名空间std::this_thread中的get_id()方法可以得到当前线程的线程ID</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="function">thread::id <span class="title">get_id</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-2-sleep-for"><a href="#2-2-sleep-for" class="headerlink" title="2.2 sleep_for()"></a>2.2 sleep_for()</h2><blockquote><p>线程被创建后有这五种状态：创建态，就绪态，运行态，阻塞态(挂起态)，退出态(终止态)<br>关于状态之间的转换和进程是一样的</p></blockquote><p>线程和进程的执行有很多相似之处，在计算机中启动的多个线程都需要占用CPU资源<br>但是CPU的个数是有限的并且每个CPU在同一时间点不能同时处理多个任务。<br>为了实现并发处理，多个线程都是分时复用CPU时间片，快速的交替处理各个线程中的任务。<br>因此多个线程之间需要争抢CPU时间片，抢到了就执行，抢不到则无法执行<br>因为默认所有的线程优先级都相同，内核也会从中调度，不会出现某个线程永远抢不到CPU时间片的情况。</p><p>命名空间<code>this_thread</code>中提供了一个休眠函数<code>sleep_for()</code><br>调用这个函数的线程会马上从<code>运行态变成阻塞态</code>并在这种状态下<code>休眠</code>一定的时长<br>因为阻塞态的线程已经让出了CPU资源，代码也不会被执行，所以线程休眠过程中对CPU来说没有任何负担。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sleep_for</span> <span class="params">(<span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time)</span></span>;</span><br></pre></td></tr></table></figure><p>参数需要指定一个休眠时长，是一个时间段</p><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在func()函数的for循环中使用了<code>this_thread::sleep_for(chrono::seconds(1));</code>之后，每循环一次程序都会阻塞1秒钟，也就是说每隔1秒才会进行一次输出。<br><code>注意</code>：程序休眠完成之后，会从阻塞态重新变成就绪态，就绪态的线程需要再次争抢CPU时间片，抢到之后才会变成运行态，这时候程序才会继续向下运行。</p><hr><h2 id="2-3-sleep-until"><a href="#2-3-sleep-until" class="headerlink" title="2.3 sleep_until()"></a>2.3 sleep_until()</h2><blockquote><p>命名空间<code>this_thread</code>中提供了另一个休眠函数<code>sleep_until()</code>，和<code>sleep_for()</code>不同的是它的参数类型不一样<br><code>sleep_until()</code>：指定线程阻塞到某一个指定的时间点<code>time_point</code>类型，之后解除阻塞<br><code>sleep_for()</code>：指定线程阻塞一定的时间长度<code>duration</code> 类型，之后解除阻塞</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sleep_until</span> <span class="params">(<span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)</span></span>;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取当前系统时间点</span></span><br><span class="line">        <span class="keyword">auto</span> now = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="comment">// 时间间隔为2s</span></span><br><span class="line">        <span class="function">chrono::seconds <span class="title">sec</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 当前时间点之后休眠两秒</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_until</span>(now + sec);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sleep_until()</code>和<code>sleep_for()</code>函数的功能是一样的<br>只不过前者是基于时间点去阻塞线程<br>后者是基于时间段去阻塞线程</p><hr><h2 id="2-4-yield"><a href="#2-4-yield" class="headerlink" title="2.4  yield()"></a>2.4  yield()</h2><blockquote><p>命名空间<code>this_thread</code>中提供了一个非常绅士的函数<code>yield()</code><br>在线程中调用这个函数后，处于运行态的线程会主动让出自己已经抢到的CPU时间片，最终变为<code>就绪态</code><br>这样其它的线程就有更大的概率能够抢到CPU时间片了。<br><code>注意</code>:线程调用了yield()之后,这个线程会马上参与到下一轮CPU的抢夺中</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yield</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的程序中，执行func()中的for循环会占用大量的时间<br>极端情况下，如果当前线程占用CPU资源不释放就会导致其他线程中的任务无法被处理，或者该线程每次都能抢到CPU时间片，导致其他线程中的任务没有机会被执行。<br>解决方案就是每执行一次循环，让该线程主动放弃CPU资源，重新和其他线程再次抢夺CPU时间片，如果其他线程抢到了CPU时间片就可以执行相应的任务了。</p><p>结论：<code>std::this_thread::yield()</code> 的目的是避免一个线程长时间占用CPU资源，从而导致多线程处理性能下降</p><hr><h1 id="3-线程同步之互斥锁"><a href="#3-线程同步之互斥锁" class="headerlink" title="3. 线程同步之互斥锁"></a>3. 线程同步之互斥锁</h1><p>进行多线程编程，如果多个线程需要对同一块内存进行操作，比如：<code>同时读</code>、<code>同时写</code>、<code>同时读写</code>对于后两种情况来说，如果不做任何的人为干涉就会出现各种各样的错误数据。<br>这是因为线程在运行的时候需要先得到CPU时间片，时间片用完之后需要放弃已获得的CPU资源，就这样线程频繁地在就绪态和运行态之间切换，更复杂一点还可以在就绪态、运行态、挂起态之间切换，这样就会导致线程的执行顺序并不是有序的，而是随机的混乱的</p><p>解决多线程数据混乱的方案就是进行线程同步，最常用的就是互斥锁，在C++11中一共提供了四种互斥锁：</p><ul><li><code>std::mutex</code>：独占的互斥锁，不能递归使用</li><li><code>std::timed_mutex</code>：带超时的独占互斥锁，不能递归使用</li><li><code>std::recursive_mutex</code>：递归互斥锁，不带超时功能</li><li><code>std::recursive_timed_mutex</code>：带超时的递归互斥锁</li></ul><p>互斥锁在有些资料中也被称之为<code>互斥量</code>，二者是一个东西。</p><h2 id="3-1-std-mutex"><a href="#3-1-std-mutex" class="headerlink" title="3.1 std:mutex"></a>3.1 std:mutex</h2><p>不论是在C还是C++中，进行线程同步的处理流程基本上是一致的，C++的mutex类提供了相关的API函数：</p><h3 id="3-1-1-成员函数"><a href="#3-1-1-成员函数" class="headerlink" title="3.1.1 成员函数"></a>3.1.1 成员函数</h3><p><code>lock()</code>函数用于给临界区加锁，并且只能有一个线程获得锁的所有权，它有阻塞线程的作用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>独占互斥锁对象有两种状态：锁定和未锁定。<br>如果互斥锁是打开的，调用lock()函数的线程会得到互斥锁的所有权，并将其上锁，其它线程再调用该函数的时候由于得不到互斥锁的所有权，就会被lock()函数阻塞。<br>当拥有互斥锁所有权的线程将互斥锁解锁，此时被lock()阻塞的线程解除阻塞，抢到互斥锁所有权的线程加锁并继续运行，没抢到互斥锁所有权的线程继续阻塞。</p><p>除了使用<code>lock()</code>还可以使用<code>try_lock()</code>获取互斥锁的所有权并对互斥锁加锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>二者的区别在于try_lock()不会阻塞线程，lock()会阻塞线程：</p><ul><li>如果互斥锁是未锁定状态，得到了互斥锁所有权并加锁成功，函数返回true</li><li>如果互斥锁是锁定状态，无法得到互斥锁所有权加锁失败，函数返回false</li></ul><p>当互斥锁被锁定之后可以通过<code>unlock()</code>进行解锁，但是需要注意的是<code>只有拥有互斥锁所有权的线程也就是对互斥锁上锁的线程才能将其解锁</code>，其它线程是没有权限做这件事情的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>使用互斥锁进行线程同步的大致思路主要分为以下几步：</p><ol><li>找到多个线程操作的共享资源(全局变量、堆内存、类成员变量等),也可以称之为临界资源</li><li>找到和共享资源有关的上下文代码，也就是临界区（下图中的黄色代码部分）</li><li>在临界区的上边调用互斥锁类的<code>lock()</code>方法</li><li>在临界区的下边调用互斥锁的<code>unlock()</code>方法</li></ol><p>线程同步的目的是让多线程按照顺序依次执行临界区代码，这样做线程对共享资源的访问就从并行访问变为了线性访问，访问<code>效率降低</code>，但是保证了数据的正确性。</p><p><img src="/img/8.24.png" alt="在这里插入图片描述"></p><hr><h3 id="3-1-2-线程同步"><a href="#3-1-2-线程同步" class="headerlink" title="3.1.2 线程同步"></a>3.1.2 线程同步</h3><p>让两个线程共同操作一个全局变量，二者交替数数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_num = <span class="number">0</span>;  <span class="comment">// 为 g_num_mutex 所保护</span></span><br><span class="line">mutex g_num_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slow_increment</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        g_num_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        </span><br><span class="line">        ++g_num;</span><br><span class="line">        cout &lt;&lt; id &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; g_num &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        g_num_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(slow_increment, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(slow_increment, <span class="number">1</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例程序中，两个子线程执行的任务的一样的（可以不一样，不同的任务中也可以对共享资源进行读写操作），在任务函数中把与全局变量相关的代码加了锁，两个线程只能顺序访问这部分代码（如果不进行线程同步打印出的数据是混乱且无序的）。</p><p><code>注意</code>:</p><ol><li>在所有线程的任务函数执行完毕之前，互斥锁对象是不能被析构的，一定要在程序中保证这个对象的可用性。</li><li>互斥锁的个数和共享资源的个数相等，也就是说每一个共享资源都应该对应一个互斥锁对象。互斥锁对象的个数和线程的个数没有关系。</li></ol><hr><h2 id="3-2-std-lock-guard"><a href="#3-2-std-lock-guard" class="headerlink" title="3.2 std::lock_guard"></a>3.2 std::lock_guard</h2><blockquote><p>lock_guard是C++11新增的一个模板类，使用这个类，可以<code>简化互斥锁lock()和unlock()</code>的写法，同时也<code>更安全</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义和常用的构造函数原型</span></span><br><span class="line"><span class="comment">// 类的定义，定义于头文件 &lt;mutex&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Mutex</span> &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_guard</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">lock_guard</span><span class="params">( mutex_type&amp; m )</span></span>;</span><br></pre></td></tr></table></figure><p><code>lock_guard</code>在使用上面的构造函数构造对象时，会自动锁定互斥量<br>而在退出作用域后进行析构时就会自动解锁，从而保证了互斥量的正确操作，避免忘记unlock()操作而导致线程死锁。<br><code>lock_guard</code>使用了RAII技术，就是在类构造函数中分配资源，在析构函数中释放资源，保证资源出了作用域就释放。</p><p>使用lock_guard对上面的例子进行修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slow_increment</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用哨兵锁管理互斥锁</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(g_num_mutex)</span></span>;</span><br><span class="line">        ++g_num;</span><br><span class="line">        cout &lt;&lt; id &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; g_num &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过修改发现代码被精简了，而且不用担心因为忘记解锁而造成程序的死锁<br><code>弊端</code>:在上面的示例程序中整个for循环的体都被当做了临界区，多个线程是线性的执行临界区代码的，因此临界区越大程序效率越低</p><hr><h2 id="3-3-std-recursive-mutex"><a href="#3-3-std-recursive-mutex" class="headerlink" title="3.3 std::recursive_mutex"></a>3.3 std::recursive_mutex</h2><blockquote><p>递归互斥锁<code>std::recursive_mutex</code>允许同一线程多次获得互斥锁，可以用来解决同一线程需要多次获取互斥量时死锁的问题</p></blockquote><p>使用独占非递归互斥量会发生<code>死锁</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Calculate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Calculate</span>() : <span class="built_in">m_i</span>(<span class="number">6</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_i *= x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">div</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_i /= x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">both</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="built_in">mul</span>(x);</span><br><span class="line">        <span class="built_in">div</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calculate cal;</span><br><span class="line">    cal.<span class="built_in">both</span>(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序中执行了<code>cal.both(6, 3);</code>调用之后，程序就会发生死锁<br>在<code>both()</code>中已经对互斥锁加锁了，继续调用<code>mult()</code>函数，已经得到互斥锁所有权的线程再次获取这个互斥锁的所有权就会造成死锁（在C++中程序会异常退出，使用C库函数会导致这个互斥锁永远无法被解锁，最终阻塞所有的线程）。<br>要解决这个死锁的问题，一个简单的办法就是使用递归互斥锁<code>std::recursive_mutex</code>，它允许一个线程多次获得互斥锁的所有权。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Calculate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Calculate</span>() : <span class="built_in">m_i</span>(<span class="number">6</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;recursive_mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_i *= x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">div</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;recursive_mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_i /= x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">both</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;recursive_mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="built_in">mul</span>(x);</span><br><span class="line">        <span class="built_in">div</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    recursive_mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calculate cal;</span><br><span class="line">    cal.<span class="built_in">both</span>(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;cal.m_i = &quot;</span> &lt;&lt; cal.m_i &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然递归互斥锁可以解决同一个互斥锁频繁获取互斥锁资源的问题，但是还是建议<code>少用</code></p><ol><li>使用递归互斥锁的场景往往都是可以简化的，使用递归互斥锁很容易放纵复杂逻辑的产生，从而导致bug的产生</li><li>递归互斥锁比非递归互斥锁效率要低一些。</li><li>递归互斥锁虽然允许同一个线程多次获得同一个互斥锁的所有权，但最大次数并未具体说明，一旦超过一定的次数，就会抛出std::system错误。</li></ol><hr><h2 id="3-4-std-timed-mutex"><a href="#3-4-std-timed-mutex" class="headerlink" title="3.4 std::timed_mutex"></a>3.4 std::timed_mutex</h2><blockquote><p><code>std::timed_mutex</code>是超时独占互斥锁，主要是在获取互斥锁资源时增加了超时等待功能，因为不知道获取锁资源需要等待多长时间，为了保证不一直等待下去，设置了一个超时时长，超时后线程就可以解除阻塞去做其他事情了。</p></blockquote><p><code>std::timed_mutex</code>比<code>std::_mutex</code>多了两个成员函数：<code>try_lock_for()</code> <code>try_lock_until()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::timed_mutex比std::_mutex多出的两个成员函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">try_lock_for</span> <span class="params">(<span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">try_lock_until</span> <span class="params">(<span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>try_lock_for</code>函数是当线程获取不到互斥锁资源时，让线程阻塞一定的时间长度</li><li><code>try_lock_until</code>函数是当线程获取不到互斥锁资源时，让线程阻塞到某一个指定的时间点</li><li>关于两个函数的返回值<br>当得到互斥锁的所有权之后，函数会马上解除阻塞，返回true<br>如果阻塞的时长用完或者到达指定的时间点之后，函数也会解除阻塞，返回false</li></ul><p>演示std::timed_mutex的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">timed_mutex g_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">chrono::seconds <span class="title">timeout</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过阻塞一定的时长来争取得到互斥锁所有权</span></span><br><span class="line">        <span class="keyword">if</span> (g_mutex.<span class="built_in">try_lock_for</span>(timeout))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;当前线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() </span><br><span class="line">                &lt;&lt; <span class="string">&quot;, 得到互斥锁所有权...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 模拟处理任务用了一定的时长</span></span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">10</span>));</span><br><span class="line">            <span class="comment">// 互斥锁解锁</span></span><br><span class="line">            g_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;当前线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() </span><br><span class="line">                &lt;&lt; <span class="string">&quot;, 没有得到互斥锁所有权...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 模拟处理其他任务用了一定的时长</span></span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(work)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(work)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码输出的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">当前线程ID: <span class="number">125776</span>, 得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 没有得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 没有得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 没有得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 没有得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 没有得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 没有得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 没有得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 没有得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 没有得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 得到互斥锁所有权...</span><br></pre></td></tr></table></figure><p>在上面的例子中，通过一个while循环不停的去获取超时互斥锁的所有权，如果得不到就阻塞1秒钟，1秒之后如果还是得不到阻塞50毫秒，然后再次继续尝试，直到获得互斥锁的所有权，跳出循环体。</p><p>递归超时互斥锁<code>std::recursive_timed_mutex</code>的使用方式和<code>std::timed_mutex</code>是一样的<br>只不过它可以允许一个线程多次获得互斥锁所有权<br>而<code>std::timed_mutex</code>只允许线程获取一次互斥锁所有权。<br>递归超时互斥锁<code>std::recursive_timed_mutex</code>也拥有和&#96;std::recursive_mutex&#96;&#96;一样的弊端</p><hr><h1 id="4-线程同步之条件变量"><a href="#4-线程同步之条件变量" class="headerlink" title="4.线程同步之条件变量"></a>4.线程同步之条件变量</h1><blockquote><p>条件变量是C++11提供的另外一种用于等待的同步机制，它能阻塞一个或多个线程，直到收到另外一个线程发出的通知或者超时时，才会唤醒当前阻塞的线程。<br>条件变量需要和互斥量配合起来使用</p></blockquote><p>C++11提供了两种条件变量：</p><ul><li><code>condition_variable</code>：需要配合<code>std::unique_lock&lt;std::mutex&gt;</code>进行<code>wait</code>操作，也就是阻塞线程的操作。</li><li><code>condition_variable_any</code>：可以和任意带有<code>lock()</code>、<code>unlock()</code>语义的mutex搭配使用，也就是说有四种：<ol><li><code>std::mutex</code>：独占的非递归互斥锁</li><li><code>std::timed_mutex</code>：带超时的独占非递归互斥锁</li><li><code>std::recursive_mutex</code>：不带超时功能的递归互斥锁</li><li><code>std::recursive_timed_mutex</code>：带超时的递归互斥锁</li></ol></li></ul><p>条件变量通常用于生产者和消费者模型，大致使用过程如下：</p><ol><li>拥有条件变量的线程获取互斥量</li><li>循环检查某个条件，如果条件不满足阻塞当前线程，否则线程继续向下执行<ul><li>产品的数量达到上限，生产者阻塞，否则生产者一直生产</li><li>产品的数量为零，消费者阻塞，否则消费者一直消费</li></ul></li><li>条件满足之后，可以调用<code>notify_one()</code>或<code>notify_all()</code>唤醒一个或所有被阻塞的线程<ul><li>由消费者唤醒被阻塞的生产者，生产者解除阻塞继续生产</li><li>由生产者唤醒被阻塞的消费者，消费者解除阻塞继续消费</li></ul></li></ol><hr><h2 id="4-1-condition-variable"><a href="#4-1-condition-variable" class="headerlink" title="4.1 condition_variable"></a>4.1 condition_variable</h2><h3 id="4-1-1-成员函数"><a href="#4-1-1-成员函数" class="headerlink" title="4.1.1 成员函数"></a>4.1.1 成员函数</h3><blockquote><p>condition_variable的成员函数主要分为两部分：线程等待(阻塞)函数和线程通知(唤醒)函数<br>这些函数被定义于头文件<code>&lt;condition_variable&gt;</code></p></blockquote><ul><li>等待函数</li></ul><p>调用<code>wait()</code>函数的线程会被阻塞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck)</span></span>;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>函数①：调用该函数的线程直接被阻塞</p></li><li><p>函数②：该函数的第二个参数是一个判断条件，是一个返回值为布尔类型的函数</p><ul><li>该参数可以传递一个有名函数的地址，也可以直接指定一个匿名函数</li><li>表达式返回<code>false</code>当前线程被阻塞</li><li>表达式返回<code>true</code>当前线程不会被阻塞，继续向下执行</li></ul></li><li><p>独占的互斥锁对象不能直接传递给<code>wait()</code>函数，需要通过模板类<code>unique_lock</code>进行二次处理，通过得到的对象仍然可以对独占的互斥锁对象做如下操作，使用起来更灵活。</p></li></ul><table><thead><tr><th>公共成员函数</th><th>说明</th></tr></thead><tbody><tr><td>lock</td><td>锁定关联的互斥锁</td></tr><tr><td>try_lock</td><td>尝试锁定关联的互斥锁，若无法锁定，函数直接返回</td></tr><tr><td>try_lock_for</td><td>试图锁定关联的可定时锁定互斥锁，若互斥锁在给定时长中仍不能被锁定，函数返回</td></tr><tr><td>try_lock_until</td><td>试图锁定关联的可定时锁定互斥锁，若互斥锁在给定的时间点后仍不能被锁定，函数返回</td></tr><tr><td>unlock</td><td>将互斥锁解锁</td></tr></tbody></table><ul><li>如果线程被该函数阻塞，这个线程会释放占有的互斥锁的所有权<br>当阻塞解除之后这个线程会重新得到互斥锁的所有权，继续向下执行（这个过程是在函数内部完成的,其目的是为了避免线程的死锁）。</li></ul><hr><blockquote><p><code>wait_for()</code>函数和<code>wait()</code>的功能是一样的，只不过多了一个阻塞时长<br>假设阻塞的线程没有被其他线程唤醒，当阻塞时长用完之后，线程就会自动解除阻塞，继续向下执行。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>&gt;</span><br><span class="line"><span class="function">cv_status <span class="title">wait_for</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_for</span><span class="params">(unique_lock&lt;mutex&gt;&amp; lck,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><hr><blockquote><p><code>wait_until()</code>函数和<code>wait_for()</code>的功能是一样的，它是指定让线程阻塞到某一个时间点，假设阻塞的线程没有被其他线程唤醒，当到达指定的时间点之后，线程就会自动解除阻塞，继续向下执行。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line"><span class="function">cv_status <span class="title">wait_until</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_until</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>通知函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_one</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_all</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><pre><code>notify_one()：唤醒一个被当前条件变量阻塞的线程notify_all()：唤醒全部被当前条件变量阻塞的线程</code></pre><hr><hr><h3 id="4-1-2-生产者和消费者模型"><a href="#4-1-2-生产者和消费者模型" class="headerlink" title="4.1.2 生产者和消费者模型"></a>4.1.2 生产者和消费者模型</h3><blockquote><p>我们可以使用条件变量来实现一个同步队列，这个队列作为生产者线程和消费者线程的共享资源</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SyncQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SyncQueue</span>(<span class="type">int</span> maxSize) : <span class="built_in">m_maxSize</span>(maxSize) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="comment">// 判断任务队列是不是已经满了</span></span><br><span class="line">        <span class="keyword">while</span> (m_queue.<span class="built_in">size</span>() == m_maxSize)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;任务队列已满, 请耐心等待...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 阻塞线程</span></span><br><span class="line">            m_notFull.<span class="built_in">wait</span>(locker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将任务放入到任务队列中</span></span><br><span class="line">        m_queue.<span class="built_in">push_back</span>(x);</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; 被生产&quot;</span> &lt;&lt; endl; </span><br><span class="line">        <span class="comment">// 通知消费者去消费</span></span><br><span class="line">        m_notEmpty.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">take</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (m_queue.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;任务队列已空，请耐心等待。。。&quot;</span> &lt;&lt; endl;</span><br><span class="line">            m_notEmpty.<span class="built_in">wait</span>(locker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从任务队列中取出任务(消费)</span></span><br><span class="line">        <span class="type">int</span> x = m_queue.<span class="built_in">front</span>();</span><br><span class="line">        m_queue.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="comment">// 通知生产者去生产</span></span><br><span class="line">        m_notFull.<span class="built_in">notify_one</span>();</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; 被消费&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>() == m_maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; m_queue;     <span class="comment">// 存储队列数据</span></span><br><span class="line">    mutex m_mutex;         <span class="comment">// 互斥锁</span></span><br><span class="line">    condition_variable m_notEmpty;   <span class="comment">// 不为空的条件变量</span></span><br><span class="line">    condition_variable m_notFull;    <span class="comment">// 没有满的条件变量</span></span><br><span class="line">    <span class="type">int</span> m_maxSize;         <span class="comment">// 任务队列的最大任务个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SyncQueue <span class="title">taskQ</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> produce = <span class="built_in">bind</span>(&amp;SyncQueue::put, &amp;taskQ, placeholders::_1);</span><br><span class="line">    <span class="keyword">auto</span> consume = <span class="built_in">bind</span>(&amp;SyncQueue::take, &amp;taskQ);</span><br><span class="line">    thread t1[<span class="number">3</span>];</span><br><span class="line">    thread t2[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t1[i] = <span class="built_in">thread</span>(produce, i+<span class="number">100</span>);</span><br><span class="line">        t2[i] = <span class="built_in">thread</span>(consume);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t1[i].<span class="built_in">join</span>();</span><br><span class="line">        t2[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件变量<code>condition_variable</code>类的<code>wait()</code>还有一个重载的方法<br>可以接受一个条件，这个条件也可以是一个返回值为布尔类型的函数，条件变量会先检查判断这个条件是否满足<br>如满足条（布尔值为true），则当前线程重新获得互斥锁的所有权，结束阻塞，继续向下执行；<br>如不满足（布尔值为false），当前线程会释放互斥锁（解锁）同时被阻塞，等待被唤醒。</p><blockquote><p>上面示例程序中的put()、take()函数可以做如下修改：</p></blockquote><ul><li>put()函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 根据条件阻塞线程</span></span><br><span class="line">    m_notFull.<span class="built_in">wait</span>(locker, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>() != m_maxSize;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 将任务放入到任务队列中</span></span><br><span class="line">    m_queue.<span class="built_in">push_back</span>(x);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; 被生产&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 通知消费者去消费</span></span><br><span class="line">    m_notEmpty.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>take()函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">take</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    m_notEmpty.<span class="built_in">wait</span>(locker, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">        <span class="keyword">return</span> !m_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 从任务队列中取出任务(消费)</span></span><br><span class="line">    <span class="type">int</span> x = m_queue.<span class="built_in">front</span>();</span><br><span class="line">    m_queue.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="comment">// 通知生产者去生产</span></span><br><span class="line">    m_notFull.<span class="built_in">notify_one</span>();</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; 被消费&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后可以发现，程序变得更加精简了，而且执行效率更高了，因为在这两个函数中的while循环被删掉了，但是最终的效果是一样的，推荐使用这种方式的wait()进行线程的阻塞。</p><hr><h2 id="4-2-condition-variable-any"><a href="#4-2-condition-variable-any" class="headerlink" title="4.2 condition_variable_any"></a>4.2 condition_variable_any</h2><h3 id="4-2-1-成员函数"><a href="#4-2-1-成员函数" class="headerlink" title="4.2.1 成员函数"></a>4.2.1 成员函数</h3><blockquote><p>condition_variable_any的成员函数也是分为两部分：线程等待（阻塞）函数 和线程通知（唤醒）函数，这些函数被定义于头文件 <code>&lt;condition_variable&gt;</code></p></blockquote><ul><li>等待函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>&gt; <span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(Lock&amp; lck)</span></span>;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(Lock&amp; lck, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>函数①：调用该函数的线程直接被阻塞</li><li>函数②：该函数的第二个参数是一个判断条件，是一个返回值为布尔类型的函数<ul><li>该参数可以传递一个有名函数的地址，也可以直接指定一个匿名函数</li><li>表达式返回false当前线程被阻塞，表达式返回true当前线程不会被阻塞，继续向下执行</li></ul></li><li>可以直接传递给wait()函数的互斥锁类型有四种，分别是：<br>std::mutex、std::timed_mutex、std::recursive_mutex、std::recursive_timed_mutex</li><li>如果线程被该函数阻塞，这个线程会释放占有的互斥锁的所有权，当阻塞解除之后这个线程会重新得到互斥锁的所有权，继续向下执行（这个过程是在函数内部完成的，了解这个过程即可，其目的是为了避免线程的死锁）。</li></ul><blockquote><p>wait_for()函数和wait()的功能是一样的，只不过多了一个阻塞时长，假设阻塞的线程没有被其他线程唤醒，当阻塞时长用完之后，线程就会自动解除阻塞，继续向下执行。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>, <span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>&gt;</span><br><span class="line"><span class="function">cv_status <span class="title">wait_for</span> <span class="params">(Lock&amp; lck, <span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>, <span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_for</span> <span class="params">(Lock&amp; lck, <span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>wait_until()函数和wait_for()的功能是一样的，它是指定让线程阻塞到某一个时间点，假设阻塞的线程没有被其他线程唤醒，当到达指定的时间点之后，线程就会自动解除阻塞，继续向下执行。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>, <span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line"><span class="function">cv_status <span class="title">wait_until</span> <span class="params">(Lock&amp; lck, <span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>, <span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_until</span> <span class="params">(Lock&amp; lck, </span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time, </span></span></span><br><span class="line"><span class="params"><span class="function">                 Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>通知函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_one</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_all</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><pre><code>notify_one()：唤醒一个被当前条件变量阻塞的线程notify_all()：唤醒全部被当前条件变量阻塞的线程</code></pre><hr><h3 id="4-2-2-生产者和消费者模型"><a href="#4-2-2-生产者和消费者模型" class="headerlink" title="4.2.2 生产者和消费者模型"></a>4.2.2 生产者和消费者模型</h3><blockquote><p>使用条件变量condition_variable_any同样可以实现上面的生产者和消费者的例子<br>代码只有个别细节上有所不同：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SyncQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SyncQueue</span>(<span class="type">int</span> maxSize) : <span class="built_in">m_maxSize</span>(maxSize) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="comment">// 根据条件阻塞线程</span></span><br><span class="line">        m_notFull.<span class="built_in">wait</span>(m_mutex, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">return</span> m_queue.<span class="built_in">size</span>() != m_maxSize;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 将任务放入到任务队列中</span></span><br><span class="line">        m_queue.<span class="built_in">push_back</span>(x);</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; 被生产&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 通知消费者去消费</span></span><br><span class="line">        m_notEmpty.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">take</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_notEmpty.<span class="built_in">wait</span>(m_mutex, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">return</span> !m_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 从任务队列中取出任务(消费)</span></span><br><span class="line">        <span class="type">int</span> x = m_queue.<span class="built_in">front</span>();</span><br><span class="line">        m_queue.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="comment">// 通知生产者去生产</span></span><br><span class="line">        m_notFull.<span class="built_in">notify_one</span>();</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; 被消费&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>() == m_maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; m_queue;     <span class="comment">// 存储队列数据</span></span><br><span class="line">    mutex m_mutex;         <span class="comment">// 互斥锁</span></span><br><span class="line">    condition_variable_any m_notEmpty;   <span class="comment">// 不为空的条件变量</span></span><br><span class="line">    condition_variable_any m_notFull;    <span class="comment">// 没有满的条件变量</span></span><br><span class="line">    <span class="type">int</span> m_maxSize;         <span class="comment">// 任务队列的最大任务个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SyncQueue <span class="title">taskQ</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> produce = <span class="built_in">bind</span>(&amp;SyncQueue::put, &amp;taskQ, placeholders::_1);</span><br><span class="line">    <span class="keyword">auto</span> consume = <span class="built_in">bind</span>(&amp;SyncQueue::take, &amp;taskQ);</span><br><span class="line">    thread t1[<span class="number">3</span>];</span><br><span class="line">    thread t2[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t1[i] = <span class="built_in">thread</span>(produce, i + <span class="number">100</span>);</span><br><span class="line">        t2[i] = <span class="built_in">thread</span>(consume);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t1[i].<span class="built_in">join</span>();</span><br><span class="line">        t2[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：以上介绍的两种条件变量各自有各自的特点</p><p><code>condition_variable</code> 配合 <code>unique_lock</code> 使用更灵活，可以在在任何时候自由地释放互斥锁<br><code>condition_variable_any</code> 如果和<code>lock_guard</code> 一起使用必须要等到其生命周期结束才能将互斥锁释放。<br><code>condition_variable_any</code> 可以和多种互斥锁配合使用，应用场景也更广<br> <code>condition_variable</code> 只能和独占的非递归互斥锁（mutex）配合使用，有一定的局限性。</p><hr><h1 id="5-原子变量"><a href="#5-原子变量" class="headerlink" title="5. 原子变量"></a>5. 原子变量</h1><p>C++11提供了一个原子类型<code>std::atomic&lt;T&gt;</code>，通过这个原子类型管理的内部变量就可以称之为原子变量，我们可以给原子类型指定<code>bool、char、int、long、指针等类型</code>作为模板参数（<code>不支持浮点类型和复合类型</code>）。</p><p>原子指的是一系列不可被CPU上下文交换的机器指令，这些指令组合在一起就形成了原子操作。在多核CPU下，当某个CPU核心开始运行原子操作时，会先暂停其它CPU内核对内存的操作，以保证原子操作不会被其它CPU内核所干扰。</p><p>由于原子操作是通过指令提供的支持，因此它的性能相比锁和消息传递会好很多。<br>相比较于锁而言，原子类型不需要开发者处理加锁和释放锁的问题，同时支持修改，读取等操作，还具备较高的并发性能，几乎所有的语言都支持原子类型。</p><p>可以看出原子类型是无锁类型，但是无锁不代表无需等待，因为原子类型内部使用了<code>CAS</code>循环，当大量的冲突发生时，该等待还是得等待,但是总归<code>比锁要好</code>。</p><p>C++11内置了整形的原子变量，这样就可以更方便的使用原子变量了。在多线程操作中，使用原子变量之后就不需要再使用互斥量来保护该变量了，用起来更简洁。<br>因为对原子变量进行的操作只能是一个原子操作（atomic operation），<code>原子操作指的是不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何上下文切换。</code><br>多线程同时访问共享资源造成数据混乱的原因就是因为CPU的上下文切换导致的，使用原子变量解决了这个问题，因此互斥锁的使用也就不再需要了。</p><blockquote><p><code>CAS</code>全称是<code>Compare and swap</code><br>它通过一条指令读取指定的内存地址，然后判断其中的值是否等于给定的前置值<br>如果相等，则将其修改为新的值</p></blockquote><hr><h2 id="5-1-atomic-类成员"><a href="#5-1-atomic-类成员" class="headerlink" title="5.1 atomic 类成员"></a>5.1 atomic 类成员</h2><p>类定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义于头文件 &lt;atomic&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">atomic</span>;</span><br></pre></td></tr></table></figure><p>通过定义可得知：<code>在使用这个模板类的时候，一定要指定模板类型。</code></p><hr><h3 id="5-1-1-构造函数"><a href="#5-1-1-构造函数" class="headerlink" title="5.1.1 构造函数"></a>5.1.1 构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">atomic</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">atomic</span><span class="params">(T desired)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">atomic</span>(<span class="type">const</span> atomic&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><ul><li>构造函数①：默认无参构造函数。</li><li>构造函数②：使用 desired 初始化原子变量的值。</li><li>构造函数③：使用&#x3D;delete显示删除拷贝构造函数, <code>不允许进行对象之间的拷贝</code></li></ul><hr><h3 id="5-1-2-公共成员函数"><a href="#5-1-2-公共成员函数" class="headerlink" title="5.1.2 公共成员函数"></a>5.1.2 公共成员函数</h3><blockquote><p>原子类型在类内部重载了&#x3D;操作符，并且不允许在类的外部使用 &#x3D; 进行对象的拷贝。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">operator</span>=( T desired ) <span class="keyword">noexcept</span>;</span><br><span class="line">T <span class="keyword">operator</span>=( T desired ) <span class="keyword">volatile</span> <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">atomic&amp; <span class="keyword">operator</span>=( <span class="type">const</span> atomic&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">atomic&amp; <span class="keyword">operator</span>=( <span class="type">const</span> atomic&amp; ) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><hr><blockquote><p>以 <code>desired</code> 替换当前值。按照 <code>order</code> 的值影响内存。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span><span class="params">( T desired, std::memory_order order = std::memory_order_seq_cst )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span><span class="params">( T desired, std::memory_order order = std::memory_order_seq_cst )</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><ul><li>desired：存储到原子变量中的值</li><li>order：强制的内存顺序</li></ul><hr><blockquote><p>原子地加载并返回原子变量的当前值。按照 order 的值影响内存。直接访问原子对象也可以得到原子变量的当前值。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">load</span><span class="params">(std::memory_order order = std::memory_order_seq_cst)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">T <span class="title">load</span><span class="params">(std::memory_order order = std::memory_order_seq_cst)</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="5-1-3-特化成员函数"><a href="#5-1-3-特化成员函数" class="headerlink" title="5.1.3 特化成员函数"></a>5.1.3 特化成员函数</h3><ul><li>复合赋值运算符重载，主要包含以下形式：</li></ul><p>当模板类型T为整数：</p><table><thead><tr><th>操作符重载</th><th>描述</th></tr></thead><tbody><tr><td>T operator+&#x3D; (T val) volatile noexcept;</td><td>原子地执行加法并赋值，返回新的值 (volatile版本)</td></tr><tr><td>T operator+&#x3D; (T val) noexcept;</td><td>原子地执行加法并赋值，返回新的值</td></tr><tr><td>T operator-&#x3D; (T val) volatile noexcept;</td><td>原子地执行减法并赋值，返回新的值 (volatile版本)</td></tr><tr><td>T operator-&#x3D; (T val) noexcept;</td><td>原子地执行减法并赋值，返回新的值</td></tr><tr><td>T operator&amp;&#x3D; (T val) volatile noexcept;</td><td>原子地执行按位与操作并赋值，返回新的值 (volatile版本)</td></tr><tr><td>T operator&amp;&#x3D; (T val) noexcept;</td><td>原子地执行按位与操作并赋值，返回新的值</td></tr><tr><td>T operator</td><td>&#x3D; (T val) volatile noexcept;</td></tr><tr><td>T operator</td><td>&#x3D; (T val) noexcept;</td></tr><tr><td>T operator^&#x3D; (T val) volatile noexcept;</td><td>原子地执行按位异或操作并赋值，返回新的值 (volatile版本)</td></tr><tr><td>T operator^&#x3D; (T val) noexcept;</td><td>原子地执行按位异或操作并赋值，返回新的值</td></tr></tbody></table><p>当模板类型T为指针：</p><table><thead><tr><th>操作符重载</th><th>描述</th></tr></thead><tbody><tr><td>T operator+&#x3D; (ptrdiff_t val) volatile noexcept;</td><td>原子地执行指针加法并赋值，返回新的指针 (volatile版本)</td></tr><tr><td>T operator+&#x3D; (ptrdiff_t val) noexcept;</td><td>原子地执行指针加法并赋值，返回新的指针</td></tr><tr><td>T operator-&#x3D; (ptrdiff_t val) volatile noexcept;</td><td>原子地执行指针减法并赋值，返回新的指针 (volatile版本)</td></tr><tr><td>T operator-&#x3D; (ptrdiff_t val) noexcept;</td><td>原子地执行指针减法并赋值，返回新的指针</td></tr></tbody></table><ul><li>以上各个 operator 都会有对应的 fetch_* 操作，详细见下表：</li></ul><table><thead><tr><th>操作符</th><th>操作符重载函数</th><th>等级的成员函数</th><th>整形</th><th>指针</th><th>其他</th></tr></thead><tbody><tr><td>+</td><td>atomic::operator+&#x3D;</td><td>atomic::fetch_add</td><td>是</td><td>是</td><td>否</td></tr><tr><td>-</td><td>atomic::operator-&#x3D;</td><td>atomic::fetch_sub</td><td>是</td><td>是</td><td>否</td></tr><tr><td>&amp;</td><td>atomic::operator&amp;&#x3D;</td><td>atomic::fetch_and</td><td>是</td><td>否</td><td>否</td></tr><tr><td>|</td><td>atomic::operator|&#x3D;</td><td>atomic::fetch_or</td><td>是</td><td>否</td><td>否</td></tr><tr><td>^</td><td>atomic::operator^&#x3D;</td><td>atomic::fetch_xor</td><td>是</td><td>否</td><td>否</td></tr></tbody></table><hr><h3 id="5-1-4-内存顺序约束"><a href="#5-1-4-内存顺序约束" class="headerlink" title="5.1.4 内存顺序约束"></a>5.1.4 内存顺序约束</h3><blockquote><p>通过上面的 API 函数我们可以看出，在调用 atomic类提供的 API 函数的时候，需要指定原子顺序<br>在C++11给我们提供的 API中使用枚举用作执行原子操作的函数的实参，以指定如何同步不同线程上的其他操作。</p></blockquote><p>定义如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">memory_order</span> &#123;</span><br><span class="line">    memory_order_relaxed,   <span class="comment">// relaxed</span></span><br><span class="line">    memory_order_consume,   <span class="comment">// consume</span></span><br><span class="line">    memory_order_acquire,   <span class="comment">// acquire</span></span><br><span class="line">    memory_order_release,   <span class="comment">// release</span></span><br><span class="line">    memory_order_acq_rel,   <span class="comment">// acquire/release</span></span><br><span class="line">    memory_order_seq_cst    <span class="comment">// sequentially consistent</span></span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure><ul><li><code>memory_order_relaxed</code>,这是最宽松的规则，它对编译器和CPU不做任何限制，可以乱序</li><li><code>memory_order_release</code> <strong>释放</strong>，设定内存屏障(Memory barrier)，保证它之前的操作永远在它之前，但是它后面的操作可能被重排到它前面</li><li><code>memory_order_acquire</code> <strong>获取</strong>, 设定内存屏障，保证在它之后的访问永远在它之后，但是它之前的操作却有可能被重排到它后面，往往和<code>Release</code>在不同线程中联合使用</li><li><code>memory_order_consume</code>：改进版的<code>memory_order_acquire</code> ，开销更小</li><li><code>memory_order_acq_rel</code>，它是<code>Acquire</code> 和 <code>Release</code> 的结合，同时拥有它们俩提供的保证。比如你要对一个 atomic 自增 1，同时希望该操作之前和之后的读取或写入操作不会被重新排序</li><li><code>memory_order_seq_cst</code> 顺序一致性， <code>memory_order_seq_cst</code> 就像是<code>memory_order_acq_rel</code>的加强版，它不管原子操作是属于读取还是写入的操作<br>只要某个线程有用到<code>memory_order_seq_cst</code> 的原子操作，线程中该<code>memory_order_seq_cst</code> 操作前的数据操作绝对不会被重新排在该<code>memory_order_seq_cst</code> 操作之后，且该<code>memory_order_seq_cst</code> 操作后的数据操作也绝对不会被重新排在<code>memory_order_seq_cst</code> 操作前。</li></ul><h3 id="5-1-5-C-20新增成员"><a href="#5-1-5-C-20新增成员" class="headerlink" title="5.1.5 C++20新增成员"></a>5.1.5 C++20新增成员</h3><blockquote><p>在C++20版本中添加了新的功能函数，可以通过原子类型来阻塞线程，和条件变量中的等待&#x2F;通知函数是一样的。</p></blockquote><table><thead><tr><th>公共成员函数</th><th>说明</th></tr></thead><tbody><tr><td>wait (C++20)</td><td>阻塞线程直至被提醒且原子值更改</td></tr><tr><td>notify_one (C++20)</td><td>通知（唤醒）至少一个在原子对象上阻塞的线程</td></tr><tr><td>notify_all (C++20)</td><td>通知（唤醒）所有在原子对象上阻塞的线程</td></tr></tbody></table><p><strong>类型别名</strong></p><table><thead><tr><th>别名</th><th>原始类型定义</th></tr></thead><tbody><tr><td>atomic_bool (C++11)</td><td>std::atomic&lt;bool&gt;</td></tr><tr><td>atomic_char (C++11)</td><td>std::atomic&lt;char&gt;</td></tr><tr><td>atomic_schar (C++11)</td><td>std::atomic&lt;signed char&gt;</td></tr><tr><td>atomic_uchar (C++11)</td><td>std::atomic&lt;unsigned char&gt;</td></tr><tr><td>atomic_short (C++11)</td><td>std::atomic&lt;short&gt;</td></tr><tr><td>atomic_ushort (C++11)</td><td>std::atomic&lt;unsigned short&gt;</td></tr><tr><td>atomic_int (C++11)</td><td>std::atomic&lt;int&gt;</td></tr><tr><td>atomic_uint (C++11)</td><td>std::atomic&lt;unsigned int&gt;</td></tr><tr><td>atomic_long (C++11)</td><td>std::atomic&lt;long&gt;</td></tr><tr><td>atomic_ulong (C++11)</td><td>std::atomic&lt;unsigned long&gt;</td></tr><tr><td>atomic_llong (C++11)</td><td>std::atomic&lt;long long&gt;</td></tr><tr><td>atomic_ullong (C++11)</td><td>std::atomic&lt;unsigned long long&gt;</td></tr><tr><td>atomic_char8_t (C++20)</td><td>std::atomic&lt;char8_t&gt;</td></tr><tr><td>atomic_char16_t (C++11)</td><td>std::atomic&lt;char16_t&gt;</td></tr><tr><td>atomic_char32_t (C++11)</td><td>std::atomic&lt;char32_t&gt;</td></tr><tr><td>atomic_wchar_t (C++11)</td><td>std::atomic&lt;wchar_t&gt;</td></tr><tr><td>atomic_int8_t (C++11)</td><td>std::atomic&lt;std::int8_t&gt;</td></tr><tr><td>atomic_uint8_t (C++11)</td><td>std::atomic&lt;std::uint8_t&gt;</td></tr><tr><td>atomic_int16_t (C++11)</td><td>std::atomic&lt;std::int16_t&gt;</td></tr><tr><td>atomic_uint16_t (C++11)</td><td>std::atomic&lt;std::uint16_t&gt;</td></tr><tr><td>atomic_int32_t (C++11)</td><td>std::atomic&lt;std::int32_t&gt;</td></tr><tr><td>atomic_uint32_t (C++11)</td><td>std::atomic&lt;std::uint32_t&gt;</td></tr><tr><td>atomic_int64_t (C++11)</td><td>std::atomic&lt;std::int64_t&gt;</td></tr><tr><td>atomic_uint64_t (C++11)</td><td>std::atomic&lt;std::uint64_t&gt;</td></tr><tr><td>atomic_int_least8_t (C++11)</td><td>std::atomic&lt;std::int_least8_t&gt;</td></tr><tr><td>atomic_uint_least8_t (C++11)</td><td>std::atomic&lt;std::uint_least8_t&gt;</td></tr><tr><td>atomic_int_least16_t (C++11)</td><td>std::atomic&lt;std::int_least16_t&gt;</td></tr><tr><td>atomic_uint_least16_t (C++11)</td><td>std::atomic&lt;std::uint_least16_t&gt;</td></tr><tr><td>atomic_int_least32_t (C++11)</td><td>std::atomic&lt;std::int_least32_t&gt;</td></tr><tr><td>atomic_uint_least32_t (C++11)</td><td>std::atomic&lt;std::uint_least32_t&gt;</td></tr><tr><td>atomic_int_least64_t (C++11)</td><td>std::atomic&lt;std::int_least64_t&gt;</td></tr><tr><td>atomic_uint_least64_t (C++11)</td><td>std::atomic&lt;std::uint_least64_t&gt;</td></tr><tr><td>atomic_int_fast8_t (C++11)</td><td>std::atomic&lt;std::int_fast8_t&gt;</td></tr><tr><td>atomic_uint_fast8_t (C++11)</td><td>std::atomic&lt;std::uint_fast8_t&gt;</td></tr><tr><td>atomic_int_fast16_t (C++11)</td><td>std::atomic&lt;std::int_fast16_t&gt;</td></tr><tr><td>atomic_uint_fast16_t (C++11)</td><td>std::atomic&lt;std::uint_fast16_t&gt;</td></tr><tr><td>atomic_int_fast32_t (C++11)</td><td>std::atomic&lt;std::int_fast32_t&gt;</td></tr><tr><td>atomic_uint_fast32_t (C++11)</td><td>std::atomic&lt;std::uint_fast32_t&gt;</td></tr><tr><td>atomic_int_fast64_t (C++11)</td><td>std::atomic&lt;std::int_fast64_t&gt;</td></tr><tr><td>atomic_uint_fast64_t (C++11)</td><td>std::atomic&lt;std::uint_fast64_t&gt;</td></tr><tr><td>atomic_intptr_t (C++11)</td><td>std::atomic&lt;std::intptr_t&gt;</td></tr><tr><td>atomic_uintptr_t (C++11)</td><td>std::atomic&lt;std::uintptr_t&gt;</td></tr><tr><td>atomic_size_t (C++11)</td><td>std::atomic&lt;std::size_t&gt;</td></tr><tr><td>atomic_ptrdiff_t (C++11)</td><td>std::atomic&lt;std::ptrdiff_t&gt;</td></tr><tr><td>atomic_intmax_t (C++11)</td><td>std::atomic&lt;std::intmax_t&gt;</td></tr><tr><td>atomic_uintmax_t (C++11)</td><td>std::atomic&lt;std::uintmax_t&gt;</td></tr></tbody></table><hr><h2 id="5-2-原子变量的使用"><a href="#5-2-原子变量的使用" class="headerlink" title="5.2 原子变量的使用"></a>5.2 原子变量的使用</h2><blockquote><p>假设我们要制作一个多线程交替数数的计数器，我们使用互斥锁和原子变量的方式分别进行实现，对比一下二者的差异：</p></blockquote><h3 id="5-2-1-互斥锁版本"><a href="#5-2-1-互斥锁版本" class="headerlink" title="5.2.1 互斥锁版本"></a>5.2.1 互斥锁版本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            m_value++;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;increment number: &quot;</span> &lt;&lt; m_value </span><br><span class="line">                &lt;&lt; <span class="string">&quot;, theadID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            m_value--;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;decrement number: &quot;</span> &lt;&lt; m_value </span><br><span class="line">                &lt;&lt; <span class="string">&quot;, theadID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_value = <span class="number">0</span>;</span><br><span class="line">    mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Counter c;</span><br><span class="line">    <span class="keyword">auto</span> increment = <span class="built_in">bind</span>(&amp;Counter::increment, &amp;c);</span><br><span class="line">    <span class="keyword">auto</span> decrement = <span class="built_in">bind</span>(&amp;Counter::decrement, &amp;c);</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(decrement)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-2-原子变量版本"><a href="#5-2-2-原子变量版本" class="headerlink" title="5.2.2 原子变量版本"></a>5.2.2 原子变量版本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_value++;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;increment number: &quot;</span> &lt;&lt; m_value</span><br><span class="line">                &lt;&lt; <span class="string">&quot;, theadID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_value--;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;decrement number: &quot;</span> &lt;&lt; m_value</span><br><span class="line">                &lt;&lt; <span class="string">&quot;, theadID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// atomic&lt;int&gt; == atomic_int</span></span><br><span class="line">    atomic_int m_value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Counter c;</span><br><span class="line">    <span class="keyword">auto</span> increment = <span class="built_in">bind</span>(&amp;Counter::increment, &amp;c);</span><br><span class="line">    <span class="keyword">auto</span> decrement = <span class="built_in">bind</span>(&amp;Counter::decrement, &amp;c);</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(decrement)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码的对比可以看出，使用了原子变量之后，就不需要再定义互斥量了，在使用上更加简便，并且这两种方式都能保证在多线程操作过程中数据的正确性，不会出现数据的混乱。</p><p>原子类型<code>atomic&lt;T&gt;</code> 可以封装原始数据最终得到一个原子变量对象，操作原子对象能够得到和操作原始数据一样的效果，当然也可以通过<code>store()</code>和<code>load()</code>来读写原子对象内部的原始数据。</p><hr><h1 id="6-多线程异步操作"><a href="#6-多线程异步操作" class="headerlink" title="6. 多线程异步操作"></a>6. 多线程异步操作</h1><h2 id="6-1-std-future"><a href="#6-1-std-future" class="headerlink" title="6.1 std:future"></a>6.1 std:future</h2><blockquote><p>C++11中增加的线程类，使得我们能够非常方便的创建和使用线程<br>但有时会有些不方便，比如需要获取线程返回的结果，就不能通过join()得到结果，只能通过一些额外手段获得，比如：定义一个全局变量，在子线程中赋值，在主线程中读这个变量的值，整个过程比较繁琐。</p></blockquote><p>C++提供的线程库中提供了一些类用于访问异步操作的结果。</p><p>那么，什么叫做异步呢？<br><img src="/img/8.25.png" alt="在这里插入图片描述"></p><p>我们去星巴克买咖啡，因为都是现磨的，所以需要等待，但是我们付完账后不会站在柜台前死等，而是去找个座位坐下来玩玩手机打发一下时间，当店员把咖啡磨好之后，就会通知我们过去取，这就叫做异步。</p><ul><li>顾客（主线程）发起一个任务（子线程磨咖啡），磨咖啡的过程中顾客去做别的事情了，有两条时间线（异步）</li><li>顾客（主线程）发起一个任务（子线程磨咖啡），磨咖啡的过程中顾客没去做别的事情而是死等，这时就只有一条时间线（同步），此时效率相对较低。</li></ul><p>因此多线程程序中的任务大都是异步的，主线程和子线程分别执行不同的任务，如果想要在主线中得到某个子线程任务函数返回的结果可以使用C++11提供的<code>std:future</code>类，这个类需要和其他类或函数搭配使用</p><p>先来介绍一下这个类的API函数：</p><p><strong>类的定义</strong></p><p>通过类的定义可以得知，<code>future</code>是一个模板类，也就是这个类可以存储任意指定类型的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义于头文件 &lt;future&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt; <span class="keyword">class</span> <span class="title class_">future</span>;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt; <span class="keyword">class</span> <span class="title class_">future</span>&lt;T&amp;&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;          <span class="keyword">class</span> <span class="title class_">future</span>&lt;<span class="type">void</span>&gt;;</span><br></pre></td></tr></table></figure><p><strong>构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">future</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">future</span>( future&amp;&amp; other ) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">future</span>( <span class="type">const</span> future&amp; other ) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><ul><li>构造函数①：默认无参构造函数</li><li>构造函数②：移动构造函数，转移资源的所有权</li><li>构造函数③：使用&#x3D;delete显示删除拷贝构造函数, 不允许进行对象之间的拷贝</li></ul><p><strong>常用成员函数（public)</strong></p><blockquote><p>一般情况下使用<code>=</code>进行赋值操作就进行对象的拷贝，但是future对象<code>不可用复制</code><br>因此会根据实际情况进行处理：</p></blockquote><ul><li>如果other是右值，那么转移资源的所有权</li><li>如果other是非右值，不允许进行对象之间的拷贝（该函数被显示删除禁止使用）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">future&amp; <span class="keyword">operator</span>=( future&amp;&amp; other ) <span class="keyword">noexcept</span>;</span><br><span class="line">future&amp; <span class="keyword">operator</span>=( <span class="type">const</span> future&amp; other ) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><hr><blockquote><p>取出<code>future</code>对象内部保存的数据，其中<code>void get()</code>是为<code>future&lt;void&gt;</code>准备的<br>此时对象内部类型就是<code>void</code>，该函数是一个阻塞函数，当子线程的数据就绪后解除阻塞就能得到传出的数值了。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">T&amp; <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><blockquote><p>因为<code>future</code>对象内部存储的是异步线程任务执行完毕后的结果，是在调用之后的将来得到的，因此可以通过调用<code>wait()</code>方法，阻塞当前线程，等待这个子线程的任务执行完毕，任务执行完毕当前线程的阻塞也就解除了。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><code>wait()</code>方法就会死等，直到子线程任务执行完毕将返回值写入到<code>future</code>对象中<br><code>wait_for()</code>只会让线程阻塞一定的时长，但是这样并不能保证对应的那个子线程中的任务已经执行完毕了。<br><code>wait_until()</code>和<code>wait_for()</code>函数功能是差不多<br>前者是阻塞到某一指定的时间点，后者是阻塞一定的时长。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Rep, <span class="keyword">class</span> Period &gt;</span></span><br><span class="line"><span class="function">std::future_status <span class="title">wait_for</span><span class="params">( <span class="type">const</span> std::chrono::duration&lt;Rep,Period&gt;&amp; timeout_duration )</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Clock, <span class="keyword">class</span> Duration &gt;</span></span><br><span class="line"><span class="function">std::future_status <span class="title">wait_until</span><span class="params">( <span class="type">const</span> std::chrono::time_point&lt;Clock,Duration&gt;&amp; timeout_time )</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>当<code>wait_until()</code>和<code>wait_for()</code>函数返回之后，并不能确定子线程当前的状态，因此我们需要判断函数的返回值，这样就能知道子线程当前的状态了：</p><table><thead><tr><th>常量</th><th>解释</th></tr></thead><tbody><tr><td>future_status::deferred</td><td>子线程中的任务函仍未启动</td></tr><tr><td>future_status::ready</td><td>子线程中的任务已经执行完毕，结果已就绪</td></tr><tr><td>future_status::timeout</td><td>子线程中的任务正在执行中，指定等待时长已用完</td></tr></tbody></table><hr><h2 id="6-2-std-promise"><a href="#6-2-std-promise" class="headerlink" title="6.2 std::promise"></a>6.2 std::promise</h2><blockquote><p><code>std::promise</code>是一个协助线程赋值的类，它能够将数据和future对象绑定起来，为获取线程函数中的某个值提供便利。</p></blockquote><h3 id="6-2-1-类成员函数"><a href="#6-2-1-类成员函数" class="headerlink" title="6.2.1 类成员函数"></a>6.2.1 类成员函数</h3><p><strong>类定义</strong></p><p>通过<code>std::promise</code>类的定义可以得知，这也是一个模板类，我们要在线程中传递什么类型的数据，模板参数就指定为什么类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义于头文件 &lt;future&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">R</span> &gt; <span class="keyword">class</span> <span class="title class_">promise</span>;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">R</span> &gt; <span class="keyword">class</span> <span class="title class_">promise</span>&lt;R&amp;&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;          <span class="keyword">class</span> <span class="title class_">promise</span>&lt;<span class="type">void</span>&gt;;</span><br></pre></td></tr></table></figure><p><strong>构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ①</span></span><br><span class="line"><span class="built_in">promise</span>();</span><br><span class="line"><span class="comment">// ②</span></span><br><span class="line"><span class="built_in">promise</span>( promise&amp;&amp; other ) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// ③</span></span><br><span class="line"><span class="built_in">promise</span>( <span class="type">const</span> promise&amp; other ) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><ul><li>构造函数①：默认构造函数，得到一个空对象</li><li>构造函数②：移动构造函数</li><li>构造函数③：使用&#x3D;delete显示删除拷贝构造函数, 不允许进行对象之间的拷贝</li></ul><p><strong>公共成员函数</strong></p><blockquote><p>在<code>std::promise</code>类内部管理着一个<code>future</code>类对象，调用<code>get_future()</code>就可以得到这个<code>future</code>对象了</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function">std::future&lt;T&gt; <span class="title">get_future</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>存储要传出的 <code>value</code> 值，并立即让状态就绪，这样数据被传出其它线程就可以得到这个数据了。重载的第四个函数是为<code>promise&lt;void&gt;</code>类型的对象准备的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">( <span class="type">const</span> R&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">( R&amp;&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">( R&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>存储要传出的 <code>value</code> 值，但是不立即令状态就绪。在当前线程退出时，子线程资源被销毁，再令状态就绪。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value_at_thread_exit</span><span class="params">( <span class="type">const</span> R&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value_at_thread_exit</span><span class="params">( R&amp;&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value_at_thread_exit</span><span class="params">( R&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value_at_thread_exit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="6-2-2-promise的使用"><a href="#6-2-2-promise的使用" class="headerlink" title="6.2.2 promise的使用"></a>6.2.2 promise的使用</h3><p>通过promise传递数据的过程一共分为5步：</p><ol><li>在主线程中创建std::promise对象</li><li>将这个std::promise对象通过引用的方式传递给子线程的任务函数</li><li>在子线程任务函数中给std::promise对象赋值</li><li>在主线程中通过std::promise对象取出绑定的future实例对象</li><li>通过得到的future对象取出子线程任务函数中返回的值。</li></ol><p><strong>子线程任务函数执行期间，让状态就绪</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    promise&lt;<span class="type">int</span>&gt; pr;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">([](promise&lt;<span class="type">int</span>&gt; &amp;p) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        p.set_value(<span class="number">100</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">        this_thread::sleep_for(chrono::seconds(<span class="number">3</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;睡醒了....&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;, ref(pr))</span></span>;</span><br><span class="line"></span><br><span class="line">    future&lt;<span class="type">int</span>&gt; f = pr.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="type">int</span> value = f.<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例程序输出的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value: <span class="number">100</span></span><br><span class="line">睡醒了....</span><br></pre></td></tr></table></figure><p>示例程序的中子线程的任务函数指定的是一个匿名函数，在这个匿名的任务函数执行期间通过<code>p.set_value(100);</code>传出了数据并且激活了状态<br>数据就绪后，外部主线程中的<code>int value = f.get();</code>解除阻塞，并将得到的数据打印出来，5秒钟之后子线程休眠结束，匿名的任务函数执行完毕。</p><p><strong>子线程任务函数执行结束，让状态就绪</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    promise&lt;<span class="type">int</span>&gt; pr;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">([](promise&lt;<span class="type">int</span>&gt; &amp;p) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        p.set_value_at_thread_exit(<span class="number">100</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">        this_thread::sleep_for(chrono::seconds(<span class="number">3</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;睡醒了....&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;, ref(pr))</span></span>;</span><br><span class="line"></span><br><span class="line">    future&lt;<span class="type">int</span>&gt; f = pr.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="type">int</span> value = f.<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例程序输出的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">睡醒了....</span><br><span class="line">value: <span class="number">100</span></span><br></pre></td></tr></table></figure><p>在示例程序中，子线程的这个匿名的任务函数中通过<code>p.set_value_at_thread_exit(100);</code>在执行完毕并退出之后才会传出数据并激活状态<br>数据就绪后，外部主线程中的<code>int value = f.get();</code>解除阻塞，并将得到的数据打印出来，因此子线程在休眠5秒钟之后主线程中才能得到传出的数据。</p><p><code>注意</code>:在外部主线程中创建的<code>promise</code>对象必须要通过引用的方式传递到子线程的任务函数中，在实例化子线程对象的时候，如果任务函数的参数是引用类型，那么实参一定要放到<code>std::ref()</code>函数中，表示要传递这个实参的引用到任务函数中。</p><hr><h2 id="6-3-std-packaged-task"><a href="#6-3-std-packaged-task" class="headerlink" title="6.3. std::packaged_task"></a>6.3. std::packaged_task</h2><blockquote><p><code>std::packaged_task</code>类包装了一个可调用对象包装器类对象（可调用对象包装器包装的是可调用对象，可调用对象都可以作为函数来使用），恶补一下可调用对象和可调用对象包装器</p></blockquote><p>这个类可以将内部包装的函数和<code>future</code>类绑定到一起,以便进行后续的异步调用,和<code>std::promise</code>有点类似<br><code>std::promise</code>内部保存一个共享状态的值，而<code>std::packaged_task</code>保存的是一个函数。</p><hr><h3 id="6-3-1-类成员函数"><a href="#6-3-1-类成员函数" class="headerlink" title="6.3.1 类成员函数"></a>6.3.1 类成员函数</h3><p><strong>类的定义</strong></p><p>通过类的定义可以看到这也是一个模板类，模板类型和要在线程中传出的数据类型是一致的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义于头文件 &lt;future&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> &gt; <span class="keyword">class</span> <span class="title class_">packaged_task</span>;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span> ...Args &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">packaged_task</span>&lt;<span class="built_in">R</span>(Args...)&gt;;</span><br></pre></td></tr></table></figure><p><strong>构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ①</span></span><br><span class="line"><span class="built_in">packaged_task</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// ②</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">packaged_task</span><span class="params">( F&amp;&amp; f )</span></span>;</span><br><span class="line"><span class="comment">// ③</span></span><br><span class="line"><span class="built_in">packaged_task</span>( <span class="type">const</span> packaged_task&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="comment">// ④</span></span><br><span class="line"><span class="built_in">packaged_task</span>( packaged_task&amp;&amp; rhs ) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><ul><li>构造函数①：无参构造，构造一个无任务的空对象</li><li>构造函数②：通过一个可调用对象，构造一个任务对象</li><li>构造函数③：显示删除，不允许通过拷贝构造函数进行对象的拷贝</li><li>构造函数④：移动构造函数</li></ul><p><strong>常用公共成员函数</strong></p><p>通过调用任务对象内部的<code>get_future()</code>方法就可以得到一个<code>future</code>对象，基于这个对象就可以得到传出的数据了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function">std::future&lt;R&gt; <span class="title">get_future</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="6-3-2-packaged-task的使用"><a href="#6-3-2-packaged-task的使用" class="headerlink" title="6.3.2 packaged_task的使用"></a>6.3.2 packaged_task的使用</h3><blockquote><p><code>packaged_task</code>其实就是对子线程要执行的任务函数进行了包装，和可调用对象包装器的使用方法相同，包装完毕之后直接将包装得到的任务对象传递给线程对象就可以了。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">([](<span class="type">int</span> x) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">return</span> x += <span class="number">100</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(ref(task), <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    future&lt;<span class="type">int</span>&gt; f = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="type">int</span> value = f.<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例代码中，通过<code>packaged_task</code>类包装了一个匿名函数作为子线程的任务函数，最终的得到的这个任务对象需要通过引用的方式传递到子线程内部，这样才能在主线程的最后通过任务对象得到<code>future</code>对象，再通过这个<code>future</code>对象取出子线程通过返回值传递出的数据。</p><hr><h2 id="6-4-std-async"><a href="#6-4-std-async" class="headerlink" title="6.4 std::async"></a>6.4 std::async</h2><blockquote><p><code>std::async</code>函数比前面提到的<code>std::promise</code>和<code>packaged_task</code>更高级一些<br>因为通过这函数可以直接启动一个子线程并在这个子线程中执行对应的任务函数，异步任务执行完成返回的结果也是存储到一个<code>future</code>对象中<br>当需要获取异步任务的结果时，只需要调用<code>future</code>类的<code>get()</code>方法即可<br>如果不关注异步任务的结果，只是简单地等待任务完成的话，可以调用<code>future</code>类的<code>wait()</code>或者<code>wait_for()</code>方法。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">// 定义于头文件 &lt;future&gt;</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">std::future&lt;std::<span class="type">result_of_t</span>&lt;std::<span class="built_in">decay_t</span>&lt;Function&gt;(std::<span class="type">decay_t</span>&lt;Args&gt;...)&gt;&gt;</span><br><span class="line">    <span class="built_in">async</span>( Function&amp;&amp; f, Args&amp;&amp;... args );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args &gt;</span><br><span class="line">std::future&lt;std::<span class="type">result_of_t</span>&lt;std::<span class="built_in">decay_t</span>&lt;Function&gt;(std::<span class="type">decay_t</span>&lt;Args&gt;...)&gt;&gt;</span><br><span class="line">    <span class="built_in">async</span>( std::launch policy, Function&amp;&amp; f, Args&amp;&amp;... args );</span><br></pre></td></tr></table></figure><p>可以看到这是一个模板函数，在C++11中这个函数有两种调用方式：</p><ul><li><p>函数①：直接调用传递到函数体内部的可调用对象，返回一个<code>future</code>对象</p></li><li><p>函数②：通过指定的策略调用传递到函数内部的可调用对象，返回一个<code>future</code>对象<br>函数参数:</p></li><li><p><code>f</code>：可调用对象，这个对象在子线程中被作为任务函数使用</p></li><li><p><code>Args</code>：传递给 f 的参数（实参）</p></li><li><p><code>policy</code>：可调用对象·f的执行策略</p></li></ul><table><thead><tr><th>策略</th><th>说明</th></tr></thead><tbody><tr><td>std::launch::async</td><td>调用async函数时创建新的线程执行任务函数</td></tr><tr><td>std::launch::deferred</td><td>调用async函数时不执行任务函数，直到调用了future的get()或者wait()时才执行任务（这种方式不会创建新的线程）</td></tr></tbody></table><p>关于std::async()函数的使用，对应的示例代码如下：</p><h3 id="6-4-1-方式1"><a href="#6-4-1-方式1" class="headerlink" title="6.4.1 方式1"></a>6.4.1 方式1</h3><p><strong>调用async()函数直接创建线程执行任务</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 调用函数直接创建线程执行任务</span></span><br><span class="line">    future&lt;<span class="type">int</span>&gt; f = <span class="built_in">async</span>([](<span class="type">int</span> x) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">return</span> x += <span class="number">100</span>;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    future_status status;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        status = f.<span class="built_in">wait_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (status == future_status::deferred)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;线程还没有执行...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            f.<span class="built_in">wait</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (status == future_status::ready)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;子线程返回值: &quot;</span> &lt;&lt; f.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (status == future_status::timeout)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;任务还未执行完毕, 继续等待...&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (status != future_status::ready);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例程序输出的结果为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">主线程ID: <span class="number">8904</span></span><br><span class="line">子线程ID: <span class="number">25036</span></span><br><span class="line">任务还未执行完毕, 继续等待...</span><br><span class="line">任务还未执行完毕, 继续等待...</span><br><span class="line">任务还未执行完毕, 继续等待...</span><br><span class="line">任务还未执行完毕, 继续等待...</span><br><span class="line">任务还未执行完毕, 继续等待...</span><br><span class="line">子线程返回值: <span class="number">200</span></span><br></pre></td></tr></table></figure><p>调用<code>async()</code>函数时不指定策略就是直接创建线程并执行任务,示例代码的主线程中做了如下操作<br><code>status = f.wait_for(chrono::seconds(1));</code><br>其实直接调用<code>f.get()</code>就能得到子线程的返回值。<br>为了演示&#96;wait_for()&#96;&#96;的使用，所以写的复杂了些。</p><hr><h3 id="6-4-2-方式2"><a href="#6-4-2-方式2" class="headerlink" title="6.4.2 方式2"></a>6.4.2 方式2</h3><p><strong>调用async()函数不创建线程执行任务</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 调用函数直接创建线程执行任务</span></span><br><span class="line">    future&lt;<span class="type">int</span>&gt; f = <span class="built_in">async</span>(launch::deferred, [](<span class="type">int</span> x) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> x += <span class="number">100</span>;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    cout &lt;&lt; f.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例程序输出的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主线程ID: <span class="number">24760</span></span><br><span class="line">主线程开始休眠<span class="number">5</span>秒...</span><br><span class="line">子线程ID: <span class="number">24760</span></span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure><p>由于指定了<code>launch::deferred</code> 策略，因此调用<code>async()</code>函数并不会创建新的线程执行任务<br>当使用<code>future</code>类对象调用了<code>get()</code>或者<code>wait()</code>方法后才开始执行任务（此处一定要注意调用<code>wait_for()</code>函数是不行的）。</p><p>通过测试程序输出的结果可以看到，两次输出的线程ID是相同的，任务函数是在主线程中被延迟（主线程休眠了5秒）调用了。</p><p>最终总结：</p><ol><li>使用<code>async()</code>函数，是多线程操作中最简单的一种方式，不需要自己创建线程对象，并且可以得到子线程函数的返回值。</li><li>使用<code>std::promise</code>类，在子线程中可以传出返回值也可以传出其他数据，并且可选择在什么时机将数据从子线程中传递出来，使用起来更灵活。</li><li>使用<code>std::packaged_task</code>类，可将子线程的任务函数进行包装，并可得到子线程返回值。</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-线程的使用&quot;&gt;&lt;a href=&quot;#1-线程的使用&quot; class=&quot;headerlink&quot; title=&quot;1.线程的使用&quot;&gt;&lt;/a&gt;1.线程的使用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;C++11中增加了线程以及线程相关的类，支持了并发编程，提高了编</summary>
      
    
    
    
    <category term="线程" scheme="http://example.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="线程同步" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
    <category term="C++线程" scheme="http://example.com/tags/C-%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="原子变量" scheme="http://example.com/tags/%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/"/>
    
    <category term="线程异步" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://example.com/2023/10/22/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://example.com/2023/10/22/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2023-10-22T01:52:41.000Z</published>
    <updated>2023-10-22T02:24:18.499Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-线程池原理"><a href="#1-线程池原理" class="headerlink" title="1. 线程池原理"></a>1. 线程池原理</h1><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便<br>但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>那么有没有一种办法使得线程可以复用:<br>执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？</p><p>线程池是一种多线程处理形式，处理过程中将任务添加到队列<br>在创建线程后<code>自动启动</code>这些任务。线程池线程都是后台线程。<br>每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。<br>如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。<br>如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。<br>超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p><p>在各个编程语言的语种中都有线程池的概念，并且很多语言中直接提供了线程池，作为程序猿直接使用就可以了，下面给大家介绍一下线程池的实现原理：</p><ul><li><p>线程池的组成主要分为3个部分，这三部分配合工作就可以得到一个完整的线程池：</p><ol><li><code>任务队列，存储需要处理的任务，由工作的线程来处理这些任务</code><ul><li>通过线程池提供的API函数，将一个待处理的任务添加到任务队列，或者从任务队列中删除</li><li>已处理的任务会被从任务队列中删除</li><li>线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程</li></ul></li><li><code>工作的线程（任务队列任务的消费者） ，N个</code><ul><li>线程池中维护了一定数量的工作线程, 他们的作用是是不停的读任务队列, 从里边取出任务并处理</li><li>工作的线程相当于是任务队列的消费者角色，</li><li>如果任务队列为空, 工作的线程将会被阻塞 (使用条件变量&#x2F;信号量阻塞)</li><li>如果阻塞之后有了新的任务, 由生产者将阻塞解除, 工作线程开始工作</li></ul></li><li><code>管理者线程（不处理任务队列中的任务），1个</code><ul><li>它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测<ul><li>当任务过多的时候, 可以适当的创建一些新的工作线程</li><li>当任务过少的时候, 可以适当的销毁一些工作的线程</li></ul></li></ul></li></ol></li></ul><p><img src="/img/8.22.png" alt="在这里插入图片描述"></p><hr><h1 id="2-C实现线程池"><a href="#2-C实现线程池" class="headerlink" title="2. C实现线程池"></a>2. C实现线程池</h1><h2 id="2-1-头文件"><a href="#2-1-头文件" class="headerlink" title="2.1 头文件"></a>2.1 头文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">void</span> (*function)(<span class="type">void</span>* args);</span><br><span class="line"><span class="type">void</span>* args;</span><br><span class="line">&#125;Task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//任务队列</span></span><br><span class="line">Task* task_queue;</span><br><span class="line"><span class="type">int</span> queue_capacity;<span class="comment">//容量</span></span><br><span class="line"><span class="type">int</span> queue_size;<span class="comment">//当前任务个数</span></span><br><span class="line"><span class="type">int</span> queue_front;<span class="comment">//队头-&gt;消费用</span></span><br><span class="line"><span class="type">int</span> queue_tail;<span class="comment">//队尾-&gt;生产用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> managerID;<span class="comment">//管理者线程ID(1个)</span></span><br><span class="line"><span class="type">pthread_t</span>* threadID;<span class="comment">//工作的线程ID(多个,用指针)</span></span><br><span class="line"><span class="type">int</span> min_num;<span class="comment">//最小的线程数量</span></span><br><span class="line"><span class="type">int</span> max_num;<span class="comment">//最大的线程数量</span></span><br><span class="line"><span class="type">int</span> busy_num;<span class="comment">//在忙的线程数量</span></span><br><span class="line"><span class="type">int</span> live_num;<span class="comment">//存活的线程数量</span></span><br><span class="line"><span class="type">int</span> exit_num;<span class="comment">//将要销毁的线程数量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_pool;<span class="comment">//线程池的锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_busy_num;<span class="comment">//busy_num的锁</span></span><br><span class="line"><span class="type">pthread_cond_t</span> producer_wait_consumer;<span class="comment">//生产者等待消费者</span></span><br><span class="line"><span class="type">pthread_cond_t</span> consumer_wait_producer;<span class="comment">//消费者等待生产者</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> shutdown;<span class="comment">//是否销毁线程池,销毁为1,否则为0</span></span><br><span class="line">&#125;ThreadPool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程池并且初始化</span></span><br><span class="line">ThreadPool* <span class="title function_">Thread_Pool_Create</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, <span class="type">int</span> queuesize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁线程池</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Thread_Pool_Destroy</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给线程池添加任务(相当于生产者)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread_Pool_Add</span><span class="params">(ThreadPool* pool, <span class="type">void</span>(*function)(<span class="type">void</span>*), <span class="type">void</span>* args)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线程池中工作的线程个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_Busy_Num</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线程池中存活的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_Live_Num</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为被封装的函数</span></span><br><span class="line"><span class="comment">//工作的线程(消费者线程)任务函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">Worker</span><span class="params">(<span class="type">void</span>* args)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理者线程任务函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">Manager</span><span class="params">(<span class="type">void</span>* args)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单个线程的退出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread_Exit</span><span class="params">(ThreadPool* pool)</span>;</span><br></pre></td></tr></table></figure><h2 id="2-2-源文件的定义"><a href="#2-2-源文件的定义" class="headerlink" title="2.2 源文件的定义"></a>2.2 源文件的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">ThreadPool* <span class="title function_">Thread_Pool_Create</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, <span class="type">int</span> queuesize)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//开线程池</span></span><br><span class="line">ThreadPool* pool = (ThreadPool*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadPool));</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pool == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc threadpool fail\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开线程ID</span></span><br><span class="line">pool-&gt;threadID = (<span class="type">pthread_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;threadID == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc threadID fail\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始线程ID都初始化为0</span></span><br><span class="line"><span class="built_in">memset</span>(pool-&gt;threadID, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">pool-&gt;max_num = max;</span><br><span class="line">pool-&gt;min_num = min;</span><br><span class="line">pool-&gt;busy_num = <span class="number">0</span>;</span><br><span class="line">pool-&gt;live_num = min;</span><br><span class="line">pool-&gt;exit_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化锁和条件变量</span></span><br><span class="line"><span class="keyword">if</span> (pthread_mutex_init(&amp;pool-&gt;mutex_pool, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">pthread_mutex_init(&amp;pool-&gt;mutex_busy_num, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">pthread_cond_init(&amp;pool-&gt;producer_wait_consumer, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">pthread_cond_init(&amp;pool-&gt;consumer_wait_producer, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mutex or cond init fail\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化任务队列</span></span><br><span class="line">pool-&gt;task_queue = (Task*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Task) * queuesize);</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;task_queue == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc task_queue fail...\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pool-&gt;queue_capacity = queuesize;</span><br><span class="line">pool-&gt;queue_size = <span class="number">0</span>;</span><br><span class="line">pool-&gt;queue_front = <span class="number">0</span>;</span><br><span class="line">pool-&gt;queue_tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">pool-&gt;shutdown = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程</span></span><br><span class="line">pthread_create(&amp;pool-&gt;managerID, <span class="literal">NULL</span>, Manager, pool);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; min; ++i)</span><br><span class="line">&#123;</span><br><span class="line">pthread_create(&amp;pool-&gt;threadID[i], <span class="literal">NULL</span>, Worker, pool);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pool; <span class="comment">//到这里说明成功,返回创建出来的线程池</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳到这里说明失败了,释放资源</span></span><br><span class="line"><span class="keyword">if</span> (pool &amp;&amp; pool-&gt;threadID)</span><br><span class="line"><span class="built_in">free</span>(pool-&gt;threadID);</span><br><span class="line"><span class="keyword">if</span> (pool)</span><br><span class="line"><span class="built_in">free</span>(pool);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Thread_Pool_Destroy</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果线程池本就不存在</span></span><br><span class="line"><span class="keyword">if</span> (pool == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">pool-&gt;shutdown = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//阻塞并回收管理者线程</span></span><br><span class="line">pthread_join(pool-&gt;managerID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒阻塞的消费者进程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;live_num; ++i)</span><br><span class="line">pthread_cond_signal(&amp;pool-&gt;consumer_wait_producer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放堆内存</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;task_queue)</span><br><span class="line"><span class="built_in">free</span>(pool-&gt;task_queue);</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;threadID)</span><br><span class="line"><span class="built_in">free</span>(pool-&gt;threadID);</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁锁和条件变量</span></span><br><span class="line">pthread_mutex_destroy(&amp;pool-&gt;mutex_pool);</span><br><span class="line">pthread_mutex_destroy(&amp;pool-&gt;mutex_busy_num);</span><br><span class="line">pthread_cond_destroy(&amp;pool-&gt;consumer_wait_producer);</span><br><span class="line">pthread_cond_destroy(&amp;pool-&gt;producer_wait_consumer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁线程池</span></span><br><span class="line"><span class="built_in">free</span>(pool);</span><br><span class="line">pool = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread_Pool_Add</span><span class="params">(ThreadPool* pool, <span class="type">void</span>(*function)(<span class="type">void</span>*), <span class="type">void</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="comment">//如果任务队列满了</span></span><br><span class="line"><span class="keyword">while</span> (pool-&gt;queue_size == pool-&gt;queue_capacity &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//生产者阻塞,等待消费者进程</span></span><br><span class="line">pthread_cond_wait(&amp;pool-&gt;producer_wait_consumer, &amp;pool-&gt;mutex_pool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果线程池要关闭</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;shutdown)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加任务</span></span><br><span class="line"><span class="comment">//队尾添加任务,队尾向后移动,队列任务数加一</span></span><br><span class="line">pool-&gt;task_queue[pool-&gt;queue_tail].function = function;</span><br><span class="line">pool-&gt;task_queue[pool-&gt;queue_tail].args = args;</span><br><span class="line">pool-&gt;queue_tail = (pool-&gt;queue_tail + <span class="number">1</span>) % pool-&gt;queue_capacity;</span><br><span class="line">pool-&gt;queue_size++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提醒消费者消费</span></span><br><span class="line">pthread_cond_signal(&amp;pool-&gt;consumer_wait_producer);</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_pool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_Busy_Num</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_busy_num);</span><br><span class="line"><span class="type">int</span> busynum = pool-&gt;busy_num;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_busy_num);</span><br><span class="line"><span class="keyword">return</span> busynum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_Live_Num</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="type">int</span> livenum = pool-&gt;live_num;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="keyword">return</span> livenum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">Worker</span><span class="params">(<span class="type">void</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line">ThreadPool* pool = (ThreadPool*)args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果当前任务队列为空</span></span><br><span class="line"><span class="keyword">while</span> (pool-&gt;queue_size == <span class="number">0</span> &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//阻塞消费者线程</span></span><br><span class="line">pthread_cond_wait(&amp;pool-&gt;consumer_wait_producer,&amp;pool-&gt;mutex_pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要销毁线程</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;exit_num &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pool-&gt;exit_num--;</span><br><span class="line"><span class="comment">//同时如果存活线程大于最小值</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;live_num &gt; pool-&gt;min_num)</span><br><span class="line">&#123;</span><br><span class="line">pool-&gt;live_num--;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_pool);</span><br><span class="line">Thread_Exit(pool);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果线程池要关闭</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;shutdown)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_pool);</span><br><span class="line">Thread_Exit(pool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从任务队列取出任务</span></span><br><span class="line">Task task;</span><br><span class="line">task.function = pool-&gt;task_queue[pool-&gt;queue_front].function;</span><br><span class="line">task.args = pool-&gt;task_queue[pool-&gt;queue_front].args;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队头向后移动以下次取任务</span></span><br><span class="line">pool-&gt;queue_front = (pool-&gt;queue_front + <span class="number">1</span>) % pool-&gt;queue_capacity;</span><br><span class="line">pool-&gt;queue_size--;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁提醒生产者</span></span><br><span class="line">pthread_cond_signal(&amp;pool-&gt;producer_wait_consumer);</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印,busynum++</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread %ld start working...\n&quot;</span>, pthread_self());</span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_busy_num);</span><br><span class="line">pool-&gt;busy_num++;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_busy_num);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行函数,完成任务,销毁任务队列中这个数据(函数)</span></span><br><span class="line">task.function(task.args);</span><br><span class="line"><span class="built_in">free</span>(task.args);</span><br><span class="line">task.args = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印,busynum--</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread %ld end working\n&quot;</span>, pthread_self());</span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_busy_num);</span><br><span class="line">pool-&gt;busy_num--;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_busy_num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;shutdown)</span><br><span class="line">Thread_Exit(pool);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">Manager</span><span class="params">(<span class="type">void</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line">ThreadPool* pool = (ThreadPool*)args;</span><br><span class="line"><span class="keyword">while</span> (!pool-&gt;shutdown)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//每隔三秒检查一次</span></span><br><span class="line">sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出线程池中任务的数量和当前的线程数量</span></span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="type">int</span> queue_size = pool-&gt;queue_size;</span><br><span class="line"><span class="type">int</span> live_num = pool-&gt;live_num;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出忙的线程数量</span></span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_busy_num);</span><br><span class="line"><span class="type">int</span> busy_num = pool-&gt;busy_num;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_busy_num);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加线程</span></span><br><span class="line"><span class="comment">//任务个数&gt;存活线程个数 &amp;&amp; 存活线程个数&lt;最大线程数(消费者太少了,任务队列消化太慢</span></span><br><span class="line"><span class="keyword">if</span> (queue_size &gt; live_num &amp;&amp; live_num &lt; pool-&gt;max_num)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;max_num &amp;&amp;</span><br><span class="line"> counter &lt; NUMBER &amp;&amp; </span><br><span class="line">pool-&gt;live_num &lt; pool-&gt;max_num; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;threadID[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_create(&amp;pool-&gt;threadID[i], <span class="literal">NULL</span>, Worker, pool);</span><br><span class="line">counter++;</span><br><span class="line">pool-&gt;live_num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_pool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁线程</span></span><br><span class="line"><span class="comment">//忙的线程*2 &lt; 存活的线程数 &amp;&amp; 存活的线程&gt;最小线程数</span></span><br><span class="line"><span class="keyword">if</span> (busy_num * <span class="number">2</span> &lt; live_num &amp;&amp; live_num &gt; pool-&gt;min_num)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_pool);</span><br><span class="line">pool-&gt;exit_num = NUMBER;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">//让工作的线程自杀</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMBER; ++i)</span><br><span class="line">&#123;</span><br><span class="line">pthread_cond_signal(&amp;pool-&gt;consumer_wait_producer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread_Exit</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pthread_t</span> tid = pthread_self();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;max_num; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;threadID[i] == tid)</span><br><span class="line">&#123;</span><br><span class="line">pool-&gt;threadID[i] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread %ld exiting...\n&quot;</span>, tid);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-测试部分"><a href="#2-3-测试部分" class="headerlink" title="2.3 测试部分"></a>2.3 测试部分</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Task_Test</span><span class="params">(<span class="type">void</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num = *(<span class="type">int</span>*)args;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread %ld is working,number = %d\n&quot;</span>, pthread_self(), num);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">ThreadPool* pool = Thread_Pool_Create(<span class="number">3</span>, <span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>* num = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*num = i + <span class="number">100</span>;</span><br><span class="line">Thread_Pool_Add(pool, Task_Test, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">Thread_Pool_Destroy(pool);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="3-C-实现线程池"><a href="#3-C-实现线程池" class="headerlink" title="3. C++实现线程池"></a>3. C++实现线程池</h1><h2 id="3-1-头文件"><a href="#3-1-头文件" class="headerlink" title="3.1 头文件"></a>3.1 头文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> callback = <span class="built_in">void</span>(*)(<span class="type">void</span>*);</span><br><span class="line"><span class="comment">//任务的结构体</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Task</span>()</span><br><span class="line">&#123;</span><br><span class="line">function = <span class="literal">nullptr</span>;</span><br><span class="line">args = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Task</span>(callback fun, <span class="type">void</span>* args)</span><br><span class="line">&#123;</span><br><span class="line">function = fun;</span><br><span class="line"><span class="keyword">this</span> -&gt; args = (T*)args;</span><br><span class="line">&#125;</span><br><span class="line">callback function;</span><br><span class="line">T* args;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务队列</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_mutex_init</span>(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddTask</span><span class="params">(Task&lt;T&gt; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">queue.<span class="built_in">push</span>(task);</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddTask</span><span class="params">(callback fun, <span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"><span class="function">Task&lt;T&gt; <span class="title">task</span><span class="params">(fun,args)</span></span>; </span><br><span class="line">queue.<span class="built_in">push</span>(task);</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出一个任务</span></span><br><span class="line"><span class="function">Task&lt;T&gt; <span class="title">TakeTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Task&lt;T&gt; task;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">if</span> (queue.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">task = queue.<span class="built_in">front</span>();</span><br><span class="line">queue.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前队列中的任务个数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetTaskNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> queue.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex; <span class="comment">//互斥锁</span></span><br><span class="line">std::queue&lt;Task&lt;T&gt;&gt; queue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ThreadPool</span>(<span class="type">int</span> min , <span class="type">int</span> max)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//实例化任务队列</span></span><br><span class="line">taskqueue = <span class="keyword">new</span> TaskQueue&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化线程池</span></span><br><span class="line">min_num = min;</span><br><span class="line">max_num = max;</span><br><span class="line">busy_num = <span class="number">0</span>;</span><br><span class="line">live_num = min;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据线程最大上限,给线程数组分配内存</span></span><br><span class="line">threadID = <span class="keyword">new</span> <span class="type">pthread_t</span>[max];</span><br><span class="line"><span class="keyword">if</span> (threadID == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;new threadID fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化线程ID</span></span><br><span class="line"><span class="built_in">memset</span>(threadID, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化互斥锁和条件变量</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;mutex_pool, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line"><span class="built_in">pthread_cond_init</span>(&amp;notempty, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mutex or cond init fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; min; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;threadID[i], <span class="literal">NULL</span>, Work, <span class="keyword">this</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;create thread ID :&quot;</span> &lt;&lt; <span class="built_in">to_string</span>(threadID[i]) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;managerID, <span class="literal">NULL</span>, Manage, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">shutdown = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//销毁管理者进程</span></span><br><span class="line"><span class="built_in">pthread_join</span>(managerID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒消费者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; live_num; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_cond_signal</span>(&amp;notempty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (taskqueue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> taskqueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (threadID)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] threadID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_pool);</span><br><span class="line"><span class="built_in">pthread_cond_destroy</span>(&amp;notempty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add_Task</span><span class="params">(Task&lt;T&gt; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (shutdown)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加任务,不需加锁,队列中有</span></span><br><span class="line">taskqueue-&gt;<span class="built_in">AddTask</span>(task);</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒消费者</span></span><br><span class="line"><span class="built_in">pthread_cond_signal</span>(&amp;notempty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取忙线程个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get_Busy_Num</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> busynum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex_pool);</span><br><span class="line">busynum = busy_num;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_pool);</span><br><span class="line"><span class="keyword">return</span> busynum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取存活线程个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get_Live_Num</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> livenum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex_pool); </span><br><span class="line">livenum = live_num; </span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_pool); </span><br><span class="line"><span class="keyword">return</span> livenum; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//工作的线程任务函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">Work</span><span class="params">(<span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ThreadPool* pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//访问任务队列加锁</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="comment">//判断任务队列是否为空,空了就堵塞</span></span><br><span class="line"><span class="keyword">while</span> (pool-&gt;taskqueue-&gt;<span class="built_in">GetTaskNum</span>() == <span class="number">0</span> &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;thread :&quot;</span> &lt;&lt; <span class="built_in">to_string</span>(<span class="built_in">pthread_self</span>()) &lt;&lt; <span class="string">&quot; waiting...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">pthread_cond_wait</span>(&amp;pool-&gt;notempty, &amp;pool-&gt;mutex_pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解除后 判断是否要销毁进程</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;exit_num &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pool-&gt;exit_num--;</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;live_num &gt; pool-&gt;min_num)</span><br><span class="line">&#123;</span><br><span class="line">pool-&gt;live_num--;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line">pool-&gt;<span class="built_in">Thread_Exit</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断线程池是否要关闭了</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;shutdown)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line">pool-&gt;<span class="built_in">Thread_Exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从任务队列取出任务</span></span><br><span class="line">Task&lt;T&gt; task = pool-&gt;taskqueue-&gt;<span class="built_in">TakeTask</span>();</span><br><span class="line">pool-&gt;busy_num++;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;thread :&quot;</span> &lt;&lt; <span class="built_in">to_string</span>(<span class="built_in">pthread_self</span>()) &lt;&lt; <span class="string">&quot; start working...&quot;</span> &lt;&lt; endl;</span><br><span class="line">task.<span class="built_in">function</span>(task.args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> task.args;</span><br><span class="line">task.args = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务结束</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;thread :&quot;</span> &lt;&lt; <span class="built_in">to_string</span>(<span class="built_in">pthread_self</span>()) &lt;&lt; <span class="string">&quot; end working...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line">pool-&gt;busy_num--;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理者线程任务函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">Manage</span><span class="params">(<span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ThreadPool* pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(args);</span><br><span class="line"><span class="keyword">while</span> (!pool-&gt;shutdown)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//5秒检测一次</span></span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="type">int</span> livenum = pool-&gt;live_num;</span><br><span class="line"><span class="type">int</span> busynum = pool-&gt;busy_num;</span><br><span class="line"><span class="type">int</span> queuesize = pool-&gt;taskqueue-&gt;<span class="built_in">GetTaskNum</span>();</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUMBER = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="keyword">if</span> (queuesize &gt; livenum &amp;&amp; livenum &lt; pool-&gt;max_num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;max_num &amp;&amp; </span><br><span class="line">num &lt; NUMBER &amp;&amp; </span><br><span class="line">pool-&gt;live_num &lt; pool-&gt;max_num ; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;threadID[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;pool-&gt;threadID[i], <span class="literal">NULL</span>, Work, pool);</span><br><span class="line">num++;</span><br><span class="line">pool-&gt;live_num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="keyword">if</span> (busynum * <span class="number">2</span> &lt; livenum &amp;&amp; livenum &gt; pool-&gt;min_num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line">pool-&gt;exit_num = NUMBER;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMBER; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;notempty);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread_Exit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">pthread_t</span> tid = <span class="built_in">pthread_self</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max_num; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (threadID[i] == tid)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;thread :&quot;</span> &lt;&lt; <span class="built_in">to_string</span>(<span class="built_in">pthread_self</span>()) &lt;&lt; <span class="string">&quot;exiting&quot;</span> &lt;&lt; endl;</span><br><span class="line">threadID[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_pool;</span><br><span class="line"><span class="type">pthread_cond_t</span> notempty;</span><br><span class="line"><span class="type">pthread_t</span>* threadID;</span><br><span class="line"><span class="type">pthread_t</span> managerID;</span><br><span class="line">TaskQueue&lt;T&gt;* taskqueue;</span><br><span class="line"><span class="type">int</span> min_num;</span><br><span class="line"><span class="type">int</span> max_num;</span><br><span class="line"><span class="type">int</span> busy_num;</span><br><span class="line"><span class="type">int</span> live_num;</span><br><span class="line"><span class="type">int</span> exit_num;</span><br><span class="line"><span class="type">bool</span> shutdown = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-2-测试部分"><a href="#3-2-测试部分" class="headerlink" title="3.2  测试部分"></a>3.2  测试部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ThreadPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task_Test</span><span class="params">(<span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> num = *(<span class="type">int</span>*)args;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;thread :&quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; is working &quot;</span> &lt;&lt; <span class="string">&quot;number =&quot;</span> &lt;&lt; num &lt;&lt;endl;</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line"><span class="function">ThreadPool&lt;<span class="type">int</span>&gt; <span class="title">pool</span><span class="params">(<span class="number">3</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>* num = <span class="keyword">new</span> <span class="built_in">int</span>(i+<span class="number">100</span>);</span><br><span class="line">pool.<span class="built_in">Add_Task</span>(<span class="built_in">Task</span>&lt;<span class="type">int</span>&gt;(Task_Test,num));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">40</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><blockquote><p>以上只是基于C修改出对应于C++的代码</p></blockquote><p>并且以上代码存在一个问题<br>输出的结果有时会因为线程原因出现混乱<br>可以通过加锁来解决,但锁的数量超过1就容易导致死锁问题,所以暂且搁置</p><hr><h1 id="4-C-11实现线程池"><a href="#4-C-11实现线程池" class="headerlink" title="4. C++11实现线程池"></a>4. C++11实现线程池</h1><p>并非原创,摘于<a href="https://www.cnblogs.com/lzpong/p/6397997.html">此处</a></p><h2 id="4-1-头文件"><a href="#4-1-头文件" class="headerlink" title="4.1 头文件"></a>4.1 头文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_MAX_NUM 16</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> _initsize;</span><br><span class="line"><span class="keyword">using</span> Task = function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">vector&lt;thread&gt; _pool;</span><br><span class="line">queue&lt;Task&gt; _tasks;</span><br><span class="line">mutex _lock;</span><br><span class="line">mutex _lockGrow;</span><br><span class="line">condition_variable _task_cv;</span><br><span class="line">atomic&lt;<span class="type">bool</span>&gt; _run&#123;<span class="literal">true</span>&#125;;</span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; _spa_trd_num&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">threadpool</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> size = <span class="number">4</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_initsize = size;</span><br><span class="line"><span class="built_in">Add_Thread</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> ~<span class="built_in">threadpool</span>()</span><br><span class="line">&#123;</span><br><span class="line">_run = <span class="literal">false</span>;</span><br><span class="line">_task_cv.<span class="built_in">notify_all</span>();</span><br><span class="line"><span class="keyword">for</span> (thread&amp; thread : _pool)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (thread.<span class="built_in">joinable</span>())</span><br><span class="line">thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F,<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">commit</span><span class="params">(F&amp;&amp; f, Args&amp;&amp; ...args)</span> -&gt; future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span> &gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!_run)</span><br><span class="line"><span class="keyword">throw</span> runtime_error&#123;<span class="string">&quot;commit auto stop&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">using</span> RetType = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...));</span><br><span class="line"><span class="keyword">auto</span> task = make_shared&lt;packaged_task&lt;<span class="built_in">RetType</span>()&gt;&gt;(<span class="built_in">bind</span>(forward&lt;F&gt;(f), forward&lt;Args&gt;(args)...));</span><br><span class="line">future&lt;RetType&gt; future = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">&#123;</span><br><span class="line">lock_guard&lt;mutex&gt; lock&#123;_lock&#125;;</span><br><span class="line">_tasks.<span class="built_in">emplace</span>([task]() &#123;(*task)(); &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (_spa_trd_num &lt; <span class="number">1</span> &amp;&amp; _pool.<span class="built_in">size</span>() &lt; THREADPOOL_MAX_NUM)</span><br><span class="line"><span class="built_in">Add_Thread</span>(<span class="number">1</span>);</span><br><span class="line">_task_cv.<span class="built_in">notify_one</span>();</span><br><span class="line"><span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">commit2</span><span class="params">(F&amp;&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!_run)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#123;</span><br><span class="line">lock_guard&lt;mutex&gt; lock&#123;_lock&#125;;</span><br><span class="line">_tasks.<span class="built_in">emplace</span>(forward&lt;F&gt;(f));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (_spa_trd_num &lt; <span class="number">1</span> &amp;&amp; _pool.<span class="built_in">size</span>() &lt; THREADPOOL_MAX_NUM)</span><br><span class="line"><span class="built_in">Add_Thread</span>(<span class="number">1</span>);</span><br><span class="line">_task_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">idlCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _spa_trd_num; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">thrCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _pool.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add_Thread</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!_run)</span><br><span class="line"><span class="keyword">throw</span> runtime_error&#123;<span class="string">&quot;Add_Thread stop&quot;</span>&#125;;</span><br><span class="line">unique_lock&lt;mutex&gt; lockgrow&#123;_lockGrow&#125;;</span><br><span class="line"><span class="keyword">for</span> (; _pool.<span class="built_in">size</span>() &lt; THREADPOOL_MAX_NUM &amp;&amp; size &gt; <span class="number">0</span>; --size)</span><br><span class="line">&#123;</span><br><span class="line">_pool.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">Task task;</span><br><span class="line">&#123;</span><br><span class="line">unique_lock&lt;mutex&gt; lock&#123;_lock&#125;;</span><br><span class="line">_task_cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> !_run || !_tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"><span class="keyword">if</span> (!_run &amp;&amp; _tasks.<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">_spa_trd_num--;</span><br><span class="line">task = <span class="built_in">move</span>(_tasks.<span class="built_in">front</span>());</span><br><span class="line">_tasks.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">task</span>();</span><br><span class="line"><span class="keyword">if</span> (_spa_trd_num &gt; <span class="number">0</span> &amp;&amp; _pool.<span class="built_in">size</span>() &gt; _initsize)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#123;</span><br><span class="line">unique_lock&lt;mutex&gt; lock&#123;_lock&#125;;</span><br><span class="line">_spa_trd_num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#123;</span><br><span class="line">unique_lock&lt;mutex&gt; lock&#123;_lock&#125;;</span><br><span class="line">_spa_trd_num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>要使用pthread依赖库</p></blockquote><hr><h2 id="4-2-测试部分"><a href="#4-2-测试部分" class="headerlink" title="4.2 测试部分"></a>4.2 测试部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ThreadPool.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> slp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun1  %ld\n&quot;</span>, std::this_thread::<span class="built_in">get_id</span>());</span><br><span class="line">    <span class="keyword">if</span> (slp &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fun1 sleep %ld  =========  %ld\n&quot;</span>, slp, std::this_thread::<span class="built_in">get_id</span>());</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(slp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">gfun</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;gfun  %ld\n&quot;</span>, n, std::this_thread::<span class="built_in">get_id</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Afun</span><span class="params">(<span class="type">int</span> n = <span class="number">0</span>)</span> <span class="comment">//函数必须是 static 的才能直接使用线程池</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot;Afun  &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">Bfun</span><span class="params">(<span class="type">int</span> n, std::string str, <span class="type">char</span> c)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot;Bfun   &quot;</span> &lt;&lt; str.<span class="built_in">c_str</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; (<span class="type">int</span>)c &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">try</span> </span>&#123;</span><br><span class="line">    std::threadpool executor&#123; <span class="number">50</span> &#125;;</span><br><span class="line">    std::future&lt;<span class="type">void</span>&gt; ff = executor.<span class="built_in">commit</span>(fun1, <span class="number">0</span>);</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fg = executor.<span class="built_in">commit</span>(gfun&#123;&#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//std::future&lt;int&gt; gg = executor.commit(A::Afun, 9999); //IDE提示错误,但可以编译运行</span></span><br><span class="line">    std::future&lt;std::string&gt; gh = executor.<span class="built_in">commit</span>(A::Bfun, <span class="number">9998</span>, <span class="string">&quot;mult args&quot;</span>, <span class="number">123</span>);</span><br><span class="line">    std::future&lt;std::string&gt; fh = executor.<span class="built_in">commit</span>([]()-&gt;std::string &#123; std::cout &lt;&lt; <span class="string">&quot;hello, fh !  &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl; <span class="keyword">return</span> <span class="string">&quot;hello,fh ret !\n&quot;</span>; &#125;);</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    std::cout &lt;&lt; fg.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; fh.<span class="built_in">get</span>().<span class="built_in">c_str</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; =======  fun1,55 ========= &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">    executor.<span class="built_in">commit</span>(fun1, <span class="number">55</span>).<span class="built_in">get</span>();    <span class="comment">//调用.get()获取返回值会等待线程执行完</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::threadpool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    std::vector&lt; std::future&lt;<span class="type">int</span>&gt; &gt; results;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        results.<span class="built_in">emplace_back</span>(</span><br><span class="line">            pool.<span class="built_in">commit</span>([i] &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;hello &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">                std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;world &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> i * i;</span><br><span class="line">                &#125;)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">15</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; result : results)</span><br><span class="line">        std::cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;some error &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果<br><img src="/img/8.23.png" alt="在这里插入图片描述"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-线程池原理&quot;&gt;&lt;a href=&quot;#1-线程池原理&quot; class=&quot;headerlink&quot; title=&quot;1. 线程池原理&quot;&gt;&lt;/a&gt;1. 线程池原理&lt;/h1&gt;&lt;p&gt;我们使用线程的时候就去创建一个线程，这样实现起来非常简便&lt;br&gt;但是就会有一个问题：如</summary>
      
    
    
    
    <category term="线程" scheme="http://example.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="小项目" scheme="http://example.com/tags/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="C线程" scheme="http://example.com/tags/C%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="C++线程" scheme="http://example.com/tags/C-%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="线程池" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
</feed>
