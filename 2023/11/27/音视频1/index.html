<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>音视频入门 | 9TSe</title><meta name="author" content="9TSe"><meta name="copyright" content="9TSe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 音视频播放原理 2. 图像篇2.1 YUV和RGB音视频中编码前的图像格式，即YUV和RGB。 YUV，RGB，包括YcbCr是色彩空间的模型，而平常所说的BMP、PNG、JPEG是文件的存储形式。而YUV是音视频（编解码）最常用的格式。  YUV有两种分类方式，即空间-间和空间-内。空间-间的划分方式主要体现在Y、U、V的比例不同；空间-内的划分方式主要体现在Y、U、V的比例一定，存储格式">
<meta property="og:type" content="article">
<meta property="og:title" content="音视频入门">
<meta property="og:url" content="http://example.com/2023/11/27/%E9%9F%B3%E8%A7%86%E9%A2%911/index.html">
<meta property="og:site_name" content="9TSe">
<meta property="og:description" content="1. 音视频播放原理 2. 图像篇2.1 YUV和RGB音视频中编码前的图像格式，即YUV和RGB。 YUV，RGB，包括YcbCr是色彩空间的模型，而平常所说的BMP、PNG、JPEG是文件的存储形式。而YUV是音视频（编解码）最常用的格式。  YUV有两种分类方式，即空间-间和空间-内。空间-间的划分方式主要体现在Y、U、V的比例不同；空间-内的划分方式主要体现在Y、U、V的比例一定，存储格式">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/pic/1.png">
<meta property="article:published_time" content="2023-11-27T14:24:43.000Z">
<meta property="article:modified_time" content="2023-12-01T12:23:34.983Z">
<meta property="article:author" content="9TSe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/pic/1.png"><link rel="shortcut icon" href="/pic/12.png"><link rel="canonical" href="http://example.com/2023/11/27/%E9%9F%B3%E8%A7%86%E9%A2%911/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '音视频入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-01 20:23:34'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="9TSe" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/pic/avater.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/pic/1.png')"><nav id="nav"><span id="blog-info"><a href="/" title="9TSe"><img class="site-icon" src="/pic/9.png"/></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">音视频入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-27T14:24:43.000Z" title="发表于 2023-11-27 22:24:43">2023-11-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-01T12:23:34.983Z" title="更新于 2023-12-01 20:23:34">2023-12-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="音视频入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-音视频播放原理"><a href="#1-音视频播放原理" class="headerlink" title="1. 音视频播放原理"></a>1. 音视频播放原理</h1><p><img src="/img/mv1.1.png"></p>
<h1 id="2-图像篇"><a href="#2-图像篇" class="headerlink" title="2. 图像篇"></a>2. 图像篇</h1><h2 id="2-1-YUV和RGB"><a href="#2-1-YUV和RGB" class="headerlink" title="2.1 YUV和RGB"></a>2.1 YUV和RGB</h2><p>音视频中编码前的图像格式，即YUV和RGB。</p>
<p>YUV，RGB，包括YcbCr是色彩空间的模型，而平常所说的BMP、PNG、JPEG是文件的存储形式。<br>而YUV是音视频（编解码）最常用的格式。</p>
<blockquote>
<p>YUV有两种分类方式，即<code>空间-间</code>和<code>空间-内</code>。<br><strong>空间-间的划分方式主要体现在Y、U、V的比例不同；<br>空间-内的划分方式主要体现在Y、U、V的比例一定，存储格式不同。</strong></p>
</blockquote>
<p><strong>1. YUV 空间-间 的数据划分</strong></p>
<p>YUV按照<code>空间-间</code>的划分方式，分为<code>YUV444</code>、<code>YUV422</code>、<code>YUV420</code>，如下所示，假设图像为1920*1080：</p>
<p><img src="/img/mv1.2.png"></p>
<p><strong>2. YUV 空间-内 的数据划分</strong></p>
<p>YUV按照<code>空间-内</code>的划分方式，主要分为<code>packet</code>、<code>planar</code>、<code>semi-planar</code>三种：</p>
<ul>
<li><p>packet：打包格式，即先存储一个yuv，再存储下一个yuv；</p>
</li>
<li><p>planar：平面格式，即先存储y平面，再存储u平面，再存储v平面；</p>
</li>
<li><p>semi-planar：先存储y平面，再存储uv平面；</p>
</li>
</ul>
<p> YUV422各种存储格式如下：</p>
<p><img src="/img/mv1.3.png"></p>
<p>YUV420各种存储格式如下：</p>
<p><img src="/img/mv1.4.png"></p>
<p>针对上图中的NV12、NV21、NV16、NV61说明：</p>
<ul>
<li><p>NV：NV系列都属于semi-plane系列，12、16代表先U后V || 21、61代表先V后U</p>
</li>
<li><p>12、16：代表一个像素占的位数</p>
</li>
</ul>
<p><strong>3. YUV和RGB</strong></p>
<p>RGB：即red，green，blue三色存储空间，因音视频主要用的是YUV的色彩空间，只简单介绍下RGB和YUV的转换公式：</p>
<ul>
<li>RGB 转 YUV：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Y = 0.299R + 0.587G + 0.114B</span><br><span class="line"></span><br><span class="line">U= -0.147R - 0.289G + 0.436B</span><br><span class="line"></span><br><span class="line">V = 0.615R - 0.515G - 0.100B</span><br></pre></td></tr></table></figure>

<ul>
<li>YUV 转 RGB：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R = Y + 1.14V</span><br><span class="line"></span><br><span class="line">G = Y - 0.39U - 0.58V</span><br><span class="line"></span><br><span class="line">B = Y + 2.03U</span><br></pre></td></tr></table></figure>


<h2 id="2-2-H-264"><a href="#2-2-H-264" class="headerlink" title="2.2 H.264"></a>2.2 H.264</h2><blockquote>
<p>H.264是由 ITU-T视频编码专家组(VCEG) 和 ISO&#x2F;IEC动态图像专家组(MPEG)<br>联合组成的联合视频组（JVT，Joint Video Team）提出的<code>高度压缩数字视频编解码器标准</code>。</p>
</blockquote>
<p><strong>1. H.264的数据格式</strong></p>
<p>H.264由<code>视频编码层</code>（VCL）和 <code>网络适配层</code>（NAL）组成。</p>
<ul>
<li><p><code>VCL</code>：H.264编码&#x2F;压缩的核心，主要负责将视频数据编码&#x2F;压缩，再切分。</p>
</li>
<li><p>NALU(NAL单元) &#x3D; <code>NALU header(头部)</code> + NALU payload(有效负载)</p>
</li>
</ul>
<p><code>NALU payload</code> 是根据<code>NALU头部</code>中 <code>nal_unit_type</code> 的不同而变化的，它可能包含了不同类型的视频数据。举例来说：</p>
<ol>
<li>对于片（slice）类型的NALU，NALU payload 将包含经过编码和压缩的视频像素数据，这些数据经过了帧内预测和帧间预测、DCT 变换、量化和比特流编码等处理。</li>
<li>对于参数集类型（如SPS、PPS），NALU payload 将包含编码视频序列的相关参数信息，如图像分辨率、帧率、编码方式等。</li>
<li>对于补充增强信息（SEI），NALU payload 可能包含了额外的元数据或增强信息，例如色彩空间信息、时间戳、双流传输信息等。</li>
</ol>
<p><strong>2. VCL管理H264视频数据</strong></p>
<ol>
<li><strong>压缩过程</strong> ：<ul>
<li><strong>预测</strong> ：H.264使用帧内预测和帧间预测来利用视频序列中的时间和空间相关性。帧内预测通过对当前帧内的像素进行预测来减少冗余。帧间预测利用邻近帧的信息进行运动补偿，以减少帧间冗余。</li>
<li><strong>DCT 变换和量化</strong> ：对预测残差进行离散余弦变换（DCT），然后将其量化，以减少数据量。</li>
<li><strong>比特流编码</strong> ：采用不同的编码技术对量化后的数据进行编码，如熵编码（如CABAC和CAVLC），以生成最终的压缩比特流。</li>
</ul>
</li>
<li><strong>数据切分</strong> ：<ul>
<li><strong>切片（slice）</strong> ：VCL将帧划分为不同的切片，每个切片包含一部分宏块（macroblock），允许并行处理和解码，提高系统效率。</li>
<li><strong>宏块（macroblock）</strong> ：它是一个像素块，包含在切片中，用于进行预测和编码。宏块是H.264中处理的基本单元。</li>
</ul>
</li>
<li><strong>包装成NAL</strong> ：<ul>
<li>NAL（网络抽象层）是为了适应不同网络传输需求而封装VCL生成的编码视频数据。NAL单元由NAL头部和NAL有效负载组成，它提供了对应用层和传输层之间的接口。NAL单元的创建允许对VCL生成的数据进行适当的封装和传输，以便在网络上传输和存储。</li>
</ul>
</li>
</ol>
<p><code>VCL</code>最后会被包装成<code>NAL</code></p>
<p><strong>3. NAL头的数据结构体</strong></p>
<p><img src="/img/mv1.5.png"></p>
<ul>
<li><p>F（forbidden_zero_bit）：1 位，初始为0。<br>当网络识别此单元存在比特<code>错误</code>时，可将其<code>设为 1</code>，以便接收方丢掉该单元</p>
</li>
<li><p>NRI（nal_ref_idc）：2 位，用来指示该NALU 的重要性等级。<br>值越大，表示当前NALU越重要。具体大于0 时取何值，没有明确规定</p>
</li>
<li><p>Type（nal_unit_type）：5 位，指出NALU 的类型，如下所示：(5,7,8)</p>
</li>
</ul>
<p><img src="/img/mv1.6.png"></p>
<p><strong>4. H.264码流结构</strong></p>
<ul>
<li>H.264 &#x3D; start_code + NALU</li>
</ul>
<ol>
<li><strong>3 字节的 start_code：</strong><ul>
<li><code>0000 0001</code>（8 比特，即一个字节）或者是 <code>0000 01</code>（6 比特）。</li>
<li>用于分隔两个连续的 NALU 单元。</li>
<li>较短的起始码占用更少的比特数（6或8比特），节省了一些带宽。</li>
</ul>
<ul>
<li>在较早的H.264编码器或特定的实现中可能会使用这种较短的起始码。</li>
</ul>
</li>
<li><strong>4 字节的 start_code：</strong><ul>
<li><code>0000 0000 0000 0001</code>（16 比特，两个字节）或者是 <code>00 00 00 01</code>（32 比特，四个字节）。</li>
<li>同样也是为了分隔两个连续的 NALU 单元。</li>
<li>更长的起始码提供了更大的辨识性和可靠性。在传输过程中，更长的起始码可能对于错误检测和恢复更有帮助。</li>
</ul>
<ul>
<li>在更多现代的H.264编码器和实现中使用这种较长的起始码，因为它们提供了更好的容错性。</li>
</ul>
</li>
</ol>
<p><img src="/img/mv1.7.png"></p>
<ul>
<li><p>每个NAL前有一个起始码 <code>0x00 00 01</code>（或者<code>0x00 00 00 01</code>）<br>解码器检测每个起始码，作为一个NAL的起始标识<br>当检测到下一个起始码时，当前NAL结束。</p>
</li>
<li><p>同时H.264规定，当检测到<code>0x00 00 00</code>时，也可以表征当前NAL的结束。<br>那么NAL中数据出现<code>0x00 00 01</code>或<code>0x00 00 00</code>时怎么办？<br>H.264引入了防止竞争机制<br>如果编码器检测到NAL数据存在<code>0x00 00 01</code>或<code>0x00 00 00</code>时，编码器会在最后个字节前插入一个新的字节0x03，这样：<br><code>0x00 00 00</code>－&gt;<code>0x00 00 03 00</code><br><code>0x00 00 01</code>－&gt;<code>0x00 00 03 01</code><br><code>0x00 00 02</code>－&gt;<code>0x00 00 03 02</code><br><code>0x00 00 03</code>－&gt;<code>0x00 00 03 03</code></p>
</li>
</ul>
<p><strong>5. I帧、P帧和B帧</strong></p>
<p>提到H.264，不得不提I帧、P帧、B帧、IDR帧、GOP。</p>
<ul>
<li><p>I帧（Intra-coded picture，帧内编码图像帧），表示<code>关键帧</code>，采用类似JPEG压缩的DCT(Discrete Cosine Transform，离散余弦变换)压缩技术，可达1&#x2F;6压缩比而无明显压缩痕迹；</p>
</li>
<li><p>P帧（Predictive-coded picture，前向预测编码图像帧），表示的是跟<code>之前的一个关键帧或P帧的差别</code>，P帧是<code>参考帧</code>，它可能造成解码错误的扩散；</p>
</li>
<li><p>B帧（Bidirectionally predicted picture，双向预测编码图像帧），<code>本帧与前后帧（I或P帧）的差别</code>，B帧压缩率高，但解码耗费CPU；</p>
</li>
<li><p>IDR帧（Instantaneous Decoding Refresh，即时解码刷新）：<code>首个I帧</code>，是立刻刷新,使错误不致传播<br>IDR导致DPB（DecodedPictureBuffer参考帧列表——这是关键所在）清空；<br>在IDR帧之后的所有帧都不能引用任何IDR帧之前的帧的内容；<br>IDR具有随机访问的能力，播放器可以从一个IDR帧播放。</p>
</li>
<li><p>GOP（Group Of Picture，图像序列）：两个I帧之间是一个GOP(图像序列)，一个GOP包含一个I帧</p>
</li>
</ul>
<p><strong>6. 解码时间戳和显示时间戳</strong></p>
<p>当然，H.264中还有两个重要的概念：<code>DTS</code> 和 <code>PTS</code></p>
<ul>
<li><p>DTS（Decoding Time Stamp，解码时间戳解）：读入内存中的比特流在什么时候开始送入解码器中进行解码</p>
</li>
<li><p>PTS（Presentation Time Stamp，显示时间戳）：解码后的视频帧什么时候被显示出来</p>
</li>
</ul>
<p><img src="/img/mv1.8.png"></p>
<hr>
<h1 id="3-音频篇"><a href="#3-音频篇" class="headerlink" title="3. 音频篇"></a>3. 音频篇</h1><h2 id="3-1-PCM"><a href="#3-1-PCM" class="headerlink" title="3.1 PCM"></a>3.1 PCM</h2><blockquote>
<p><code>PCM</code>(<code>Pulse Code Modulation</code>，<code>脉冲编码调制</code>)音频数据是未经压缩的音频采样数据裸流，它是由模拟信号经过采样、量化、编码转换成的标准数字音频数据。</p>
</blockquote>
<p><strong>1. 理解PCM</strong></p>
<p>PCM是一种用数字表示采样模拟信号方法。主要包括<code>采样</code>，<code>量化</code>，<code>编码</code>三个主要过程。</p>
<ul>
<li>先来看看模拟信号采样的过程：</li>
</ul>
<p><img src="/img/mv1.9.png"></p>
<ul>
<li><p>采样率：每秒钟采样的样本数。比如我们常说的44.1kHz，即每秒钟采样44100次。</p>
</li>
<li><p>量化：将采样信号数据四舍五入到一个可用整数表示的过程。（位深）</p>
</li>
</ul>
<p><img src="/img/mv1.10.png"></p>
<ul>
<li>编码：将量化后的信号转换成二进制数据。</li>
</ul>
<p><strong>2. 描述PCM数据的6个参数：</strong></p>
<ul>
<li><p><code>Sample Rate</code> : 采样频率。<code>8kHz</code>(电话)、<code>44.1kHz</code>(CD)、<code>48kHz</code>(DVD)。</p>
</li>
<li><p><code>Sample Size</code> : 量化位数。常见值为<code>8-bit</code>、<code>16-bit</code>。</p>
</li>
<li><p><code>Number of Channels</code> : 通道个数。常见的音频有<code>立体声(stereo)</code>和<code>单声道(mono)</code>两种类型，立体声包含左声道和右声道。另外还有环绕立体声等其它不太常用的类型。</p>
</li>
<li><p><code>Sign</code> : 表示样本数据是否是有符号位，比如用一字节表示的样本数据，有符号的话表示范围为-128 ~ 127，无符号是0 ~ 255。</p>
</li>
<li><p><code>Byte Ordering</code> : 字节序。字节序是<code>little-endian</code>还是<code>big-endian</code>。通常均为<code>little-endian</code>。</p>
</li>
<li><p><code>Integer Or Floating Point</code> : 整形或浮点型。大多数格式的PCM样本数据使用整形表示，而在一些对精度要求高的应用方面，使用浮点类型表示PCM样本数据</p>
</li>
</ul>
<h2 id="3-2-AAC"><a href="#3-2-AAC" class="headerlink" title="3.2 AAC"></a>3.2 AAC</h2><blockquote>
<p><code>AAC(Advanced Audio Coding，高级音频编码)</code>是一种声音数据的文件<code>压缩格式</code>。AAC分为<code>ADIF</code>和<code>ADTS</code>两种文件格式。</p>
</blockquote>
<p><strong>1. 什么是ADIF和ADTS？</strong></p>
<ul>
<li><p><code>ADIF</code>：<code>Audio Data Interchange Format 音频数据交换格式</code>。<br>这种格式的特征是可以确定的找到这个音频数据的开始，不需进行在音频数据流中间开始的解码<br>即它的解码必须在<code>明确定义的开始处进行</code>。故这种格式常用在<code>磁盘文件</code>中。</p>
</li>
<li><p><code>ADTS</code>：<code>Audio Data Transport Stream 音频数据传输流</code>。<br>这种格式的特征是它是一个有同步字的比特流，解码可以在这个流中<code>任何位置开始</code>。</p>
</li>
</ul>
<p><strong>2. ADTS的数据结构</strong></p>
<p><img src="/img/mv1.11.png"></p>
<hr>
<h1 id="4-字幕篇-SSA-ASS"><a href="#4-字幕篇-SSA-ASS" class="headerlink" title="4. 字幕篇(SSA &amp; ASS)"></a>4. 字幕篇(SSA &amp; ASS)</h1><blockquote>
<p><code>SSA</code>（SubStation Alpha），是由CS Low（亦称Kotus）创建，比传统字幕格式（如<code>SRT</code>）功能更加先进的字幕文件格式。<br>该格式字幕的外挂文件以<code>*.ssa</code>作为后缀。</p>
</blockquote>
<blockquote>
<p><code>ASS</code>（Advanced SubStation Alpha），是一种比<code>SSA</code>更为高级的字幕格式, 其实质版本是<code>SSA v4.00+</code>，它是基于SSA 4.00+编码构建的。<br> ASS的主要变化就是在SSA编写风格的基础上增添更多的特效和指令。<br> 该格式字幕的外挂文件以<code>*.ass</code>作为后缀。</p>
</blockquote>
<p><strong>1. SSA&#x2F;ASS的基本结构</strong></p>
<p><code>SSA/ASS</code>字幕是一种类<code>ini</code>风格纯文本文件；<br>包含五个section：<code>Script Info</code>、<code>v4+ Styles</code>、<code>Events</code>、<code>Fonts</code>、<code>Graphics</code>。</p>
<ul>
<li><p><code>Script Info</code>：包含了脚本的头部和总体信息。<code>Script Info</code> 必须是 v4 版本脚本的第一行。</p>
</li>
<li><p><code>v4+ Styles</code>：包含了所有样式的定义。每一个被脚本使用的样式都应该在这里定义。<br>ASS 使用 <code>v4+ Styles</code>。</p>
</li>
<li><p><code>Events</code>：包含了所有脚本的事件，有字幕、注释、图片、声音、影像和命令。基本上，所有在屏幕上看到的内容都在这一部分。</p>
</li>
<li><p><code>Fonts</code>：包含了脚本中内嵌字体的信息。</p>
</li>
<li><p><code>Graphics</code>：包含了脚本中内嵌图片的信息。</p>
</li>
</ul>
<p><strong>2. SSA字幕范例</strong></p>
<p>SSA字幕样本范例如下：</p>
<p><img src="/img/mv1.12.png"></p>
<p><a target="_blank" rel="noopener" href="https://wiki.multimedia.cx/index.php/SubStation_Alpha">参考链接</a></p>
<hr>
<h1 id="5-视频封装格式篇"><a href="#5-视频封装格式篇" class="headerlink" title="5. 视频封装格式篇"></a>5. 视频封装格式篇</h1><h2 id="5-1-FLV"><a href="#5-1-FLV" class="headerlink" title="5.1 FLV"></a>5.1 FLV</h2><p><strong>1. FLV的封装格式</strong></p>
<p><code>FLV</code>（Flash Video），Adobe公司设计开发的一种流行的流媒体格式，由于其视频文件体积轻巧、封装简单等特点，使其很适合在互联网上进行应用。除了播放视频，在直播时也可以使用。采用FLV格式封装的文件后缀为<code>.flv</code>，格式如下（<code>FLV = FLV Header + Body</code>）</p>
<p><img src="/img/mv1.13.png"></p>
<p><strong>2. FLV Header</strong></p>
<p>Header 部分记录了FLV的类型、版本、流信息、Header 长度等。<br>一般整个Header占用<code>9</code>个字节，大于9个字节则表示头部信息在这基础之上还存在扩展数据。<br>FLV Header 的信息排布如下所示：</p>
<p><img src="/img/mv1.14.png"></p>
<p><strong>3. FLV Body</strong></p>
<p>Body 是由一个个<code>Tag</code>组成的，每个Tag下面有一块<code>4</code>个字节的空间，用来记录这个Tag 的长度。<br>这个后置的<code>PreviousTagSize</code>用于<code>逆向</code>读取处理，表示的是前面的Tag的大小。<br>FLV Body 的信息排布如下：</p>
<p><img src="/img/mv1.15.png"></p>
<p><strong>4. FLV Tag</strong></p>
<p>每个Tag 也是由两部分组成的：<code>Tag Header</code> 和 <code>Tag Data</code>。<br>Tag Header 存放了当前Tag的类型，数据长度、时间戳、时间戳扩展、StreamsID等信息，然后再接着数据区Tag Data。<br>Tag的排布如下：</p>
<p><img src="/img/mv1.16.png"></p>
<p><strong>5. Tag Data</strong></p>
<p>Tag Data分成 <code>Audio</code>，<code>Video</code>，<code>Script</code> 三种。</p>
<p><strong>5.1 Audio Tag Data</strong></p>
<p>音频的Tag Data又分为 <code>AudioTagHeader</code> 和 <code>Data</code> 数据区，其排布结构如下图所示：</p>
<p><img src="/img/mv1.17.png"></p>
<p><strong>5.2 Video Tag Data</strong></p>
<ul>
<li>Video Tag 由<code>一个字节的VideoTagHeader</code> 和 <code>Video数据区</code>部分组成</li>
</ul>
<p><img src="/img/mv1.18.png"></p>
<ul>
<li>Video数据区部分格式不确定。对于<code>AVC (H.264)</code>编码部分，Video数据区排布如下:</li>
</ul>
<p><img src="/img/mv1.19.png"></p>
<p><strong>5.3 Script Tag Data</strong></p>
<p><img src="/img/mv1.20.png"></p>
<h2 id="5-2-TS"><a href="#5-2-TS" class="headerlink" title="5.2 TS"></a>5.2 TS</h2><blockquote>
<p><code>TS</code>（Transport Stream，<code>传输流</code>），一种常见的视频封装格式，是基于<code>MPEG-2</code>的封装格式（所以也叫<code>MPEG-TS</code>），后缀为<code>.ts</code>。</p>
</blockquote>
<p><strong>1. TS的分层结构</strong></p>
<p>TS文件分为三层，如下所示（可以倒序看更好理解）：</p>
<ul>
<li><p><code>TS层</code>（Transport Stream）<br>在PES层基础上加入了数据流识别信息和传输信息。</p>
</li>
<li><p><code>PES层</code>（Packet Elemental Stream）<br>在ES层基础上加入时间戳（PTS&#x2F;DTS）等信息。</p>
</li>
<li><p><code>ES层</code>（Elementary Stream）<br>压缩编码后的音视频数据。</p>
</li>
</ul>
<p><img src="/img/mv1.21.png"></p>
<p><strong>2. TS层</strong></p>
<blockquote>
<p>ts包大小<code>固定为188字节</code> ，ts层分为三个部分：<code>ts header</code>、<code>adaptation field</code>、<code>payload</code>。</p>
</blockquote>
<ul>
<li><p><code>ts header</code>固定<code>4</code>个字节；</p>
</li>
<li><p><code>adaptation field</code>可能存在也可能不存在，主要作用是给不足188字节的数据做<code>填充</code>。</p>
</li>
<li><p><code>payload</code>是 <code>PES</code> 数据，或者<code>PAT</code>，<code>PMT</code>等。</p>
</li>
</ul>
<p>◆ ts Header + adaptation field 格式如下：</p>
<p><img src="/img/mv1.22.png"></p>
<p><strong>2.1 TS Header</strong></p>
<ul>
<li>TS Header格式如下：</li>
</ul>
<p><img src="/img/mv1.23.png"></p>
<ul>
<li><code>pid</code> 决定了<code>负载内容</code>的类型，主要包括：PAT表，PMT表，视频流，音频流。常用的PID值：</li>
</ul>
<table>
<thead>
<tr>
<th>表</th>
<th>PAT</th>
<th>CAT</th>
<th>TSDT</th>
<th>EIT,ST</th>
<th>RST,ST</th>
<th>TDT,TOT,ST</th>
</tr>
</thead>
<tbody><tr>
<td>PID</td>
<td>0x0000</td>
<td>0x0001</td>
<td>0x0002</td>
<td>0x0012</td>
<td>0x0013</td>
<td>0x0014</td>
</tr>
</tbody></table>
<p><strong>2.2 调整字段</strong></p>
<p><img src="/img/mv1.24.png"></p>
<p><strong>2.3 PAT表结构（指明PMT表的PID值）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TS_PAT</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> table_id                 :<span class="number">8</span>  <span class="comment">//固定位0x00，表示该表是PAT</span></span><br><span class="line">    <span class="type">unsigned</span> section_syntax_indicator :<span class="number">1</span>  <span class="comment">//段语法标志，固定为1</span></span><br><span class="line">    <span class="type">unsigned</span> zero                     :<span class="number">1</span>  <span class="comment">//固定为0</span></span><br><span class="line">    <span class="type">unsigned</span> reserved_1               :<span class="number">2</span>  <span class="comment">//第一个保留位</span></span><br><span class="line">    <span class="type">unsigned</span> section_length           :<span class="number">12</span> <span class="comment">//表示这个字节之后有用的字节数，包括CRC_32</span></span><br><span class="line">    <span class="type">unsigned</span> transport_stream_id      :<span class="number">16</span> <span class="comment">//传输流的ID，区别于一个网络中其他多路复用的流</span></span><br><span class="line">    <span class="type">unsigned</span> reserved_2               :<span class="number">2</span>  <span class="comment">//第二个保留位</span></span><br><span class="line">    <span class="type">unsigned</span> version_number           :<span class="number">5</span>  <span class="comment">//表示PAT的版本号</span></span><br><span class="line">    <span class="type">unsigned</span> current_next_indicator   :<span class="number">1</span>  <span class="comment">//表示发送的PAT是当前有效还是下一个有效，为1时代表当前有效</span></span><br><span class="line">    <span class="type">unsigned</span> section_number           :<span class="number">8</span>  <span class="comment">//如果PAT分段传输，那么此值每次递增1</span></span><br><span class="line">    <span class="type">unsigned</span> last_section_number      :<span class="number">8</span>  <span class="comment">//最后一个分段的号码</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">unsigned</span> Program_number           :<span class="number">16</span> <span class="comment">//节目号</span></span><br><span class="line">        <span class="type">unsigned</span> Reversed_3               :<span class="number">3</span>  <span class="comment">//保留位</span></span><br><span class="line">        <span class="keyword">if</span>(Program_number == <span class="number">0</span>)</span><br><span class="line">            Network_id                    :<span class="number">13</span> <span class="comment">//网络信息表（NIT）的PID</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Program_MAP_PID               :<span class="number">13</span> <span class="comment">//节目映射表的PID，每个节目都有一个</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> CRC_32                   :<span class="number">32</span> <span class="comment">//CRC32校检码</span></span><br><span class="line">&#125;TS_PAT</span><br></pre></td></tr></table></figure>

<p><strong>2.4 PMT表（指明音视频流的PID值）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TS_program_map_section</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> Table_id                    :<span class="number">8</span>  <span class="comment">//标志PSI分段的内容，对于PMT，此值为0x02</span></span><br><span class="line">    <span class="type">unsigned</span> Section_syntax_indicator    :<span class="number">1</span>  <span class="comment">//置为1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="string">&#x27;0&#x27;</span>                         :<span class="number">1</span></span><br><span class="line">    <span class="type">unsigned</span> Reserved                    :<span class="number">2</span>  <span class="comment">//保留位</span></span><br><span class="line">    <span class="type">unsigned</span> Section_length              :<span class="number">12</span> <span class="comment">//指明了自此到最后CRC_32的字节数</span></span><br><span class="line">    <span class="type">unsigned</span> Program_number              :<span class="number">16</span> <span class="comment">//指出该节目的节目号，与PAT表对应</span></span><br><span class="line">    <span class="type">unsigned</span> Reserved                    :<span class="number">2</span>  <span class="comment">//保留位</span></span><br><span class="line">    <span class="type">unsigned</span> Version_number              :<span class="number">5</span>  <span class="comment">//取值0-31，代表当前PMT的版本号</span></span><br><span class="line">    <span class="type">unsigned</span> Current_next_indicator      :<span class="number">1</span>  <span class="comment">//代表当前PMT是否有效</span></span><br><span class="line">    <span class="type">unsigned</span> Section_number              :<span class="number">8</span>  <span class="comment">//给出了当前所处段的数目</span></span><br><span class="line">    <span class="type">unsigned</span> Last_section_number         :<span class="number">8</span>  <span class="comment">//给出了最后一个分段，即分段的最大数目</span></span><br><span class="line">    <span class="type">unsigned</span> Reserved                    :<span class="number">3</span>  <span class="comment">//保留位</span></span><br><span class="line">    <span class="type">unsigned</span> PCR_PID                     :<span class="number">13</span> <span class="comment">//指示TS包的PCR值，该TS包含有PCR字段</span></span><br><span class="line">    <span class="type">unsigned</span> Reserved                    :<span class="number">4</span>  <span class="comment">//保留位</span></span><br><span class="line">    <span class="type">unsigned</span> Program_info_length         :<span class="number">12</span> <span class="comment">//该字段描述跟随其后对节目信息描述的字节数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">Descriptr</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="type">unsigned</span> Stream_type             :<span class="number">8</span>  <span class="comment">//0x00：保留， 0x01：MPEG1视频，0x02：MPEG2视频，0x03:MPEG1音频，0x04：MPEG2音频，0x05：私有字段，0x06：含有私有数据的PES包 ......</span></span><br><span class="line">        <span class="type">unsigned</span> Reserved                :<span class="number">3</span>  <span class="comment">//保留</span></span><br><span class="line">        <span class="type">unsigned</span> Elementary_PID          :<span class="number">13</span> <span class="comment">//指示TS包的PID，这些TS包含有相同的PID</span></span><br><span class="line">        <span class="type">unsigned</span> Reserved                :<span class="number">4</span>  <span class="comment">//保留</span></span><br><span class="line">        <span class="type">unsigned</span> ES_info_length          :<span class="number">12</span> <span class="comment">//指示跟随其后描述相关节目元素的字节数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N2; j++)</span><br><span class="line">            <span class="built_in">Descriptr</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> CRC_32                      :<span class="number">32</span> <span class="comment">//循环校检位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.5 补充</strong></p>
<ul>
<li><p>打包ts流时<code>PAT</code>和<code>PMT</code>表是没有调整字段的，不够的长度直接补<code>0xff</code>即可。</p>
</li>
<li><p><code>视频流</code>和<code>音频流</code>都需要加<code>adaptation field</code>，<font color = red>通常加在一个帧的第一个ts包和最后一个ts包里，中间的ts包不加。</font></p>
</li>
</ul>
<p><strong>3. PES 层</strong></p>
<ul>
<li><p><code>PES</code>（Packetized Elementary Stream，打包的ES），在 ES 层的基础上加入了时间戳（PTS&#x2F;TDS）等信息。</p>
</li>
<li><p>ES数据包比较大，加入PES头时需<code>将ES进行分割</code>，只在<code>第一个分割的ES上加PES头</code>，如下图所示</p>
</li>
</ul>
<p><img src="/img/mv1.25.png"></p>
<ul>
<li><p><code>PES packet length</code> — 指示PES 包中跟随该字段最后字节的字节数。0 值指示PES 包长度既未指示也未限定并且仅在这样的PES 包中才被允许，该PES 包的有效载荷由来自传输流包中所包含的视频基本流的字节组成。</p>
</li>
<li><p>PES结构如下：</p>
</li>
</ul>
<p><img src="/img/mv1.26.png"></p>
<ul>
<li>PES 关键字段说明</li>
</ul>
<p><img src="/img/mv1.27.png"></p>
<p><strong>4. ES 层</strong></p>
<ul>
<li><p><code>ES</code>（Elementary Stream，基本码流），就是<code>音视频编码数据流</code>，比如视频<code>H.264</code>，音频<code>AAC</code>。</p>
</li>
<li><p><font color = red>一个 ES 流中只包含一种类型的数据（视频，或音频，或字幕）。</font></p>
</li>
</ul>
<p><strong>5. easyice下载链接：</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.easyice.cn/archives/85">easyice</a></p>
<h2 id="5-3-MP4"><a href="#5-3-MP4" class="headerlink" title="5.3 MP4"></a>5.3 MP4</h2><p><strong>1. MP4（MPEG-4）</strong></p>
<blockquote>
<p><code>MP4</code>是一套用于音频、视频信息的<code>压缩编码标准</code>，由国际标准化组织（ISO）和国际电工委员会（IEC）下属的“动态图像专家组”（Moving Picture Experts Group，即MPEG）制定，第一版在1998年10月通过，第二版在1999年12月通过。MPEG-4格式的主要用途在于网上流、光盘、语音发送（视频电话），以及电视广播。</p>
</blockquote>
<ul>
<li>MP4由许多<code>box</code>组成，每个box包含不同的信息，这些box以<code>树形结构</code>的方式组成，<code>box 中可以包含 box</code><br> 如下：</li>
</ul>
<p><img src="/img/mv1.28.png"></p>
<p><strong>2. box</strong></p>
<p>mp4文件由若干个box组成。下面是box结构的一个示意图：</p>
<p><img src="/img/mv1.29.png"></p>
<ul>
<li><p>box 由 <code>header</code> 和 <code>body</code> 组成<br>header 指明 box 的 size 和 type。<font color = blue>size 是包含 box header 的整个 box 的大小。</font></p>
</li>
<li><p><code>box type</code>，通常是4个ASCII码的字符如<code>ftyp</code>、<code>moov</code>等，这些 box type都是已经预定义好的，表示固定的含义。<br>如果是<code>uuid</code>，表示该box为用户自定义扩展类型<br>如果 box type 是未定义的，应该将其忽略。</p>
</li>
<li><p>如果 header 中的 size 为<code>1</code>，则表示 box 长度需要更多的bits位来描述，在后面会有一个 8字节的 largesize 用来描述 box 的长度。<br>如果 size 为<code>0</code>，表示该 box 为文件的最后一个box，文件结尾（同样只存在于<code>mdat</code>类型的box中）。</p>
</li>
<li><p>box 分为两种，<code>Box</code> 和 <code>Fullbox</code>。FullBox 是 Box 的扩展，Header 中增加了<code>version</code> 和 <code>flags</code>字段。</p>
</li>
</ul>
<p>◆ box 定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">aligned</span>(<span class="number">8</span>) <span class="function"><span class="keyword">class</span> <span class="title">Box</span> <span class="params">(<span class="type">unsigned</span> <span class="type">int</span>(<span class="number">32</span>) boxtype,</span></span></span><br><span class="line"><span class="params"><span class="function">    optional <span class="type">unsigned</span> <span class="type">int</span>(<span class="number">8</span>)[<span class="number">16</span>] extended_type)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> size</span>;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> type </span>= boxtype;</span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="type">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> largesize</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size==<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// box extends to end of file</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (boxtype==‘uuid’) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="built_in">int</span>(<span class="number">8</span>)[<span class="number">16</span>] usertype = extended_type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>◆ FullBox 定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">aligned</span>(<span class="number">8</span>) <span class="function"><span class="keyword">class</span> <span class="title">FullBox</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>(<span class="number">32</span>) boxtype, <span class="type">unsigned</span> <span class="type">int</span>(<span class="number">8</span>) v, bit(<span class="number">24</span>) f)</span></span></span><br><span class="line"><span class="function">extends <span class="title">Box</span><span class="params">(boxtype)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">8</span>)</span> version </span>= v;</span><br><span class="line">    <span class="built_in">bit</span>(<span class="number">24</span>) flags = f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. ISO&#x2F;ICE 14496-12</strong></p>
<p><img src="/img/mv1.30.png"></p>
<p><strong>4. MP4分析工具：</strong></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://gpac.github.io/mp4box.js">mp4box.js</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.bento4.com/">bento4</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.greenxf.com/soft/179781.html">mp4info</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://api.256file.com/download/378144_qtatomviewer.exe">qtauomviewer</a></p>
</li>
</ul>
<hr>
<h1 id="6-FFmpeg篇"><a href="#6-FFmpeg篇" class="headerlink" title="6. FFmpeg篇"></a>6. FFmpeg篇</h1><h2 id="6-1-安装"><a href="#6-1-安装" class="headerlink" title="6.1 安装"></a>6.1 安装</h2><p><a target="_blank" rel="noopener" href="https://github.com/FFmpeg/FFmpeg">FFmpeg源码地址</a></p>
<p><a target="_blank" rel="noopener" href="https://ffmpeg.org/download.html">FFmpeg可执行文件地址</a></p>
<ul>
<li><p>ffmpeg.exe：用于音视频<code>转码</code>, 也可以从url&#x2F;现场音频&#x2F;视频源抓取输入源。</p>
</li>
<li><p>ffplay.exe：一个非常简单和可移植的媒体播放器，使用<code>FFmpeg库</code>和<code>SDL库</code>。</p>
</li>
<li><p>ffprobe.exe：查看多媒体文件的<code>信息</code>。</p>
</li>
</ul>
<h2 id="6-2-ffmpeg-ffplay-ffprobe"><a href="#6-2-ffmpeg-ffplay-ffprobe" class="headerlink" title="6.2 ffmpeg, ffplay, ffprobe"></a>6.2 ffmpeg, ffplay, ffprobe</h2><p><strong>1. ffmpeg.exe</strong></p>
<ul>
<li><p>用于音视频<code>转码</code>, 也可以从url&#x2F;现场音频&#x2F;视频源抓取输入源等。一部分ffmpeg常用参数如下（尤其在开发过程中，由于ffmpeg版本不同，ffmpeg参数也有少量出入，建议在命令行窗口输入<code>ffmpeg -h</code>查看本机部署的ffmpeg支持的参数）：</p>
</li>
<li><p>ffmpeg 部分参数</p>
</li>
</ul>
<p><img src="/img/mv1.31.png"></p>
<ul>
<li><code>ffmpeg -h</code>查看参数如下：</li>
</ul>
<p><img src="/img/mv1.32.png"></p>
<ul>
<li>ffmpeg 范例</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从视频第3秒开始剪切，持续4秒，并保存文件</span></span><br><span class="line">ffmpeg -ss <span class="number">00</span>:<span class="number">00</span>:<span class="number">03</span> -t <span class="number">00</span>:<span class="number">00</span>:<span class="number">04</span> -i test.mpg -vcodec copy -acodec copy test_cut.mpg</span><br><span class="line"><span class="comment">//test.mpg 裁剪后 生成 test_cut.mpg</span></span><br></pre></td></tr></table></figure>

<p><strong>2. ffplay</strong></p>
<ul>
<li>一个非常简单和可移植的媒体播放器，使用<code>FFmpeg库和SDL库</code>。ffplay参数如下：</li>
</ul>
<p><img src="/img/mv1.33.png"></p>
<p>ffplay.exe范例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//播放视频</span></span><br><span class="line">ffplay -i test.mpg</span><br></pre></td></tr></table></figure>

<p><strong>3. ffprobe.exe</strong></p>
<ul>
<li>查看多媒体文件的信息。ffprobe参数如下：</li>
</ul>
<p><img src="/img/mv1.34.png"></p>
<p>ffprobe.exe范例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看视频文件的音频流和视频流信息</span></span><br><span class="line">ffprobe test.mpg</span><br></pre></td></tr></table></figure>



<h2 id="6-3-解码"><a href="#6-3-解码" class="headerlink" title="6.3 解码"></a>6.3 解码</h2><p>正式进入FFmpeg代码的学习。结合代码的形式介绍<code>FFmpeg的解码流程</code>和<code>SDL2播放流程</code>。</p>
<p><strong>1. 环境</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/BtbN/FFmpeg-Builds/releases"> FFmpeg 开发库下载地址(shared)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.libsdl.org/download-2.0.php">SDL 开发库下载地址(选择Development Libraries VC.zip) </a></p>
<p><strong>2. 音视频解码</strong></p>
<p>音视频<code>解码</code>流程，以及相关的 <code>ffmpeg</code> 代码如下</p>
<p><img src="/img/mv1.35.png"></p>
<p><strong>3. 音视频播放</strong></p>
<p>Windows平台使用<code>SDL2</code>来<code>播放</code>音视频，调用流程及相关代码如下</p>
<p><img src="/img/mv1.36.png"></p>
<p><strong>4. 视频解码代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:output_log.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUF_LEN 1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_log_debug_flag = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> g_log_info_flag = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> g_log_warnning_flag = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> g_log_error_flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LOG_LEVEL</span></span><br><span class="line">  &#123;</span><br><span class="line">    LOG_DEBUG,</span><br><span class="line">    LOG_INFO,</span><br><span class="line">    LOG_WARNING,</span><br><span class="line">    LOG_ERROR</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_log_flag</span><span class="params">(<span class="type">int</span> log_debug_flag, <span class="type">int</span> log_info_flag, <span class="type">int</span> log_warnning_flag, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span> log_error_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  g_log_debug_flag = log_debug_flag;</span><br><span class="line">  g_log_info_flag = log_info_flag;</span><br><span class="line">  g_log_warnning_flag = log_warnning_flag;</span><br><span class="line">  g_log_error_flag = log_error_flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_log</span><span class="params">(LOG_LEVEL log_level, <span class="type">const</span> <span class="type">char</span>* fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  va_list args;</span><br><span class="line">  <span class="built_in">va_start</span>(args, fmt);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[MAX_BUF_LEN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="built_in">vsnprintf</span>(buf, MAX_BUF_LEN - <span class="number">1</span>, fmt, args);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (log_level)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> LOG_DEBUG:</span><br><span class="line">    <span class="keyword">if</span> (g_log_debug_flag)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[Log-Debug]:%s\n&quot;</span>, buf);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> LOG_INFO:</span><br><span class="line">    <span class="keyword">if</span> (g_log_info_flag)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[Log-Info]:%s\n&quot;</span>, buf);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> LOG_WARNING:</span><br><span class="line">    <span class="keyword">if</span> (g_log_warnning_flag)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[Log-Warnning]:%s\n&quot;</span>, buf);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> LOG_ERROR:</span><br><span class="line">    <span class="keyword">if</span> (g_log_error_flag)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[Log-Error]:%s\n&quot;</span>, buf);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">va_end</span>(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:vPlayer_sdl2.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vPlayer_sdl2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;output_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STDC_CONSTANT_MACROS</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libswscale/swscale.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/imgutils.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SDL.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_frame_rate = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_sfp_refresh_thread_exit = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_sfp_refresh_thread_pause = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SFM_REFRESH_EVENT (SDL_USEREVENT+1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SFM_BREAK_EVENT (SDL_USEREVENT+2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">FFmpeg_V_Param_T</span></span><br><span class="line">&#123;</span><br><span class="line">  AVFormatContext *pFormatCtx;</span><br><span class="line">  AVCodecContext *pCodecCtx;</span><br><span class="line">  SwsContext *pSwsCtx;</span><br><span class="line">  <span class="type">int</span> video_index;</span><br><span class="line">&#125;FFmpeg_V_Param;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SDL_Param_T</span></span><br><span class="line">&#123;</span><br><span class="line">  SDL_Window *p_sdl_window;</span><br><span class="line">  SDL_Renderer *p_sdl_renderer;</span><br><span class="line">  SDL_Texture *p_sdl_texture;</span><br><span class="line">  SDL_Rect sdl_rect;</span><br><span class="line">  SDL_Thread *p_sdl_thread;</span><br><span class="line">&#125;SDL_Param;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  return value:zero(success) non-zero(failure)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init_ffmpeg</span><span class="params">(FFmpeg_V_Param* p_ffmpeg_param, <span class="type">char</span>* filePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//init FFmpeg_V_Param</span></span><br><span class="line">  p_ffmpeg_param-&gt;pFormatCtx = <span class="built_in">avformat_alloc_context</span>();</span><br><span class="line">  <span class="type">const</span> AVCodec *pCodec = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//do global initialization of network libraries</span></span><br><span class="line">  <span class="built_in">avformat_network_init</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//open input stream</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">avformat_open_input</span>(&amp;(p_ffmpeg_param-&gt;pFormatCtx), filePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">output_log</span>(LOG_ERROR, <span class="string">&quot;avformat_open_input error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//find stream info</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">avformat_find_stream_info</span>(p_ffmpeg_param-&gt;pFormatCtx, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">output_log</span>(LOG_ERROR, <span class="string">&quot;avformat_find_stream_info error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//get video pCodecParms, codec and frame rate</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p_ffmpeg_param-&gt;pFormatCtx-&gt;nb_streams; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    AVStream *pStream = p_ffmpeg_param-&gt;pFormatCtx-&gt;streams[i];</span><br><span class="line">    <span class="keyword">if</span> (pStream-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO)</span><br><span class="line">    &#123;</span><br><span class="line">      pCodec = <span class="built_in">avcodec_find_decoder</span>(pStream-&gt;codecpar-&gt;codec_id);</span><br><span class="line">      p_ffmpeg_param-&gt;pCodecCtx = <span class="built_in">avcodec_alloc_context3</span>(pCodec);</span><br><span class="line">      <span class="built_in">avcodec_parameters_to_context</span>(p_ffmpeg_param-&gt;pCodecCtx, pStream-&gt;codecpar);</span><br><span class="line">      g_frame_rate = pStream-&gt;avg_frame_rate.num / pStream-&gt;avg_frame_rate.den;</span><br><span class="line">      p_ffmpeg_param-&gt;video_index = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!p_ffmpeg_param-&gt;pCodecCtx)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">output_log</span>(LOG_ERROR, <span class="string">&quot;could not find video codecCtx&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//open codec</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">avcodec_open2</span>(p_ffmpeg_param-&gt;pCodecCtx, pCodec, <span class="literal">NULL</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">output_log</span>(LOG_ERROR, <span class="string">&quot;avcodec_open2 error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//get scale pixelformat context</span></span><br><span class="line">  p_ffmpeg_param-&gt;pSwsCtx = <span class="built_in">sws_getContext</span>(p_ffmpeg_param-&gt;pCodecCtx-&gt;width,</span><br><span class="line">    p_ffmpeg_param-&gt;pCodecCtx-&gt;height, p_ffmpeg_param-&gt;pCodecCtx-&gt;pix_fmt,</span><br><span class="line">    p_ffmpeg_param-&gt;pCodecCtx-&gt;width, p_ffmpeg_param-&gt;pCodecCtx-&gt;height,</span><br><span class="line">    AV_PIX_FMT_YUV420P,  SWS_BICUBIC, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">av_dump_format</span>(p_ffmpeg_param-&gt;pFormatCtx, p_ffmpeg_param-&gt;video_index, filePath, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  return value:zero(success) non-zero(failure)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">release_ffmpeg</span><span class="params">(FFmpeg_V_Param* p_ffmpeg_param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p_ffmpeg_param)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//realse scale pixelformat context</span></span><br><span class="line">  <span class="keyword">if</span> (p_ffmpeg_param-&gt;pSwsCtx)</span><br><span class="line">    <span class="built_in">sws_freeContext</span>(p_ffmpeg_param-&gt;pSwsCtx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//close codec</span></span><br><span class="line">  <span class="keyword">if</span> (p_ffmpeg_param-&gt;pCodecCtx)</span><br><span class="line">    <span class="built_in">avcodec_close</span>(p_ffmpeg_param-&gt;pCodecCtx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//close input stream</span></span><br><span class="line">  <span class="keyword">if</span> (p_ffmpeg_param-&gt;pFormatCtx)</span><br><span class="line">    <span class="built_in">avformat_close_input</span>(&amp;(p_ffmpeg_param-&gt;pFormatCtx));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//free AVCodecContext</span></span><br><span class="line">  <span class="keyword">if</span> (p_ffmpeg_param-&gt;pCodecCtx)</span><br><span class="line">    <span class="built_in">avcodec_free_context</span>(&amp;(p_ffmpeg_param-&gt;pCodecCtx));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//free AVFormatContext</span></span><br><span class="line">  <span class="keyword">if</span> (p_ffmpeg_param-&gt;pFormatCtx)</span><br><span class="line">    <span class="built_in">avformat_free_context</span>(p_ffmpeg_param-&gt;pFormatCtx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//free FFmpeg_V_Param</span></span><br><span class="line">  <span class="keyword">delete</span> p_ffmpeg_param;</span><br><span class="line">  p_ffmpeg_param = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sfp_refresh_thread</span><span class="params">(<span class="type">void</span>* opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  g_sfp_refresh_thread_exit = <span class="number">0</span>;</span><br><span class="line">  g_sfp_refresh_thread_pause = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!g_sfp_refresh_thread_exit)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_sfp_refresh_thread_pause)</span><br><span class="line">    &#123;</span><br><span class="line">      SDL_Event sdl_event;</span><br><span class="line">      sdl_event.type = SFM_REFRESH_EVENT;</span><br><span class="line">      <span class="built_in">SDL_PushEvent</span>(&amp;sdl_event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SDL_Delay</span>(<span class="number">1000</span> / g_frame_rate);</span><br><span class="line">  &#125;</span><br><span class="line">  g_sfp_refresh_thread_exit = <span class="number">0</span>;</span><br><span class="line">  g_sfp_refresh_thread_pause = <span class="number">0</span>;</span><br><span class="line">  SDL_Event sdl_event;</span><br><span class="line">  sdl_event.type = SFM_BREAK_EVENT;</span><br><span class="line">  <span class="built_in">SDL_PushEvent</span>(&amp;sdl_event);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init_sdl2</span><span class="params">(SDL_Param_T *p_sdl_param, <span class="type">int</span> screen_w, <span class="type">int</span> screen_h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">SDL_Init</span>(SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_TIMER))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">output_log</span>(LOG_ERROR, <span class="string">&quot;SDL_Init error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  p_sdl_param-&gt;p_sdl_window = <span class="built_in">SDL_CreateWindow</span>(<span class="string">&quot;vPlayer_sdl&quot;</span>, SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">    SDL_WINDOWPOS_UNDEFINED, screen_w, screen_h, SDL_WINDOW_OPENGL);</span><br><span class="line">  <span class="keyword">if</span> (!p_sdl_param-&gt;p_sdl_window)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">output_log</span>(LOG_ERROR, <span class="string">&quot;SDL_CreateWindow error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  p_sdl_param-&gt;p_sdl_renderer = <span class="built_in">SDL_CreateRenderer</span>(p_sdl_param-&gt;p_sdl_window, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  p_sdl_param-&gt;p_sdl_texture = <span class="built_in">SDL_CreateTexture</span>(p_sdl_param-&gt;p_sdl_renderer, SDL_PIXELFORMAT_IYUV,</span><br><span class="line">    SDL_TEXTUREACCESS_STREAMING, screen_w, screen_h);</span><br><span class="line">  p_sdl_param-&gt;sdl_rect.x = <span class="number">0</span>;</span><br><span class="line">  p_sdl_param-&gt;sdl_rect.y = <span class="number">0</span>;</span><br><span class="line">  p_sdl_param-&gt;sdl_rect.w = screen_w;</span><br><span class="line">  p_sdl_param-&gt;sdl_rect.h = screen_h;</span><br><span class="line">  p_sdl_param-&gt;p_sdl_thread = <span class="built_in">SDL_CreateThread</span>(sfp_refresh_thread, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">release_sdl2</span><span class="params">(SDL_Param_T *p_sdl_param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">SDL_DestroyTexture</span>(p_sdl_param-&gt;p_sdl_texture);</span><br><span class="line">  <span class="built_in">SDL_DestroyRenderer</span>(p_sdl_param-&gt;p_sdl_renderer);</span><br><span class="line">  <span class="built_in">SDL_DestroyWindow</span>(p_sdl_param-&gt;p_sdl_window);</span><br><span class="line">  <span class="built_in">SDL_Quit</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vPlayer_sdl2</span><span class="params">(<span class="type">char</span>* filePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//ffmpeg param</span></span><br><span class="line">  FFmpeg_V_Param *p_ffmpeg_param = <span class="literal">NULL</span>;</span><br><span class="line">  AVPacket *packet = <span class="literal">NULL</span>;</span><br><span class="line">  AVFrame *pFrame = <span class="literal">NULL</span>, *pFrameYUV = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> out_buffer_size = <span class="number">0</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>* out_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//sdl param</span></span><br><span class="line">  SDL_Param_T *p_sdl_param = <span class="literal">NULL</span>;</span><br><span class="line">  SDL_Event sdl_event;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//init ffmpeg</span></span><br><span class="line">  p_ffmpeg_param = <span class="keyword">new</span> <span class="built_in">FFmpeg_V_Param</span>();</span><br><span class="line">  <span class="built_in">memset</span>(p_ffmpeg_param, <span class="number">0</span>, <span class="built_in">sizeof</span>(FFmpeg_V_Param));</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">init_ffmpeg</span>(p_ffmpeg_param, filePath))</span><br><span class="line">  &#123;</span><br><span class="line">    ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">  &#125;</span><br><span class="line">  packet = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line">  pFrame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">  pFrameYUV = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">  out_buffer_size = <span class="built_in">av_image_get_buffer_size</span>(AV_PIX_FMT_YUV420P,</span><br><span class="line">    p_ffmpeg_param-&gt;pCodecCtx-&gt;width, p_ffmpeg_param-&gt;pCodecCtx-&gt;height, <span class="number">1</span>);</span><br><span class="line">  out_buffer = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">av_malloc</span>(out_buffer_size);</span><br><span class="line">  <span class="built_in">av_image_fill_arrays</span>(pFrameYUV-&gt;data, pFrameYUV-&gt;linesize, out_buffer,</span><br><span class="line">    p_ffmpeg_param-&gt;pCodecCtx-&gt;pix_fmt, </span><br><span class="line">    p_ffmpeg_param-&gt;pCodecCtx-&gt;width, p_ffmpeg_param-&gt;pCodecCtx-&gt;height, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//init sdl2</span></span><br><span class="line">  p_sdl_param = <span class="keyword">new</span> <span class="built_in">SDL_Param_T</span>();</span><br><span class="line">  <span class="built_in">memset</span>(p_sdl_param, <span class="number">0</span>, <span class="built_in">sizeof</span>(SDL_Param_T));</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">init_sdl2</span>(p_sdl_param, p_ffmpeg_param-&gt;pCodecCtx-&gt;width, p_ffmpeg_param-&gt;pCodecCtx-&gt;height))</span><br><span class="line">  &#123;</span><br><span class="line">    ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//demuxing and show</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> temp_ret = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">SDL_WaitEvent</span>(&amp;sdl_event);</span><br><span class="line">    <span class="keyword">if</span> (sdl_event.type == SFM_REFRESH_EVENT)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">av_read_frame</span>(p_ffmpeg_param-&gt;pFormatCtx, packet) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          g_sfp_refresh_thread_exit = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (packet-&gt;stream_index == p_ffmpeg_param-&gt;video_index)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">avcodec_send_packet</span>(p_ffmpeg_param-&gt;pCodecCtx, packet))</span><br><span class="line">        g_sfp_refresh_thread_exit = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        temp_ret = <span class="built_in">avcodec_receive_frame</span>(p_ffmpeg_param-&gt;pCodecCtx, pFrame);</span><br><span class="line">        <span class="keyword">if</span> (temp_ret == AVERROR_EOF)</span><br><span class="line">        &#123;</span><br><span class="line">          g_sfp_refresh_thread_exit = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp_ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">sws_scale</span>(p_ffmpeg_param-&gt;pSwsCtx, (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* <span class="type">const</span>*)pFrame-&gt;data,</span><br><span class="line">            pFrame-&gt;linesize, <span class="number">0</span>, p_ffmpeg_param-&gt;pCodecCtx-&gt;height, pFrameYUV-&gt;data,</span><br><span class="line">            pFrameYUV-&gt;linesize);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="built_in">SDL_UpdateTexture</span>(p_sdl_param-&gt;p_sdl_texture, &amp;(p_sdl_param-&gt;sdl_rect),</span><br><span class="line">            pFrameYUV-&gt;data[<span class="number">0</span>], pFrameYUV-&gt;linesize[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="built_in">SDL_RenderClear</span>(p_sdl_param-&gt;p_sdl_renderer);</span><br><span class="line">          <span class="built_in">SDL_RenderCopy</span>(p_sdl_param-&gt;p_sdl_renderer, p_sdl_param-&gt;p_sdl_texture,</span><br><span class="line">            <span class="literal">NULL</span>, &amp;(p_sdl_param-&gt;sdl_rect));</span><br><span class="line">          <span class="built_in">SDL_RenderPresent</span>(p_sdl_param-&gt;p_sdl_renderer);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">while</span> (temp_ret != <span class="built_in">AVERROR</span>(EAGAIN));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//av_packet_unref(packet);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sdl_event.type == SFM_BREAK_EVENT)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sdl_event.type == SDL_KEYDOWN)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (sdl_event.key.keysym.sym == SDLK_SPACE)</span><br><span class="line">        g_sfp_refresh_thread_pause = !g_sfp_refresh_thread_pause;</span><br><span class="line">      <span class="keyword">if</span> (sdl_event.key.keysym.sym == SDLK_q)</span><br><span class="line">        g_sfp_refresh_thread_exit = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sdl_event.type == SDL_QUIT)</span><br><span class="line">    &#123;</span><br><span class="line">      g_sfp_refresh_thread_exit = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">  <span class="built_in">release_ffmpeg</span>(p_ffmpeg_param);</span><br><span class="line">  <span class="built_in">av_packet_free</span>(&amp;packet);</span><br><span class="line">  <span class="built_in">av_frame_free</span>(&amp;pFrame);</span><br><span class="line">  <span class="built_in">av_frame_free</span>(&amp;pFrameYUV);</span><br><span class="line">  <span class="built_in">release_sdl2</span>(p_sdl_param);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-4-编码"><a href="#6-4-编码" class="headerlink" title="6.4 编码"></a>6.4 编码</h2><p>日常开发过程中，我们涉及到的<code>主要是解码</code>相关内容，但FFmpeg同样具有<code>编码</code>的能力。简单介绍下FFmpeg编码的内容。</p>
<p><strong>1. FFmpeg编码视频</strong></p>
<p>使用FFmpeg库编码<code>YUV</code>，代码及调用逻辑如下</p>
<p><img src="/img/mv1.37.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:encode_yuv_to_h264.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;encode_yuv_to_h264.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;output_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define __STDC_CONSTANT_MACROS</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/opt.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/imgutils.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">encode</span><span class="params">(AVCodecContext* pCodecCtx, AVFrame *pFrame, AVPacket* pPacket, FILE* p_output_f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  ret = <span class="built_in">avcodec_send_frame</span>(pCodecCtx, pFrame);</span><br><span class="line">  <span class="keyword">while</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ret = <span class="built_in">avcodec_receive_packet</span>(pCodecCtx, pPacket);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="built_in">AVERROR</span>(EAGAIN) || ret == AVERROR_EOF)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">fwrite</span>(pPacket-&gt;data, <span class="number">1</span>, pPacket-&gt;size, p_output_f);</span><br><span class="line">    <span class="built_in">av_packet_unref</span>(pPacket);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//codec_name=&quot;libx264&quot;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">encode_yuv_to_h264</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* output_filePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  AVCodecContext* pCodecCtx = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">const</span> AVCodec* pCodec = <span class="literal">NULL</span>;</span><br><span class="line">  AVPacket* pPacket = <span class="literal">NULL</span>;</span><br><span class="line">  AVFrame* pFrame = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">char</span> codec_name[] = <span class="string">&quot;libx264&quot;</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> endcode[] = &#123; <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x7b</span> &#125;;</span><br><span class="line">  FILE* p_output_f = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> i, x, y;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  pCodec = <span class="built_in">avcodec_find_encoder_by_name</span>(codec_name);</span><br><span class="line">  <span class="comment">//pCodec = avcodec_find_encoder(AV_CODEC_ID_H264);</span></span><br><span class="line">  <span class="keyword">if</span> (!pCodec)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">output_log</span>(LOG_ERROR, <span class="string">&quot;avcodec_find_encoder_by_name error, codec_name=%s&quot;</span>, codec_name);</span><br><span class="line">    ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">  &#125;    </span><br><span class="line">  pCodecCtx = <span class="built_in">avcodec_alloc_context3</span>(pCodec);</span><br><span class="line">  <span class="keyword">if</span> (!pCodecCtx)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">output_log</span>(LOG_ERROR, <span class="string">&quot;avcodec_alloc_context3 error, pCodecCtx is NULL&quot;</span>);</span><br><span class="line">    ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">  &#125;</span><br><span class="line">  pPacket = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line">  pFrame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//set AVCodecContext parameters</span></span><br><span class="line">  pCodecCtx-&gt;bit_rate = <span class="number">400000</span>;</span><br><span class="line">  pCodecCtx-&gt;width = <span class="number">352</span>;</span><br><span class="line">  pCodecCtx-&gt;height = <span class="number">288</span>;</span><br><span class="line">  pCodecCtx-&gt;time_base = &#123; <span class="number">1</span>, <span class="number">25</span> &#125;;</span><br><span class="line">  pCodecCtx-&gt;framerate = &#123; <span class="number">25</span>, <span class="number">1</span> &#125;;</span><br><span class="line">  <span class="comment">/* emit one intra frame every ten frames</span></span><br><span class="line"><span class="comment">   * check frame pict_type before passing frame</span></span><br><span class="line"><span class="comment">   * to encoder, if frame-&gt;pict_type is AV_PICTURE_TYPE_I</span></span><br><span class="line"><span class="comment">   * then gop_size is ignored and the output of encoder</span></span><br><span class="line"><span class="comment">   * will always be I frame irrespective to gop_size</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  pCodecCtx-&gt;gop_size = <span class="number">10</span>;</span><br><span class="line">  pCodecCtx-&gt;max_b_frames = <span class="number">1</span>;</span><br><span class="line">  pCodecCtx-&gt;pix_fmt = AV_PIX_FMT_YUV420P;</span><br><span class="line">  <span class="keyword">if</span> (pCodec-&gt;id == AV_CODEC_ID_H264)</span><br><span class="line">    <span class="built_in">av_opt_set</span>(pCodecCtx-&gt;priv_data, <span class="string">&quot;preset&quot;</span>, <span class="string">&quot;slow&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//open codec</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">avcodec_open2</span>(pCodecCtx, pCodec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  pFrame-&gt;format = pCodecCtx-&gt;pix_fmt;</span><br><span class="line">  pFrame-&gt;width = pCodecCtx-&gt;width;</span><br><span class="line">  pFrame-&gt;height = pCodecCtx-&gt;height;</span><br><span class="line">  <span class="comment">//Allocate new buffer(s) for audio or video data.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">av_frame_get_buffer</span>(pFrame, <span class="number">32</span>) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">output_log</span>(LOG_ERROR, <span class="string">&quot;av_frame_get_buffer error&quot;</span>);</span><br><span class="line">    ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//open output_file</span></span><br><span class="line">  <span class="built_in">fopen_s</span>(&amp;p_output_f, output_filePath, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!p_output_f)</span><br><span class="line">  &#123;</span><br><span class="line">    ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//encode 5 seconds of video</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">25</span> * <span class="number">5</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//make sure the frame data is writeable</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">av_frame_is_writable</span>(pFrame) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ret = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Y</span></span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; pCodecCtx-&gt;height; y++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; pCodecCtx-&gt;width; x++)</span><br><span class="line">      &#123;</span><br><span class="line">        pFrame-&gt;data[<span class="number">0</span>][y*pFrame-&gt;linesize[<span class="number">0</span>] + x] = x + y + i * <span class="number">3</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Y and V</span></span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; pCodecCtx-&gt;height / <span class="number">2</span>; y++) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; pCodecCtx-&gt;width / <span class="number">2</span>; x++) </span><br><span class="line">      &#123;</span><br><span class="line">        pFrame-&gt;data[<span class="number">1</span>][y * pFrame-&gt;linesize[<span class="number">1</span>] + x] = <span class="number">128</span> + y + i * <span class="number">2</span>;</span><br><span class="line">        pFrame-&gt;data[<span class="number">2</span>][y * pFrame-&gt;linesize[<span class="number">2</span>] + x] = <span class="number">64</span> + x + i * <span class="number">5</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pFrame-&gt;pts = i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//encode this img</span></span><br><span class="line">    <span class="built_in">encode</span>(pCodecCtx, pFrame, pPacket, p_output_f);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//flush the encoder</span></span><br><span class="line">  <span class="built_in">encode</span>(pCodecCtx, <span class="literal">NULL</span>, pPacket, p_output_f);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//add sequence end code to have a real MPEG file</span></span><br><span class="line">  <span class="built_in">fwrite</span>(endcode, <span class="number">1</span>, <span class="built_in">sizeof</span>(endcode), p_output_f);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fclose</span>(p_output_f);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">  <span class="keyword">if</span> (pCodecCtx)</span><br><span class="line">    <span class="built_in">avcodec_free_context</span>(&amp;pCodecCtx);</span><br><span class="line">  <span class="keyword">if</span> (pPacket)</span><br><span class="line">    <span class="built_in">av_packet_free</span>(&amp;pPacket);</span><br><span class="line">  <span class="keyword">if</span> (pFrame)</span><br><span class="line">    <span class="built_in">av_frame_free</span>(&amp;pFrame);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;=============== encode_yuv_to_h264 done ===============\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. FFmpeg编码音频</strong></p>
<p>使用FFmpeg库编码<code>PCM</code>，代码及调用逻辑如下</p>
<p><img src="/img/mv1.38.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:encode_pcm_to_pm2.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;encode_pcm_to_mp2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;output_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/channel_layout.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/common.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/frame.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/samplefmt.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check that a given sample format is supported by the encoder */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">check_sample_fmt</span><span class="params">(<span class="type">const</span> AVCodec *pCodec, <span class="keyword">enum</span> AVSampleFormat sample_fmt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">enum</span> <span class="title class_">AVSampleFormat</span> *p = pCodec-&gt;sample_fmts;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*p != AV_SAMPLE_FMT_NONE) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (*p == sample_fmt)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    p++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* just pick the highest supported samplerate */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">select_sample_rate</span><span class="params">(<span class="type">const</span> AVCodec *pCodec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> *p;</span><br><span class="line">  <span class="type">int</span> best_samplerate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!pCodec-&gt;supported_samplerates)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">44100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  p = pCodec-&gt;supported_samplerates; <span class="comment">//&lt; array of supported audio samplerates, or NULL if unknown, array is terminated by 0</span></span><br><span class="line">  <span class="keyword">while</span> (*p)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (!best_samplerate || <span class="built_in">abs</span>(<span class="number">44100</span> - *p) &lt; <span class="built_in">abs</span>(<span class="number">44100</span> - best_samplerate))</span><br><span class="line">      best_samplerate = *p;</span><br><span class="line">    p++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> best_samplerate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* select layout with the highest channel count */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">select_channel_layout</span><span class="params">(<span class="type">const</span> AVCodec *codec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> *p;</span><br><span class="line">  <span class="type">uint64_t</span> best_ch_layout = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> best_nb_channels = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!codec-&gt;channel_layouts)</span><br><span class="line">    <span class="keyword">return</span> AV_CH_LAYOUT_STEREO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  p = codec-&gt;channel_layouts; <span class="comment">//&lt; array of support channel layouts, or NULL if unknown. array is terminated by 0</span></span><br><span class="line">  <span class="keyword">while</span> (*p)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> nb_channels = <span class="built_in">av_get_channel_layout_nb_channels</span>(*p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nb_channels &gt; best_nb_channels) </span><br><span class="line">    &#123;</span><br><span class="line">      best_ch_layout = *p;</span><br><span class="line">      best_nb_channels = nb_channels;</span><br><span class="line">    &#125;</span><br><span class="line">    p++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> best_ch_layout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">encode</span><span class="params">(AVCodecContext* pCodecCtx, AVFrame *pFrame, AVPacket* pPacket, FILE* p_output_f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  ret = <span class="built_in">avcodec_send_frame</span>(pCodecCtx, pFrame);</span><br><span class="line">  <span class="keyword">while</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ret = <span class="built_in">avcodec_receive_packet</span>(pCodecCtx, pPacket);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="built_in">AVERROR</span>(EAGAIN) || ret == AVERROR_EOF)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">fwrite</span>(pPacket-&gt;data, <span class="number">1</span>, pPacket-&gt;size, p_output_f);</span><br><span class="line">    <span class="built_in">av_packet_unref</span>(pPacket);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">encode_pcm_to_mp2</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* output_filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  AVCodecContext* pCodecCtx = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">const</span> AVCodec* pCodec = <span class="literal">NULL</span>;</span><br><span class="line">  AVPacket* pPacket = <span class="literal">NULL</span>;</span><br><span class="line">  AVFrame* pFrame = <span class="literal">NULL</span>;</span><br><span class="line">  FILE* p_output_f = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> i, j, k, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint16_t</span> *samples;</span><br><span class="line">  <span class="type">float</span> t, tincr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  pCodec = <span class="built_in">avcodec_find_encoder</span>(AV_CODEC_ID_MP2);</span><br><span class="line">  <span class="keyword">if</span> (!pCodec)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">output_log</span>(LOG_ERROR, <span class="string">&quot;avcodec_find_encoder(AV_CODEC_ID_MP2) error&quot;</span>);</span><br><span class="line">    ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">  &#125;</span><br><span class="line">  pCodecCtx = <span class="built_in">avcodec_alloc_context3</span>(pCodec);</span><br><span class="line">  pPacket = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line">  <span class="keyword">if</span> (!pPacket)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">output_log</span>(LOG_ERROR, <span class="string">&quot;av_packet_alloc error&quot;</span>);</span><br><span class="line">    ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">  &#125;</span><br><span class="line">  pFrame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">  <span class="keyword">if</span> (!pFrame)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">output_log</span>(LOG_ERROR, <span class="string">&quot;av_frame_alloc error&quot;</span>);</span><br><span class="line">    ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//set AVCodecContext parameters</span></span><br><span class="line">  pCodecCtx-&gt;bit_rate = <span class="number">64000</span>;</span><br><span class="line">  <span class="comment">/* check that the encoder supports s16 pcm input */</span></span><br><span class="line">  pCodecCtx-&gt;sample_fmt = AV_SAMPLE_FMT_S16;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">check_sample_fmt</span>(pCodec, pCodecCtx-&gt;sample_fmt))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">output_log</span>(LOG_ERROR, <span class="string">&quot;check_sample_fmt error&quot;</span>);</span><br><span class="line">    ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* select other audio parameters supported by the encoder */</span></span><br><span class="line">  pCodecCtx-&gt;sample_rate = <span class="built_in">select_sample_rate</span>(pCodec);</span><br><span class="line">  pCodecCtx-&gt;channel_layout = <span class="built_in">select_channel_layout</span>(pCodec);</span><br><span class="line">  pCodecCtx-&gt;channels = <span class="built_in">av_get_channel_layout_nb_channels</span>(pCodecCtx-&gt;channel_layout);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//open codec</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">avcodec_open2</span>(pCodecCtx, pCodec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//set AVFrame parameters</span></span><br><span class="line">  pFrame-&gt;nb_samples = pCodecCtx-&gt;frame_size;</span><br><span class="line">  pFrame-&gt;format = pCodecCtx-&gt;sample_fmt;</span><br><span class="line">  pFrame-&gt;channel_layout = pCodecCtx-&gt;channel_layout;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">av_frame_get_buffer</span>(pFrame, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">output_log</span>(LOG_ERROR, <span class="string">&quot;av_frame_get_buffer error&quot;</span>);</span><br><span class="line">    ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fopen_s</span>(&amp;p_output_f, output_filepath, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!p_output_f)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">output_log</span>(LOG_ERROR, <span class="string">&quot;fopen_s error&quot;</span>);</span><br><span class="line">    ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//encode a single tone sound</span></span><br><span class="line">  t = <span class="number">0</span>;</span><br><span class="line">  tincr = <span class="number">2</span> * M_PI * <span class="number">440.0</span> / pCodecCtx-&gt;sample_rate;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* make sure the frame is writable -- makes a copy if the encoder</span></span><br><span class="line"><span class="comment">    * kept a reference internally */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">av_frame_make_writable</span>(pFrame) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">output_log</span>(LOG_ERROR, <span class="string">&quot;av_frame_make_writable error&quot;</span>);</span><br><span class="line">      ret = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    samples = (<span class="type">uint16_t</span>*)pFrame-&gt;data[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; pCodecCtx-&gt;frame_size; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      samples[<span class="number">2</span> * j] = (<span class="type">int</span>)(<span class="built_in">sin</span>(t) * <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; pCodecCtx-&gt;channels; k++)</span><br><span class="line">      &#123;</span><br><span class="line">        samples[<span class="number">2</span> * j + k] = samples[<span class="number">2</span> * j];</span><br><span class="line">      &#125;</span><br><span class="line">      t += tincr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">encode</span>(pCodecCtx, pFrame, pPacket, p_output_f);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//flush the encoder </span></span><br><span class="line">  <span class="built_in">encode</span>(pCodecCtx, <span class="literal">NULL</span>, pPacket, p_output_f);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fclose</span>(p_output_f);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">  <span class="keyword">if</span> (pCodecCtx)</span><br><span class="line">    <span class="built_in">avcodec_free_context</span>(&amp;pCodecCtx);</span><br><span class="line">  <span class="keyword">if</span> (pPacket)</span><br><span class="line">    <span class="built_in">av_packet_free</span>(&amp;pPacket);</span><br><span class="line">  <span class="keyword">if</span> (pFrame)</span><br><span class="line">    <span class="built_in">av_frame_free</span>(&amp;pFrame);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;=============== encode_pcm_to_mp2 done ===============\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-5-转码"><a href="#6-5-转码" class="headerlink" title="6.5 转码"></a>6.5 转码</h2><p>转码比较好理解，就是将<code>解码和编码结合</code>起来，过程为：<code>解封装-&gt;解码-&gt;编码-&gt;封装</code>。逻辑如下：</p>
<ul>
<li><p>解封装：将音视频文件的封装格式去掉，<code>获取视频流（H.264）和音频流（AAC）</code></p>
</li>
<li><p>解码：将视频流<code>解码成原始图像数据</code>（YUV），将音频流<code>解码成原始音频数据</code>（PCM）</p>
</li>
<li><p>编码：将原始图像（YUV）进行<code>编码</code>（MPG2），将音频流进行<code>编码</code>（MP3）</p>
</li>
<li><p>封装：将视频流和音频流封装成视频文件</p>
</li>
</ul>
<p><img src="/img/mv1.39.png"></p>
<h2 id="6-6-ffmpeg-结构体分析"><a href="#6-6-ffmpeg-结构体分析" class="headerlink" title="6.6 ffmpeg 结构体分析"></a>6.6 ffmpeg 结构体分析</h2><p>知道了如何通过调用FFmpeg代码来进行解码和编码，知其然还要知其所以然<br>这篇文章分析下FFmpeg编解码过程中主要的结构体，通过对这些结构体的分析，可以更好的<code>理解FFmpeg的编解码过程。</code></p>
<p><strong>1. FFmpeg结构体分析</strong></p>
<p>总结FFmpeg结构体主要分为三个层次：<br><code>协议层</code>（AVIOContext）、<code>封装层</code>（AVInputFormat）、<code>解码层</code>（AVStream）</p>
<p><img src="/img/mv1.40.png"></p>
<p><strong>2. FFmpeg编解码关键结构体</strong></p>
<p>按照FFmpeg编解码时代码的调用过程，总结八个关键结构体。<br>按照编解码调用顺序介绍如下：</p>
<p><strong>2.1 AVFormatContext</strong> ：描述媒体文件或媒体流的构成和基本信息，贯穿ffmpeg使用<code>整个流程</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AVInputFormat *iformat、AVOutputFormat *oformat <span class="comment">//输入或者输出流的格式（只能存在一个）(封装层)</span></span><br><span class="line">AVIOContext *pb <span class="comment">//管理输入输出数据   (协议层)     </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> nb_streams <span class="comment">//音视频流的个数</span></span><br><span class="line">AVStream **streams <span class="comment">//音视频流       (解码层) </span></span><br><span class="line"><span class="type">char</span> *url <span class="comment">//文件名</span></span><br><span class="line"><span class="type">int64_t</span> duration <span class="comment">//时长</span></span><br><span class="line"><span class="type">int</span> bit_rate <span class="comment">//比特率（单位bite/s）</span></span><br><span class="line">AVDictionary *metadata <span class="comment">//元数据（查看元数据：ffprobe filename）</span></span><br></pre></td></tr></table></figure>

<p><strong>2.2 AVInputFormat：</strong> 文件的封装格式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* name <span class="comment">//封装格式的名字</span></span><br><span class="line"><span class="type">char</span>* long_name <span class="comment">//封装格式的长名字</span></span><br><span class="line"><span class="type">char</span>* extensions <span class="comment">//文件扩展名</span></span><br></pre></td></tr></table></figure>

<p><strong>2.3 AVIOContext-&gt;URLContext-&gt;URLProtocol</strong></p>
<ul>
<li><code>AVIOContext</code> ：文件（协议）操作的顶层对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *buffer <span class="comment">//缓冲开始位置</span></span><br><span class="line"><span class="type">int</span> buffer_size <span class="comment">//缓冲区大小（默认32768）</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *buf_ptr <span class="comment">//当前指针读取到的位置</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *buf_end <span class="comment">//缓存结束的位置</span></span><br><span class="line"><span class="type">void</span> *opaque <span class="comment">//URLContext结构体</span></span><br><span class="line">(*read_packet)(...) <span class="comment">//读取音视频数据的函数指针</span></span><br><span class="line">(*write_packet)(...) <span class="comment">//写入音视频数据的函数指针</span></span><br><span class="line">(*read_pause)(...) <span class="comment">//网络流媒体协议的暂停或恢复播放函数指针</span></span><br></pre></td></tr></table></figure>


<ul>
<li><code>URLContext</code> ：每种协议，有一个协议操作对象和一个关联的协议对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* name <span class="comment">//协议名称</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">URLProtocol</span> *prot <span class="comment">//协议操作对象（ff_file_protocol、ff_librtmp_protocol...）</span></span><br><span class="line"><span class="type">void</span> *priv_data <span class="comment">//协议对象（FileContext、LibRTMPContext）</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>URLProtocol</code> ：协议操作对象</li>
</ul>
<p><strong>2.4 AVStream</strong> ：存储音频流或视频流的结构体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> index <span class="comment">//音频流或视频流的索引</span></span><br><span class="line">AVRational time_base <span class="comment">//计算pts或dts是使用的时间戳基本单位（显示时间：pt = av_q2d(video_stream-&gt;time_base) * frame-&gt;pts）</span></span><br><span class="line"><span class="type">int64_t</span> duration <span class="comment">//该视频/音频流长度</span></span><br><span class="line">AVRational avg_frame_rate <span class="comment">//平均帧率（对于视频来说，frame_rate=avg_frame_rate.num / avg_frame_rate.den）</span></span><br><span class="line">AVCodecParameters *codecpar <span class="comment">//解码器参数</span></span><br></pre></td></tr></table></figure>

<p><strong>2.5 AVCodecParameter 和 AVCodecContext</strong></p>
<ul>
<li><p>新的 ffmpeg 中 <code>AVStream.codecpar(struct AVCodecParameter)</code> 代替 <code>AVStream.codec(struct AVCodecContext)</code><br><code>AVCodecParameter</code> 是由 <code>AVCodecContext</code> 分离出来的，<code>AVCodecParameter中没有函数</code></p>
</li>
<li><p><code>AVCodecContext</code> 结构体仍然是编解码时不可或缺的结构体<br><code>avcodec_send_packet</code> 和 <code>avcodec_receive_frame</code> 使用 <code>AVCodecContext</code></p>
</li>
</ul>
<blockquote>
<p><code>AVCodecContext</code> 和 <code>AVCodec</code> 的获取方法</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=============== new version code ===============</span></span><br><span class="line"><span class="type">char</span> filePath[] = <span class="string">&quot;test.mp4&quot;</span>;</span><br><span class="line">AVFormatContext  *pFormatCtx;</span><br><span class="line">AVCodecContext *pCodecCtx;</span><br><span class="line">AVCodec *pCodec;</span><br><span class="line">pFormatCtx = <span class="built_in">avformat_alloc_context</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">av_register_all</span>();</span><br><span class="line"><span class="built_in">avformat_network_init</span>();</span><br><span class="line"><span class="built_in">avformat_open_input</span>(&amp;pFormatCtx, filePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">avformat_find_stream_info</span>(pFormatCtx, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++)</span><br><span class="line">&#123;</span><br><span class="line">    AVStream *pStream = pFormatCtx-&gt;streams[i];</span><br><span class="line">    pCodec = <span class="built_in">avcodec_find_decoder</span>(pStream-&gt;codecpar-&gt;codec_id); <span class="comment">//new_begin</span></span><br><span class="line">    pCodecCtx = <span class="built_in">avcodec_alloc_context3</span>(pCodec);</span><br><span class="line">    <span class="built_in">avcodec_parameters_to_context</span>(pCodecCtx, pStream-&gt;codecpar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//============ old version code ============</span></span><br><span class="line"><span class="type">char</span> filePath[] = <span class="string">&quot;test.mp4&quot;</span>;</span><br><span class="line">AVFormatContext  *pFormatCtx;</span><br><span class="line">AVCodecContext *pCodecCtx;</span><br><span class="line">AVCodec *pCodec;</span><br><span class="line">pFormatCtx = <span class="built_in">avformat_alloc_context</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">av_register_all</span>();</span><br><span class="line"><span class="built_in">avformat_network_init</span>();</span><br><span class="line"><span class="built_in">avformat_open_input</span>(&amp;pFormatCtx, filePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">avformat_find_stream_info</span>(pFormatCtx, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++)</span><br><span class="line">&#123;</span><br><span class="line">    AVStream *pStream = pFormatCtx-&gt;streams[i];</span><br><span class="line">    pCodecCtx = pStream-&gt;codec;</span><br><span class="line">    pCodec = <span class="built_in">avcodec_find_decoder</span>(pCodecCtx-&gt;codec_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>◆ 关键参数：可参考 avcodec_parameters_to_context 源码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">AVMediaType</span> codec_type <span class="comment">//编解码器的类型（视频，音频...）</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">AVCodecID</span> codec_id <span class="comment">//标示特定的编码器</span></span><br><span class="line">AVCodecContext:<span class="keyword">struct</span> <span class="title class_">AVCodec</span> *codec <span class="comment">//采用的解码器AVCodec（H.264,MPEG2...）</span></span><br><span class="line"><span class="type">int</span> bit_rate <span class="comment">//平均比特率</span></span><br><span class="line"><span class="type">uint8_t</span> *extradata; <span class="type">int</span> extradata_size <span class="comment">//针对特定编码器包含的附加信息（例如对于H.264解码器来说，存储SPS，PPS等）</span></span><br><span class="line">AVCodecContext:<span class="keyword">enum</span> <span class="title class_">AVPixelFormat</span> pix_fmt <span class="comment">//像素格式（视频）</span></span><br><span class="line"><span class="type">int</span> width, height <span class="comment">//宽和高（视频）</span></span><br><span class="line">AVCodecContext:<span class="keyword">enum</span> <span class="title class_">AVSampleFormat</span> sample_fmt <span class="comment">//采样格式（音频）</span></span><br><span class="line"><span class="type">int</span> sample_rate <span class="comment">//采样率（音频）</span></span><br><span class="line"><span class="type">int</span> channels <span class="comment">//声道数（音频）</span></span><br><span class="line"><span class="type">uint64_t</span> channel_layout <span class="comment">//声道格式</span></span><br><span class="line">AVCodecParameters:<span class="type">int</span> format <span class="comment">//像素格式（视频）/采样格式（音频）</span></span><br></pre></td></tr></table></figure>

<p><strong>2.6 AVCodec</strong> ：编解码器结构体</p>
<ul>
<li>每一个解码器<code>对应</code>一个<code>AVCodec结构体</code><br>AVCodec ff_h264_decoder，AVCodec ff_jpeg2000_decoder</li>
</ul>
<p>◆ 关键成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *name <span class="comment">//编解码器短名字（形如：&quot;h264&quot;）</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *long_name <span class="comment">//编解码器全称（形如：&quot;H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10&quot;）</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">AVMediaType</span> type <span class="comment">//媒体类型：视频、音频或字母</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">AVCodecID</span> id <span class="comment">//标示特定的编码器</span></span><br><span class="line"><span class="type">const</span> AVRational *supported_framerates <span class="comment">//支持的帧率（仅视频）</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">enum</span> <span class="title class_">AVPixelFormat</span> *pix_fmts <span class="comment">//支持的像素格式（仅视频）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *supported_samplerates <span class="comment">//支持的采样率（仅音频）</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">enum</span> <span class="title class_">AVSampleFormat</span> *sample_fmts <span class="comment">//支持的采样格式（仅音频）</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint64_t</span> *channel_layouts <span class="comment">//支持的声道数（仅音频）</span></span><br></pre></td></tr></table></figure>

<p><strong>2.7 AVPacket</strong> ：存储解码前数据的结构体</p>
<p>◆ 关键成员变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AVBufferRef *buf <span class="comment">//管理data指向的数据</span></span><br><span class="line"><span class="type">uint8_t</span> *data <span class="comment">//压缩编码的数据</span></span><br><span class="line"><span class="type">int</span> size <span class="comment">//data的大小</span></span><br><span class="line"><span class="type">int64_t</span> pts <span class="comment">//显示时间戳</span></span><br><span class="line"><span class="type">int64_t</span> dts <span class="comment">//解码时间戳</span></span><br><span class="line"><span class="type">int</span> stream_index <span class="comment">//标识该AVPacket所属的视频/音频流</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>AVPacket的内存管理：AVPacket本身并不包含压缩的数据，通过<code>data指针</code>引用数据的缓存空间<br> 多个AVPacket<code>共享</code>同一个数据缓存（<code>AVBufferRef</code>、<code>AVBuffer</code>）<br> AVPacket拥有<code>独立的数据缓存</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">av_read_frame</span>(pFormatCtx, packet)  <span class="comment">// 读取Packet</span></span><br><span class="line"><span class="built_in">av_packet_ref</span>(dst_pkt,packet) <span class="comment">// dst_pkt 和 packet 共享同一个数据缓存空间，引用计数+1</span></span><br><span class="line"><span class="built_in">av_packet_unref</span>(dst_pkt); <span class="comment">//释放 pkt_pkt 引用的数据缓存空间，引用计数-1</span></span><br></pre></td></tr></table></figure>


<p>◆ AVBuffer 关键成员变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> *data <span class="comment">//压缩编码的数据</span></span><br><span class="line"><span class="type">size_t</span> size <span class="comment">//数据长度</span></span><br><span class="line">atomic_uint refcount <span class="comment">//引用计数，如果引用计数为0,则释放数据缓存空间</span></span><br></pre></td></tr></table></figure>

<p><strong>2.8 AVFrame</strong> ：存储解码后数据的结构体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> *data[AV_NUM_DATA_POINTERS] <span class="comment">//解码后原始数据（对视频来说是YUV，RGB，对音频来说是PCM）</span></span><br><span class="line"><span class="type">int</span> linesize[AV_NUM_DATA_POINTERS] <span class="comment">//data中“一行”数据的大小。注意：未必等于图像的宽，一般大于图像的宽。</span></span><br><span class="line"><span class="type">int</span> width, height <span class="comment">//视频帧宽和高（1920x1080,1280x720...）</span></span><br><span class="line"><span class="type">int</span> nb_samples <span class="comment">//音频的一个AVFrame中可能包含多个音频帧，在此标记包含了几个</span></span><br><span class="line"><span class="type">int</span> format <span class="comment">//解码后原始数据类型（YUV420，YUV422，RGB24...）</span></span><br><span class="line"><span class="type">int</span> key_frame <span class="comment">//是否是关键帧</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">AVPictureType</span> pict_type <span class="comment">//帧类型（I,B,P...）</span></span><br><span class="line">AVRational sample_aspect_ratio <span class="comment">//图像宽高比（16:9，4:3...）</span></span><br><span class="line"><span class="type">int64_t</span> pts <span class="comment">//显示时间戳</span></span><br><span class="line"><span class="type">int</span> coded_picture_number <span class="comment">//编码帧序号</span></span><br><span class="line"><span class="type">int</span> display_picture_number <span class="comment">//显示帧序号</span></span><br></pre></td></tr></table></figure>

<h2 id="6-7-ffmpeg-源码分析"><a href="#6-7-ffmpeg-源码分析" class="headerlink" title="6.7 ffmpeg 源码分析"></a>6.7 ffmpeg 源码分析</h2><p>前面分析FFmpeg的编解码调用过程，也对FFmpeg编解码过程中使用到的关键结构体进行分析<br>现以FFmpeg<code>解码流程</code>为主线，深入分析其中层层调用的FFmpeg代码。</p>
<p>FFmpeg解码过程涉及到源码调用过程，如图所示<br>橙色部分+红色箭头为解码主流程<br>橙色部分为FFmpeg对外提供的接口函数<br>白色部分为橙色功能函数实现中涉及到主要功能函数）：</p>
<p><img src="/img/mv1.41.png"></p>
<p>主要函数</p>
<ul>
<li><p>avformat_network_init()：初始化网络库</p>
</li>
<li><p>avformat_open_input()：打开输入流，获取头信息</p>
</li>
<li><p>avformat_find_stream_info()：通过读媒体数据，获取音视频流信息</p>
</li>
<li><p>avcodec_find_decoder()：通过ID查找音频解码器或者视频解码器</p>
</li>
<li><p>avcodec_parameters_to_context()：填充解码器上下文</p>
</li>
<li><p>avcodec_open2()：打开音频解码器或者视频解码器</p>
</li>
<li><p>av_read_frame()：获取音视频（编码）数据</p>
</li>
<li><p>avcodec_send_packet()：将音视频编码数据发送给解码器</p>
</li>
<li><p>avcodec_receive_frame()：获取解码后的音视频数据（音视频原始数据，如YUV和PCM）</p>
</li>
</ul>
<h2 id="6-8-ffplay源码分析"><a href="#6-8-ffplay源码分析" class="headerlink" title="6.8 ffplay源码分析"></a>6.8 ffplay源码分析</h2><p>前面介绍FFmpeg的解码、编码、转码流程及相关的函数调用，并以FFmpeg解码流程为主线，深入分析其中层层调用的FFmpeg代码</p>
<p>做一个真正的播放器，还有很多问题需要处理：<code>音视频同步</code>，<code>多线程解复用</code>、<code>解码</code>，<code>线程安全等</code>问题需要处理。<br>带着问题，分析下ffplay(FFmpeg提供的一个简单的播放器)的源码。</p>
<p>ffplay解码并播放音视频的源码分析如图所示<br>（分为两条主线，一条为解复用、解码，另一条为事件循环（包含音视频播放））：</p>
<p><img src="/img/mv1.42.png"></p>
<p><strong>1. 解复用、解码</strong></p>
<ul>
<li><p>stream_open：起始入口</p>
</li>
<li><p>audio_thread：音频处理线程</p>
</li>
<li><p>音频数据流转：audioq（编码数据）-&gt;sampq（解码数据）</p>
</li>
<li><p>video_thread：视频处理线程</p>
</li>
<li><p>视频数据流转：videoq（编码数据）-&gt;pictq（解码数据）</p>
</li>
<li><p>subtitle_thread：字幕解码线程</p>
</li>
<li><p>字幕数据流转：subtitleq（编码数据）-&gt;subpq（解码数据）</p>
</li>
</ul>
<p><strong>2. 事件循环（包含音视频播放）</strong></p>
<ul>
<li><p>event_loop：起始入口</p>
</li>
<li><p>refresh_loop_wait_event：显示音视频（包括音视频同步）</p>
</li>
</ul>
<p><strong>3. 事件循环</strong></p>
<ul>
<li><p>事件循环函数调用SDL_PeepEvents函数，查看事件队列中是否有事件存在</p>
</li>
<li><p>如果有事件（如键盘、鼠标等事件），优先处理事件</p>
</li>
<li><p>如果事件队列中没有事件，则播放音视频</p>
</li>
</ul>
<hr>
<h1 id="7-协议篇"><a href="#7-协议篇" class="headerlink" title="7. 协议篇"></a>7. 协议篇</h1><h2 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1 简介"></a>7.1 简介</h2><p><code>RTP</code>，<code>RTCP</code>，<code>RTMP</code>等等协议</p>
<p>如下罗列了部分流媒体相关协议，稍后详细介绍这些协议：</p>
<ul>
<li><p>RTP(Real-time Transport Protocol)，实时传输协议。</p>
</li>
<li><p>RTCP(Real-time Transport Control Protocol)，实时传输控制协议。</p>
</li>
<li><p>RTSP(Real Time Streaming Protocol)，实时流协议。</p>
</li>
<li><p>RTMP(Real Time Messaging Protocol)，实时消息传输协议。</p>
</li>
<li><p>HLS(HTTP Live Streaming)，苹果公司提出的基于HTTP的流媒体网络传输协议。</p>
</li>
<li><p>HTTP-FLV，将<code>RTMP</code>等负载信息携带在HTTP协议之上的码流传输协议。</p>
</li>
</ul>
<h2 id="7-2-RTP-RTCP-RTSP"><a href="#7-2-RTP-RTCP-RTSP" class="headerlink" title="7.2 RTP &amp; RTCP &amp; RTSP"></a>7.2 RTP &amp; RTCP &amp; RTSP</h2><p>RTP、RTCP这两个协议一般是成对出现，而他们与RTSP协同工作。介绍下这三个协议。</p>
<p><strong>1. RTP、RTCP、RTSP的关系</strong></p>
<blockquote>
<p>RTP 负责多媒体的传输<br>RTCP 配合 RTP 做控制和流量统计<br>RTSP 负责建立和控制会话</p>
</blockquote>
<p><img src="/img/mv1.43.png"></p>
<p><img src="/img/mv1.44.png"></p>
<p><strong>2. RTP(Real-time Transport Protocol)，实时传输协议：</strong></p>
<ul>
<li><p>RTP建立在<code>UDP</code>协议上；</p>
</li>
<li><p>RTP<code>不确保</code>网络底层的可靠性，<code>不提供</code>按时发送机制或其他服务质量（QoS）保证；</p>
</li>
<li><p>RTP<code>不保证</code>传送或防止无序传送；</p>
</li>
<li><p>RTP<code>提供</code>时间标志，序列号以及其他能够保证在实时数据传输时处理时间的<code>方法</code>；</p>
</li>
</ul>
<p>◆ RTP报文格式如下：</p>
<p><img src="/img/mv1.45.png"></p>
<blockquote>
<p><code>V</code>：RTP协议的版本号，占2位，当前协议版本号为2P：填充标志，占1位，如果P&#x3D;1，则在该报文的尾部填充一个或多个额外的八位组，它们不是有效载荷的一部分。<br><code>X</code>：扩展标志，占1位，如果X&#x3D;1，则在RTP报头后跟有一个扩展报头<br><code>CC</code>：CSRC计数器，占4位，指示CSRC 标识符的个数<br><code>M</code>：标记，占1位，不同的有效载荷有不同的含义，对于视频，标记一帧的结束；对于音频，标记会话的开始。<br><code>PT</code>：有效荷载类型，占7位，用于说明RTP报文中有效载荷的类型，如GSM音频、JPEM图像等,在流媒体中大部分是用来区分音频流和视频流的，这样便于客户端进行解析。<br><code>sequence number</code>：序列号，16比特，发送方在每发送完一个RTP包后就将该域的值增加1，接收方可以由该域检测包的丢失及恢复包序列。序列号的初始值是随机的。<br><code>timestamp</code>：时间戳，32比特，记录了该包中数据的第一个字节的采样时刻。在一次会话开始时，时间戳初始化成一个初始值。即使在没有信号发送时，时间戳的数值也要随时间而不断地增加（时间在流逝嘛）。时间戳是去除抖动和实现同步不可缺少的。<br><code>SSRC</code>：同步源标识符，32比特，同步源就是指RTP包流的来源。在同一个RTP会话中不能有两个相同的SSRC值。该标识符是随机选取的 RFC1889推荐了MD5随机算法。<br><code>CSRC</code>：贡献源列表，0～15项，每项32比特，用来标志对一个RTP混合器产生的新包有贡献的所有RTP包的源。由混合器将这些有贡献的SSRC标识符插入表中。SSRC标识符都被列出来，以便接收端能正确指出交谈双方的身份 </p>
</blockquote>
<p><strong>3. RTCP(Real-time Transport Control Protocol)，实时传输控制协议：</strong></p>
<ul>
<li><p><code>RTP</code>和<code>RTCP</code>是一起使用的；</p>
</li>
<li><p>RTCP的主要功能是为RTP所提供的服务质量<code>提供反馈</code>，RTCP收集相关媒体连接的统计信息<br>例如：传输字节数，传输分组数，丢失分组数，时延抖动，单向和双向网络延迟等等；</p>
</li>
<li><p>网络应用程序可以利用RTCP所提供的信息试图<code>提高服务质量</code>，比如限制信息流量或改用压缩比较小的编解码器；</p>
</li>
<li><p>RTCP本身<code>不提供</code>数据加密或身份认证，其伴生协议<code>SRTCP</code>（安全实时传输控制协议）则可用于此类用途；</p>
</li>
</ul>
<p>◆ RTCP报文格式如下：</p>
<p><img src="/img/mv1.46.png"></p>
<p><strong>4. RTSP(Real Time Streaming Protocol)，实时流协议：</strong></p>
<ul>
<li><p>RTSP是一种<code>双向实时数据传输协议</code>；</p>
</li>
<li><p>RTSP在体系结构上位于<code>RTP和RTCP之上</code>，它使用TCP或RTP完成数据传输；</p>
</li>
<li><p>RTSP主要用来控制具有<code>实时特性</code>的数据发送<br>比如：对流媒体提供诸如播放、暂停、快进等操作；</p>
</li>
<li><p>RTSP负责定义具体的控制消息、操作方法、状态码等，但它本身并<code>不传输数据</code>，而是必须<code>依赖于下层传输协议</code>所提供的某些服务；</p>
</li>
</ul>
<h2 id="7-3-RTMP-HLS"><a href="#7-3-RTMP-HLS" class="headerlink" title="7.3 RTMP &amp; HLS"></a>7.3 RTMP &amp; HLS</h2><p><strong>1. RTMP(Real Time Messaging Protocol)</strong></p>
<p>RTMP是Real Time Messaging Protocol（实时消息传输协议）的首字母缩写。该协议<code>基于TCP</code>，是一个协议族，包括RTMP基本协议RTMPT&#x2F;RTMPS&#x2F;RTMPE等多种变种。<br>RTMP是一种设计用来进行实时数据通信的网络协议，主要用来在Flash&#x2F;AIR平台和支持RTMP协议的流媒体&#x2F;交互服务器之间进行音视频和数据通信。<br>支持该协议的软件包括Adobe Media Server&#x2F;Ultrant Media Server&#x2F;red5等。RTMP与HTTP一样，都属于TCP&#x2F;IP四层模型的应用层。</p>
<ul>
<li><p>应用层协议，依靠TCP保证可靠传输。</p>
</li>
<li><p>默认端口：<code>1953</code>，可能被防火墙屏蔽。</p>
</li>
<li><p>在流媒体&#x2F;交互服务器之间进行音视频和数据<code>通信</code>。</p>
</li>
</ul>
<p><strong>2. HLS(HTTP Live Streaming)</strong></p>
<p>HLS是一个由苹果公司提出的<strong>基于HTTP</strong>的流媒体网络传输协议。</p>
<p><font color = red>工作原理 : 把整个流分成一个个小的基于HTTP的TS文件来下载，每次只下载一些。</font><br>当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。</p>
<p>HLS请求基本的HTTP报文，与实时传输协议（<code>RTP</code>)不同<br><font color = red>HLS可以穿过任何允许HTTP数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。 </font></p>
<p>HLS规范：</p>
<ul>
<li><p>视频的封装格式是<code>TS</code>。</p>
</li>
<li><p>音视频采用<code>H264</code>编码和<code>AAC</code>编码。</p>
</li>
<li><p>除了<code>TS</code>视频文件本身，还定义了用来控制播放的<code>m3u8</code>索引文件</p>
</li>
</ul>
<h2 id="7-4-对比RTMP，HLS和HTTP-FLV"><a href="#7-4-对比RTMP，HLS和HTTP-FLV" class="headerlink" title="7.4 对比RTMP，HLS和HTTP-FLV"></a>7.4 对比RTMP，HLS和HTTP-FLV</h2><p>在开始之前，我们先要明确一个问题，根据应用场景不同，流媒体协议分为：</p>
<ul>
<li><p>推流协议</p>
</li>
<li><p>拉流播放协议</p>
</li>
</ul>
<blockquote>
<p><code>RTMP</code>  &gt;&gt; 双端<br><code>HLS</code> &gt;&gt; 拉流端<br><code>HTTP-FLV</code> &gt;&gt; 拉流端。</p>
</blockquote>
<p>我们先放一张表格从几个维度来对比下这三种协议。</p>
<table>
<thead>
<tr>
<th></th>
<th>RTMP</th>
<th>HTTP-FLV</th>
<th>HLS</th>
</tr>
</thead>
<tbody><tr>
<td>传输协议</td>
<td>TCP</td>
<td>HTTP</td>
<td>HTTP</td>
</tr>
<tr>
<td>视频封装格式</td>
<td>flv</td>
<td>flv</td>
<td>ts</td>
</tr>
<tr>
<td>延时</td>
<td>1-3秒</td>
<td>1-3秒</td>
<td>5-20秒</td>
</tr>
<tr>
<td>Web支持</td>
<td>H5需要使用插件</td>
<td>H5需要使用插件</td>
<td>支持H5</td>
</tr>
<tr>
<td>数据</td>
<td>连续流</td>
<td>连续流</td>
<td>切片文件</td>
</tr>
</tbody></table>
<p>ps: H5 是 HTML5</p>
<p><strong>1. RTMP &amp; HTTP-FLV</strong></p>
<ul>
<li><p>这两个协议实际上传输的数据是一样的，数据都是<code>flv文件的tag</code>。</p>
</li>
<li><p>RTMP：实时播放服务器的 FLV 文件或服务器转发的FLV数据，本地<code>无 FLV 缓存文件</code>，<code>FLV保密性好</code>。</p>
</li>
<li><p>HTTP-FLV：将 FLV <code>下载到本地</code>再播放，FLV<code>保密性不好</code>。</p>
</li>
</ul>
<p><strong>2. HLS &amp; RTMP</strong></p>
<ul>
<li><p>RTMP：采用<code>1935</code>端口，而非HTTP<code>80</code>端口，在某些网络环境下可能被<code>屏蔽</code>。</p>
</li>
<li><p>RTMP：是一种<code>有状态协议</code>，需要为每一个播放视频流的客户端维护状态，服务器平滑<code>扩展难度大</code>。</p>
</li>
<li><p>HLS：基于<code>无状态HTTP协议</code>，客户端只需要按顺序使用下载的TS文件就可，负载均衡如同普通的HTTP文件服务器负载均衡一样。</p>
</li>
</ul>
<p><strong>3. HTTP-FLV</strong></p>
<p>HTTP-FLV 结合了 RTMP 和 HLS 的优点，易用（HTTP协议）低延时（flv）</p>
<p><strong>4. 为什么 RTPM 比 HLS 快</strong></p>
<ul>
<li><p>HLS拉流：服务器音视频数据切片生成 TS 文件</p>
</li>
<li><p>HLS拉流：客户端必须等待服务端至少生成一个 TS 文件<br>通常下载完两个媒体文件后才能保证不同分段音视频间的无缝连接。</p>
</li>
<li><p>HLS一直在等切片数据，<code>RTMP不需要切片</code></p>
</li>
</ul>
<p><img src="/img/mv1.47.png"></p>
<hr>
<h1 id="8-服务器篇"><a href="#8-服务器篇" class="headerlink" title="8. 服务器篇"></a>8. 服务器篇</h1><blockquote>
<p>介绍下目前常用的流媒体服务器，并实际部署下部分服务器，感受下流媒体服务器是如何工作。<br>市面上优秀的流媒体服务器解决方案有很多，比如SRS，Red5，EasyDarwin，nginx-rtmp，live555，mediasoup等等。<br>这些服务器框架各有优缺点，需要明白的是，世上没有一款完美的流媒体服务器解决方案，在流媒体选型的时候，需要根据自己的业务选择适合的流媒体服务器</p>
</blockquote>
<h2 id="8-1-nginx-rtmp-的部署"><a href="#8-1-nginx-rtmp-的部署" class="headerlink" title="8.1 nginx-rtmp 的部署"></a>8.1 nginx-rtmp 的部署</h2><p>介绍下使用nginx-rtmp来部署一套流媒体服务器，并用FFmpeg来推流，VLC来拉流。</p>
<p><strong>1. 下载nginx 和 nginx-rtmp-module</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://nginx.org/en/download.html</span><br><span class="line">https://github.com/arut/nginx-rtmp-module.git</span><br></pre></td></tr></table></figure>

<p><strong>2. 解压压缩包</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$tar</span> xvf nginx-1.20.1.tar.gz</span><br><span class="line"><span class="variable">$unzip</span> nginx-rtmp-module-master.zip</span><br></pre></td></tr></table></figure>

<p><strong>3. 创建build目录</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> nginx-1.20.1</span><br><span class="line"><span class="variable">$mkdir</span> build</span><br></pre></td></tr></table></figure>

<p><strong>4. config &amp; make &amp; make install</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$./configure --prefix=/home/fly/work/nginx-rtmp/nginx-1.20.1/build --add-module=/home/fly/work/nginx-rtmp/nginx-rtmp-module-master</span><br><span class="line"><span class="variable">$make</span></span><br><span class="line"><span class="variable">$make</span> install</span><br></pre></td></tr></table></figure>

<p><strong>5. config过程中错误及错误处理</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error : ./configure: error: the HTTP rewrite module requires the PCRE library.</span><br><span class="line">error :./configure: error: SSL modules require the OpenSSL library.</span><br><span class="line">error :./configure: error: the HTTP gzip module requires the zlib library.</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libpcre3 libpcre3-dev</span><br><span class="line">sudo apt-get install openssl libssl-dev</span><br><span class="line">sudo apt-get install zlib1g-dev</span><br></pre></td></tr></table></figure>

<p><strong>6. 配置文件：&#x2F;home&#x2F;fly&#x2F;work&#x2F;nginx-rtmp&#x2F;nginx-1.20.1&#x2F;build&#x2F;conf&#x2F;nginx.conf</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1935;</span><br><span class="line">        chunk_size 4096;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># live on</span></span><br><span class="line">        application rtmp_live &#123;</span><br><span class="line">            live on;</span><br><span class="line">            <span class="comment"># hls on; #这个参数把直播服务器改造成实时回放服务器。</span></span><br><span class="line">            <span class="comment"># wait_key on; #对视频切片进行保护，这样就不会产生马赛克了。</span></span><br><span class="line">            <span class="comment"># hls_path ./sbin/html; #切片视频文件存放位置。</span></span><br><span class="line">            <span class="comment"># hls_fragment 10s;     #每个视频切片的时长。</span></span><br><span class="line">            <span class="comment"># hls_playlist_length 60s;  #总共可以回看的时间，这里设置的是1分钟。</span></span><br><span class="line">            <span class="comment"># hls_continuous on; #连续模式。</span></span><br><span class="line">            <span class="comment"># hls_cleanup on;    #对多余的切片进行删除。</span></span><br><span class="line">            <span class="comment"># hls_nested on;     #嵌套模式。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># play videos</span></span><br><span class="line">        application rtmp_play&#123;</span><br><span class="line">            play ./videos;  <span class="comment">#build directory</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>7. 启动 nginx</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/home/fly/work/nginx-rtmp/nginx-1.20.1/build$ sudo ./sbin/nginx</span><br></pre></td></tr></table></figure>

<p><strong>8. ffmpeg推流</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.flv -vcodec libx264 -acodec aac -f flv rtmp://192.168.2.128:1935/rtmp_live/mystream</span><br></pre></td></tr></table></figure>

<p><strong>9. VLC拉流（直播、点播）</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直播：rtmp://192.168.2.128:1935/rtmp_live/mystream</span><br><span class="line">点播：rtmp://192.168.2.128:1935/rtmp_play/test.flv</span><br></pre></td></tr></table></figure>

<h2 id="8-2-SRS-的部署"><a href="#8-2-SRS-的部署" class="headerlink" title="8.2 SRS 的部署"></a>8.2 SRS 的部署</h2><p>介绍下使用SRS来部署一套流媒体服务器，并用FFmpeg来推流，VLC来拉流。</p>
<p><strong>1. 下载srs源码</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/ossrs/srs/releases</span><br></pre></td></tr></table></figure>

<p><strong>2. 解压压缩包</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$tar</span> xvf srs-3.0-r8.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>3. 创建build目录</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> srs-3.0-r8/trunk/</span><br><span class="line"><span class="variable">$mkdir</span> build</span><br></pre></td></tr></table></figure>

<p><strong>4. config &amp; make &amp; make install</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$./configure --prefix=/home/fly/work/srs/srs-3.0-r8/trunk/build --full</span><br><span class="line"><span class="variable">$make</span></span><br><span class="line"><span class="variable">$make</span> install</span><br></pre></td></tr></table></figure>

<p><strong>5. make过程中出现错误及解决方法</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In file included from ../../../objs/gtest/include/gtest/internal/gtest-port.h:197:0,</span><br><span class="line">                 from ../../../objs/gtest/include/gtest/internal/gtest-internal.h:40,</span><br><span class="line">                 from ../../../objs/gtest/include/gtest/gtest.h:57,</span><br><span class="line">                 from ../../../src/utest/srs_utest.hpp:36,</span><br><span class="line">                 from ../../../src/utest/srs_utest.cpp:24:</span><br><span class="line">/usr/include/c++/7/sstream:300:7: error: ‘struct std::__cxx11::basic_stringbuf&lt;_CharT, _Traits, _Alloc&gt;::__xfer_bufptrs’ redeclared with different access struct __xfer_bufptrs</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$./configure --prefix=/home/fly/work/srs/srs-3.0-r8/trunk/build --full --without-utest</span><br><span class="line"><span class="variable">$make</span></span><br><span class="line"><span class="variable">$make</span> install</span><br></pre></td></tr></table></figure>

<p><strong>6. 增加配置文件：&#x2F;home&#x2F;fly&#x2F;work&#x2F;srs&#x2F;srs-3.0-r8&#x2F;trunk&#x2F;build&#x2F;conf&#x2F;my_hls.conf</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">listen              1935;</span><br><span class="line">max_connections     1000;</span><br><span class="line">daemon              on;</span><br><span class="line">srs_log_tank        file;</span><br><span class="line">srs_log_level        error;</span><br><span class="line">srs_log_file        ./objs/srs.log;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http_server &#123;</span><br><span class="line">    enabled         on;</span><br><span class="line">    listen          8081;</span><br><span class="line">    <span class="built_in">dir</span>             ./objs/nginx/html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vhost __defaultVhost__ &#123;</span><br><span class="line">    hls &#123;</span><br><span class="line">        enabled         on;</span><br><span class="line">        hls_fragment    10;</span><br><span class="line">        hls_window      60;</span><br><span class="line">        hls_path        ./objs/nginx/html;</span><br><span class="line">        hls_m3u8_file   [app]/[stream].m3u8;</span><br><span class="line">        hls_ts_file     [app]/[stream]-[<span class="built_in">seq</span>].ts;</span><br><span class="line">        hls_cleanup     on;</span><br><span class="line">        hls_dispose     30;</span><br><span class="line">        hls_on_error    <span class="built_in">continue</span>;</span><br><span class="line">        hls_storage     disk;</span><br><span class="line">        hls_wait_keyframe       on;</span><br><span class="line">        hls_acodec      aac;</span><br><span class="line">        hls_vcodec      h264;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>7. 启动 srs</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/home/fly/work/srs/srs-3.0-r8/trunk/build<span class="variable">$sudo</span> ./objs/srs -c ./conf/my_hls.conf</span><br></pre></td></tr></table></figure>

<p><strong>8. ffmpeg推流</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -vcodec libx264 -acodec aac -f flv rtmp://192.168.2.128:1935/live/index</span><br></pre></td></tr></table></figure>

<p><strong>9. 生成的 m3u8 和 ts 文件路径</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/work/srs/srs-3.0-r8/trunk/build/objs/nginx/html/live</span><br></pre></td></tr></table></figure>

<p><strong>10. VLC拉流（rtmp、http）</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rtmp://192.168.2.128:1935/live/index</span><br><span class="line">http://192.168.2.128:8081/live/index.m3u8</span><br><span class="line">``````</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 8.3 live555 的部署</span></span><br><span class="line"></span><br><span class="line">本篇文章，我们详细介绍下使用live555来部署一套流媒体服务器，并使用VLC来拉流。</span><br><span class="line"></span><br><span class="line">**1.下载live555源码**</span><br><span class="line"></span><br><span class="line">```sh</span><br><span class="line">http://www.live555.com/liveMedia/public/</span><br></pre></td></tr></table></figure>

<p><strong>2. 解压</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$tar</span> vxf live.2021.08.24.tar.gz</span><br><span class="line"><span class="comment">#cd live</span></span><br></pre></td></tr></table></figure>

<p><strong>3. make</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$./genMakefiles linux-64bit</span><br><span class="line"><span class="variable">$make</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 启动live555</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> mediaServer</span><br><span class="line"><span class="variable">$sudo</span> ./live555MediaServer</span><br></pre></td></tr></table></figure>

<p><strong>5. 上传视频</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将test.mkv上传至 live/mediaServer目录下</span><br></pre></td></tr></table></figure>

<p><strong>6. 播放</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">拷贝 live555 生成的 url 地址</span><br><span class="line">vlc拉流：rtsp://192.168.2.128:8554/test.mkv</span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/pic/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/05/ffmpeg/" title="ffmpeg命令行简介"><img class="cover" src="/pic/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ffmpeg命令行简介</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/27/algorithm-other/" title="代码随想录-补充篇"><img class="cover" src="/pic/10.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">代码随想录-补充篇</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/pic/avater.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">9TSe</div><div class="author-info__description">难正经</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/9tse"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/9TSe" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:9TSewer@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">C++部分,Qt,Linux,文章摘于 https://subingwen.cn/</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%8E%9F%E7%90%86"><span class="toc-text">1. 音视频播放原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%9B%BE%E5%83%8F%E7%AF%87"><span class="toc-text">2. 图像篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-YUV%E5%92%8CRGB"><span class="toc-text">2.1 YUV和RGB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-H-264"><span class="toc-text">2.2 H.264</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E9%9F%B3%E9%A2%91%E7%AF%87"><span class="toc-text">3. 音频篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-PCM"><span class="toc-text">3.1 PCM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-AAC"><span class="toc-text">3.2 AAC</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%AD%97%E5%B9%95%E7%AF%87-SSA-ASS"><span class="toc-text">4. 字幕篇(SSA &amp; ASS)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E8%A7%86%E9%A2%91%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F%E7%AF%87"><span class="toc-text">5. 视频封装格式篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-FLV"><span class="toc-text">5.1 FLV</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-TS"><span class="toc-text">5.2 TS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-MP4"><span class="toc-text">5.3 MP4</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-FFmpeg%E7%AF%87"><span class="toc-text">6. FFmpeg篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%AE%89%E8%A3%85"><span class="toc-text">6.1 安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-ffmpeg-ffplay-ffprobe"><span class="toc-text">6.2 ffmpeg, ffplay, ffprobe</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E8%A7%A3%E7%A0%81"><span class="toc-text">6.3 解码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E7%BC%96%E7%A0%81"><span class="toc-text">6.4 编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E8%BD%AC%E7%A0%81"><span class="toc-text">6.5 转码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-ffmpeg-%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%86%E6%9E%90"><span class="toc-text">6.6 ffmpeg 结构体分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-ffmpeg-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">6.7 ffmpeg 源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-ffplay%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">6.8 ffplay源码分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%8D%8F%E8%AE%AE%E7%AF%87"><span class="toc-text">7. 协议篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">7.1 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-RTP-RTCP-RTSP"><span class="toc-text">7.2 RTP &amp; RTCP &amp; RTSP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-RTMP-HLS"><span class="toc-text">7.3 RTMP &amp; HLS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E5%AF%B9%E6%AF%94RTMP%EF%BC%8CHLS%E5%92%8CHTTP-FLV"><span class="toc-text">7.4 对比RTMP，HLS和HTTP-FLV</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87"><span class="toc-text">8. 服务器篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-nginx-rtmp-%E7%9A%84%E9%83%A8%E7%BD%B2"><span class="toc-text">8.1 nginx-rtmp 的部署</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-SRS-%E7%9A%84%E9%83%A8%E7%BD%B2"><span class="toc-text">8.2 SRS 的部署</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/05/RTSP1/" title="RTSP服务器"><img src="/pic/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RTSP服务器"/></a><div class="content"><a class="title" href="/2023/12/05/RTSP1/" title="RTSP服务器">RTSP服务器</a><time datetime="2023-12-05T13:58:26.000Z" title="发表于 2023-12-05 21:58:26">2023-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/05/ffmpeg/" title="ffmpeg命令行简介"><img src="/pic/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ffmpeg命令行简介"/></a><div class="content"><a class="title" href="/2023/12/05/ffmpeg/" title="ffmpeg命令行简介">ffmpeg命令行简介</a><time datetime="2023-12-05T13:37:52.000Z" title="发表于 2023-12-05 21:37:52">2023-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/27/%E9%9F%B3%E8%A7%86%E9%A2%911/" title="音视频入门"><img src="/pic/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="音视频入门"/></a><div class="content"><a class="title" href="/2023/11/27/%E9%9F%B3%E8%A7%86%E9%A2%911/" title="音视频入门">音视频入门</a><time datetime="2023-11-27T14:24:43.000Z" title="发表于 2023-11-27 22:24:43">2023-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/27/algorithm-other/" title="代码随想录-补充篇"><img src="/pic/10.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代码随想录-补充篇"/></a><div class="content"><a class="title" href="/2023/11/27/algorithm-other/" title="代码随想录-补充篇">代码随想录-补充篇</a><time datetime="2023-11-27T14:24:29.000Z" title="发表于 2023-11-27 22:24:29">2023-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/27/dp/" title="动态规划"><img src="/pic/10.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="动态规划"/></a><div class="content"><a class="title" href="/2023/11/27/dp/" title="动态规划">动态规划</a><time datetime="2023-11-27T14:00:24.000Z" title="发表于 2023-11-27 22:00:24">2023-11-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 9TSe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>