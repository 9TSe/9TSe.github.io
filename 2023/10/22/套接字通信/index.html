<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>套接字通信 | NineTSe</title><meta name="author" content="NineTSe"><meta name="copyright" content="NineTSe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 套接字-socket1.1 概念 局域网和广域网 局域网：局域网将一定区域内的各种计算机、外部设备和数据库连接起来形成计算机通信的私有网络。 广域网：又称广域网、外网、公网。  是连接不同地区局域网或城域网计算机通信的远程公共网络。   IP（Internet Protocol）：本质是一个整形数，用于表示计算机在网络中的地址。IP协议版本有两个：IPv4和IPv6 IPv4（Intern">
<meta property="og:type" content="article">
<meta property="og:title" content="套接字通信">
<meta property="og:url" content="http://example.com/2023/10/22/%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/index.html">
<meta property="og:site_name" content="NineTSe">
<meta property="og:description" content="1. 套接字-socket1.1 概念 局域网和广域网 局域网：局域网将一定区域内的各种计算机、外部设备和数据库连接起来形成计算机通信的私有网络。 广域网：又称广域网、外网、公网。  是连接不同地区局域网或城域网计算机通信的远程公共网络。   IP（Internet Protocol）：本质是一个整形数，用于表示计算机在网络中的地址。IP协议版本有两个：IPv4和IPv6 IPv4（Intern">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/pic/3.png">
<meta property="article:published_time" content="2023-10-22T01:53:35.000Z">
<meta property="article:modified_time" content="2023-10-22T02:56:02.229Z">
<meta property="article:author" content="NineTSe">
<meta property="article:tag" content="socket">
<meta property="article:tag" content="套接字通信">
<meta property="article:tag" content="TCP">
<meta property="article:tag" content="IO多路转接复用">
<meta property="article:tag" content="UDP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/pic/3.png"><link rel="shortcut icon" href="/pic/12.png"><link rel="canonical" href="http://example.com/2023/10/22/%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '套接字通信',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-22 10:56:02'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="NineTSe" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/pic/avater.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">70</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/pic/3.png')"><nav id="nav"><span id="blog-info"><a href="/" title="NineTSe"><img class="site-icon" src="/pic/9.png"/></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">套接字通信</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-22T01:53:35.000Z" title="发表于 2023-10-22 09:53:35">2023-10-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-22T02:56:02.229Z" title="更新于 2023-10-22 10:56:02">2023-10-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="套接字通信"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<h1 id="1-套接字-socket"><a href="#1-套接字-socket" class="headerlink" title="1. 套接字-socket"></a>1. 套接字-socket</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><ul>
<li>局域网和广域网<ul>
<li>局域网：局域网将一定区域内的各种计算机、外部设备和数据库连接起来形成计算机通信的私有网络。</li>
<li>广域网：又称<strong>广域网</strong>、<strong>外网</strong>、<strong>公网</strong>。<br>  是连接不同地区局域网或城域网计算机通信的远程公共网络。</li>
</ul>
</li>
<li>IP（Internet Protocol）：本质是一个整形数，用于表示计算机在网络中的地址。<br>IP协议版本有两个：IPv4和IPv6<ul>
<li>IPv4（Internet Protocol version4）：<ul>
<li>使用一个32位的整形数描述一个IP地址，4个字节，int型</li>
<li>也可以使用一个点分十进制字符串描述这个IP地址： <code>192.168.130.198</code></li>
<li>分成了4份，每份1字节，8bit（char），最大值为 255<ul>
<li>0.0.0.0 是最小的IP地址</li>
<li>255.255.255.255是最大的IP地址</li>
</ul>
</li>
<li>按照IPv4协议计算，可以使用的IP地址共有 2^32^ 个</li>
</ul>
</li>
<li>IPv6（Internet Protocol version6）：<ul>
<li>使用一个128位的整形数描述一个IP地址，16个字节</li>
<li>也可以使用一个字符串描述这个IP地址：2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b</li>
<li>分成了8份，每份2字节，每一部分以16进制的方式表示</li>
<li>按照IPv6协议计算，可以使用的IP地址共有 2^128^ 个</li>
</ul>
</li>
</ul>
</li>
<li>查看IP地址</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># linux</span></span><br><span class="line">$ ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># windows</span></span><br><span class="line">$ ipconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试网络是否畅通</span></span><br><span class="line"><span class="comment"># 主机a: 192.168.1.11</span></span><br><span class="line"><span class="comment"># 当前主机: 192.168.1.12</span></span><br><span class="line">$ ping 192.168.1.11     <span class="comment"># 测试是否可用连接局域网</span></span><br><span class="line">$ ping www.baidu.com    <span class="comment"># 测试是否可用连接外网</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 特殊的IP地址: 127.0.0.1  ==&gt; 和本地的IP地址是等价的</span></span><br><span class="line"><span class="comment"># 假设当前电脑没有联网, 就没有IP地址, 又要做网络测试, 可用使用 127.0.0.1 进行本地测试</span></span><br></pre></td></tr></table></figure>

<ul>
<li>端口<br>端口的作用是定位到主机上的某一个进程，通过这个端口进程就可接受到对应的网络数据。</li>
</ul>
<blockquote>
<p>比如: 在电脑上运行了微信和QQ, 小明通过客户端给我的的微信发消息, 电脑上的微信就收到了消息, 为什么?</p>
<p>运行在电脑上的微信和QQ都绑定了不同的端口 通过IP地址可以定位到某一台主机<br>通过端口就可以定位到主机上的某一个进程<br>通过指定的IP和端口，发送数据的时候对端就能接受到数据了</p>
</blockquote>
<p>端口也是一个整形数 <code>unsigned short</code> ，一个16位整形数，有效端口的取值范围是：<br><code>0 ~ 65535</code>(0 ~ 2^16^-1)</p>
<blockquote>
<p>计算机中所有的进程都需要关联一个端口吗?<br>不需要，如果这个进程不需要网络通信，那么这个进程就不需要绑定端口的<br>.<br>一个端口可以被重复使用吗?<br>一个端口只能给某一个进程使用，多个进程不能同时使用同一端口</p>
</blockquote>
<ul>
<li>OSI&#x2F;ISO 网络分层模型<br>OSI（Open System Interconnect），即开放式系统互联。<br>一般都叫OSI参考模型，是ISO（国际标准化组织组织）在1985年研究的网络互联模型。</li>
</ul>
<p><img src="/img/9.21.png" alt="在这里插入图片描述"></p>
<blockquote>
<ul>
<li>物理层：负责最后将信息编码成电流脉冲或其它信号用于网上传输 </li>
<li>数据链路层:<ul>
<li>数据链路层通过物理网络链路供数据传输。</li>
<li>规定了0和1的分包形式，确定了网络数据包的形式；</li>
</ul>
</li>
<li>网络层 <ul>
<li>网络层负责在源和终点之间建立连接;</li>
<li>此处需要确定计算机的位置，通过IPv4，IPv6格式的IP地址来找到对应的主机</li>
</ul>
</li>
<li>传输层 </li>
<li>传输层向高层提供可靠的端到端的网络数据流服务。<ul>
<li>每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信</li>
</ul>
</li>
<li>会话层 </li>
<li>会话层建立、管理和终止表示层与实体之间的通信会话；<ul>
<li>建立一个连接（自动的手机信息、自动的网络寻址）;</li>
</ul>
</li>
<li>表示层:<ul>
<li>对应用层数据编码和转化, 确保以一个系统应用层发送的信息 可以被另一个系统应用层识别;</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<h2 id="1-2-网络协议"><a href="#1-2-网络协议" class="headerlink" title="1.2 网络协议"></a>1.2 网络协议</h2><p>网络协议指的是计算机网络中互相通信的对等实体之间交换信息时所必须遵守的规则的集合。<br>一般系统网络协议包括五个部分：通信环境，传输服务，词汇表，信息的编码格式，时序、规则和过程。<br>通过几幅图了解下常用的网络协议的格式：</p>
<ul>
<li>TCP协议 -&gt; 传输层协议</li>
</ul>
<p><img src="/img/9.22.png" alt="在这里插入图片描述"></p>
<ul>
<li>UDP协议 -&gt; 传输层协议</li>
</ul>
<p><img src="/img/9.23.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>IP协议(IPV4) -&gt; 网络层协议<br><img src="/img/9.24.png" alt="在这里插入图片描述"></p>
</li>
<li><p>以太网帧协议 -&gt; 网络接口层协议</p>
</li>
</ul>
<p><img src="/img/9.25.png" alt="在这里插入图片描述"></p>
<ul>
<li>数据的封装<br><img src="/img/9.26.png" alt="在这里插入图片描述"></li>
</ul>
<p>在网络通信的时候, 我们需负责的应用层数据的处理(最上层)</p>
<ul>
<li>应用层的数据可以使用某些协议进行封装, 也可以不封装</li>
<li>我们需要调用发送数据的接口函数，将数据发送出去</li>
<li>我们调用的API做底层数据处理<ul>
<li>传输层使用传输层协议打包数据</li>
<li>网络层使用网络层协议打包数据</li>
<li>网络接口层使用网络接口层协议打包数据</li>
<li>数据被发送到internet</li>
</ul>
</li>
<li>接收端接收到发送端的数据<ul>
<li>我们调用接收数据的函数接收数据</li>
<li>调用的API做相关的底层处理:<ul>
<li>网络接口层拆包 &#x3D;&#x3D;&gt; 网络层的包</li>
<li>网络层拆包 &#x3D;&#x3D;&gt; 网络层的包</li>
<li>传输层拆包 &#x3D;&#x3D;&gt; 传输层数据</li>
</ul>
</li>
<li>如果应用层也使用了协议对数据进行了封装，数据的包的解析需要我们做</li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-3-socket编程"><a href="#1-3-socket编程" class="headerlink" title="1.3 socket编程"></a>1.3 socket编程</h2><p>Socket套接字由远景研究规划局（Advanced Research Projects Agency, ARPA）资助加里福尼亚大学伯克利分校的一个研究组研发。<br>其目的是将TCP&#x2F;IP协议相关软件移植到UNIX类系统中。设计者开发了一个接口，以便应用程序能简单地调用该接口通信。<br>这个接口不断完善，最终形成了Socket套接字。Linux系统采用了Socket套接字，因此，Socket接口就被广泛使用，到现在已经成为事实上的标准。<br>与套接字相关的函数被包含在头文件<code>sys/socket.h</code>中。</p>
<p>套接字对我们来说就是一套网络通信的接口，使用这套接口就可以完成网络通信。<br>网络通信的主体主要分为两部分：<code>客户端</code>和<code>服务器端</code>。<br>在客户端和服务器通信的时候需要频繁提到三个概念：<code>IP</code>、<code>端口</code>、<code>通信数据</code></p>
<h3 id="1-3-1-字节序"><a href="#1-3-1-字节序" class="headerlink" title="1.3.1 字节序"></a>1.3.1 字节序</h3><p>在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编&#x2F;译码从而导致通信失败。</p>
<p><code>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序 也就是说对于单字符来说是没有字节序问题的，字符串是单字符的集合，因此字符串也没有字节序问题。</code></p>
<p>目前在各种体系的计算机中通常采用的字节存储机制主要有两种：<code>Big-Endian</code> 和 <code>Little-Endian</code></p>
<p>下面先从字节序说起。</p>
<blockquote>
<p>大小端的这个名词最早出现在《格列佛游记》中，里边记载了两个征战的强国，你不会想到的是，他们打仗竟然和剥鸡蛋的顺序有关。很多人认为，剥鸡蛋时应该打破鸡蛋较大的一端，这群人被称作“大端（Big endian）派”。可是那时皇帝儿子小时候吃鸡蛋的时候碰巧将一个手指弄破了。所以，当时的皇帝就下令剥鸡蛋必须打破鸡蛋较小的一端，违令者重罚，由此产生了“小端（Little endian）派”。<br>老百姓们对这项命令极其反感，由此引发了6次叛乱，其中一个皇帝送了命，另一个丢了王位。据估计，先后几次有11000人情愿受死也不肯去打破鸡蛋较小的一端！</p>
</blockquote>
<ul>
<li><p>Little-Endian -&gt; 主机字节序 (小端)</p>
<ul>
<li>数据的<code>低位字节</code>存储到内存的<code>低地址位</code>, 数据的<code>高位字节</code>存储到内存的<code>高地址位</code></li>
<li>我们使用的PC机，数据的存储默认使用的是小端</li>
</ul>
</li>
<li><p>Big-Endian -&gt; 网络字节序 (大端)</p>
<ul>
<li>数据的<code>低位字节</code>存储到内存的<code>高地址位</code>, 数据的<code>高位字节</code>存储到内存的<code>低地址位</code></li>
<li>套接字通信过程中操作的数据都是大端存储的，包括：接收&#x2F;发送的数据,IP地址,端口</li>
</ul>
</li>
<li><p>字节序举例</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有一个16进制的数, 有32位 (int): 0xab5c01ff</span></span><br><span class="line"><span class="comment">// 字节序, 最小的单位: char 字节, int 有4个字节, 需要将其拆分为4份</span></span><br><span class="line"><span class="comment">// 一个字节 unsigned char, 最大值是 255(十进制) ==&gt; ff(16进制) </span></span><br><span class="line">                 内存低地址位                内存的高地址位</span><br><span class="line">---------------------------------------------------------------------------&gt;</span><br><span class="line">小端:         <span class="number">0xff</span>        <span class="number">0x01</span>        <span class="number">0x5c</span>        <span class="number">0xab</span></span><br><span class="line">大端:         <span class="number">0xab</span>        <span class="number">0x5c</span>        <span class="number">0x01</span>        <span class="number">0xff</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/9.27.png" alt="在这里插入图片描述"></p>
<ul>
<li>函数</li>
</ul>
<blockquote>
<p>BSD Socket提供了封装好的转换接口，方便我们使用。<br>包括从主机字节序到网络字节序的转换函数：htons、htonl；<br>从网络字节序到主机字节序的转换函数：ntohs、ntohl。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// u:unsigned</span></span><br><span class="line"><span class="comment">// 16: 16位, 32:32位</span></span><br><span class="line"><span class="comment">// h: host, 主机字节序</span></span><br><span class="line"><span class="comment">// n: net, 网络字节序</span></span><br><span class="line"><span class="comment">// s: short</span></span><br><span class="line"><span class="comment">// l: int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这套api主要用于 网络通信过程中 IP 和 端口 的 转换</span></span><br><span class="line"><span class="comment">// 将一个短整形从主机字节序 -&gt; 网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;	</span><br><span class="line"><span class="comment">// 将一个整形从主机字节序 -&gt; 网络字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;	</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个短整形从网络字节序 -&gt; 主机字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span></span><br><span class="line"><span class="comment">// 将一个整形从网络字节序 -&gt; 主机字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="1-3-2-IP地址转换"><a href="#1-3-2-IP地址转换" class="headerlink" title="1.3.2 IP地址转换"></a>1.3.2 IP地址转换</h3><p>虽然IP地址本质是一个整形数，但是在使用的过程中都是通过一个字符串来描述<br>下面的函数描述了如何将一个字符串类型的IP地址进行大小端转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主机字节序的IP地址转换为网络字节序</span></span><br><span class="line"><span class="comment">// 主机字节序的IP地址是字符串, 网络字节序IP地址是整形</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>; </span><br></pre></td></tr></table></figure>

<ul>
<li>参数:<ul>
<li>af: 地址族(IP地址的家族包括ipv4和ipv6)协议<ul>
<li>AF_INET: ipv4格式的ip地址</li>
<li>AF_INET6: ipv6格式的ip地址</li>
</ul>
</li>
<li>src: 传入参数, 对应要转换的点分十进制的ip地址: 192.168.1.100</li>
<li>dst: 传出参数, 函数调用完成, 转换得到的大端整形IP被写入到这块内存中</li>
</ul>
</li>
<li>返回值：成功返回1，失败返回0或者-1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将大端的整形数, 转换为小端的点分十进制的IP地址        </span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li>af: 地址族协议<ul>
<li>AF_INET: ipv4格式的ip地址</li>
<li>AF_INET6: ipv6格式的ip地址</li>
</ul>
</li>
<li>src: 传入参数, 这个指针指向的内存中存储了大端的整形IP地址</li>
<li>dst: 传出参数, 存储转换得到的小端的点分十进制的IP地址</li>
<li>size: 修饰dst参数的, 标记dst指向的内存中最多可以存储多少个字节</li>
</ul>
</li>
<li>返回值:<ul>
<li>成功: 指针指向第三个参数对应的内存地址, 通过返回值也可以直接取出转换得到的IP字符串</li>
<li>失败: NULL</li>
</ul>
</li>
</ul>
<p>还有一组函数也能进程IP地址大小端的转换，但是只能处理ipv4的ip地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点分十进制IP -&gt; 大端整形</span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大端整形 -&gt; 点分十进制IP</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-3-3-sockaddr-数据结构"><a href="#1-3-3-sockaddr-数据结构" class="headerlink" title="1.3.3 sockaddr 数据结构"></a>1.3.3 sockaddr 数据结构</h3><p><img src="/img/9.28.png" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在写数据的时候不好用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sa_family;       <span class="comment">// 地址族协议, ipv4</span></span><br><span class="line">	<span class="type">char</span>        sa_data[<span class="number">14</span>];     <span class="comment">// 端口(2字节) + IP地址(4字节) + 填充(8字节)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>  <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>    <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(struct sockaddr) == sizeof(struct sockaddr_in)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;		<span class="comment">/* 地址族协议: AF_INET */</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;         <span class="comment">/* 端口, 2字节-&gt; 大端  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">/* IP地址, 4字节 -&gt; 大端  */</span></span><br><span class="line">    <span class="comment">/* 填充 8字节 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) - <span class="keyword">sizeof</span>(sin_family) -</span><br><span class="line">               <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<hr>
<h3 id="1-3-4-套接字函数"><a href="#1-3-4-套接字函数" class="headerlink" title="1.3.4 套接字函数"></a>1.3.4 套接字函数</h3><p>使用套接字通信函数需要包含头文件<code>&lt;arpa/inet.h&gt;</code>，包含了这个头文件<code>&lt;sys/socket.h&gt;</code>就不用在包含了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数:<ul>
<li>domain: 使用的地址族协议<ul>
<li>AF_INET: 使用IPv4格式的ip地址</li>
<li>AF_INET6: 使用IPv4格式的ip地址</li>
</ul>
</li>
<li>type:<ul>
<li>SOCK_STREAM: 使用流式的传输协议</li>
<li>SOCK_DGRAM: 使用报式(报文)的传输协议</li>
</ul>
</li>
<li>protocol: 一般写0即可, 使用默认的协议<ul>
<li>SOCK_STREAM: 流式传输默认使用的是tcp</li>
<li>SOCK_DGRAM: 报式传输默认使用的udp</li>
</ul>
</li>
</ul>
</li>
<li>返回值:<ul>
<li>成功: 可用于套接字通信的文件描述符</li>
<li>失败: -1</li>
</ul>
</li>
</ul>
<p>函数的返回值是一个文件描述符，通过这个文件描述符可以操作内核中的某一块内存，网络通信是基于这个文件描述符来完成的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将文件描述符和本地的IP与端口进行绑定   </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数:<ul>
<li>sockfd: 监听的文件描述符, 通过socket()调用得到的返回值</li>
<li>addr: 传入参数, 要绑定的IP和端口信息需要初始化到这个结构体中，IP和端口要转换为网络字节序</li>
<li>addrlen: 参数addr指向的内存大小, sizeof(struct sockaddr)</li>
</ul>
</li>
<li>返回值：成功返回0，失败返回-1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给监听的套接字设置监听</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数:<ul>
<li>sockfd: 文件描述符, 可以通过调用socket()得到，在监听之前必须要绑定 bind()</li>
<li>backlog: 同时能处理的最大连接要求，最大值为128</li>
</ul>
</li>
<li>返回值：函数调用成功返回0，调用失败返回 -1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待并接受客户端的连接请求, 建立新的连接, 会得到一个新的文件描述符(通信的)		</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数:<ul>
<li>sockfd: 监听的文件描述符</li>
<li>addr: 传出参数, 里边存储了建立连接的客户端的地址信息</li>
<li>addrlen: 传入传出参数，用于存储addr指向的内存大小</li>
</ul>
</li>
<li>返回值：函数调用成功，得到一个文件描述符, 用于和建立连接的这个客户端通信<br>  调用失败返回 -1</li>
</ul>
<p><code>这个函数是一个阻塞函数，当没有新的客户端连接请求的时候，该函数阻塞；当检测到有新的客户端连接请求时，阻塞解除，新连接就建立了，得到的返回值也是一个文件描述符，基于这个文件描述符就可以和客户端通信了。</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数:<ul>
<li>sockfd: 用于通信的文件描述符, accept() 函数的返回值</li>
<li>buf: 指向一块有效内存, 用于存储接收是数据</li>
<li>size: 参数buf指向的内存的容量</li>
<li>flags: 特殊的属性, 一般不使用, 指定为 0</li>
</ul>
</li>
<li>返回值:<ul>
<li>大于0：实际接收的字节数</li>
<li>等于0：对方断开了连接</li>
<li>-1：接收数据失败了</li>
</ul>
</li>
</ul>
<p><code>如果连接没有断开，接收端接收不到数据，接收数据的函数会阻塞等待数据到达，数据到达后函数解除阻塞，开始接收数据， 当发送端断开连接，接收端无法接收到任何数据，但是这时候就不会阻塞了，函数直接返回0。</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送数据的函数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数:<ul>
<li>fd: 通信的文件描述符, accept() 函数的返回值</li>
<li>buf: 传入参数, 要发送的字符串</li>
<li>len: 要发送的字符串的长度</li>
<li>flags: 特殊的属性, 一般不使用, 指定为 0</li>
</ul>
</li>
<li>返回值：<ul>
<li>大于0：实际发送的字节数，和参数len是相等的</li>
<li><pre><code>-1：发送数据失败了
</code></pre>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功连接服务器之后, 客户端会自动随机绑定一个端口</span></span><br><span class="line"><span class="comment">// 服务器端调用accept()的函数, 第二个参数存储的就是客户端的IP和端口信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数:<ul>
<li>sockfd: 通信的文件描述符, 通过调用socket()函数就得到了</li>
<li>addr: 存储了要连接的服务器端的地址信息: iP 和 端口，这个IP和端口也需要转换为大端然后再赋值</li>
<li>addrlen: addr指针指向的内存的大小 sizeof(struct sockaddr)</li>
</ul>
</li>
<li>返回值：连接成功返回0，连接失败返回-1</li>
</ul>
<hr>
<h2 id="1-4-TCP通信流程"><a href="#1-4-TCP通信流程" class="headerlink" title="1.4 TCP通信流程"></a>1.4 TCP通信流程</h2><p>TCP是一个面向连接的，安全的，流式传输协议，这个协议是一个传输层协议。</p>
<ul>
<li>面向连接：是一个双向连接，通过三次握手完成，断开连接需要通过四次挥手完成。</li>
<li>安全：tcp通信过程中,会对发送的每一数据包都会进行校验, 如果发现数据丢失, 会自动重传</li>
<li>流式传输：发送端和接收端处理数据的速度，数据的量都可以不一致<br><img src="/img/9.29.png" alt="在这里插入图片描述"></li>
</ul>
<h3 id="1-4-1-服务器端通信流程"><a href="#1-4-1-服务器端通信流程" class="headerlink" title="1.4.1 服务器端通信流程"></a>1.4.1 服务器端通信流程</h3><ol>
<li>创建用于监听的套接字, 这个套接字是一个文件描述符</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lfd = socket();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将得到的监听的文件描述符和本地的IP 端口进行绑定</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置监听(成功之后开始监听, 监听的是客户端的连接)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>等待并接受客户端的连接请求, 建立新的连接, 会得到一个新的文件描述符(通信的)，没有新连接请求就阻塞</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cfd = accept();</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>通信，读写操作默认都是阻塞的</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line">read(); / recv();</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">write(); / send();</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>断开连接, 关闭套接字</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在tcp的服务器端, 有两类文件描述符</p>
<ul>
<li>监听的文件描述符 <ul>
<li>只需要有一个</li>
<li>不负责和客户端通信, 负责检测客户端的连接请求, 检测到之后调用accept就可以建立新的连接</li>
</ul>
</li>
<li>通信的文件描述符<ul>
<li>负责和建立连接的客户端通信</li>
<li>如果有N个客户端和服务器建立了新的连接,通信的文件描述符就有N个，每个客户端和服务器都对应一个通信的文件描述符</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/img/9.30.png" alt="在这里插入图片描述"></p>
<ul>
<li>文件描述符对应的内存结构：<ul>
<li><code>一个文件文件描述符对应两块内存, 一块内存是读缓冲区, 一块内存是写缓冲区</code></li>
<li>读数据: <code>通过文件描述符将内存中的数据读出, 这块内存称之为读缓冲区</code></li>
<li>写数据: <code>通过文件描述符将数据写入到某块内存中, 这块内存称之为写缓冲区</code></li>
</ul>
</li>
<li>监听的文件描述符:<ul>
<li>客户端的连接请求会发送到服务器端监听的文件描述符的读缓冲区中</li>
<li>读缓冲区中有数据, 说明有新的客户端连接</li>
<li>调用accept()函数, 这个函数会检测监听文件描述符的读缓冲区<ul>
<li>检测不到数据, 该函数阻塞</li>
<li>如果检测到数据, 解除阻塞, 新的连接建立</li>
</ul>
</li>
</ul>
</li>
<li>通信的文件描述符:<ul>
<li>客户端和服务器端都有通信的文件描述符</li>
<li>发送数据：调用函数 write() &#x2F; send()，数据进入到内核中<ul>
<li>数据并没有被发送出去, 而是将数据写入到了通信的文件描述符对应的写缓冲区中</li>
<li>内核检测到通信的文件描述符写缓冲区中有数据, 内核会将数据发送到网络中</li>
</ul>
</li>
<li>接收数据: 调用的函数 read() &#x2F; recv(), 从内核读数据<ul>
<li>数据如何进入到内核我们不需要处理, 数据进入到通信的文件描述符的读缓冲区中</li>
<li>数据进入到内核, 必须使用通信的文件描述符, 将数据从读缓冲区中读出即可</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>基于tcp的服务器端通信代码:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将socket()返回值和本地的IP端口绑定到一起</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="comment">// INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏可以代表任意一个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏一般用于本地的绑定操作</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 这个宏的值为0 == 0.0.0.0</span></span><br><span class="line"><span class="comment">//    inet_pton(AF_INET, &quot;192.168.237.131&quot;, &amp;addr.sin_addr.s_addr);</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 阻塞等待并接受客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印客户端的地址信息</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">24</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP地址: %s, 端口: %d\n&quot;</span>,</span><br><span class="line">           inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, <span class="keyword">sizeof</span>(ip)),</span><br><span class="line">           ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 和客户端通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">            write(cfd, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="1-4-2-客户端的通信流程"><a href="#1-4-2-客户端的通信流程" class="headerlink" title="1.4.2 客户端的通信流程"></a>1.4.2 客户端的通信流程</h3><blockquote>
<p>在单线程的情况下客户端通信的文件描述符有一个, 没有监听的文件描述符</p>
</blockquote>
<ol>
<li>创建一个通信的套接字</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cfd = socket();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>连接服务器, 需要知道服务器绑定的IP和端口</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通信</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line">read(); / recv();</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">write(); / send();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>断开连接, 关闭文件描述符(套接字)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>基于tcp通信的客户端通信代码:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.237.131&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 和服务器端通信</span></span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;你好, 服务器...%d\n&quot;</span>, number++);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器say: %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);   <span class="comment">// 每隔1s发送一条数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="1-5-扩展阅读"><a href="#1-5-扩展阅读" class="headerlink" title="1.5  扩展阅读"></a>1.5  扩展阅读</h2><p>在Window中也提供了套接字通信的API，这些API函数与Linux平台的API函数几乎相同，以至于很多人认为套接字通信的API函数库只有一套，看一下这些Windows平台的套接字函数：</p>
<h3 id="1-5-1-初始化套接字环境"><a href="#1-5-1-初始化套接字环境" class="headerlink" title="1.5.1 初始化套接字环境"></a>1.5.1 初始化套接字环境</h3><p>使用Windows中的套接字函数需要额外包含对应的头文件以及加载响应的动态库：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用包含的头文件 </span></span><br><span class="line">include &lt;winsock2.h&gt;</span><br><span class="line"><span class="comment">// 使用的套接字库 </span></span><br><span class="line">ws2_32.dll       </span><br></pre></td></tr></table></figure>

<p>在Windows中使用套接字需要先加载套接字库（套接字环境），最后需要释放套接字资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化Winsock库</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR。</span></span><br><span class="line">WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);</span><br></pre></td></tr></table></figure>

<ul>
<li>参数:<ul>
<li>wVersionRequested: 使用的Windows Socket的版本, 一般使用的版本是 2.2<ul>
<li>初始化这个 MAKEWORD(2, 2);参数</li>
</ul>
</li>
<li>lpWSAData：一个WSADATA结构指针, 这是一个传入参数<ul>
<li>创建一个 WSADATA 类型的变量, 将地址传递给该函数的第二个参数</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注销Winsock相关库，函数调用成功返回0，失败返回 SOCKET_ERROR。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">WSACleanup</span> <span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>使用举例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WSAData wsa;</span><br><span class="line"><span class="comment">// 初始化套接字库</span></span><br><span class="line">WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .......</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注销Winsock相关库</span></span><br><span class="line">WSACleanup();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-5-2-套接字通信函数"><a href="#1-5-2-套接字通信函数" class="headerlink" title="1.5.2 套接字通信函数"></a>1.5.2 套接字通信函数</h3><p>基于Linux的套接字通信流程是最全面的一套通信流程，如果是在某个框架中进行套接字通信，通信流程只会更简单，直接使用window的套接字api进行套接字通信，和Linux平台上的通信流程完全相同。</p>
<h4 id="1-5-2-1-结构体"><a href="#1-5-2-1-结构体" class="headerlink" title="1.5.2.1 结构体"></a>1.5.2.1 结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/////////////////////////////// Windows ///////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">　　<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">　　	<span class="class"><span class="keyword">struct</span>&#123;</span> <span class="type">unsigned</span> <span class="type">char</span> s_b1,s_b2, s_b3,s_b4;&#125; S_un_b;</span><br><span class="line">　　	<span class="class"><span class="keyword">struct</span>&#123;</span> <span class="type">unsigned</span> <span class="type">short</span> s_w1, s_w2;&#125; S_un_w;</span><br><span class="line">　　	<span class="type">unsigned</span> <span class="type">long</span> S_addr;	<span class="comment">// 存储IP地址</span></span><br><span class="line">　　&#125; S_un;</span><br><span class="line">&#125;IN_ADDR;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">　　<span class="type">short</span> <span class="type">int</span> sin_family; <span class="comment">/* Address family */</span></span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sin_port; <span class="comment">/* Port number */</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* Internet address */</span></span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">/* Same size as struct sockaddr */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////// Linux ////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>  <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>    <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(struct sockaddr) == sizeof(struct sockaddr_in)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;     <span class="comment">/* 地址族协议: AF_INET */</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;         <span class="comment">/* 端口, 2字节-&gt; 大端  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">/* IP地址, 4字节 -&gt; 大端  */</span></span><br><span class="line">    <span class="comment">/* 填充 8字节 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) - <span class="keyword">sizeof</span>(sin_family) -</span><br><span class="line">                      <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<hr>
<h4 id="1-5-2-2-大小端转换函数"><a href="#1-5-2-2-大小端转换函数" class="headerlink" title="1.5.2.2 大小端转换函数"></a>1.5.2.2 大小端转换函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主机字节序 -&gt; 网络字节序</span></span><br><span class="line">u_short <span class="title function_">htons</span> <span class="params">(u_short hostshort )</span>;</span><br><span class="line">u_long <span class="title function_">htonl</span> <span class="params">( u_long hostlong)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络字节序 -&gt; 主机字节序</span></span><br><span class="line">u_short <span class="title function_">ntohs</span> <span class="params">(u_short netshort )</span>;</span><br><span class="line">u_long <span class="title function_">ntohl</span> <span class="params">( u_long netlong)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// linux函数, window上没有这两个函数</span></span><br><span class="line">inet_ntop(); </span><br><span class="line">inet_pton();</span><br><span class="line"></span><br><span class="line"><span class="comment">// windows 和 linux 都使用, 只能处理ipv4的ip地址</span></span><br><span class="line"><span class="comment">// 点分十进制IP -&gt; 大端整形</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> FAR * cp)</span>;	<span class="comment">// windows</span></span><br><span class="line"><span class="type">in_addr_t</span>     <span class="title function_">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;			<span class="comment">// linux</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大端整形 -&gt; 点分十进制IP</span></span><br><span class="line"><span class="comment">// window, linux相同</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="1-5-2-3-套接字函数"><a href="#1-5-2-3-套接字函数" class="headerlink" title="1.5.2.3 套接字函数"></a>1.5.2.3 套接字函数</h4><blockquote>
<p>window的api中套接字对应的类型是 SOCKET 类型, linux中是 int 类型, 本质是一样的</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个套接字</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回套接字, 失败返回INVALID_SOCKET</span></span><br><span class="line">SOCKET <span class="title function_">socket</span><span class="params">(<span class="type">int</span> af,<span class="type">int</span> type,<span class="type">int</span> protocal)</span>;</span><br><span class="line">参数:</span><br><span class="line">    - af: 地址族协议</span><br><span class="line">        - ipv4: AF_INET (windows/linux)</span><br><span class="line">        - PF_INET (windows)</span><br><span class="line">        - AF_INET == PF_INET</span><br><span class="line">   - type: 和linux一样</span><br><span class="line">       	- SOCK_STREAM</span><br><span class="line">        - SOCK_DGRAM</span><br><span class="line">   - protocal: 一般写<span class="number">0</span> 即可</span><br><span class="line">       - 在windows上的另一种写法</span><br><span class="line">           - IPPROTO_TCP, 使用指定的流式协议中的tcp协议</span><br><span class="line">           - IPPROTO_UDP, 使用指定的报式协议中的udp协议</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 关键字: FAR NEAR, 这两个关键字在32/64位机上是没有意义的, 指定的内存的寻址方式</span></span><br><span class="line"><span class="comment">// 套接字绑定本地IP和端口</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR</span></span><br><span class="line"><span class="type">int</span> bind(SOCKET s,<span class="type">const</span> <span class="keyword">struct</span> sockaddr FAR* name, <span class="type">int</span> namelen);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置监听</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(SOCKET s,<span class="type">int</span> backlog)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待并接受客户端连接</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回用于的套接字，失败返回INVALID_SOCKET。</span></span><br><span class="line">SOCKET <span class="title function_">accept</span> <span class="params">( SOCKET s, <span class="keyword">struct</span> sockaddr FAR* addr, <span class="type">int</span> FAR* addrlen )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接服务器</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span> <span class="params">(SOCKET s,<span class="type">const</span> <span class="keyword">struct</span> sockaddr FAR* name,<span class="type">int</span> namelen )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Qt中connect用户信号槽的连接, 如果要使用windows api 中的 connect 需要在函数名前加::</span></span><br><span class="line">::connect(sock, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="comment">// 返回值: 成功时返回接收的字节数，收到EOF时为0，失败时返回SOCKET_ERROR。</span></span><br><span class="line"><span class="comment">//		==0 代表对方已经断开了连接</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recv</span> <span class="params">(SOCKET s,<span class="type">char</span> FAR* buf,<span class="type">int</span> len,<span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回传输字节数，失败返回SOCKET_ERROR。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">send</span> <span class="params">(SOCKET s,<span class="type">const</span> <span class="type">char</span> FAR * buf, <span class="type">int</span> len,<span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭套接字</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closesocket</span> <span class="params">(SOCKET s)</span>;		<span class="comment">// 在linux中使用的函数是: int close(int fd);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------- udp 通信函数 -------------------------</span></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recvfrom</span><span class="params">(SOCKET s,<span class="type">char</span> FAR *buf,<span class="type">int</span> len,<span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">         <span class="keyword">struct</span> sockaddr FAR *from,<span class="type">int</span> FAR *fromlen)</span>;</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendto</span><span class="params">(SOCKET s,<span class="type">const</span> <span class="type">char</span> FAR *buf,<span class="type">int</span> len,<span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">       <span class="type">const</span> <span class="keyword">struct</span> sockaddr FAR *to,<span class="type">int</span> tolen)</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="2-三次握手-四次挥手"><a href="#2-三次握手-四次挥手" class="headerlink" title="2. 三次握手,四次挥手"></a>2. 三次握手,四次挥手</h1><p>TCP协议是一个安全的、面向连接的、流式传输协议，所谓的面向连接就是三次握手<br>对于我们来说只需要在客户端调用<code>connect()</code>函数，三次握手就自动进行了。<br>通过下图看TCP协议的格式</p>
<h2 id="2-1-tcp协议介绍"><a href="#2-1-tcp协议介绍" class="headerlink" title="2.1 tcp协议介绍"></a>2.1 tcp协议介绍</h2><p><img src="/img/9.31.png" alt="在这里插入图片描述"></p>
<p>在Tcp协议中，比较重要的字段有：</p>
<ul>
<li><p>源端口：表示发送端端口号，字段长 16 位，2个字节</p>
</li>
<li><p>目的端口：表示接收端端口号，字段长 16 位，2个字节</p>
</li>
<li><p>序号（sequence number）：字段长 32 位，占4个字节，序号的范围为 [0，4284967296]。</p>
<ul>
<li>由于TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按顺序编号</li>
<li>首部中的序号字段则是指本报文段所发送的数据的第一个字节的序号，这是随机生成的。</li>
<li>序号是循环使用的，当序号增加到最大值时，下一个序号就又回到了0</li>
</ul>
</li>
<li><p>确认序号（acknowledgement number）：占32位（4字节），表示收到的下一个报文段的第一个数据字节的序号，如果确认序号为N，序号为S，则表明到序号N-S为止的所有数据字节都已经被正确地接收到了。</p>
</li>
<li><p>8个标志位（Flag）:</p>
<ul>
<li>CWR：CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小；</li>
<li>ECE：若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 			ECN 为 1 时将 TCP 首部中的 ECE 设为 1；</li>
<li>URG：该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关；</li>
<li><code>ACK</code>：该位设为 1，确认应答的字段有效，TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1；</li>
<li>PSH：该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存；</li>
<li>RST：该位设为 1，表示 TCP 连接出现异常必须强制断开连接；</li>
<li><code>SYN</code>：用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；</li>
<li><code>FIN</code>：该位设为 1，表示今后不再有数据发送，希望断开连接。</li>
</ul>
</li>
<li><p>窗口大小：该字段长 16 位，表示从确认序号所指位置开始能够接收的数据大小，TCP 不允许发送超过该窗口大小的数据。</p>
</li>
</ul>
<hr>
<h2 id="2-2-三次握手"><a href="#2-2-三次握手" class="headerlink" title="2.2 三次握手"></a>2.2 三次握手</h2><p>Tcp连接是双向连接，客户端和服务器需要分别向对方发送连接请求，并且建立连接，三次握手成功之后，二者之间的双向连接也就成功建立了。如果要保证三次握手顺利完成，必须要满足以下条件：</p>
<ul>
<li>服务器端：已经启动，并且启动了监听（被动接受连接的一端）</li>
<li>客户端：基于服务器端监听的IP和端口，向服务器端发起连接请求（主动发起连接的一端）<br><img src="/img/9.32.png" alt="在这里插入图片描述"></li>
</ul>
<p>三次握手具体过程如下：</p>
<p>第一次握手：</p>
<ul>
<li>客户端：客户端向服务器端发起连接请求将报文中的SYN字段置为1，生成随机序号x，seq&#x3D;x</li>
<li>服务器端：接收客户端发送的请求数据，解析tcp协议，校验SYN标志位是否为1，并得到序号 x</li>
</ul>
<p>第二次握手：</p>
<ul>
<li>服务器端：给客户端回复数据<ol>
<li>回复ACK, 将tcp协议ACK对应的标志位设置为1，表示同意了客户端建立连接的请求</li>
<li>回复了 ack&#x3D;x+1, 这是确认序号<ul>
<li>x: 客户端生成的随机序号</li>
<li>1: 客户端给服务器发送的数据的量, SYN标志位存储到某一个字节中, 因此按照一个字节计算，表示客户端给服务器发送的1个字节服务器收到了。</li>
</ul>
</li>
<li>将tcp协议中的SYN对应的标志位设置为 1, 服务器向客户端发起了连接请求</li>
<li>服务器端生成了一个随机序号 y, 发送给了客户端</li>
</ol>
</li>
<li>客户端：接收回复的数据，并解析tcp协议<ol>
<li>校验ACK标志位，为1表示服务器接收了客户端的连接请求</li>
<li>数据校验，确认发送给服务器的数据服务器收到了没有，计算公式如下：<br>发送的数据的量 &#x3D; 使用服务器回复的确认序号 - 客户端生成的随机序号 &#x3D;&#x3D;&#x3D;&gt; 1&#x3D;x+1-x</li>
<li>校验SYN标志位，为1表示服务器请求和客户端建立连接</li>
<li>得到服务器生成的随机序号: y</li>
</ol>
</li>
</ul>
<p>第三次握手：</p>
<ul>
<li>客户端：发送数据给服务器<ol>
<li>将tcp协议中ACK标志位设置为1，表示同意了服务器的连接请求</li>
<li>给服务器回复了一个确认序号 ack &#x3D; y+1<ul>
<li>y：服务器端生成的随机序号</li>
<li>1：服务器给客户端发送的数据量，服务器给客户端发送了ACK和SYN, 都存储在这一个字节中</li>
</ul>
</li>
<li>发送给服务器的序号就是上一次从服务器端收的确认序号因此 seq &#x3D; x+1</li>
</ol>
</li>
<li>服务器端：接收数据, 并解析tcp协议<ol>
<li>查看ACK对应的标志位是否为1, 如果是1代表, 客户端同意了服务器的连接请求</li>
<li>数据校验，确认发送给客户端的数据客户端收到了没有，计算公式如下：<br>给客户端发送的数据量 &#x3D; 确认序号 - 服务器生成的随机序号 &#x3D;&#x3D;&#x3D;&gt; 1&#x3D;y+1-y</li>
<li>得到客户端发送的序号：x+1</li>
</ol>
</li>
</ul>
<hr>
<h2 id="2-2-TCP四次挥手"><a href="#2-2-TCP四次挥手" class="headerlink" title="2.2 TCP四次挥手"></a>2.2 TCP四次挥手</h2><p>四次挥手是断开连接的过程，需要双向断开，关于由哪一端先断开连接是没有要求的。通信的两端如果想要断开连接就需要调用<code>close()</code>函数，当两端都调用了该函数，四次挥手也就完成了。</p>
<ul>
<li><p>客户端和服务器断开连接 -&gt; 单向断开</p>
</li>
<li><p>服务器和客户端断开连接 -&gt; 单向断开</p>
</li>
</ul>
<p>进行了两次单向断开，双向断开就完成了，每进行一次单向断开，就会完成两次挥手的动作。<br><img src="/img/9.33.png" alt="在这里插入图片描述"></p>
<p>基于上图的例子对四次挥手的具体过程进行阐述（实际上那端先断开连接都是允许的）：</p>
<p>第一次挥手:</p>
<ul>
<li>主动断开连接的一方：发送断开连接的请求<ol>
<li>将tcp协议中FIN标志位设置为1，表示请求断开连接</li>
<li>发送序号x给对端，seq&#x3D;x，基于这个序号用于客户端数据校验的计算</li>
</ol>
</li>
<li>被动断开连接的一方：接收请求数据, 并解析TCP协议<ol>
<li>校验FIN标志位是否为1</li>
<li>收到了序号 x，基于这个数据计算回复的确认序号 ack 的值</li>
</ol>
</li>
</ul>
<p>第二次挥手:</p>
<ul>
<li>被动断开连接的一方：回复数据<ol>
<li>同意了对方断开连接的请求，将ACK标志位设置为1</li>
<li>回复 ack&#x3D;x+1，表示成功接受了客户端发送的一个字节数据</li>
<li>向客户端发送序号 seq&#x3D;y，基于这个序号用于服务器端数据校验的计算</li>
</ol>
</li>
<li>主动断开连接的一方：接收回复数据, 并解析TCP协议<ol>
<li>校验ACK标志位，如果为1表示断开连接的请求对方已经同意了</li>
<li>校验 ack确认发送的数据服务器是否收到了，发送的数据 &#x3D; ack - x &#x3D; x + 1 -x &#x3D; 1</li>
</ol>
</li>
</ul>
<p>第三次挥手:</p>
<ul>
<li>被动断开连接的一方：将tcp协议中FIN标志位设置为1，表示请求断开连接</li>
<li>主动断开连接的一方：接收请求数据, 并解析TCP协议，校验FIN标志位是否为1</li>
</ul>
<p>第四次挥手:</p>
<ul>
<li>主动断开连接的一方：回复数据<ol>
<li>将tcp协议中ACK对应的标志位设置为1，表示同意了断开连接的请求</li>
<li>ack&#x3D;y+1，表示服务器发送给客户端的一个字节客户端接收到了</li>
<li>序号 seq&#x3D;h，此时的h应该等于 x+1，也就是第三次挥手时服务器回复的确认序号ack的值</li>
</ol>
</li>
<li>被动断开连接的一方：收到回复的ACK, 此时双向连接双向断开, 通信的两端没有任何关系了</li>
</ul>
<hr>
<h2 id="2-3-流量控制"><a href="#2-3-流量控制" class="headerlink" title="2.3 流量控制"></a>2.3 流量控制</h2><p>流量控制可以让发送端根据接收端的实际接受能力控制发送的数据量。<br>它的具体操作是，<code>接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不会超过该大小的数据，该限制大小即为窗口大小，即窗口大小由接收端主机决定。</code></p>
<p>TCP 首部中，专门有一个字段来通知窗口大小，接收主机将自己可以接收的缓冲区大小放在该字段中通知发送端。<br><code>当接收端的缓冲区面临数据溢出时，窗口大小的值也是随之改变，设置为一个更小的值通知发送端，从而控制数据的发送量，这样达到流量的控制</code>。这个控制流程的窗口也可以称作滑动窗口。</p>
<p>此图为一个单向的数据发送:<br><img src="/img/9.34.png" alt="在这里插入图片描述"></p>
<p>左侧是数据发送端：对应的是发送端的写缓冲区(内存)，通过一个环形队列进行数据管理</p>
<ul>
<li>白色格子: 空闲的内存, 可以写数据</li>
<li>粉色的格子: 被写入到内存, 但是还没有被发送出去的数据</li>
<li>灰色的格子: 代表已经被发送出去的数据</li>
</ul>
<p>右侧是数据接收端：对应的是接收端的读缓冲区，存储发送端发送过来的数据</p>
<ul>
<li>白色格子：空闲的内存, 可以继续接收数据, 滑动窗口的值记录的就是白色的格子的大小<ul>
<li>随着接收的数据越来越多, 白色格子越来越少, 滑动窗口的值越来越小</li>
<li>如果白色格子没有了, 滑动窗口变为0, 这时候, 发送端就被阻塞了</li>
</ul>
</li>
<li>粉色格子：接收的数据，但是这个数据还没有从内核中读走，使用read() &#x2F; recv()<ul>
<li>粉色格子变少了, 可用空间就变多了, 滑动窗口的值就变大了</li>
<li>如果滑动窗口的值从0变为大于0, 接收端又重新有容量接收数据了, 发送端的阻塞自动解除，继续发送数据</li>
</ul>
</li>
</ul>
<p>基于TCP通信的流程图，记录了从三次握手 -&gt; 数据通信 -&gt; 四次挥手的全过程：<br><img src="/img/9.35.png" alt="在这里插入图片描述"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fast sender: 客户端</span></span><br><span class="line"><span class="comment"># slow recerver: 服务器</span></span><br><span class="line"><span class="comment"># win: 滑动窗口大小</span></span><br><span class="line"><span class="comment"># mss: maximum segment size, 单条数据的最大长度</span></span><br></pre></td></tr></table></figure>

<p>第1步：第一次握手，发送连接请求SYN到服务器端</p>
<ul>
<li>0(0)：0表示客户端生成的随机序号，(0)表示客户端没有额外给服务器发送数据, 因此数据的量为0</li>
<li>win4096: 客户端告诉服务器, 能接收的数据(缓存)的最大量为4k</li>
<li>mss1460: 客户端可以处理的单条最大字节数是1460字节</li>
</ul>
<p>第2步：第二次握手</p>
<ul>
<li>ACK: 服务器同意了客户端的连接请求<ul>
<li>SYN: 服务器请求和客户端建立连接</li>
</ul>
</li>
<li>8000(0)：8000是服务器端生成的随机序号，(0)表示服务器没有额外给客户端发送数据, 因此数据的量为0</li>
<li>1: 发送给客户端的确认序号<ul>
<li>确认序号 &#x3D; 客户端生成的随机序号 + 客户端给服务器发送的数据量(字节数) &#x3D;&#x3D;&#x3D;&gt; 1&#x3D;0+1</li>
<li>表示客户端给服务器发送的1个字节服务器收到了</li>
</ul>
</li>
<li>win6144: 服务器告诉客户端我能最多缓存 6k数据</li>
<li>mss1024: 服务器能处理的单条数据最大长度是 1k</li>
</ul>
<p>第3步: 第三次握手</p>
<ul>
<li>ACK: 客户端同意了服务器的连接请求</li>
<li>8001: 发送给服务器的确认序号<ul>
<li>确认序号 &#x3D; 服务器生成的随机序号 + 服务器给客户端发送的数据量 &#x3D;&#x3D;&#x3D;&gt; 8001 &#x3D; 8000 + 1</li>
<li>客户端告诉服务器, 你给我发送的1个字节的数据我收到了</li>
</ul>
</li>
<li>win4096: 告诉服务器客户端能缓存的最大数据量是4k</li>
</ul>
<p>第4~9步: 客户端给服务器发送数据</p>
<ul>
<li><p>1(1024)：1 （1-0）表示之前一共给服务器发送了1个字节，(1024)表示这次要发送的数据量为 1k</p>
</li>
<li><p>1025(1024)：1025（1025-0）表示之前一共给服务器发送了1025个字节，(1024)表示这次要发送的数据量为 1k</p>
</li>
<li><p>2049(1024)：2049（2049-0）表示之前一共给服务器发送了2049个字节，(1024)表示这次要发送的数据量为 1k</p>
</li>
<li><p>第9步完成之后，服务器的滑动窗口变为0，接收数据的缓存被写满了，发送端阻塞</p>
</li>
</ul>
<p>第10步:</p>
<ul>
<li><p>ack6145: 服务器给客户端回复数据，6145是确认序号, 代表实际接收的字节数<br>服务器实际接收的字节数 &#x3D; 确认序号 - 客户端生成的随机序号 &#x3D;&#x3D;&#x3D;&gt; 6145 &#x3D; 6145 - 0</p>
</li>
<li><p>win2048：服务器告诉客户端我的缓存还有2k，也就是还有4k还在缓存中没有被读走</p>
</li>
</ul>
<p>第11步：win4096表示滑动窗口变为4k，代表还可以接收4k数据，还有2k在缓存中</p>
<p>第12步：客户端又给服务器发送了1k数据</p>
<p>第13步: 第一次挥手，FIN表示客户端主动和服务器断开连接，并且发送了1k数据到服务器端</p>
<p>第14步: 第二次挥手，回复ACK, 同意断开连接</p>
<p>第15, 16步: 服务器端从读缓冲区中读数据, 第16步数据读完, 滑动窗口变成最大的6k</p>
<p>第17步: 第三次挥手</p>
<ul>
<li><p>FIN: 服务器请求和客户端断开连接</p>
</li>
<li><p>8001(0): 服务器一共给客户端发送的字节数 8001 - 8000 &#x3D; 1个字节，携带的数据量为0（FIN不计算在内）</p>
</li>
<li><p>ack8194: 服务器收到了客户端的多少个字节: 8194 - 0 &#x3D; 8194个字节</p>
</li>
</ul>
<p>第18步: 第四次挥手</p>
<ul>
<li>ACK: 客户端同意了服务器断开连接的请求</li>
<li>8002: 确认序号, 可以计算出服务器给客户端发送了多少数据，8002 - 8000 &#x3D; 2 个字节</li>
</ul>
<hr>
<h1 id="3-TCP状态转换"><a href="#3-TCP状态转换" class="headerlink" title="3. TCP状态转换"></a>3. TCP状态转换</h1><h2 id="3-1-TCP状态转换"><a href="#3-1-TCP状态转换" class="headerlink" title="3.1 TCP状态转换"></a>3.1 TCP状态转换</h2><p>在TCP进行三次握手，或者四次挥手的过程中，通信的服务器和客户端内部会发送状态上的变化，发生的状态变化在程序中是看不到的，这个状态的变化也不需要我们去维护，但在某些情况下进行程序的调试会去查看相关的状态信息，先来看三次握手过程中的状态转换。</p>
<p><img src="/img/9.36.png" alt="在这里插入图片描述"></p>
<h3 id="3-1-1-三次握手"><a href="#3-1-1-三次握手" class="headerlink" title="3.1.1 三次握手"></a>3.1.1 三次握手</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在第一次握手之前，服务器端必须先启动，并且已经开始了监听</span><br><span class="line">  - 服务器端先调用了 listen() 函数, 开始监听</span><br><span class="line">  - 服务器启动监听前后的状态变化: 没有状态 ---&gt; LISTEN</span><br></pre></td></tr></table></figure>


<p>当服务器监听启动之后，由客户端发起的三次握手过程中状态转换如下：</p>
<p>第一次握手:</p>
<ul>
<li>客户端：调用了<code>connect()</code> 函数，状态变化：<code>没有状态 -&gt; SYN_SENT</code></li>
<li>服务器：收到连接请求SYN，状态变化：<code>LISTEN -&gt; SYN_RCVD</code></li>
</ul>
<p>第二次握手:</p>
<ul>
<li>服务器：给客户端回复ACK，并且请求和客户端建立连接，状态无变化，依然是 SYN_RCVD</li>
<li>客户端：接收数据，收到了ACK，状态变化：<code>SYN_SENT -&gt; ESTABLISHED</code></li>
</ul>
<p>第三次握手:</p>
<ul>
<li>客户端：给服务器回复ACK，同意建立连接，状态没有变化，还是 ESTABLISHED</li>
<li>服务器：收到了ACK，状态变化：<code>SYN_RCVD -&gt; ESTABLISHED</code></li>
</ul>
<p><code>三次握手完成之后，客户端和服务器都变成了同一种状态，这种状态叫：ESTABLISHED，表示双向连接已经建立， 可以通信了。在通过过程中，正常的通信状态就是 ESTABLISHED。</code></p>
<hr>
<h3 id="3-1-2-四次挥手"><a href="#3-1-2-四次挥手" class="headerlink" title="3.1.2 四次挥手"></a>3.1.2 四次挥手</h3><p>关于四次挥手对于客户端和服务器哪段先断开连接没有要求，根据实际情况处理即可。下面根据上图中的实例描述一下四次挥手过程中TCP的状态转换（上图中主动断开连接的一方是客户端）：</p>
<p>第一次挥手:</p>
<ul>
<li><p>客户端：调用<code>close()</code> 函数，将tcp协议中的FIN设置为1，请求和服务器断开连接，<br>状态变化:<code>ESTABLISHED -&gt; FIN_WAIT_1</code></p>
</li>
<li><p>服务器：收到断开连接请求，状态变化: <code>ESTABLISHED -&gt; CLOSE_WAIT</code></p>
</li>
</ul>
<p>第二次挥手:</p>
<ul>
<li>服务器：回复ACK，同意断开连接的请求，状态没有变化，还是 CLOSE_WAIT</li>
<li>客户端：收到ACK，状态变化：<code>FIN_WAIT_1 -&gt; FIN_WAIT_2</code></li>
</ul>
<p>第三次挥手:</p>
<ul>
<li>服务器端：调用close() 函数，发送FIN给客户端，请求断开连接，状态变化：<code>CLOSE_WAIT -&gt; LAST_ACK</code></li>
<li>客户端：收到FIN，状态变化：<code>FIN_WAIT_2 -&gt; TIME_WAIT</code></li>
</ul>
<p>第四次挥手:</p>
<ul>
<li>客户端：回复ACK给服务器，状态是没有变化的，状态变化：<code>TIME_WAIT -&gt; 没有状态</code></li>
<li>服务器端：收到ACK，双向连接断开，状态变化：<code>LAST_ACK -&gt; 无状态(没有了)</code></li>
</ul>
<hr>
<h3 id="3-1-3-状态转换"><a href="#3-1-3-状态转换" class="headerlink" title="3.1.3 状态转换"></a>3.1.3 状态转换</h3><p>在下图中同样是描述TCP通信过程中的客户端和服务器端的状态转换<br>只需要看两条主线：红色实线和绿色虚线。关于黑色的实线对应的是一些特殊情况下的状态切换，在此不做任何分析。</p>
<p>因为三次握手是由客户端发起的，据此分析红色实线表示的客户端的状态，绿色虚线表示的是服务器端的状态。<br><img src="/img/9.37.png" alt="在这里插入图片描述"></p>
<ul>
<li>客户端：<ul>
<li>第一次握手：发送SYN，<code>没有状态 -&gt; SYN_SENT</code></li>
<li>第二次握手：收到回复的ACK，<code>SYN_SENT -&gt; ESTABLISHED</code></li>
<li>主动断开连接，第一次挥手发送FIN，状态<code>ESTABLISHED -&gt; FIN_WAIT_1</code></li>
<li>第二次挥手，收到ACK，状态<code>FIN_WAIT_1 -&gt; FIN_WAIT_2</code></li>
<li>第三次挥手，收到FIN，状态<code>FIN_WAIT_2 -&gt; TIME_WAIT</code></li>
<li>第四次挥手，回复ACK，等待2倍报文时长之后，状态<code>TIME_WAIT -&gt; 没有状态</code></li>
</ul>
</li>
<li>服务器端：<ul>
<li>启动监听，<code>没有状态 -&gt; LISTEN</code></li>
<li>第一次握手，收到SYN，状态<code>LISTEN -&gt; SYN_RCVD</code></li>
<li>第三次握手，收到ACK，状态<code>SYN_RCVD -&gt; ESTABLISHED</code></li>
<li>收到断开连接请求，第一次挥手状态 <code>ESTABLISHED -&gt; CLOSE_WAIT</code></li>
<li>第三次挥手，发送FIN请求和客户端断开连接，状态<code>CLOSE_WAIT -&gt; LAST_ACK</code></li>
<li>第四次挥手，收到ACK，状态<code>LAST_ACK -&gt; 无状态(没有了)</code></li>
</ul>
</li>
</ul>
<p>在TCP通信的时候，当主动断开连接的一方接收到被动断开连接的一方发送的FIN和最终的ACK后（第三次挥手完成），连接的主动关闭方必须处于<code>TIME_WAIT</code>状态并持续<code>2MSL(Maximum Segment Lifetime)</code>时间，这样就能够让TCP连接的主动关闭方在它发送的ACK丢失的情况下重新发送最终的ACK。</p>
<p>一倍报文寿命(MSL)大概时长为30s，因此两倍报文寿命一般在1分钟作用。</p>
<p><code>主动关闭方重新发送的最终ACK，是因为被动关闭方重传了它的FIN。事实上，被动关闭方总是重传FIN直到它收到一个最终的ACK。</code></p>
<hr>
<h3 id="3-1-4-相关命令"><a href="#3-1-4-相关命令" class="headerlink" title="3.1.4 相关命令"></a>3.1.4 相关命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ netstat 参数</span><br><span class="line">$ netstat -apn	| grep 关键字</span><br></pre></td></tr></table></figure>

<ul>
<li>参数:<ul>
<li><code>-a</code> (all)显示所有选项</li>
<li><code>-p</code> 显示建立相关链接的程序名</li>
<li><code>-n</code> 拒绝显示别名，能显示数字的全部转化成数字。</li>
<li><code>-l</code> 仅列出有在 Listen (监听) 的服务状态</li>
<li><code>-t </code>(tcp)仅显示tcp相关选项</li>
<li><code>-u</code> (udp)仅显示udp相关选项</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-2-半关闭"><a href="#3-2-半关闭" class="headerlink" title="3.2 半关闭"></a>3.2 半关闭</h2><p>TCP连接只有一方发送了FIN，另一方没有发出FIN包，仍然可以在一个方向上正常发送数据，这中状态可以称之为半关闭或者半连接。当四次挥手完成两次的时候，就相当于实现了半关闭，在程序中只需要在某一端直接调用 close() 函数即可。套接字通信默认是双工的，也就是双向通信，如果进行了半关闭就变成了单工，数据只能单向流动了。比如下面的这个例子：</p>
<ul>
<li>服务器端:<ul>
<li>调用了close() 函数，因此不能发数据，只能接收数据</li>
<li>关闭了服务器端的写操作，现在只能进行读操作 –&gt; 变成了读端</li>
</ul>
</li>
<li>客户端:<ul>
<li>没有调用close()，客户端和服务器的连接还保持着</li>
<li>客户端可以给服务器发送数据，也可以接收服务器发送的数据 （但是，服务器已经丧失了发送数据的能力），因此客户端也只能发送数据，接收不到数据 –&gt; 变成了写端</li>
</ul>
</li>
</ul>
<p>按照上述流程做了半关闭之后，从双工变成了单工，数据单向流动的方向: 客户端 —–&gt; 服务器端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 专门处理半关闭的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 可以有选择的关闭读/写, close()函数只能关闭写操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数:<ul>
<li>sockfd: 要操作的文件描述符</li>
<li>how:<ul>
<li>SHUT_RD: 关闭文件描述符对应的读操作</li>
<li>SHUT_WR: 关闭文件描述符对应的写操作</li>
<li>SHUT_RDWR: 关闭文件描述符对应的读写操作</li>
</ul>
</li>
</ul>
</li>
<li>返回值：函数调用成功返回0，失败返回-1</li>
</ul>
<hr>
<h2 id="3-3-端口复用"><a href="#3-3-端口复用" class="headerlink" title="3.3 端口复用"></a>3.3 端口复用</h2><p>在网络通信中，一个端口只能被一个进程使用，不能多个进程共用同一个端口。我们在进行套接字通信的时候，如果按顺序执行如下操作：先启动服务器程序，再启动客户端程序，然后关闭服务器进程，再退出客户端进程，最后再启动服务器进程，就会出如下错误信息：<code>bind error: Address already in use</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二次启动服务器进程</span></span><br><span class="line">$ ./server </span><br><span class="line"><span class="built_in">bind</span> error: Address already <span class="keyword">in</span> use</span><br><span class="line"></span><br><span class="line">$ netstat -apn|grep 9999</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        0      0 127.0.0.1:9999          127.0.0.1:50178         TIME_WAIT   -   </span><br></pre></td></tr></table></figure>

<p>通过<code>netstat</code>查看TCP状态，发现上一个服务器进程其实还没有真正退出。<br>因为服务器进程是主动断开连接的进程, 最后状态变成了 <code>TIME_WAIT</code>状态，这个进程会等待<code>2msl(大约1分钟)</code>才会退出，如果该进程不退出，其绑定的端口就不会释放，再次启动新的进程还是使用这个未释放的端口，<code>端口被重复使用</code>，<code>bind error: Address already in use</code></p>
<p>如果想要解决上述问题，就必须要设置端口复用，使用的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数是一个多功能函数, 可以设置套接字选项</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数:<ul>
<li>sockfd：用于监听的文件描述符</li>
<li>level：设置端口复用需要使用 SOL_SOCKET 宏</li>
<li>optname：要设置什么属性（下边的两个宏都可以设置端口复用）<ul>
<li>SO_REUSEADDR</li>
<li>SO_REUSEPORT</li>
</ul>
</li>
<li>optval：设置是去除端口复用属性还是设置端口复用属性，实际应该使用 int 型变量<ul>
<li>0：不设置</li>
<li>1：设置</li>
</ul>
</li>
<li>optlen：optval指针指向的内存大小 sizeof(int)</li>
</ul>
</li>
</ul>
<blockquote>
<p>这个函数应该添加到服务器端代码中，具体应放在绑定之前设置端口复用</p>
</blockquote>
<ol>
<li>创建监听的套接字</li>
<li>设置端口复用</li>
<li>绑定</li>
<li>设置监听</li>
<li>等待并接受客户端连接</li>
<li>通信</li>
<li>断开连接</li>
</ol>
<p>参考代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">// 本地多有的ＩＰ</span></span><br><span class="line">    <span class="comment">// 127.0.0.1</span></span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr.s_addr);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd_set reads, tmp;</span><br><span class="line">    FD_ZERO(&amp;reads);</span><br><span class="line">    FD_SET(lfd, &amp;reads);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = reads;</span><br><span class="line">        <span class="type">int</span> ret = select(maxfd+<span class="number">1</span>, &amp;tmp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(lfd, &amp;tmp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cfd = accept(lfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            FD_SET(cfd, &amp;reads);</span><br><span class="line">            maxfd = cfd &gt; maxfd ? cfd : maxfd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=lfd+<span class="number">1</span>; i&lt;=maxfd; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(i, &amp;tmp))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">int</span> len = read(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client say: %s\n&quot;</span>, buf);</span><br><span class="line">                    write(i, buf, len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接\n&quot;</span>);</span><br><span class="line">                    FD_CLR(i, &amp;reads);</span><br><span class="line">                    close(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="4-服务器并发"><a href="#4-服务器并发" class="headerlink" title="4. 服务器并发"></a>4. 服务器并发</h1><h2 id="4-1-单线程-进程"><a href="#4-1-单线程-进程" class="headerlink" title="4.1 单线程&#x2F;进程"></a>4.1 单线程&#x2F;进程</h2><p>在TCP通信过程中，服务器端启动之后可以同时和多个客户端建立连接，并进行网络通信，但是在介绍TCP通信流程的时候，提供的服务器代码却不能完成这样的需求<br>看之前的服务器代码的处理思路，分析弊端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 2. 将socket()返回值和本地的IP端口绑定到一起</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="comment">// INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏可以代表任意一个IP地址</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 这个宏的值为0 == 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="comment">// 4. 阻塞等待并接受客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">    <span class="comment">// 5. 和客户端通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">            write(cfd, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中用到了三个会引起程序阻塞的函数，分别是：</p>
<ul>
<li><code>accept()</code>：如果服务器端没有新客户端连接，阻塞当前进程&#x2F;线程，如果检测到新连接解除阻塞，建立连接</li>
<li><code>read()</code>：如果通信的套接字对应的读缓冲区没有数据，阻塞当前进程&#x2F;线程，检测到数据解除阻塞，接收数据</li>
<li><code>write()</code>：如果通信的套接字写缓冲区被写满了，阻塞当前进程&#x2F;线程（比较少见）</li>
</ul>
<p>如果需要和发起新的连接请求的客户端建立连接，那么就必须在服务器端通过一个循环调用<code>accept()</code>函数，另外已经和服务器建立连接的客户端需要和服务器通信，发送数据时的阻塞可以忽略，当接收不到数据时程序也会被阻塞，这时候就会非常矛盾，被<code>accept()</code>阻塞就无法通信，被<code>read()</code>阻塞就无法和客户端建立新连接。<br>基于上述处理方式，在单线程&#x2F;单进程场景下，服务器是无法处理多连接的<br>解决方案也有很多，常用的有三种：</p>
<ol>
<li>使用多线程实现</li>
<li>使用多进程实现</li>
<li>使用IO多路转接（复用）实现</li>
<li>使用IO多路转接 + 多线程实现</li>
</ol>
<hr>
<h2 id="4-2-多进程并发"><a href="#4-2-多进程并发" class="headerlink" title="4.2 多进程并发"></a>4.2 多进程并发</h2><p>如果要编写多进程版的并发服务器程序，首先要考虑，创建出的多个进程都是什么角色，这样就可以在程序中对号入座了。在Tcp服务器端一共有两个角色，分别是：监听和通信，监听是一个持续的动作，如果有新连接就建立连接，如果没有新连接就阻塞。关于通信是需要和多个客户端同时进行的，因此需要多个进程，这样才能达到互不影响的效果。进程也有两大类：父进程和子进程，通过分析我们可以这样分配进程：</p>
<ul>
<li>父进程：<ul>
<li>负责监听，处理客户端的连接请求，也就是在父进程中循环调用<code>accept()</code>函数</li>
<li>创建子进程：建立一个新的连接，就创建一个新的子进程，让这个子进程和对应的客户端通信</li>
<li>回收子进程资源：子进程退出回收其内核PCB资源，防止出现僵尸进程</li>
</ul>
</li>
<li>子进程：负责通信，基于父进程建立新连接之后得到的文件描述符，和对应的客户端完成数据的接收和发送。<ul>
<li>发送数据：<code>send() / write()</code></li>
<li>接收数据：<code>recv() / read()</code></li>
</ul>
</li>
</ul>
<p>在多进程版的服务器端程序中，多个进程是有血缘关系，对应有血缘关系的进程来说，还需要想明白他们有哪些资源是可以被继承的，哪些资源是独占的，以及一些其他细节：</p>
<ul>
<li><p>子进程是父进程的拷贝，在子进程的内核区PCB中，文件描述符也是可以被拷贝的，因此在父进程可以使用的文件描述符在子进程中也有一份，并且可以使用它们做和父进程一样的事情。</p>
</li>
<li><p>父子进程有用各自的独立的虚拟地址空间，因此所有的资源都是独占的</p>
</li>
<li><p>为了节省系统资源，对于只有在父进程才能用到的资源，可以在子进程中将其释放掉，父进程亦如此。</p>
</li>
<li><p>由于需要在父进程中做accept()操作，并且要释放子进程资源，如果想要更高效一下可以使用信号的方式处理<br><img src="/img/9.38.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<p>多进程版并发TCP服务器示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">callback</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(pid &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程正在运行, 或者子进程被回收完毕了\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">childWork</span><span class="params">(<span class="type">int</span> cfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将socket()返回值和本地的IP端口绑定到一起</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="comment">// INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏可以代表任意一个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏一般用于本地的绑定操作</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 这个宏的值为0 == 0.0.0.0</span></span><br><span class="line">    <span class="comment">//    inet_pton(AF_INET, &quot;192.168.237.131&quot;, &amp;addr.sin_addr.s_addr);</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号的捕捉</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = callback;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受多个客户端连接, 对需要循环调用 accept</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 4. 阻塞等待并接受客户端连接</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// accept调用被信号中断了, 解除阻塞, 返回了-1</span></span><br><span class="line">                <span class="comment">// 重新调用一次accept</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印客户端的地址信息</span></span><br><span class="line">        <span class="type">char</span> ip[<span class="number">24</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP地址: %s, 端口: %d\n&quot;</span>,</span><br><span class="line">               inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, <span class="keyword">sizeof</span>(ip)),</span><br><span class="line">               ntohs(cliaddr.sin_port));</span><br><span class="line">        <span class="comment">// 新的连接已经建立了, 创建子进程, 让子进程和这个客户端通信</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 子进程 -&gt; 和客户端通信</span></span><br><span class="line">            <span class="comment">// 通信的文件描述符cfd被拷贝到子进程中</span></span><br><span class="line">            <span class="comment">// 子进程不负责监听</span></span><br><span class="line">            close(lfd);</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> ret = childWork(cfd);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt;=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 退出子进程</span></span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 父进程不和客户端通信</span></span><br><span class="line">            close(cfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 和客户端通信</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">childWork</span><span class="params">(<span class="type">int</span> cfd)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="type">int</span> len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">        write(cfd, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例代码中，父子进程中分别关掉了用不到的文件描述符（父进程不需要通信，子进程也不需要监听）。如果客户端主动断开连接，那么服务器端负责和客户端通信的子进程也就退出了，子进程退出之后会给父进程发送一个叫做<code>SIGCHLD</code>的信号，在父进程中通过<code>sigaction()</code>函数捕捉了该信号，通过回调函数<code>callback()</code>中的<code>waitpid()</code>对退出的子进程进行了资源回收。</p>
<p>还有一个细节，这是父进程的处理代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// accept调用被信号中断了, 解除阻塞, 返回了-1</span></span><br><span class="line">                <span class="comment">// 重新调用一次accept</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>如果父进程调用<code>accept()</code> 函数没有检测到新的客户端连接，父进程就阻塞在这儿了，这时候有子进程退出了，发送信号给父进程，父进程就捕捉到了这个信号<code>SIGCHLD</code><br>由于信号的优先级很高，会打断代码正常的执行流程，因此父进程的阻塞被中断，转而去处理这个信号对应的函数<code>callback()</code>，处理完毕<br>再次回到<code>accept()</code>位置，但是这是已经无法阻塞了，函数直接返回-1，此时函数调用失败，错误描述为<code>accept: Interrupted system call</code>，对应的错误号为<code>EINTR</code>，由于代码是被信号中断导致的错误，所以可以在程序中对这个错误号进行判断，让父进程重新调用<code>accept()</code>，继续阻塞或者接受客户端的新连接。</p>
<hr>
<h2 id="4-3-多线程并发"><a href="#4-3-多线程并发" class="headerlink" title="4.3 多线程并发"></a>4.3 多线程并发</h2><p>编写多线程版的并发服务器程序和多进程思路差不多，考虑明白了对号入座即可。多线程中的线程有两大类：主线程（父线程）和子线程，他们分别要在服务器端处理监听和通信流程。</p>
<ul>
<li>主线程：<ul>
<li>负责监听，处理客户端的连接请求，也就是在父进程中循环调用<code>accept()</code>函数</li>
<li>创建子线程：建立一个新的连接，就创建一个新的子进程，让这个子进程和对应的客户端通信</li>
<li>回收子线程资源：由于回收需要调用阻塞函数，这样就会影响<code>accept()</code>，直接做<code>线程分离</code>即可。</li>
</ul>
</li>
<li>子线程：负责通信，基于主线程建立新连接之后得到的文件描述符，和对应的客户端完成数据的接收和发送。<ul>
<li>发送数据：<code>send() / write()</code></li>
<li>接收数据：<code>recv() / read()</code></li>
</ul>
</li>
</ul>
<p>在多线程版的服务器端程序中，多个线程共用同一个地址空间，有些数据是共享的，有些数据的独占的，分析其中的一些细节：</p>
<ul>
<li>同一地址空间中的多个线程的栈空间是独占的</li>
<li>多个线程共享全局数据区，堆区，以及内核区的文件描述符等资源，因此<code>需要注意数据覆盖</code>问题，并且在多个线程访问共享资源的时候，还需要进行线程同步。<br><img src="/img/9.39.png" alt="在这里插入图片描述"></li>
</ul>
<p>多线程版Tcp服务器示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> fd;                      <span class="comment">// 通信</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;               <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span>     <span class="comment">// 地址信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span> <span class="title">infos</span>[128];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span>* <span class="title">info</span> =</span> (<span class="keyword">struct</span> SockInfo*)arg;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> ret = read(info-&gt;fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端已经关闭连接...\n&quot;</span>);</span><br><span class="line">            info-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;接收数据失败...\n&quot;</span>);</span><br><span class="line">            info-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            write(info-&gt;fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于监听的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;          <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">8989</span>);        <span class="comment">// 字节序应该是网络字节序</span></span><br><span class="line">    addr.sin_addr.s_addr =  INADDR_ANY; <span class="comment">// == 0, 获取IP的操作交给了内核</span></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.设置监听</span></span><br><span class="line">    ret = listen(fd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 等待, 接受连接请求</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据初始化</span></span><br><span class="line">    <span class="type">int</span> max = <span class="keyword">sizeof</span>(infos) / <span class="keyword">sizeof</span>(infos[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        bzero(&amp;infos[i], <span class="keyword">sizeof</span>(infos[i]));</span><br><span class="line">        infos[i].fd = <span class="number">-1</span>;</span><br><span class="line">        infos[i].tid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程监听, 子进程通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span>* <span class="title">pinfo</span>;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;max; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(infos[i].fd == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pinfo = &amp;infos[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == max<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> connfd = accept(fd, (<span class="keyword">struct</span> sockaddr*)&amp;pinfo-&gt;addr, &amp;len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent thread, connfd: %d\n&quot;</span>, connfd);</span><br><span class="line">        <span class="keyword">if</span>(connfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pinfo-&gt;fd = connfd;</span><br><span class="line">        pthread_create(&amp;pinfo-&gt;tid, <span class="literal">NULL</span>, working, pinfo);</span><br><span class="line">        pthread_detach(pinfo-&gt;tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd);  <span class="comment">// 监听</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编写多线程版并发服务器代码的时候，需要注意父子线程共用同一个地址空间中的文件描述符，因此每当在主线程中建立一个新的连接，都需要将得到文件描述符值保存起来，不能在同一变量上进行覆盖，这样做丢失了之前的文件描述符值也就不知道怎么和客户端通信了。</p>
<p>在上面示例代码中是将成功建立连接之后得到的用于通信的文件描述符值保存到了一个全局数组中，每个子线程需要和不同的客户端通信，需要的文件描述符值也就不一样，只要保证存储每个有效文件描述符值的变量对应不同的内存地址，在使用的时候就不会发生数据覆盖的现象，造成通信数据的混乱了。</p>
<hr>
<h1 id="5-TCP数据粘包的处理"><a href="#5-TCP数据粘包的处理" class="headerlink" title="5. TCP数据粘包的处理"></a>5. TCP数据粘包的处理</h1><h2 id="5-1-TCP"><a href="#5-1-TCP" class="headerlink" title="5.1 TCP"></a>5.1 TCP</h2><p>在前面介绍套接字通信的时候说到了<code>TCP</code>是传输层协议，它是一个面向连接的、安全的、流式传输协议。因为数据的传输是基于流的所以发送端和接收端每次处理的数据的量，处理数据的频率可以不是对等的，可以按照自身需求来进行决策。</p>
<p>TCP协议是优势非常明显，但假设我们有需求：</p>
<blockquote>
<p>客户端和服务器之间要进行基于TCP的套接字通信</p>
<ul>
<li>通信过程中客户端会每次会不定期给服务器发送一个不定长度的有特定含义的字符串。</li>
<li>通信的服务器端每次都需要接收到客户端这个不定长度的字符串，并对其进行解析</li>
</ul>
</blockquote>
<p>根据上面的描述，服务器在接收数据的时候有如下几种情况：</p>
<ol>
<li>一次接收到了客户端发送过来的一个完整的数据包</li>
<li>一次接收到了客户端发送过来的N个数据包，由于每个包的长度不定，无法将各个数据包拆开</li>
<li>一次接收到了一个或者N个数据包 + 下一个数据包的一部分，无法将数据包拆开</li>
<li>一次收到了半个数据包，下一次接收数据的时候收到了剩下的一部分+下个数据包的一部分</li>
<li>另外，还有一些不可抗拒的因素：比如客户端和服务器端的网速不一样，发送和接收的数据量也会不一致</li>
</ol>
<p>对于以上描述的现象很多时候我们将其称之为<code>TCP的粘包问题</code>，	<code>本身TCP就是面向连接的流式传输协议，特性如此，我们却说是TCP这个协议出了问题，这是使用者的无知。多个数据包粘连到一起无法拆分是需求过于复杂造成的，是我们的问题而不是协议的问题。</code></p>
<p>服务器端如果想保证每次都能接收到客户端发送过来的这个不定长度的数据包，如何解决？</p>
<ol>
<li>使用标准的应用层协议（比如：http、https）来封装要传输的不定长的数据包</li>
<li>在每条数据的尾部添加特殊字符, 如果遇到特殊字符, 代表当条数据接收完毕了<ul>
<li>有缺陷: 效率低, 需要一个字节一个字节接收, 接收一个字节判断一次</li>
</ul>
</li>
<li>在发送数据块之前, 在数据块最前边添加一个固定大小的数据头, 这时候数据由两部分组成：数据头+数据块<ul>
<li>数据头：存储当前数据包的总字节数，接收端先接收数据头，然后在根据数据头接收对应大小的字节</li>
<li>数据块：当前数据包的内容</li>
</ul>
</li>
</ol>
<hr>
<h2 id="5-2-解决方案"><a href="#5-2-解决方案" class="headerlink" title="5.2 解决方案"></a>5.2 解决方案</h2><p>如果使用TCP进行套接字通信，如果发送的数据包粘连到一起导致接收端无法解析，我们通常使用添加包头的方式解决这个问题。<br>关于数据包的包头大小可以根据自己的实际需求进行设定，这里没特殊需求，因此规定包头的固定大小为4个字节，用于存储当前数据块的总字节数。<br><img src="/img/9.40.png" alt="在这里插入图片描述"></p>
<h3 id="5-2-1-发送端"><a href="#5-2-1-发送端" class="headerlink" title="5.2.1 发送端"></a>5.2.1 发送端</h3><p>对于发送端来说，数据的发送分为4步：</p>
<ol>
<li>根据待发送的数据长度N动态申请一块固定大小的内存：N+4（4是包头占用的字节数）</li>
<li>将待发送数据的总长度写入申请的内存的前四字节中，<code>此处需要将其转换为网络字节序(大端)</code></li>
<li>将待发送的数据拷贝到包头后边的地址空间中，将完整的数据包发送出去<code>（字符串没有字节序问题）</code></li>
<li>释放申请的堆内存。</li>
</ol>
<p>由于发送端每次都需要将这个数据包完整的发送出去，因此可以设计一个发送函数，如果当前数据包中的数据没有发送完就让它一直发送，处理代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数描述: 发送指定的字节数</span></span><br><span class="line"><span class="comment">函数参数:</span></span><br><span class="line"><span class="comment">    - fd: 通信的文件描述符(套接字)</span></span><br><span class="line"><span class="comment">    - msg: 待发送的原始数据</span></span><br><span class="line"><span class="comment">    - size: 待发送的原始数据的总字节数</span></span><br><span class="line"><span class="comment">函数返回值: 函数调用成功返回发送的字节数, 发送失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* buf = msg;</span><br><span class="line">    <span class="type">int</span> count = size;</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> len = send(fd, buf, count, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buf += len;</span><br><span class="line">        count -= len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个功能函数之后就可以发送带有包头的数据块了，具体处理动作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数描述: 发送带有数据头的数据包</span></span><br><span class="line"><span class="comment">函数参数:</span></span><br><span class="line"><span class="comment">    - cfd: 通信的文件描述符(套接字)</span></span><br><span class="line"><span class="comment">    - msg: 待发送的原始数据</span></span><br><span class="line"><span class="comment">    - len: 待发送的原始数据的总字节数</span></span><br><span class="line"><span class="comment">函数返回值: 函数调用成功返回发送的字节数, 发送失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendMsg</span><span class="params">(<span class="type">int</span> cfd, <span class="type">char</span>* msg, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(msg == <span class="literal">NULL</span> || len &lt;= <span class="number">0</span> || cfd &lt;=<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 申请内存空间: 数据长度 + 包头4字节(存储数据长度)</span></span><br><span class="line">   <span class="type">char</span>* data = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len+<span class="number">4</span>);</span><br><span class="line">   <span class="type">int</span> bigLen = htonl(len);</span><br><span class="line">   <span class="built_in">memcpy</span>(data, &amp;bigLen, <span class="number">4</span>);</span><br><span class="line">   <span class="built_in">memcpy</span>(data+<span class="number">4</span>, msg, len);</span><br><span class="line">   <span class="comment">// 发送数据</span></span><br><span class="line">   <span class="type">int</span> ret = writen(cfd, data, len+<span class="number">4</span>);</span><br><span class="line">   <span class="comment">// 释放内存</span></span><br><span class="line">   <span class="built_in">free</span>(data);</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>字符串没有字节序问题，但是数据头不是字符串是整形，因此需从主机字节序转换为网络字节序再发送。</code></p>
<hr>
<h3 id="5-2-2-接收端"><a href="#5-2-2-接收端" class="headerlink" title="5.2.2 接收端"></a>5.2.2 接收端</h3><p>了解了套接字的发送端如何发送数据，接收端的处理步骤也就清晰了，具体过程如下：</p>
<ol>
<li>首先接收4字节数据，并将其从网络字节序转换为主机字节序，这样就得到了即将要接收的数据的总长度</li>
<li>根据得到的长度申请固定大小的堆内存，用于存储待接收的数据</li>
<li>根据得到的数据块长度接收固定数目的数据保存到申请的堆内存中</li>
<li>处理接收的数据</li>
<li>释放存储数据的堆内存</li>
</ol>
<p>从数据包头解析出要接收的数据长度之后，还需要将这个数据块完整的接收到本地才能进行后续的数据处理，因此需要编写一个接收数据的功能函数，保证能够得到一个完整的数据包数据<br>处理函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数描述: 接收指定的字节数</span></span><br><span class="line"><span class="comment">函数参数:</span></span><br><span class="line"><span class="comment">    - fd: 通信的文件描述符(套接字)</span></span><br><span class="line"><span class="comment">    - buf: 存储待接收数据的内存的起始地址</span></span><br><span class="line"><span class="comment">    - size: 指定要接收的字节数</span></span><br><span class="line"><span class="comment">函数返回值: 函数调用成功返回发送的字节数, 发送失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* pt = buf;</span><br><span class="line">    <span class="type">int</span> count = size;</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> len = recv(fd, pt, count, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> size - count;</span><br><span class="line">        &#125;</span><br><span class="line">        pt += len;</span><br><span class="line">        count -= len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数搞定之后，就可以轻松地接收带包头的数据块了，接收函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数描述: 接收带数据头的数据包</span></span><br><span class="line"><span class="comment">函数参数:</span></span><br><span class="line"><span class="comment">    - cfd: 通信的文件描述符(套接字)</span></span><br><span class="line"><span class="comment">    - msg: 一级指针的地址，函数内部会给这个指针分配内存，用于存储待接收的数据，这块内存需要使用者释放</span></span><br><span class="line"><span class="comment">函数返回值: 函数调用成功返回接收的字节数, 发送失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recvMsg</span><span class="params">(<span class="type">int</span> cfd, <span class="type">char</span>** msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="comment">// 1. 读数据头</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    readn(cfd, (<span class="type">char</span>*)&amp;len, <span class="number">4</span>);</span><br><span class="line">    len = ntohl(len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据块大小: %d\n&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据读出的长度分配内存，+1 -&gt; 这个字节存储\0</span></span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ret = readn(cfd, buf, len);</span><br><span class="line">    <span class="keyword">if</span>(ret != len)</span><br><span class="line">    &#123;</span><br><span class="line">        close(cfd);</span><br><span class="line">        <span class="built_in">free</span>(buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    *msg = buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在进行套接字通信的时候通过调用封装的<code>sendMsg()</code>和<code>recvMsg()</code>就可以发送和接收带数据头的数据包了，而且完美地解决了粘包的问题。</p>
<hr>
<h1 id="6-套接字通信类的封装"><a href="#6-套接字通信类的封装" class="headerlink" title="6. 套接字通信类的封装"></a>6. 套接字通信类的封装</h1><p>在掌握了基于TCP的套接字通信流程之后，为了方便使用，提高编码效率，可以对通信操作进行封装，先基于C语言进行面向过程的函数封装，再基于C++进行面向对象的类封装。</p>
<h2 id="6-1-基于C语言的封装"><a href="#6-1-基于C语言的封装" class="headerlink" title="6.1 基于C语言的封装"></a>6.1 基于C语言的封装</h2><p>基于TCP的套接字通信分为两部分：服务器端通信和客户端通信。只要掌握了通信流程，封装出对应的功能函数也就不在话下了，回顾一下通信流程：</p>
<ul>
<li>服务器端<ol>
<li>创建用于监听的套接字</li>
<li>将用于监听的套接字和本地的IP以及端口进行绑定</li>
<li>启动监听</li>
<li>等待并接受新的客户端连接，连接建立得到用于通信的套接字和客户端的IP、端口信息</li>
<li>使用得到的通信的套接字和客户端通信（接收和发送数据）</li>
<li>通信结束，关闭套接字（监听 + 通信）</li>
</ol>
</li>
<li>客户端<ol>
<li>创建用于通信的套接字</li>
<li>使用服务器端绑定的IP和端口连接服务器</li>
<li>使用通信的套接字和服务器通信（发送和接收数据）</li>
<li>通信结束，关闭套接字（通信）</li>
</ol>
</li>
</ul>
<h3 id="6-1-1-函数声明"><a href="#6-1-1-函数声明" class="headerlink" title="6.1.1 函数声明"></a>6.1.1 函数声明</h3><p>通过通信流程可以看出服务器和客户端有些操作步骤是相同的，因此封装的功能函数是可以共用的，相关的通信函数声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////////////////////////// </span></span><br><span class="line"><span class="comment">//////////////////// 服务器 ///////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bindSocket</span><span class="params">(<span class="type">int</span> lfd, <span class="type">unsigned</span> <span class="type">short</span> port)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setListen</span><span class="params">(<span class="type">int</span> lfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">acceptConn</span><span class="params">(<span class="type">int</span> lfd, <span class="keyword">struct</span> sockaddr_in *addr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////// </span></span><br><span class="line"><span class="comment">//////////////////// 客户端 ///////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connectToHost</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////// </span></span><br><span class="line"><span class="comment">///////////////////// 共用 ////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">createSocket</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sendMsg</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* msg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">recvMsg</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* msg, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">closeSocket</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>关于函数readn()和writen()的作用 参考 TCP数据粘包处理</p>
<hr>
<h3 id="6-1-2-函数定义"><a href="#6-1-2-函数定义" class="headerlink" title="6.1.2 函数定义"></a>6.1.2 函数定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建监套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">createSocket</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;套接字创建成功, fd=%d\n&quot;</span>, fd);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定本地的IP和端口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bindSocket</span><span class="params">(<span class="type">int</span> lfd, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(port);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0 = 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;套接字绑定成功, ip: %s, port: %d\n&quot;</span>,</span><br><span class="line">           inet_ntoa(saddr.sin_addr), port);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置监听</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setListen</span><span class="params">(<span class="type">int</span> lfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;设置监听成功...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞并等待客户端的连接</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">acceptConn</span><span class="params">(<span class="type">int</span> lfd, <span class="keyword">struct</span> sockaddr_in *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cfd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(addr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cfd = accept(lfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">        cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)addr, &amp;addrlen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功和客户端建立连接...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> cfd; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recvMsg</span><span class="params">(<span class="type">int</span> cfd, <span class="type">char</span>** msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(msg == <span class="literal">NULL</span> || cfd &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="comment">// 1. 读数据头</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    readn(cfd, (<span class="type">char</span>*)&amp;len, <span class="number">4</span>);</span><br><span class="line">    len = ntohl(len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据块大小: %d\n&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据读出的长度分配内存</span></span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ret = readn(cfd, buf, len);</span><br><span class="line">    <span class="keyword">if</span>(ret != len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    *msg = buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendMsg</span><span class="params">(<span class="type">int</span> cfd, <span class="type">char</span>* msg, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(msg == <span class="literal">NULL</span> || len &lt;= <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 申请内存空间: 数据长度 + 包头4字节(存储数据长度)</span></span><br><span class="line">   <span class="type">char</span>* data = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len+<span class="number">4</span>);</span><br><span class="line">   <span class="type">int</span> bigLen = htonl(len);</span><br><span class="line">   <span class="built_in">memcpy</span>(data, &amp;bigLen, <span class="number">4</span>);</span><br><span class="line">   <span class="built_in">memcpy</span>(data+<span class="number">4</span>, msg, len);</span><br><span class="line">   <span class="comment">// 发送数据</span></span><br><span class="line">   <span class="type">int</span> ret = writen(cfd, data, len+<span class="number">4</span>);</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接服务器</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connectToHost</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2. 连接服务器IP port</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;saddr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功和服务器建立连接...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closeSocket</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = close(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收指定的字节数</span></span><br><span class="line"><span class="comment">// 函数调用成功返回 size</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nread = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = size;</span><br><span class="line">    <span class="type">char</span>* p = buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((nread = read(fd, p, left)) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p += nread;</span><br><span class="line">            left -= nread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nread == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送指定的字节数</span></span><br><span class="line"><span class="comment">// 函数调用成功返回 size</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> left = size;</span><br><span class="line">    <span class="type">int</span> nwrite = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p = msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((nwrite = write(fd, msg, left)) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p += nwrite;</span><br><span class="line">            left -= nwrite;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nwrite == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-2-基于C-的封装"><a href="#6-2-基于C-的封装" class="headerlink" title="6.2 基于C++的封装"></a>6.2 基于C++的封装</h2><p>编写C++程序应当遵循面向对象三要素：封装、继承、多态。简单地说就是封装之后的类可以隐藏掉某些属性使操作更简单并且类的功能要单一，如果要代码重用可以进行类之间的继承，如果要让函数的使用更加灵活可以使用多态。<br>因此，我们需要封装两个类：客户端类和服务器端的类。</p>
<h3 id="6-2-1-版本1"><a href="#6-2-1-版本1" class="headerlink" title="6.2.1 版本1"></a>6.2.1 版本1</h3><p>根据面向对象的思想，整个通信过程不管是监听还是通信的套接字都是可以封装到类的内部并且将其隐藏掉，这样相关操作函数的参数也就随之减少了，使用者用起来也更简便。</p>
<h4 id="6-2-1-1-客户端"><a href="#6-2-1-1-客户端" class="headerlink" title="6.2.1.1 客户端"></a>6.2.1.1 客户端</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TcpClient</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TcpClient</span>();</span><br><span class="line">    ~<span class="built_in">TcpClient</span>();</span><br><span class="line">    <span class="comment">// int connectToHost(int fd, const char* ip, unsigned short port);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">connectToHost</span><span class="params">(string ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int sendMsg(int fd, const char* msg);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sendMsg</span><span class="params">(string msg)</span></span>;</span><br><span class="line">    <span class="comment">// int recvMsg(int fd, char* msg, int size);</span></span><br><span class="line">    <span class="function">string <span class="title">recvMsg</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// int createSocket();</span></span><br><span class="line">    <span class="comment">// int closeSocket(int fd);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// int readn(int fd, char* buf, int size);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line">    <span class="comment">// int writen(int fd, const char* msg, int size);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">writen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cfd;	<span class="comment">// 通信的套接字</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过对客户端的操作进行封装，我们可以看到有如下的变化：</p>
<ol>
<li>文件描述被隐藏了，封装到了类的内部已经无法进行外部访问</li>
<li>功能函数的参数变少了，因为类成员函数可以直接使用类内部的成员变量。</li>
<li>创建和销毁套接字的函数去掉了，这两个操作可以分别放到构造和析构函数内部进行处理。</li>
<li>在C++中可以适当的将char* 替换为 string 类，这样操作字符串就更简便一些。</li>
</ol>
<hr>
<h4 id="6-2-1-2-服务器端"><a href="#6-2-1-2-服务器端" class="headerlink" title="6.2.1.2 服务器端"></a>6.2.1.2 服务器端</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TcpServer</span>();</span><br><span class="line">    ~<span class="built_in">TcpServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int bindSocket(int lfd, unsigned short port) + int setListen(int lfd)</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">setListen</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line">    <span class="comment">// int acceptConn(int lfd, struct sockaddr_in *addr);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">acceptConn</span><span class="params">(<span class="keyword">struct</span> sockaddr_in *addr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int sendMsg(int fd, const char* msg);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sendMsg</span><span class="params">(string msg)</span></span>;</span><br><span class="line">    <span class="comment">// int recvMsg(int fd, char* msg, int size);</span></span><br><span class="line">    <span class="function">string <span class="title">recvMsg</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// int createSocket();</span></span><br><span class="line">    <span class="comment">// int closeSocket(int fd);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// int readn(int fd, char* buf, int size);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line">    <span class="comment">// int writen(int fd, const char* msg, int size);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">writen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> lfd;	<span class="comment">// 监听的套接字</span></span><br><span class="line">    <span class="type">int</span> cfd;	<span class="comment">// 通信的套接字</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过对服务器端的操作进行封装，我们可以看到这个类和客户端的类结构以及封装思路是差不多的，并且两个类的内部有些操作的重叠的：接收和发送通信数据的函数<code>recvMsg()</code>、<code>sendMsg()</code>，以及内部函数<code>readn()</code>、<code>writen()</code>。<br>不仅如此服务器端的类设计成这样样子是有缺陷的：<code>服务器端一般需要和多个客户端建立连接，因此通信的套接字就需要有N个，但是在上面封装的类里边只有一个。</code></p>
<p>如何解决服务器和客户端的代码冗余和服务器不能跟多客户端通信的问题？</p>
<p><code>减负。可以将服务器的通信功能去掉，只留下监听并建立新连接一个功能。将客户端类变成一个专门用于套接字通信的类即可。服务器端整个流程使用服务器类+通信类来处理；客户端整个流程通过通信的类来处理。</code></p>
<hr>
<h3 id="6-2-2-版本2"><a href="#6-2-2-版本2" class="headerlink" title="6.2.2 版本2"></a>6.2.2 版本2</h3><p>根据对第一个版本的分析，可以对以上代码做如下修改：</p>
<h4 id="6-2-2-1-通信类"><a href="#6-2-2-1-通信类" class="headerlink" title="6.2.2.1 通信类"></a>6.2.2.1 通信类</h4><p>套接字通信类既可以在客户端使用，也可以在服务器端使用，职责是接收和发送数据包。</p>
<p>类声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TcpSocket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TcpSocket</span>();</span><br><span class="line">    <span class="built_in">TcpSocket</span>(<span class="type">int</span> socket);</span><br><span class="line">    ~<span class="built_in">TcpSocket</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">connectToHost</span><span class="params">(string ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sendMsg</span><span class="params">(string msg)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">recvMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">writen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_fd;	<span class="comment">// 通信的套接字</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>(<span class="type">int</span> socket)</span><br><span class="line">&#123;</span><br><span class="line">    m_fd = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::~<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_fd &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::connectToHost</span><span class="params">(string ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 连接服务器IP port</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip.<span class="built_in">data</span>(), &amp;saddr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(m_fd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;成功和服务器建立连接...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::sendMsg</span><span class="params">(string msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 申请内存空间: 数据长度 + 包头4字节(存储数据长度)</span></span><br><span class="line">    <span class="type">char</span>* data = <span class="keyword">new</span> <span class="type">char</span>[msg.<span class="built_in">size</span>() + <span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> bigLen = <span class="built_in">htonl</span>(msg.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">memcpy</span>(data, &amp;bigLen, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(data + <span class="number">4</span>, msg.<span class="built_in">data</span>(), msg.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">writen</span>(data, msg.<span class="built_in">size</span>() + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">delete</span>[]data;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">TcpSocket::recvMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="comment">// 1. 读数据头</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">readn</span>((<span class="type">char</span>*)&amp;len, <span class="number">4</span>);</span><br><span class="line">    len = <span class="built_in">ntohl</span>(len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;数据块大小: &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据读出的长度分配内存</span></span><br><span class="line">    <span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">readn</span>(buf, len);</span><br><span class="line">    <span class="keyword">if</span> (ret != len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="function">string <span class="title">retStr</span><span class="params">(buf)</span></span>;</span><br><span class="line">    <span class="keyword">delete</span>[]buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nread = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = size;</span><br><span class="line">    <span class="type">char</span>* p = buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = <span class="built_in">read</span>(m_fd, p, left)) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p += nread;</span><br><span class="line">            left -= nread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::writen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = size;</span><br><span class="line">    <span class="type">int</span> nwrite = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p = msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nwrite = <span class="built_in">write</span>(m_fd, msg, left)) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p += nwrite;</span><br><span class="line">            left -= nwrite;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nwrite == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第二个版本的套接字通信类中一共有两个构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>(<span class="type">int</span> socket)</span><br><span class="line">&#123;</span><br><span class="line">    m_fd = socket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>无参构造一般在客户端使用，通过这个套接字对象再和服务器进行连接，之后就可以通信了</code></li>
<li><code>有参构造主要在服务器端使用，当服务器端得到了一个用于通信的套接字对象之后，就可以基于这个套接字直接通信，因此不需要再次进行连接操作。</code></li>
</ul>
<hr>
<h4 id="6-2-2-2-服务器类"><a href="#6-2-2-2-服务器类" class="headerlink" title="6.2.2.2 服务器类"></a>6.2.2.2 服务器类</h4><p>服务器类主要用于套接字通信的服务器端，并且没有通信能力，当服务器和客户端的新连接建立之后，需要通过<code>TcpSocket</code>类的带参构造将通信的描述符包装成一个通信对象，这样就可以使用这个对象和客户端通信了。</p>
<p>类声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TcpServer</span>();</span><br><span class="line">    ~<span class="built_in">TcpServer</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">setListen</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line">    <span class="function">TcpSocket* <span class="title">acceptConn</span><span class="params">(<span class="keyword">struct</span> sockaddr_in* addr = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_fd;	<span class="comment">// 监听的套接字</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">TcpServer::<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpServer::~<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(m_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpServer::setListen</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0 = 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(m_fd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;套接字绑定成功, ip: &quot;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">inet_ntoa</span>(saddr.sin_addr)</span><br><span class="line">        &lt;&lt; <span class="string">&quot;, port: &quot;</span> &lt;&lt; port &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(m_fd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;设置监听成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TcpSocket* <span class="title">TcpServer::acceptConn</span><span class="params">(sockaddr_in* addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">    <span class="type">int</span> cfd = <span class="built_in">accept</span>(m_fd, (<span class="keyword">struct</span> sockaddr*)addr, &amp;addrlen);</span><br><span class="line">    <span class="keyword">if</span> (cfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功和客户端建立连接...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TcpSocket</span>(cfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调整可以发现，套接字服务器类功能更加单一了，这样设计即解决了代码冗余问题，还能使这两个类更容易维护。</p>
<hr>
<h2 id="6-3-测试代码"><a href="#6-3-测试代码" class="headerlink" title="6.3 测试代码"></a>6.3 测试代码</h2><h3 id="6-3-1-客户端"><a href="#6-3-1-客户端" class="headerlink" title="6.3.1 客户端"></a>6.3.1 客户端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    TcpSocket tcp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器IP port</span></span><br><span class="line">    <span class="type">int</span> ret = tcp.<span class="built_in">connectToHost</span>(<span class="string">&quot;192.168.237.131&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="type">int</span> fd1 = <span class="built_in">open</span>(<span class="string">&quot;english.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="built_in">sizeof</span>(tmp));</span><br><span class="line">    <span class="keyword">while</span> ((length = <span class="built_in">read</span>(fd1, tmp, <span class="built_in">sizeof</span>(tmp))) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        tcp.<span class="built_in">sendMsg</span>(<span class="built_in">string</span>(tmp, length));</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;send Msg: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; tmp &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="built_in">sizeof</span>(tmp));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-2-服务器端"><a href="#6-3-2-服务器端" class="headerlink" title="6.3.2 服务器端"></a>6.3.2 服务器端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SockInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    TcpServer* s;</span><br><span class="line">    TcpSocket* tcp;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">working</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SockInfo</span>* pinfo = <span class="built_in">static_cast</span>&lt;<span class="keyword">struct</span> SockInfo*&gt;(arg);</span><br><span class="line">    <span class="comment">// 连接建立成功, 打印客户端的IP和端口信息</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP: %s, 端口: %d\n&quot;</span>,</span><br><span class="line">        <span class="built_in">inet_ntop</span>(AF_INET, &amp;pinfo-&gt;addr.sin_addr.s_addr, ip, <span class="built_in">sizeof</span>(ip)),</span><br><span class="line">        <span class="built_in">ntohs</span>(pinfo-&gt;addr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 通信</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收数据: .....\n&quot;</span>);</span><br><span class="line">        string msg = pinfo-&gt;tcp-&gt;<span class="built_in">recvMsg</span>();</span><br><span class="line">        <span class="keyword">if</span> (!msg.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; msg &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> pinfo-&gt;tcp;</span><br><span class="line">    <span class="keyword">delete</span> pinfo;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    TcpServer s;</span><br><span class="line">    <span class="comment">// 2. 绑定本地的IP port并设置监听</span></span><br><span class="line">    s.<span class="built_in">setListen</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="comment">// 3. 阻塞并等待客户端的连接</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        SockInfo* info = <span class="keyword">new</span> SockInfo;</span><br><span class="line">        TcpSocket* tcp = s.<span class="built_in">acceptConn</span>(&amp;info-&gt;addr);</span><br><span class="line">        <span class="keyword">if</span> (tcp == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;重试....&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        info-&gt;s = &amp;s;</span><br><span class="line">        info-&gt;tcp = tcp;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, working, info);</span><br><span class="line">        <span class="built_in">pthread_detach</span>(tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="6-4-测试代码-self"><a href="#6-4-测试代码-self" class="headerlink" title="6.4 测试代码(self)"></a>6.4 测试代码(self)</h2><h3 id="6-4-1-服务器端"><a href="#6-4-1-服务器端" class="headerlink" title="6.4.1 服务器端"></a>6.4.1 服务器端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpSocket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">TcpSocket</span>();</span><br><span class="line">	<span class="built_in">TcpSocket</span>(<span class="type">int</span> socket);</span><br><span class="line">	~<span class="built_in">TcpSocket</span>();</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">ConnectToHost</span><span class="params">(string ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">SendMsg</span><span class="params">(string msg)</span></span>;</span><br><span class="line">	<span class="function">string <span class="title">ReadMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">written</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line">	<span class="type">int</span> m_fd; <span class="comment">//通信的套接字</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">	m_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>(<span class="type">int</span> socket)</span><br><span class="line">&#123;</span><br><span class="line">	m_fd = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::~<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_fd &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">close</span>(m_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::ConnectToHost</span><span class="params">(string ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sockaddr_in addr;</span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">	<span class="built_in">inet_pton</span>(AF_INET, ip.<span class="built_in">data</span>(), &amp;addr.sin_addr.s_addr);</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">connect</span>(m_fd, (sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;connect sucessfully&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::written</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> readplace = <span class="number">0</span>; <span class="comment">//开始读取数据的坐标</span></span><br><span class="line">	<span class="type">int</span> remain = size;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* space = buf;</span><br><span class="line">	<span class="keyword">while</span> (remain &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((readplace = <span class="built_in">write</span>(m_fd, space, remain)) &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			space += readplace;</span><br><span class="line">			remain -= readplace;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (readplace == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::SendMsg</span><span class="params">(string msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[msg.<span class="built_in">size</span>() + <span class="number">4</span>];</span><br><span class="line">	<span class="type">int</span> sizeflag = <span class="built_in">htonl</span>(msg.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">memcpy</span>(buf, &amp;sizeflag, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(buf + <span class="number">4</span>, msg.<span class="built_in">data</span>(), msg.<span class="built_in">size</span>());</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">written</span>(buf, msg.<span class="built_in">size</span>() + <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">delete</span>[] buf;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> readplace = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> remain = size;</span><br><span class="line">	<span class="type">char</span>* space = buf;</span><br><span class="line">	<span class="keyword">while</span> (remain &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((readplace = <span class="built_in">read</span>(m_fd, space, remain)) &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			space += readplace;   <span class="comment">//space指针后移,以下次读取</span></span><br><span class="line">			remain -= readplace;  <span class="comment">//读取大小跟随减小</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (readplace == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">TcpSocket::ReadMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">readn</span>((<span class="type">char</span>*)&amp;len, <span class="number">4</span>); <span class="comment">//从描述符里面读取前四位,将大端数据放入len</span></span><br><span class="line">	len = <span class="built_in">ntohl</span>(len);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;the size of msg : &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始接受真正的数据</span></span><br><span class="line">	<span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">readn</span>(buf, len);</span><br><span class="line">	<span class="keyword">if</span> (ret != len)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">string</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	buf[len] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//自行加入结束符,因此多开辟一字节空间</span></span><br><span class="line">	<span class="function">string <span class="title">returnstr</span><span class="params">(buf)</span></span>;</span><br><span class="line">	<span class="keyword">delete</span>[] buf;</span><br><span class="line">	<span class="keyword">return</span> returnstr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TcpServer</span>();</span><br><span class="line">	~<span class="built_in">TcpServer</span>();</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">SetListen</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line">	<span class="function">TcpSocket* <span class="title">AcceptConnect</span><span class="params">(sockaddr_in* addr = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> l_fd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TcpServer::<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">	l_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpServer::~<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">close</span>(l_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpServer::SetListen</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sockaddr_in addr;</span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">	addr.sin_addr.s_addr = INADDR_ANY; </span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">bind</span>(l_fd, (sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;bind sucessfully &quot;</span>&lt;&lt; endl</span><br><span class="line">	&lt;&lt;<span class="string">&quot;ip : &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(addr.sin_addr) &lt;&lt; endl</span><br><span class="line">	&lt;&lt; <span class="string">&quot;port : &quot;</span> &lt;&lt; port &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">listen</span>(l_fd, <span class="number">128</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;set listen sucessfully&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TcpSocket* <span class="title">TcpServer::AcceptConnect</span><span class="params">(sockaddr_in* addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (addr == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">socklen_t</span> addrlen = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line">	<span class="type">int</span> m_fd = <span class="built_in">accept</span>(l_fd, (sockaddr*)addr, &amp;addrlen);</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (m_fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;accept sucessfully&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TcpSocket</span>(m_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SocketPackage</span></span><br><span class="line">&#123;</span><br><span class="line">	TcpServer* lsntcp;</span><br><span class="line">	TcpSocket* msgtcp;</span><br><span class="line">	sockaddr_in addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Working</span><span class="params">(<span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SocketPackage* pkg = <span class="built_in">static_cast</span>&lt;SocketPackage*&gt;(args);</span><br><span class="line">	<span class="type">char</span> ip[<span class="number">32</span>];</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;client ip : &quot;</span> &lt;&lt; <span class="built_in">inet_ntop</span>(AF_INET, &amp;pkg-&gt;addr.sin_addr.s_addr, ip, <span class="built_in">sizeof</span>(ip)) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;client port : &quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(pkg-&gt;addr.sin_port) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通信</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;client say :: &quot;</span>;</span><br><span class="line">		string msg = pkg-&gt;msgtcp-&gt;<span class="built_in">ReadMsg</span>();</span><br><span class="line">		<span class="keyword">if</span> (!msg.<span class="built_in">empty</span>())</span><br><span class="line">			cout &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> pkg-&gt;msgtcp;</span><br><span class="line">	<span class="keyword">delete</span> pkg;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TcpServer server;</span><br><span class="line">	server.<span class="built_in">SetListen</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始通信</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		SocketPackage* pkg = <span class="keyword">new</span> SocketPackage;</span><br><span class="line">		TcpSocket* msgret = server.<span class="built_in">AcceptConnect</span>(&amp;pkg-&gt;addr);</span><br><span class="line">		<span class="keyword">if</span> (msgret == <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;new fail again&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//创建线程</span></span><br><span class="line">		pkg-&gt;lsntcp = &amp;server;</span><br><span class="line">		pkg-&gt;msgtcp = msgret;</span><br><span class="line">		<span class="function">thread <span class="title">child</span><span class="params">(Working,pkg)</span></span>;</span><br><span class="line">		child.<span class="built_in">detach</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-4-2-客户端"><a href="#6-4-2-客户端" class="headerlink" title="6.4.2 客户端"></a>6.4.2 客户端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpSocket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">TcpSocket</span>();</span><br><span class="line">	<span class="built_in">TcpSocket</span>(<span class="type">int</span> socket);</span><br><span class="line">	~<span class="built_in">TcpSocket</span>();</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">ConnectToHost</span><span class="params">(string ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">SendMsg</span><span class="params">(string msg)</span></span>;</span><br><span class="line">	<span class="function">string <span class="title">ReadMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">written</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line">	<span class="type">int</span> m_fd; <span class="comment">//通信的套接字</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">	m_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>(<span class="type">int</span> socket)</span><br><span class="line">&#123;</span><br><span class="line">	m_fd = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::~<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_fd &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">close</span>(m_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::ConnectToHost</span><span class="params">(string ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sockaddr_in addr;</span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">	<span class="built_in">inet_pton</span>(AF_INET, ip.<span class="built_in">data</span>(), &amp;addr.sin_addr.s_addr);</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">connect</span>(m_fd, (sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;connect sucessfully&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::written</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> readplace = <span class="number">0</span>; <span class="comment">//开始读取数据的坐标</span></span><br><span class="line">	<span class="type">int</span> remain = size;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* space = buf;</span><br><span class="line">	<span class="keyword">while</span> (remain &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((readplace = <span class="built_in">write</span>(m_fd, space, remain)) &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			space += readplace;</span><br><span class="line">			remain -= readplace;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (readplace == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::SendMsg</span><span class="params">(string msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[msg.<span class="built_in">size</span>() + <span class="number">4</span>];</span><br><span class="line">	<span class="type">int</span> sizeflag = <span class="built_in">htonl</span>(msg.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">memcpy</span>(buf, &amp;sizeflag, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(buf + <span class="number">4</span>, msg.<span class="built_in">data</span>(), msg.<span class="built_in">size</span>());</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">written</span>(buf, msg.<span class="built_in">size</span>() + <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">delete</span>[] buf;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> readplace = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> remain = size;</span><br><span class="line">	<span class="type">char</span>* space = buf;</span><br><span class="line">	<span class="keyword">while</span> (remain &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (readplace = <span class="built_in">read</span>(m_fd, space, remain) &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			space += readplace;   <span class="comment">//space指针后移,以下次读取</span></span><br><span class="line">			remain -= readplace;  <span class="comment">//读取大小跟随减小</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (readplace == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">TcpSocket::ReadMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">readn</span>((<span class="type">char</span>*)&amp;len,<span class="number">4</span>); <span class="comment">//从描述符里面读取前四位,将大端数据放入len</span></span><br><span class="line">	len = <span class="built_in">ntohl</span>(len);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;the size of msg : &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始接受真正的数据</span></span><br><span class="line">	<span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[len+<span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">readn</span>(buf, len);</span><br><span class="line">	<span class="keyword">if</span> (ret != len)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">string</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	buf[len] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//自行加入结束符,因此多开辟一字节空间</span></span><br><span class="line">	<span class="function">string <span class="title">returnstr</span><span class="params">(buf)</span></span>;</span><br><span class="line">	<span class="keyword">delete</span>[] buf;</span><br><span class="line">	<span class="keyword">return</span> returnstr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TcpSocket client;</span><br><span class="line">	<span class="type">int</span> ret = client.<span class="built_in">ConnectToHost</span>(<span class="string">&quot;192.168.200.129&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始发数据</span></span><br><span class="line">	<span class="type">int</span> tmpfd = <span class="built_in">open</span>(<span class="string">&quot;english.txt&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> ((len = <span class="built_in">read</span>(tmpfd, buf, <span class="built_in">sizeof</span>(buf))) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		client.<span class="built_in">SendMsg</span>(<span class="built_in">string</span>(buf,len));</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;client send msg : &quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">memset</span>(buf,<span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="built_in">usleep</span>(<span class="number">300</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="7-IO多路转接（复用）之select"><a href="#7-IO多路转接（复用）之select" class="headerlink" title="7. IO多路转接（复用）之select"></a>7. IO多路转接（复用）之select</h1><h2 id="7-1-IO多路转接-复用"><a href="#7-1-IO多路转接-复用" class="headerlink" title="7.1 IO多路转接(复用)"></a>7.1 IO多路转接(复用)</h2><p>IO多路转接也称为IO多路复用，它是一种网络通信的手段（机制）<br>通过这种方式可以<code>同时监测多个文件描述符并且这个过程是阻塞的，一旦检测到有文件描述符就绪（ 可以读数据或者可以写数据）程序的阻塞就会被解除，之后就可以基于这些（一个或多个）就绪的文件描述符进行通信了。</code><br>通过这种方式在单线程&#x2F;进程的场景下也可以在服务器端实现并发。<br>常见的IO多路转接方式有：<code>select</code>、<code>poll</code>、<code>epoll</code>。</p>
<p>下面先对多线程&#x2F;多进程并发和IO多路转接的并发处理流程进行对比（服务器端）：</p>
<ul>
<li>多线程&#x2F;多进程并发<ul>
<li>主线程&#x2F;父进程：调用 <code>accept()</code>监测客户端连接请求<ul>
<li>如果没有新的客户端的连接请求，当前线程&#x2F;进程会阻塞</li>
<li>如果有新的客户端连接请求解除阻塞，建立连接</li>
</ul>
</li>
<li>子线程&#x2F;子进程：和建立连接的客户端通信<ul>
<li>调用 <code>read() / recv()</code>接收客户端发送的通信数据，如果没有通信数据，当前线程&#x2F;进程会阻塞，数据到达之后阻塞自动解除</li>
<li>调用 <code>write() / send()</code> 给客户端发送数据，如果写缓冲区已满，当前线程&#x2F;进程会阻塞，否则将待发送数据写入写缓冲区中</li>
</ul>
</li>
</ul>
</li>
<li>IO多路转接并发<ul>
<li>使用IO多路转接函数委托内核检测服务器端所有的文件描述符（通信和监听两类），这个检测过程会导致进程&#x2F;线程的阻塞，如果检测到已就绪的文件描述符阻塞解除，并将这些已就绪的文件描述符传出</li>
<li>根据类型对传出的所有已就绪文件描述符进行判断，并做出不同的处理<ul>
<li>监听的文件描述符：和客户端建立连接<ul>
<li>此时调用<code>accept()</code>是不会导致程序阻塞的，因为监听的文件描述符是已就绪的（有新请求）</li>
</ul>
</li>
<li>通信的文件描述符：调用通信函数和已建立连接的客户端通信<ul>
<li>调用 <code>read() / recv()</code> 不会阻塞程序，因为通信的文件描述符是就绪的，读缓冲区内已有数据</li>
<li>调用 <code>write() / send()</code> 不会阻塞程序，因为通信的文件描述符是就绪的，写缓冲区不满，可以往里面写数据</li>
</ul>
</li>
<li>对这些文件描述符继续进行下一轮的检测（循环往复。。。）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</code></p>
<hr>
<h2 id="7-2-select"><a href="#7-2-select" class="headerlink" title="7.2  select"></a>7.2  select</h2><h3 id="7-2-1-函数原型"><a href="#7-2-1-函数原型" class="headerlink" title="7.2.1 函数原型"></a>7.2.1 函数原型</h3><p>使用select这种IO多路转接方式需要调用一个同名函数<code>select</code><br>这个函数是跨平台的，<code>Linux、Mac、Windows</code>都是支持的。通过调用这个函数可以委托内核帮助我们检测若干个文件描述符的状态，<code>其实就是检测这些文件描述符对应的读写缓冲区的状态</code>：</p>
<ul>
<li>读缓冲区：检测里边有没有数据，如果有数据该缓冲区对应的文件描述符就绪</li>
<li>写缓冲区：检测写缓冲区是否可以写(有没有容量)，如果有容量可以写，缓冲区对应的文件描述符就绪</li>
<li>读写异常：检测读写缓冲区是否有异常，如果有该缓冲区对应的文件描述符就绪</li>
</ul>
<p>委托检测的文件描述符被遍历检测完毕之后，已就绪的这些满足条件的文件描述符会通过<code>select()</code>的参数分3个集合传出,我们得到这几个集合之后就可以分情况依次处理了。</p>
<p>下面来看一下这个函数的函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span>      tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">           fd_set *exceptfds, <span class="keyword">struct</span> timeval * timeout)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数参数：<ul>
<li>nfds：委托内核检测的这三个集合中最大的文件描述符 + 1<ul>
<li>内核需要线性遍历这些集合中的文件描述符，这个值是循环结束的条件</li>
<li>在Window中这个参数是无效的，指定为-1即可</li>
</ul>
</li>
<li>readfds：文件描述符的集合, 内核只检测这个集合中文件描述符对应的读缓冲区<ul>
<li>传入传出参数，读集合一般情况下都是需要检测的，这样才知道通过哪个文件描述符接收数据</li>
</ul>
</li>
<li>writefds：文件描述符的集合, 内核只检测这个集合中文件描述符对应的写缓冲区<ul>
<li>传入传出参数，如果不需要使用这个参数可以指定为NULL</li>
</ul>
</li>
<li>exceptfds：文件描述符的集合, 内核检测集合中文件描述符是否有异常状态<ul>
<li>传入传出参数，如果不需要使用这个参数可以指定为NULL</li>
</ul>
</li>
<li>timeout：超时时长，用来强制解除select()函数的阻塞的<ul>
<li>NULL：函数检测不到就绪的文件描述符会一直阻塞。</li>
<li>等待固定时长（秒）：函数检测不到就绪的文件描述符，在指定时长之后强制解除阻塞，函数返回0</li>
<li>不等待：函数不会阻塞，直接将该参数对应的结构体初始化为0即可。</li>
</ul>
</li>
</ul>
</li>
<li>函数返回值：<ul>
<li>大于0：成功，返回集合中已就绪的文件描述符的总个数</li>
<li>等于-1：函数调用失败</li>
<li>等于0：超时，没有检测到就绪的文件描述符</li>
</ul>
</li>
</ul>
<p>另外初始化<code>fd_set</code>类型的参数还需要使用相关的一些列操作函数，具体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将文件描述符fd从set集合中删除 == 将fd对应的标志位设置为0        </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 判断文件描述符fd是否在set集合中 == 读一下fd对应的标志位到底是0还是1</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将文件描述符fd添加到set集合中 == 将fd对应的标志位设置为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将set集合中, 所有文件文件描述符对应的标志位设置为0, 集合中没有添加任何文件描述符</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="7-2-2-细节描述"><a href="#7-2-2-细节描述" class="headerlink" title="7.2.2 细节描述"></a>7.2.2 细节描述</h3><p>在<code>select()</code>函数中第2、3、4个参数都是<code>fd_set</code>类型，它表示一个文件描述符的集合，类似于信号集 <code>sigset_t</code>，这个类型的数据有128个字节，也就是1024个标志位，和内核中文件描述符表中的文件描述符个数是一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(fd_set) = <span class="number">128</span> 字节 * <span class="number">8</span> = <span class="number">1024</span> bit      <span class="comment">// int [32]</span></span><br></pre></td></tr></table></figure>

<p>这不是巧合，是故意为之。这块内存中的每一个bit 和 文件描述符表中的每一个文件描述符是一一对应的关系，这样就可以使用最小的存储空间将要表达的意思描述出来了。</p>
<p>下图中的fd_set中存储了要委托内核检测读缓冲区的文件描述符集合。</p>
<ul>
<li>如果集合中的标志位为0代表不检测这个文件描述符状态</li>
<li>如果集合中的标志位为1代表检测这个文件描述符状态<br><img src="/img/9.41.png" alt="在这里插入图片描述"></li>
</ul>
<p>内核在遍历这个读集合的过程中，如果被检测的文件描述符对应的读缓冲区中没有数据，内核将修改这个文件描述符在读集合<code>fd_set</code>中对应的标志位，改为<code>0</code>，如果有数据那么这个标志位的值不变，还是<code>1</code>。</p>
<p><img src="/img/9.42.png" alt="在这里插入图片描述"></p>
<p>当<code>select()</code>函数解除阻塞之后，被内核修改过的读集合通过参数传出，此时集合中只要标志位的值为<code>1</code>，那么它对应的文件描述符肯定是就绪的，我们就可以基于这个文件描述符和客户端建立新连接或者通信了。</p>
<hr>
<h2 id="7-3-并发处理"><a href="#7-3-并发处理" class="headerlink" title="7.3  并发处理"></a>7.3  并发处理</h2><h3 id="7-3-1-处理流程"><a href="#7-3-1-处理流程" class="headerlink" title="7.3.1 处理流程"></a>7.3.1 处理流程</h3><p>如果在服务器基于select实现并发，其处理流程如下：</p>
<ol>
<li>创建监听的套接字 lfd &#x3D; socket();</li>
<li>将监听的套接字和本地的IP和端口绑定 bind()</li>
<li>给监听的套接字设置监听 listen()</li>
<li>创建一个文件描述符集合 fd_set，用于存储需要检测读事件的所有的文件描述符<ul>
<li>通过 FD_ZERO() 初始化</li>
<li>通过 FD_SET() 将监听的文件描述符放入检测的读集合中</li>
</ul>
</li>
<li>循环调用select()，周期性的对所有的文件描述符进行检测</li>
<li>select() 解除阻塞返回，得到内核传出的满足条件的就绪的文件描述符集合<ul>
<li>通过FD_ISSET() 判断集合中的标志位是否为 1<ul>
<li>如果这个文件描述符是监听的文件描述符，调用 accept() 和客户端建立连接<ul>
<li>将得到的新的通信的文件描述符，通过FD_SET() 放入到检测集合中</li>
</ul>
</li>
<li>如果这个文件描述符是通信的文件描述符，调用通信函数和客户端通信<ul>
<li>如果客户端和服务器断开了连接，使用FD_CLR()将这个文件描述符从检测集合中删除</li>
<li>如果没有断开连接，正常通信即可</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>重复第6步<br><img src="/img/9.43.png" alt="在这里插入图片描述"></li>
</ol>
<hr>
<h3 id="7-3-2-通信代码"><a href="#7-3-2-通信代码" class="headerlink" title="7.3.2 通信代码"></a>7.3.2 通信代码</h3><blockquote>
<p>服务器端代码如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的fd</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    listen(lfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的fd的状态检测委托给内核检测</span></span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line">    <span class="comment">// 初始化检测的读集合</span></span><br><span class="line">    fd_set rdset;</span><br><span class="line">    fd_set rdtemp;</span><br><span class="line">    <span class="comment">// 清零</span></span><br><span class="line">    FD_ZERO(&amp;rdset);</span><br><span class="line">    <span class="comment">// 将监听的lfd设置到检测的读集合中</span></span><br><span class="line">    FD_SET(lfd, &amp;rdset);</span><br><span class="line">    <span class="comment">// 通过select委托内核检测读集合中的文件描述符状态, 检测read缓冲区有没有数据</span></span><br><span class="line">    <span class="comment">// 如果有数据, select解除阻塞返回</span></span><br><span class="line">    <span class="comment">// 应该让内核持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 默认阻塞</span></span><br><span class="line">        <span class="comment">// rdset 中是委托内核检测的所有的文件描述符</span></span><br><span class="line">        rdtemp = rdset;</span><br><span class="line">        <span class="type">int</span> num = select(maxfd+<span class="number">1</span>, &amp;rdtemp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// rdset中的数据被内核改写了, 只保留了发生变化的文件描述的标志位上的1, 没变化的改为0</span></span><br><span class="line">        <span class="comment">// 只要rdset中的fd对应的标志位为1 -&gt; 缓冲区有数据了</span></span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="comment">// 有没有新连接</span></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(lfd, &amp;rdtemp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 接受连接请求, 这个调用不阻塞</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">            <span class="type">int</span> cliLen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">            <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;cliLen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 得到了有效的文件描述符</span></span><br><span class="line">            <span class="comment">// 通信的文件描述符添加到读集合</span></span><br><span class="line">            <span class="comment">// 在下一轮select检测的时候, 就能得到缓冲区的状态</span></span><br><span class="line">            FD_SET(cfd, &amp;rdset);</span><br><span class="line">            <span class="comment">// 重置最大的文件描述符</span></span><br><span class="line">            maxfd = cfd &gt; maxfd ? cfd : maxfd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有新连接, 通信</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;maxfd+<span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">// 判断从监听的文件描述符之后到maxfd这个范围内的文件描述符是否读缓冲区有数据</span></span><br><span class="line">            <span class="keyword">if</span>(i != lfd &amp;&amp; FD_ISSET(i, &amp;rdtemp))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="comment">// 一次只能接收10个字节, 客户端一次发送100个字节</span></span><br><span class="line">                <span class="comment">// 一次是接收不完的, 文件描述符对应的读缓冲区中还有数据</span></span><br><span class="line">                <span class="comment">// 下一轮select检测的时候, 内核还会标记这个文件描述符缓冲区有数据 -&gt; 再读一次</span></span><br><span class="line">                <span class="comment">// 	循环会一直持续, 知道缓冲区数据被读完位置</span></span><br><span class="line">                <span class="type">int</span> len = read(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端关闭了连接...\n&quot;</span>);</span><br><span class="line">                    <span class="comment">// 将检测的文件描述符从读集合中删除</span></span><br><span class="line">                    FD_CLR(i, &amp;rdset);</span><br><span class="line">                    close(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 收到了数据</span></span><br><span class="line">                    <span class="comment">// 发送数据</span></span><br><span class="line">                    write(i, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 异常</span></span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，创建了两个<code>fd_set</code>变量，用于保存要检测的读集合：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化检测的读集合</span></span><br><span class="line">fd_set rdset;</span><br><span class="line">fd_set rdtemp;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>rdset</code>用于保存要检测的原始数据，这个变量不能作为参数传递给select函数，因为在函数内部这个变量中的值会被内核修改，函数调用完毕返回之后，里边就不是原始数据了，大部分情况下是值为1的标志位变少了，不可能每一轮检测，所有的文件描述符都是就行的状态。因此需要通过&#96;rdtemp&#96;&#96;变量将原始数据传递给内核，select()<br>调用完毕之后再将内核数据传出，这两个变量的功能是不一样的。</p>
</blockquote>
<p>客户端代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;     <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);   <span class="comment">// 服务器监听的端口, 字节序应该是网络字节序</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        <span class="comment">// sprintf(recvBuf, &quot;data: %d\n&quot;, i++);</span></span><br><span class="line">        fgets(recvBuf, <span class="keyword">sizeof</span>(recvBuf), <span class="built_in">stdin</span>);</span><br><span class="line">        write(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果客户端没有发送数据, 默认阻塞</span></span><br><span class="line">        read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>, recvBuf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端不需要使用IO多路转接进行处理，因为客户端和服务器的对应关系是 1：N，也就是说客户端是比较专一的，只能和一个连接成功的服务器通信。</p>
<p>虽然使用select这种IO多路转接技术可以降低系统开销，提高程序效率，但是它也有局限性：</p>
<ol>
<li>待检测集合（第2、3、4个参数）需要频繁的在用户区和内核区之间进行数据的拷贝，效率低</li>
<li>内核对于select传递进来的待检测集合的检测方式是线性的<ul>
<li>如果集合内待检测的文件描述符很多，检测效率会比较低</li>
<li>如果集合内待检测的文件描述符相对较少，检测效率会比较高</li>
</ul>
</li>
<li><code>使用select能够检测的最大文件描述符个数有上限，默认是1024，这是在内核中被写死了的。</code></li>
</ol>
<hr>
<h1 id="8-IO多路转接（复用）之poll"><a href="#8-IO多路转接（复用）之poll" class="headerlink" title="8. IO多路转接（复用）之poll"></a>8. IO多路转接（复用）之poll</h1><h2 id="8-1-poll函数"><a href="#8-1-poll函数" class="headerlink" title="8.1 poll函数"></a>8.1 poll函数</h2><p>poll的机制与select类似，与select在本质上没有多大差别，使用方法也类似，下面的是对于二者的对比：</p>
<ul>
<li>内核对应文件描述符的检测也是以线性的方式进行轮询，根据描述符的状态进行处理</li>
<li>poll和select检测的文件描述符集合会在检测过程中频繁的进行用户区和内核区的拷贝，它的开销随着文件描述符数量的增加而线性增大，从而效率也会越来越低。</li>
<li>select检测的文件描述符个数上限是1024，poll没有最大文件描述符数量的限制</li>
<li>select可以跨平台使用，poll只能在Linux平台使用</li>
</ul>
<p>poll函数的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 每个委托poll检测的fd都对应这样一个结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* 文件描述符实际发生的事件 -&gt; 传出 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>[100];</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数参数：<ul>
<li>fds: 这是一个struct pollfd类型的数组, 里边存储了待检测的文件描述符的信息，这个数组中有三个成员：<ul>
<li>fd：委托内核检测的文件描述符</li>
<li>events：委托内核检测的fd事件（输入、输出、错误），每一个事件有多个取值</li>
<li>revents：这是一个传出参数，数据由内核写入，存储内核检测之后的结果</li>
</ul>
</li>
<li>nfds: 这是第一个参数数组中最后一个有效元素的下标 + 1（也可以指定参数1数组的元素总个数）</li>
<li>timeout: 指定poll函数的阻塞时长<ul>
<li>-1：一直阻塞，直到检测的集合中有就绪的文件描述符（有事件产生）解除阻塞</li>
<li>0：不阻塞，不管检测集合中有没有已就绪的文件描述符，函数马上返回</li>
<li>大于0：阻塞指定的毫秒（ms）数之后，解除阻塞</li>
</ul>
</li>
</ul>
</li>
<li>函数返回值：<ul>
<li>失败： 返回-1</li>
<li>成功：返回一个大于0的整数，表示检测的集合中已就绪的文件描述符的总个数</li>
</ul>
</li>
</ul>
<p><img src="/img/9.44.png" alt="在这里插入图片描述"></p>
<hr>
<h2 id="8-2-测试代码"><a href="#8-2-测试代码" class="headerlink" title="8.2 测试代码"></a>8.2 测试代码</h2><p><strong>服务器端</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 绑定 ip, port</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 等待连接 -&gt; 循环</span></span><br><span class="line">    <span class="comment">// 检测 -&gt; 读缓冲区, 委托内核去处理</span></span><br><span class="line">    <span class="comment">// 数据初始化, 创建自定义的文件描述符集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1024];</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1024</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxfd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 委托内核检测</span></span><br><span class="line">        ret = poll(fds, maxfd+<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测的度缓冲区有变化</span></span><br><span class="line">        <span class="comment">// 有新连接</span></span><br><span class="line">        <span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 接收连接请求</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sockcli</span>;</span></span><br><span class="line">            <span class="type">int</span> len = <span class="keyword">sizeof</span>(sockcli);</span><br><span class="line">            <span class="comment">// 这个accept是不会阻塞的</span></span><br><span class="line">            <span class="type">int</span> connfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;sockcli, &amp;len);</span><br><span class="line">            <span class="comment">// 委托内核检测connfd的读缓冲区</span></span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1024</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(fds[i].fd == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    fds[i].fd = connfd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxfd = i &gt; maxfd ? i : maxfd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通信, 有客户端发送数据过来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=maxfd; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果在集合中, 说明读缓冲区有数据</span></span><br><span class="line">            <span class="keyword">if</span>(fds[i].revents &amp; POLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">                <span class="type">int</span> ret = read(fds[i].fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;对方已经关闭了连接...\n&quot;</span>);</span><br><span class="line">                    close(fds[i].fd);</span><br><span class="line">                    fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">                    write(fds[i].fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的测试代码可以得知，使用poll和select进行IO多路转接的处理思路是完全相同的，但是使用poll编写的代码看起来会更直观一些，select使用的位图的方式来标记要委托内核检测的文件描述符（每个比特位对应一个唯一的文件描述符），并且对这个<code>fd_set</code>类型的位图变量进行读写还需要借助一系列的宏函数，操作比较麻烦。而poll直接将要检测的文件描述符的相关信息封装到了一个结构体<code>struct pollfd</code>中，我们可以直接读写这个结构体变量。</p>
<p>另外poll的第二个参数有两种赋值方式，但是都和第一个参数的数组有关系：</p>
<ul>
<li>使用参数1数组的元素个数</li>
<li>使用参数1数组中存储的最后一个有效元素对应的下标值 + 1</li>
</ul>
<p>内核会根据第二个参数传递的值对参数1数组中的文件描述符进行线性遍历，这一点和select也是类似的。</p>
<p><strong>客户端</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;  <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);   <span class="comment">// 服务器监听的端口, 字节序应该是网络字节序</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        <span class="comment">// sprintf(recvBuf, &quot;data: %d\n&quot;, i++);</span></span><br><span class="line">        fgets(recvBuf, <span class="keyword">sizeof</span>(recvBuf), <span class="built_in">stdin</span>);</span><br><span class="line">        write(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果客户端没有发送数据, 默认阻塞</span></span><br><span class="line">        read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>, recvBuf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端不需要使用IO多路转接进行处理，因为客户端和服务器的对应关系是 1：N，也就是说客户端是比较专一的，只能和一个连接成功的服务器通信。</p>
<hr>
<h1 id="9-IO多路转接（复用）之epoll"><a href="#9-IO多路转接（复用）之epoll" class="headerlink" title="9. IO多路转接（复用）之epoll"></a>9. IO多路转接（复用）之epoll</h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><p>epoll 全称 eventpoll，是 linux 内核实现IO多路转接&#x2F;复用（IO multiplexing）的一个实现。IO多路转接的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。epoll是select和poll的升级版，相较于这两个前辈，epoll改进了工作方式，因此它更加高效。</p>
<ul>
<li>对于待检测集合select和poll是基于线性方式处理的，epoll是基于红黑树来管理待检测集合的。</li>
<li>select和poll每次都会线性扫描整个待检测集合，集合越大速度越慢，epoll使用的是回调机制，效率高，处理效率也不会随着检测集合的变大而下降</li>
<li>select和poll工作过程中存在内核&#x2F;用户空间数据的频繁拷贝问题，在epoll中内核和用户区使用的是共享内存（基于mmap内存映射区实现），省去了不必要的内存拷贝。</li>
<li>我们需要对select和poll返回的集合进行判断才能知道哪些文件描述符是就绪的，通过epoll可以直接得到已就绪的文件描述符集合，无需再次检测</li>
<li>使用epoll没有最大文件描述符的限制，仅受系统中进程能打开的最大文件数目限制</li>
</ul>
<p>当多路复用的文件数量庞大、IO流量频繁的时候，一般不太适合使用select()和poll()，这种情况下select()和poll()表现较差，推荐使用epoll()。</p>
<hr>
<h2 id="9-2-操作函数"><a href="#9-2-操作函数" class="headerlink" title="9.2 操作函数"></a>9.2 操作函数</h2><p>在epoll中一共提供是三个API函数，分别处理不同的操作，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建epoll实例，通过一棵红黑树管理待检测集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// 管理红黑树上的文件描述符(添加、修改、删除)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="comment">// 检测epoll树中是否有就绪的文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>select&#x2F;poll低效的原因之一是将“添加&#x2F;维护待检测任务”和“阻塞进程&#x2F;线程”两个步骤合二为一。每次调用select都需要这两步操作，然而大多数应用场景中，需要监视的socket个数相对固定，并不需要每次都修改。epoll将这两个操作分开，先用<code>epoll_ctl()</code>维护等待队列，再调用<code>epoll_wait()</code>阻塞进程（解耦）。通过下图的对比显而易见，epoll的效率得到了提升。<br><img src="/img/9.45.png" alt="在这里插入图片描述"></p>
<p><code>epoll_create()</code>函数的作用是创建一个红黑树模型的实例，用于管理待检测的文件描述符的集合。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数参数 size：在Linux内核2.6.8版本以后，这个参数是被忽略的，只需要指定一个大于0的数值就可以了。</li>
<li>函数返回值：<ul>
<li>失败：返回-1</li>
<li>成功：返回一个有效的文件描述符，通过这个文件描述符就可以访问创建的epoll实例了</li>
</ul>
</li>
</ul>
<p><code>epoll_ctl()</code>函数的作用是管理红黑树实例上的节点，可以进行添加、删除、修改操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联合体, 多个变量共用同一块内存        </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line"> 	<span class="type">void</span>        *ptr;</span><br><span class="line">	<span class="type">int</span>          fd;	<span class="comment">// 通常情况下使用这个成员, 和epoll_ctl的第三个参数相同即可</span></span><br><span class="line">	<span class="type">uint32_t</span>     u32;</span><br><span class="line">	<span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">	<span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数参数：<ul>
<li>epfd：epoll_create() 函数的返回值，通过这个参数找到epoll实例</li>
<li>op：这是一个枚举值，控制通过该函数执行什么操作<ul>
<li><code>EPOLL_CTL_ADD</code>：往epoll模型中添加新的节点</li>
<li><code>EPOLL_CTL_MOD</code>：修改epoll模型中已经存在的节点</li>
<li><code>EPOLL_CTL_DEL</code>：删除epoll模型中的指定的节点</li>
</ul>
</li>
<li>fd：文件描述符，即要添加&#x2F;修改&#x2F;删除的文件描述符</li>
<li>event：epoll事件，用来修饰第三个参数对应的文件描述符的，指定检测这个文件描述符的什么事件<ul>
<li><pre><code>events：委托epoll检测的事件
</code></pre>
<ul>
<li><code>EPOLLIN</code>：读事件, 接收数据, 检测读缓冲区，如果有数据该文件描述符就绪</li>
<li><code>EPOLLOUT</code>：写事件, 发送数据, 检测写缓冲区，如果可写该文件描述符就绪</li>
<li><code>EPOLLERR</code>：异常事件</li>
</ul>
</li>
<li><pre><code>data：用户数据变量，这是一个联合体类型，通常情况下使用里边的`fd`成员，用于存储待检测的文件描述符的值，在调用`epoll_wait()`函数的时候这个值会被传出。
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>函数返回值：<ul>
<li>失败：返回-1</li>
<li>成功：返回0<br><code>epoll_wait()</code>函数的作用是检测创建的epoll实例中有没有就绪的文件描述符。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数参数：<ul>
<li>epfd：epoll_create() 函数的返回值, 通过这个参数找到epoll实例</li>
<li>events：传出参数, 这是一个结构体数组的地址, 里边存储了已就绪的文件描述符的信息</li>
<li>maxevents：修饰第二个参数, 结构体数组的容量（元素个数）</li>
<li>timeout：如果检测的epoll实例中没有已就绪的文件描述符，该函数阻塞的时长, 单位ms 毫秒<ul>
<li>0：函数不阻塞，不管epoll实例中有没有就绪的文件描述符，函数被调用后都直接返回</li>
<li>大于0：如果epoll实例中没有已就绪的文件描述符，函数阻塞对应的毫秒数再返回</li>
<li>-1：函数一直阻塞，直到epoll实例中有已就绪的文件描述符之后才解除阻塞</li>
</ul>
</li>
</ul>
</li>
<li>函数返回值：<ul>
<li>成功：<ul>
<li>等于0：函数是阻塞被强制解除了, 没有检测到满足条件的文件描述符</li>
<li>大于0：检测到的已就绪的文件描述符的总个数</li>
</ul>
</li>
<li>失败：返回-1</li>
</ul>
</li>
</ul>
<hr>
<h2 id="9-3-epoll的使用"><a href="#9-3-epoll的使用" class="headerlink" title="9.3 epoll的使用"></a>9.3 epoll的使用</h2><h3 id="9-3-1-操作步骤"><a href="#9-3-1-操作步骤" class="headerlink" title="9.3.1 操作步骤"></a>9.3.1 操作步骤</h3><p>在服务器端使用epoll进行IO多路转接的操作步骤如下：</p>
<ol>
<li>创建监听的套接字</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置端口复用（可选）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用本地的IP与端口和监听的套接字进行绑定</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>给监听的套接字设置监听</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen(lfd, <span class="number">128</span>);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>创建epoll实例对象</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>将用于监听的套接字添加到epoll实例中</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">ev.events = EPOLLIN;    <span class="comment">// 检测lfd读读缓冲区是否有数据</span></span><br><span class="line">ev.data.fd = lfd;</span><br><span class="line"><span class="type">int</span> ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>检测添加到epoll实例中的文件描述符是否已就绪，并将这些已就绪的文件描述符进行处理</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = epoll_wait(epfd, evs, size, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是监听的文件描述符，和新客户端建立连接，将得到的文件描述符添加到epoll实例中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cfd = accept(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line">ev.data.fd = cfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是通信的文件描述符，和对应的客户端通信，如果连接已断开，将该文件描述符从epoll实例中删除</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = recv(curfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">    close(curfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    send(curfd, buf, len, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>重复第7步的操作</li>
</ol>
<hr>
<h3 id="9-3-2-示例代码"><a href="#9-3-2-示例代码" class="headerlink" title="9.3.2 示例代码"></a>9.3.2 示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">// 本地多有的ＩＰ</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="comment">// 所有的文件描述符对应读写缓冲区状态都是委托内核进行检测的epoll</span></span><br><span class="line">    <span class="comment">// 创建一个epoll模型</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往epoll实例中添加需要检测的节点, 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = EPOLLIN;    <span class="comment">// 检测lfd读读缓冲区是否有数据</span></span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[1024];</span></span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(evs) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line">    <span class="comment">// 持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用一次, 检测一次</span></span><br><span class="line">        <span class="type">int</span> num = epoll_wait(epfd, evs, size, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出当前的文件描述符</span></span><br><span class="line">            <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line">            <span class="comment">// 判断这个文件描述符是不是用于监听的</span></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 建立新的连接</span></span><br><span class="line">                <span class="type">int</span> cfd = accept(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">                ev.events = EPOLLIN;    <span class="comment">// 读缓冲区是否有数据</span></span><br><span class="line">                ev.data.fd = cfd;</span><br><span class="line">                ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl-accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理通信的文件描述符</span></span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="type">int</span> len = recv(curfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端已经断开了连接\n&quot;</span>);</span><br><span class="line">                    <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">                    send(curfd, buf, len, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在服务器端循环调用<code>epoll_wait()</code>的时候，就会得到一个就绪列表，并通过该函数的第二个参数传出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[1024];</span></span><br><span class="line"><span class="type">int</span> num = epoll_wait(epfd, evs, size, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>每当<code>epoll_wait()</code>函数返回一次，在<code>evs</code>中最多可以存储<code>size</code>个已就绪的文件描述符信息，但是在这个数组中实际存储的有效元素个数为<code>num</code>个，如果在这个epoll实例的红黑树中已就绪的文件描述符很多，并且<code>evs</code>数组无法将这些信息全部传出，那么这些信息会在下一次<code>epoll_wait()</code>函数返回的时候被传出。</p>
<p>通过<code>evs</code>数组被传递出的每一个有效元素里边都包含了已就绪的文件描述符的相关信息，这些信息并不是凭空得来的，这取决于我们在往epoll实例中添加节点的时候，往节点中初始化了哪些数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line"><span class="comment">// 节点初始化</span></span><br><span class="line">ev.events = EPOLLIN;    </span><br><span class="line">ev.data.fd = lfd;	<span class="comment">// 使用了联合体中 fd 成员</span></span><br><span class="line"><span class="comment">// 添加待检测节点到epoll实例中</span></span><br><span class="line"><span class="type">int</span> ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br></pre></td></tr></table></figure>

<p>在添加节点的时候，需要对这个<code>struct epoll_event</code>类型的节点进行初始化，当这个节点对应的文件描述符变为已就绪状态，这些被传入的初始化信息就会被原样传出，这个对应关系必须要搞清楚。</p>
<hr>
<h2 id="9-4-epoll的工作模式"><a href="#9-4-epoll的工作模式" class="headerlink" title="9.4 epoll的工作模式"></a>9.4 epoll的工作模式</h2><h3 id="9-4-1-水平模式"><a href="#9-4-1-水平模式" class="headerlink" title="9.4.1 水平模式"></a>9.4.1 水平模式</h3><p>水平模式可以简称为LT模式，<code>LT（level triggered）是缺省的工作方式，并且同时支持block和no-block socket</code>。在这种做法中，内核通知使用者哪些文件描述符已经就绪，之后就可以对这些已就绪的文件描述符进行IO操作了。<code>如果我们不作任何操作，内核还是会继续通知使用者。</code></p>
<p><strong>水平模式的特点：</strong></p>
<ul>
<li>读事件：<code>如果文件描述符对应的读缓冲区还有数据，读事件就会被触发，epoll_wait()解除阻塞</code><ul>
<li>当读事件被触发，epoll_wait()解除阻塞，之后就可以接收数据了</li>
<li>如果接收数据的buf很小，不能全部将缓冲区数据读出，那么读事件会继续被触发，直到数据被全部读出，如果接收数据的内存相对较大，读数据的效率也会相对较高（减少了读数据的次数）</li>
<li><code>因为读数据是被动的，必须通过读事件才能知道有数据到达了，因此对于读事件的检测是必须的</code></li>
</ul>
</li>
<li>写事件：<code>如果文件描述符对应的写缓冲区可写，写事件就会被触发，epoll_wait()解除阻塞</code><ul>
<li>当写事件被触发，epoll_wait()解除阻塞，之后就可以将数据写入到写缓冲区了</li>
<li><code>写事件的触发发生在写数据之前而不是之后</code>，被写入到写缓冲区中的数据是由内核自动发送出去的</li>
<li>如果写缓冲区没有被写满，写事件会一直被触发</li>
<li><code>因为写数据是主动的，并且写缓冲区一般情况下都是可写的（缓冲区不满），因此对于写事件的检测不是必须的</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="9-4-2-边沿模式"><a href="#9-4-2-边沿模式" class="headerlink" title="9.4.2 边沿模式"></a>9.4.2 边沿模式</h3><p>边沿模式可简称为ET模式，<code>ET（edge-triggered）是高速工作方式，只支持no-block socket</code>。在这种模式下，<code>当文件描述符从未就绪变为就绪时，内核会通过epoll通知使用者。然后它会假设使用者知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知（only once）</code>。<br>如果我们对这个文件描述符做IO操作，从而导致它再次变成未就绪，当这个未就绪的文件描述符再次变成就绪状态，内核会再次进行通知，并且还是只通知一次。<br><code>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。</code></p>
<p><strong>边沿模式的特点:</strong></p>
<ul>
<li>读事件：<code>当读缓冲区有新的数据进入，读事件被触发一次，没有新数据不会触发该事件</code><ul>
<li>如果有新数据进入到读缓冲区，读事件被触发，epoll_wait()解除阻塞</li>
<li>读事件被触发，可以通过调用read()&#x2F;recv()函数将缓冲区数据读出<ul>
<li><code>如果数据没有被全部读走，并且没有新数据进入，读事件不会再次触发，只通知一次</code></li>
<li><code>如果数据被全部读走或只读走一部分，此时有新数据进入，读事件被触发，且只通知一次</code></li>
</ul>
</li>
</ul>
</li>
<li>写事件：<code>当写缓冲区状态可写，写事件只会触发一次</code><ul>
<li>如果写缓冲区被检测到可写，写事件被触发，epoll_wait()解除阻塞</li>
<li>写事件被触发，就可以通过调用write()&#x2F;send()函数，将数据写入到写缓冲区中<ul>
<li>写缓冲区从不满到被写满，期间写事件只会被触发一次</li>
<li>写缓冲区从满到不满，状态变为可写，写事件只会被触发一次</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>综上所述：<code>epoll的边沿模式下 epoll_wait()检测到文件描述符有新事件才会通知，如果不是新的事件就不通知，通知的次数比水平模式少，效率比水平模式要高。</code></p>
<hr>
<h4 id="9-4-2-1-ET模式的设置"><a href="#9-4-2-1-ET模式的设置" class="headerlink" title="9.4.2.1 ET模式的设置"></a>9.4.2.1 ET模式的设置</h4><p>边沿模式不是默认的epoll模式，需要额外进行设置。epoll设置边沿模式是非常简单的，epoll管理的红黑树示例中每个节点都是<code>struct epoll_event</code>类型，只需要将<code>EPOLLET</code>添加到结构体的<code>events</code>成员中即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">ev.events = EPOLLIN | EPOLLET;	<span class="comment">// 设置边沿模式</span></span><br></pre></td></tr></table></figure>

<p>示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = epoll_wait(epfd, evs, size, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取出当前的文件描述符</span></span><br><span class="line">    <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line">    <span class="comment">// 判断这个文件描述符是不是用于监听的</span></span><br><span class="line">    <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 建立新的连接</span></span><br><span class="line">        <span class="type">int</span> cfd = accept(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">        <span class="comment">// 读缓冲区是否有数据, 并且将文件描述符设置为边沿模式</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">        ev.events = EPOLLIN | EPOLLET;   </span><br><span class="line">        ev.data.fd = cfd;</span><br><span class="line">        ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_ctl-accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="9-4-2-2-设置非阻塞"><a href="#9-4-2-2-设置非阻塞" class="headerlink" title="9.4.2.2 设置非阻塞"></a>9.4.2.2 设置非阻塞</h4><p>对于写事件的触发一般情况下是不需要进行检测的，因为写缓冲区大部分情况下都是有足够的空间可以进行数据的写入。对于读事件的触发就必须要检测了，因为服务器也不知道客户端什么时候发送数据，如果使用epoll的边沿模式进行读事件的检测，有新数据达到只会通知一次，那么必须要保证得到通知后将数据全部从读缓冲区中读出。那么，应该如何读这些数据呢？</p>
<ul>
<li>方式1：准备一块特别大的内存，用于存储从读缓冲区中读出的数据，但是这种方式有很大的弊端：<ul>
<li>内存的大小没有办法界定，太大浪费内存，太小又不够用</li>
<li>系统能够分配的最大堆内存也是有上限的，栈内存就更不必多言了</li>
</ul>
</li>
<li>方式2：循环接收数据</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = recv(curfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 数据处理...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做也是有弊端的，因为套接字操作默认是阻塞的，当读缓冲区数据被读完之后，读操作就阻塞了也就是调用的<code>read()/recv()</code>函数被阻塞了，当前进程&#x2F;线程被阻塞之后就无法处理其他操作了。</p>
<p>要解决阻塞问题，就将套接字默认的阻塞行为修改为非阻塞，需使用<code>fcntl()</code>函数进行处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置完成之后, 读写都变成了非阻塞模式</span></span><br><span class="line"><span class="type">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">flag |= O_NONBLOCK;                                                        </span><br><span class="line">fcntl(cfd, F_SETFL, flag);</span><br></pre></td></tr></table></figure>

<p>通过上述分析就可以得出一个结论：<code>epoll在边沿模式下，必须要将套接字设置为非阻塞模式</code>，但是，这样就会引发另外的一个bug，在非阻塞模式下，循环地将读缓冲区数据读到本地内存中，当缓冲区数据被读完了，调用的<code>read()/recv()</code>函数还会继续从缓冲区中读数据，此时函数调用就失败了，返回-1，对应的全局变量 errno 值为 <code>EAGAIN</code> 或者 <code>EWOULDBLOCK</code>如果打印错误信息会得到如下的信息：<code>Resource temporarily unavailable</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非阻塞模式下recv() / read()函数返回值 len == -1</span></span><br><span class="line"><span class="type">int</span> len = recv(curfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(errno == EAGAIN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数据读完了...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="9-4-2-3-示例代码"><a href="#9-4-2-3-示例代码" class="headerlink" title="9.4.2.3 示例代码"></a>9.4.2.3 示例代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">// 本地多有的ＩＰ</span></span><br><span class="line">    <span class="comment">// 127.0.0.1</span></span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr.s_addr);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="comment">// 所有的文件描述符对应读写缓冲区状态都是委托内核进行检测的epoll</span></span><br><span class="line">    <span class="comment">// 创建一个epoll模型</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往epoll实例中添加需要检测的节点, 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = EPOLLIN;    <span class="comment">// 检测lfd读读缓冲区是否有数据</span></span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[1024];</span></span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(evs) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line">    <span class="comment">// 持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用一次, 检测一次</span></span><br><span class="line">        <span class="type">int</span> num = epoll_wait(epfd, evs, size, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;==== num: %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出当前的文件描述符</span></span><br><span class="line">            <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line">            <span class="comment">// 判断这个文件描述符是不是用于监听的</span></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 建立新的连接</span></span><br><span class="line">                <span class="type">int</span> cfd = accept(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">// 将文件描述符设置为非阻塞</span></span><br><span class="line">                <span class="comment">// 得到文件描述符的属性</span></span><br><span class="line">                <span class="type">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">                flag |= O_NONBLOCK;</span><br><span class="line">                fcntl(cfd, F_SETFL, flag);</span><br><span class="line">                <span class="comment">// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">                <span class="comment">// 通信的文件描述符检测读缓冲区数据的时候设置为边沿模式</span></span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;    <span class="comment">// 读缓冲区是否有数据</span></span><br><span class="line">                ev.data.fd = cfd;</span><br><span class="line">                ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl-accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理通信的文件描述符</span></span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">5</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="comment">// 循环读数据</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> len = recv(curfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 非阻塞模式下和阻塞模式是一样的 =&gt; 判断对方是否断开连接</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">                        <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">                        epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                        close(curfd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 通信</span></span><br><span class="line">                        <span class="comment">// 接收的数据打印到终端</span></span><br><span class="line">                        write(STDOUT_FILENO, buf, len);</span><br><span class="line">                        <span class="comment">// 发送数据</span></span><br><span class="line">                        send(curfd, buf, len, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// len == -1</span></span><br><span class="line">                        <span class="keyword">if</span>(errno == EAGAIN)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;数据读完了...\n&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">                            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="10-基于UDP的套接字通信"><a href="#10-基于UDP的套接字通信" class="headerlink" title="10. 基于UDP的套接字通信"></a>10. 基于UDP的套接字通信</h1><p>udp是一个面向无连接的，不安全的，报式传输层协议，udp的通信过程默认也是阻塞的。</p>
<ul>
<li><p>UDP通信不需要建立连接 ，因此不需要进行connect()操作</p>
</li>
<li><p>UDP通信过程中，每次都需要指定数据接收端的IP和端口，和发快递差不多</p>
</li>
<li><p>UDP不对收到的数据进行排序，在UDP报文的首部中并没有关于数据顺序的信息</p>
</li>
<li><p>UDP对接收到的数据报不回复确认信息,发送端不知道数据是否被正确接收,也不会重发数据。</p>
</li>
<li><p>如果发生了数据丢失，不存在丢一半的情况，如果丢当前这个数据包就全部丢失了</p>
</li>
</ul>
<h2 id="10-1-通信流程"><a href="#10-1-通信流程" class="headerlink" title="10.1 通信流程"></a>10.1 通信流程</h2><p>使用UDP进行通信，服务器和客户端的处理步骤比TCP要简单很多，并且两端是对等的 （通信的处理流程几乎是一样的），也就是说并没有严格意义上的客户端和服务器端。UDP的通信流程如下：<br><img src="/img/9.46.png" alt="在这里插入图片描述"></p>
<h3 id="10-1-1-服务器端"><a href="#10-1-1-服务器端" class="headerlink" title="10.1.1 服务器端"></a>10.1.1 服务器端</h3><p><strong>假设服务器端是接收数据的角色：</strong></p>
<ol>
<li>创建通信的套接字</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用通信的套接字和本地的IP和端口绑定，IP和端口需要转换为大端(可选)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通信</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line">recvfrom();</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">sendto();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>关闭套接字（文件描述符）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="10-1-2-客户端"><a href="#10-1-2-客户端" class="headerlink" title="10.1.2 客户端"></a>10.1.2 客户端</h3><p><strong>假设客户端是发送数据的角色：</strong></p>
<ol>
<li>创建通信的套接字</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通信</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line">recvfrom();</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">sendto();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>关闭套接字（文件描述符）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure>

<p>在UDP通信过程中，<code>哪一端是接收数据的角色，那么这个接收端就必须绑定一个固定的端口</code>，如果某一端不需要接收数据，这个绑定操作就可省略不写，通信的套接字会自动绑定一个随机端口。</p>
<hr>
<h2 id="10-2-通信函数"><a href="#10-2-通信函数" class="headerlink" title="10.2 通信函数"></a>10.2 通信函数</h2><p>基于UDP进行套接字通信，创建套接字的函数还是<code>socket()</code>但是第二个参数的值需要指定为<code>SOCK_DGRAM</code>，通过该参数指定要创建一个基于报式传输协议的套接字，最后一个参数指定为0表示使用报式协议中的UDP协议。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数:<ul>
<li>domain：地址族协议，AF_INET -&gt; IPv4，AF_INET6-&gt; IPv6</li>
<li>type：使用的传输协议类型，报式传输协议需要指定为 SOCK_DGRAM</li>
<li>protocol：指定为0，表示使用的默认报式传输协议为 UDP</li>
</ul>
</li>
<li>返回值：函数调用成功返回一个可用的文件描述符（大于0），调用失败返回-1</li>
</ul>
<p>另外进行UDP通信，通信过程虽然默认还是阻塞的，但是通信函数和TCP不同<br>操作函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据, 如果没有数据,该函数阻塞</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数:<ul>
<li>sockfd: 基于udp的通信的文件描述符</li>
<li>buf: 指针指向的地址用来存储接收的数据</li>
<li>len: buf指针指向的内存的容量, 最多能存储多少字节</li>
<li>flags: 设置套接字属性，一般使用默认属性，指定为0即可</li>
<li>src_addr: 发送数据的一端的地址信息，IP和端口都存储在这里边, 是大端存储的<ul>
<li>如果这个参数中的信息对当前业务处理没有用处, 可以指定为NULL, 不保存这些信息</li>
</ul>
</li>
<li>addrlen: 类似于accept() 函数的最后一个参数, 是一个传入传出参数<ul>
<li>传入的是src_addr参数指向的内存的大小, 传出的也是这块内存的大小</li>
<li>如果src_addr参数指定为NULL, 这个参数也指定为NULL即可</li>
</ul>
</li>
</ul>
</li>
<li>返回值：成功返回接收的字节数，失败返回-1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送数据函数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数:<ul>
<li>sockfd: 基于udp的通信的文件描述符</li>
<li>buf: 这个指针指向的内存中存储了要发送的数据</li>
<li>len: 要发送的数据的实际长度</li>
<li>flags: 设置套接字属性，一般使用默认属性，指定为0即可</li>
<li>dest_addr: 接收数据的一端对应的地址信息, 大端的IP和端口</li>
<li>addrlen: 参数 dest_addr 指向的内存大小</li>
</ul>
</li>
<li>返回值：函数调用成功返回实际发送的字节数，调用失败返回-1</li>
</ul>
<hr>
<h2 id="10-3-通信代码"><a href="#10-3-通信代码" class="headerlink" title="10.3 通信代码"></a>10.3 通信代码</h2><p>在UDP通信过程中，服务器和客户端都可以作为数据的发送端和数据接收端，假设服务器端是被动接收数据，客户端是主动发送数据，那么在服务器端就必须绑定固定的端口了。</p>
<h3 id="10-3-1-服务器端"><a href="#10-3-1-服务器端" class="headerlink" title="10.3.1 服务器端"></a>10.3.1 服务器端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通信的套接字和本地的IP与端口绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);    <span class="comment">// 大端</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">char</span> ipbuf[<span class="number">64</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> rlen = recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP地址: %s, 端口: %d\n&quot;</span>,</span><br><span class="line">               inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ipbuf, <span class="keyword">sizeof</span>(ipbuf)),</span><br><span class="line">               ntohs(cliaddr.sin_port));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回复数据</span></span><br><span class="line">        <span class="comment">// 数据回复给了发送数据的客户端</span></span><br><span class="line">        sendto(fd, buf, rlen, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为数据接收端，服务器端通过<code>bind()</code>函数绑定了固定的端口，然后基于这个固定的端口通过<code>recvfrom()</code>函数接收客户端发送的数据，同时通过这个函数也得到了数据发送端的地址信息（recvfrom的第三个参数），这样就可以通过得到的地址信息通过<code>sendto()</code>函数给客户端回复数据了。</p>
<hr>
<h3 id="10-3-2-客户端"><a href="#10-3-2-客户端" class="headerlink" title="10.3.2 客户端"></a>10.3.2 客户端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化服务器地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);    <span class="comment">// 大端</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.1.100&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">char</span> ipbuf[<span class="number">64</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 2. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, udp %d....\n&quot;</span>, num++);</span><br><span class="line">        <span class="comment">// 发送数据, 数据发送给了服务器</span></span><br><span class="line">        sendto(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;服务器say: %s\n&quot;</span>, buf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为数据发送端，客户端不需要绑定固定端口，客户端使用的端口是随机绑定的（也可以调用bind()函数手动进行绑定）。客户端在接收服务器端回复的数据的时候需要调用<code>recvfrom()</code>函数，因为客户端在发送数据之前就已经知道服务器绑定的固定的IP和端口信息了，所以接收服务器数据的时候就可以不保存服务器端的地址信息，直接将函数的最后两个参数指定为NULL即可。</p>
<hr>
<h1 id="11-UDP特性之广播"><a href="#11-UDP特性之广播" class="headerlink" title="11. UDP特性之广播"></a>11. UDP特性之广播</h1><h2 id="11-1-广播的特点"><a href="#11-1-广播的特点" class="headerlink" title="11.1 广播的特点"></a>11.1 广播的特点</h2><p>广播的UDP的特性之一，<code>通过广播可以向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息</code>，每个广播消息都包含一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全部为1 （即点分十进制IP的最后一部分是255）。点分十进制的IP地址每一部分是1字节，最大值为255，比如：<code>192.168.1.100</code></p>
<ul>
<li>前两部分192.168表示当前网络是局域网</li>
<li>第三部分1表示局域网中的某一个网段，最大值为 255</li>
<li>第四部分100用于标记当前网段中的某一台主机，最大值为255</li>
<li>每个网段都有一个特殊的广播地址，即：192.168.xxx.255</li>
</ul>
<p>广播分为两端，即数据发送端和数据接收端，通过广播的方式发送数据，发送端和接收端的关系是 1:N</p>
<ul>
<li><p>发送广播消息的一端，通过广播地址，可以将消息同时发送到局域网的多台主机上（数据接收端）</p>
</li>
<li><p>在发送广播消息的时候，必须要把数据发送到广播地址上</p>
</li>
<li><p>广播只能在局域网内使用，广域网是无法使用UDP进行广播的</p>
</li>
<li><p>只要发送端在发送广播消息，数据接收端就能收到广播消息，消息的接收是无法拒绝的，除非将接收端的进程关闭，就接收不到了。</p>
</li>
</ul>
<p>UDP的广播和日常的广播是一样的，都是一种快速传播消息的方式，因此<code>广播的开销很小</code>，发送端使用一个广播地址，就可以将数据发送到多个接收数据的终端上，如果不使用广播，就需要进行多次发送才能将数据分别发送到不同的主机上。</p>
<hr>
<h2 id="11-2-设置广播属性"><a href="#11-2-设置广播属性" class="headerlink" title="11.2 设置广播属性"></a>11.2 设置广播属性</h2><p>基于UDP虽然可以进行数据的广播，但是这个属性默认是关闭的，如果需要对数据进行广播，那么需要在广播端代码中开启广播属性，需要通过套接字选项函数进行设置，该函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, 	<span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数:<ul>
<li>sockfd：进行UDP通信的文件描述符</li>
<li>level: 套接字级别，需要设置为 SOL_SOCKET</li>
<li>optname：选项名，此处要设置udp的广播属性，该参数需要指定为：SO_BROADCAST</li>
<li>optval：如果是设置广播属性，该指针实际指向一块int类型的内存<ul>
<li>该整型值为0：关闭广播属性</li>
<li>该整形值为1：打开广播属性</li>
</ul>
</li>
<li>optlen：optval指针指向的内存大小，即：sizeof(int)</li>
</ul>
</li>
<li>返回值：函数调用成功返回0，失败返回-1</li>
</ul>
<hr>
<h2 id="11-3-广播通信流程"><a href="#11-3-广播通信流程" class="headerlink" title="11.3 广播通信流程"></a>11.3 广播通信流程</h2><p>如果使用UDP在局域网范围内进行消息的广播，一般情况下广播端只发送数据，接收端只接受广播消息。因此在数据接收端需要绑定固定的端口，广播端则不需要手动绑定固定端口，自动随机绑定即可。</p>
<p><img src="/img/9.47.png" alt="在这里插入图片描述"></p>
<p><strong>数据发送端</strong></p>
<ol>
<li>创建通信的套接字</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>主动发送数据不需要手动绑定固定端口（自动随机分配就可以了），因此直接设置广播属性</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt  = <span class="number">1</span>;</span><br><span class="line">setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用广播地址发送广播数据到接收端绑定的固定端口上</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendto();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>关闭套接字（文件描述符）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure>

<p><strong>数据接收端</strong></p>
<ol>
<li>创建通信的套接字</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>因为是被动接收数据的一端，所以必须要绑定固定的端口和本地IP地址</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>接收广播消息</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recvfrom();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>关闭套接字（文件描述符）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="11-4-通信代码"><a href="#11-4-通信代码" class="headerlink" title="11.4 通信代码"></a>11.4 通信代码</h2><p><strong>广播端</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置广播属性</span></span><br><span class="line">    <span class="type">int</span> opt  = <span class="number">1</span>;</span><br><span class="line">    setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">9999</span>); <span class="comment">// 接收端需要绑定9999端口</span></span><br><span class="line">    <span class="comment">// 只要主机在237网段, 并且绑定了9999端口, 这个接收端就能收到广播消息</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.237.255&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, client...%d\n&quot;</span>, num++);</span><br><span class="line">        <span class="comment">// 数据广播</span></span><br><span class="line">        sendto(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发送的广播的数据: %s\n&quot;</span>, buf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：发送广播消息一端必须要开启UDP的广播属性，并且发送消息的地址必须是当前发送端所在网段的广播地址，这样才能通过调用一个消息发送函数将消息同时发送N台接收端主机上。</p>
</blockquote>
<p><strong>接收端</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通信的套接字和本地的IP与端口绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);    <span class="comment">// 大端</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收广播消息</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">// 阻塞等待数据达到</span></span><br><span class="line">        recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收到的广播消息: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于接收广播消息的一端，必须要绑定固定的端口，并由广播端将广播消息发送到这个端口上，因此所有接收端都应绑定相同的端口，这样才能同时收到广播数据。</p>
</blockquote>
<hr>
<h1 id="12-UDP特性之组播（多播）"><a href="#12-UDP特性之组播（多播）" class="headerlink" title="12. UDP特性之组播（多播）"></a>12. UDP特性之组播（多播）</h1><h2 id="12-1-组播的特点"><a href="#12-1-组播的特点" class="headerlink" title="12.1 组播的特点"></a>12.1 组播的特点</h2><p>组播也可以称之为多播这也是UDP的特性之一。<code>组播是主机间一对多的通讯模式，是一种允许一个或多个组播源发送同一报文到多个接收者的技术</code>。组播源将一份报文发送到特定的组播地址，组播地址不同于单播地址，它并不属于特定某个主机，而是属于一组主机。一个组播地址表示一个群组，需要接收组播报文的接收者都加入这个群组。</p>
<ul>
<li>广播只能在局域网访问内使用，组播既可以在局域网中使用，也可以用于广域网</li>
<li>在发送广播消息的时候，连接到局域网的客户端不管想不想都会接收到广播数据，组播可以控制发送端的消息能够被哪些接收端接收，更灵活和人性化。</li>
<li>广播使用的是广播地址，组播需要使用组播地址。</li>
<li>广播和组播属性默认都是关闭的，如果使用需要通过setsockopt()函数进行设置。</li>
</ul>
<p>组播需要使用组播地址，在 IPv4 中它的范围从 <code>224.0.0.0</code> 到 <code>239.255.255.255</code>，并被划分为局部链接多播地址、预留多播地址和管理权限多播地址三类:</p>
<table>
<thead>
<tr>
<th>IP地址</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>224.0.0.0~224.0.0.255</td>
<td>局部链接多播地址：是为路由协议和其它用途保留的地只能用于局域网中，路由器是不会转发的地址 224.0.0.0不能用，是保留地址</td>
</tr>
<tr>
<td>224.0.1.0~224.0.1.255</td>
<td>为用户可用的组播地址（临时组地址），可以用于 Internet 上的。</td>
</tr>
<tr>
<td>224.0.2.0~238.255.255.255</td>
<td>用户可用的组播地址（临时组地址），全网范围内有效</td>
</tr>
<tr>
<td>239.0.0.0~239.255.255.255</td>
<td>为本地管理组播地址，仅在特定的本地范围内有效</td>
</tr>
</tbody></table>
<p>组播地址不属于任何服务器或个人，它有点类似一个微信群号，任何成员（<strong>组播源</strong>）往微信群（<strong>组播IP</strong>）发送消息（<strong>组播数据</strong>），这个群里的成员（组播接收者）都会接收到此消息。</p>
<hr>
<h2 id="12-2-设置组播属性"><a href="#12-2-设置组播属性" class="headerlink" title="12.2 设置组播属性"></a>12.2 设置组播属性</h2><p>如果使用组播进行数据的传输，不管是消息发送端还是接收端，都需要进行相关的属性设置，设置函数使用的是同一个，即：<code>setsockopt()。</code></p>
<h3 id="12-2-1-发送端"><a href="#12-2-1-发送端" class="headerlink" title="12.2.1 发送端"></a>12.2.1 发送端</h3><p>发送组播消息的一端需要设置组播属性，具体的设置方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li>sockfd：用于UDP通信的套接字</li>
<li>level：套接字级别，设置组播属性需要将该参数指定为：IPPTOTO_IP</li>
<li>optname: 套接字选项名，设置组播属性需要将该参数指定为：IP_MULTICAST_IF</li>
<li>optval：设置组播属性，这个指针需要指向一个struct in_addr{} 类型的结构体地址，这个结构体地址用于存储组播地址，并且组播IP地址的存储方式是大端的。</li>
<li>optlen：optval指针指向的内存大小，即：sizeof(struct in_addr)</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;	<span class="comment">// unsigned int</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>



<ul>
<li>返回值：函数调用成功返回0，调用失败返回-1</li>
</ul>
<hr>
<h3 id="12-2-2-接收端"><a href="#12-2-2-接收端" class="headerlink" title="12.2.2 接收端"></a>12.2.2 接收端</h3><p>因为一个组播地址表示一个群组，所以需要接收组播报文的接收者都加入这个群组，和想要接收群消息就必须要先入群是一个道理。加入到这个组播群组的方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数:</p>
<ul>
<li><p>sockfd：基于udp的通信的套接字</p>
</li>
<li><p>level：套接字级别，加入到多播组该参数需要指定为：<code>IPPTOTO_IP</code></p>
</li>
<li><p>optname：套接字选项名，加入到多播组该参数需要指定为：<code>IP_ADD_MEMBERSHIP</code></p>
</li>
<li><p>optval：加入到多播组，这个指针应该指向一个<code>struct ip_mreqn&#123;&#125;</code>类型的结构体地址</p>
</li>
<li><p>optlen：optval指向的内存大小，即：<code>sizeof(struct ip_mreqn)</code></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>  <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;	<span class="comment">// unsigned int</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span>   <span class="comment">// 组播地址/多播地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_address</span>;</span>     <span class="comment">// 本地地址</span></span><br><span class="line">    <span class="type">int</span>   imr_ifindex;              <span class="comment">// 网卡的编号, 每个网卡都有一个编号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 必须通过网卡名字才能得到网卡的编号: 可以通过 ifconfig 命令查看网卡名字</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将网卡名转换为网卡的编号, 参数是网卡的名字, 比如: &quot;ens33&quot;</span></span><br><span class="line"><span class="comment">// 返回值就是网卡的编号</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">if_nametoindex</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ifname)</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="12-3-组播通信流程"><a href="#12-3-组播通信流程" class="headerlink" title="12.3 组播通信流程"></a>12.3 组播通信流程</h2><p>发送组播消息的一端需要将数据发送到组播地址和固定的端口上，想要接收组播消息的终端需要绑定对应的固定端口然后加入到组播的群组，最终就可以实现数据的共享。</p>
<p><img src="/img/9.48.png" alt="在这里插入图片描述"></p>
<h3 id="12-3-1-发送端"><a href="#12-3-1-发送端" class="headerlink" title="12.3.1 发送端"></a>12.3.1 发送端</h3><ol>
<li>创建通信的套接字</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>主动发送数据的一端不需要手动绑定端口（自动随机分配就可以了），设置UDP组播属性</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置组播属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">opt</span>;</span></span><br><span class="line"><span class="comment">// 将组播地址初始化到这个结构体成员中</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;239.0.1.10&quot;</span>, &amp;opt.s_addr);</span><br><span class="line">setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用组播地址发送组播消息到固定的端口（接收端需要绑定这个端口）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendto();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>关闭套接字（文件描述符）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="12-3-2-接收端"><a href="#12-3-2-接收端" class="headerlink" title="12.3.2 接收端"></a>12.3.2 接收端</h3><ol>
<li>创建通信的套接字</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>绑定固定的端口，发送端应该将数据发送到接收端绑定的端口上</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>加入到组播的群组中，入群之后就可以接受组播消息了。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入到多播组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">opt</span>;</span></span><br><span class="line"><span class="comment">// 要加入到哪个多播组, 通过组播地址来区分</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;239.0.1.10&quot;</span>, &amp;opt.imr_multiaddr.s_addr);</span><br><span class="line">opt.imr_address.s_addr = INADDR_ANY;</span><br><span class="line">opt.imr_ifindex = if_nametoindex(<span class="string">&quot;ens33&quot;</span>);</span><br><span class="line">setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>接收组播数据</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recvfrom();</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>关闭套接字（文件描述符）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="12-4-通信代码"><a href="#12-4-通信代码" class="headerlink" title="12.4 通信代码"></a>12.4 通信代码</h2><h3 id="12-4-1-发送端"><a href="#12-4-1-发送端" class="headerlink" title="12.4.1 发送端"></a>12.4.1 发送端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置组播属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">opt</span>;</span></span><br><span class="line">    <span class="comment">// 将组播地址初始化到这个结构体成员中即可</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.1.10&quot;</span>, &amp;opt.s_addr);</span><br><span class="line">    setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">9999</span>); <span class="comment">// 接收端需要绑定9999端口</span></span><br><span class="line">    <span class="comment">// 发送组播消息, 需要使用组播地址, 和设置组播属性使用的组播地址一致就可以</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.1.10&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, client...%d\n&quot;</span>, num++);</span><br><span class="line">        <span class="comment">// 数据广播</span></span><br><span class="line">        sendto(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发送的组播的数据: %s\n&quot;</span>, buf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：在组播数据的发送端，需要先设置组播属性，发送的数据是通过sendto()函数发送到某一个组播地址上，并且在程序中数据发送到了接收端的9999端口，因此接收端程序必须要绑定这个端口才能收到组播消息。</p>
</blockquote>
<hr>
<h3 id="12-4-2-接收端"><a href="#12-4-2-接收端" class="headerlink" title="12.4.2 接收端"></a>12.4.2 接收端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通信的套接字和本地的IP与端口绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);    <span class="comment">// 大端</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 加入到多播组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">opt</span>;</span></span><br><span class="line">    <span class="comment">// 要加入到哪个多播组, 通过组播地址来区分</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.1.10&quot;</span>, &amp;opt.imr_multiaddr.s_addr);</span><br><span class="line">    opt.imr_address.s_addr = INADDR_ANY;</span><br><span class="line">    opt.imr_ifindex = if_nametoindex(<span class="string">&quot;ens33&quot;</span>);</span><br><span class="line">    setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收广播消息</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">// 阻塞等待数据达到</span></span><br><span class="line">        recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收到的组播消息: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：作为组播消息的接收端，必须要先绑定一个固定端口（发送端就可以把数据发送到这个固定的端口上了），然后加入到组播的群组中（一个组播地址可以看做是一个群组），这样就可以接收到组播消息了。</p>
</blockquote>
<hr>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/socket/">socket</a><a class="post-meta__tags" href="/tags/%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/">套接字通信</a><a class="post-meta__tags" href="/tags/TCP/">TCP</a><a class="post-meta__tags" href="/tags/IO%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E5%A4%8D%E7%94%A8/">IO多路转接复用</a><a class="post-meta__tags" href="/tags/UDP/">UDP</a></div><div class="post_share"><div class="social-share" data-image="/pic/3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/22/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E4%BF%A1%E5%8F%B7%E6%A7%BD/" title="基础数据类型和信号槽"><img class="cover" src="/pic/5.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">基础数据类型和信号槽</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/22/%E8%BF%9B%E7%A8%8B/" title="进程"><img class="cover" src="/pic/3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">进程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/10/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/" title="多线程和套接字通信"><img class="cover" src="/pic/5.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-22</div><div class="title">多线程和套接字通信</div></div></a></div><div><a href="/2023/11/03/stu-msg-manage-system/" title="学生管理系统"><img class="cover" src="/pic/3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-03</div><div class="title">学生管理系统</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/pic/avater.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">NineTSe</div><div class="author-info__description">难正经</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">70</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/9tse"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/9TSe" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:9TSewer@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">C++部分,Qt,Linux,文章摘于 https://subingwen.cn/</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%A5%97%E6%8E%A5%E5%AD%97-socket"><span class="toc-text">1. 套接字-socket</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">1.1 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-text">1.2 网络协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-socket%E7%BC%96%E7%A8%8B"><span class="toc-text">1.3 socket编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-text">1.3.1 字节序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-IP%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-text">1.3.2 IP地址转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-sockaddr-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">1.3.3 sockaddr 数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-4-%E5%A5%97%E6%8E%A5%E5%AD%97%E5%87%BD%E6%95%B0"><span class="toc-text">1.3.4 套接字函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-TCP%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">1.4 TCP通信流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">1.4.1 服务器端通信流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">1.4.2 客户端的通信流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-text">1.5  扩展阅读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A5%97%E6%8E%A5%E5%AD%97%E7%8E%AF%E5%A2%83"><span class="toc-text">1.5.1 初始化套接字环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1%E5%87%BD%E6%95%B0"><span class="toc-text">1.5.2 套接字通信函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-1-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">1.5.2.1 结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-2-%E5%A4%A7%E5%B0%8F%E7%AB%AF%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-text">1.5.2.2 大小端转换函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-3-%E5%A5%97%E6%8E%A5%E5%AD%97%E5%87%BD%E6%95%B0"><span class="toc-text">1.5.2.3 套接字函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">2. 三次握手,四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-tcp%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.1 tcp协议介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">2.2 三次握手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">2.2 TCP四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">2.3 流量控制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-text">3. TCP状态转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-text">3.1 TCP状态转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">3.1.1 三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">3.1.2 四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-text">3.1.3 状态转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">3.1.4 相关命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%8D%8A%E5%85%B3%E9%97%AD"><span class="toc-text">3.2 半关闭</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8"><span class="toc-text">3.3 端口复用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E5%8F%91"><span class="toc-text">4. 服务器并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%8D%95%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B"><span class="toc-text">4.1 单线程&#x2F;进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91"><span class="toc-text">4.2 多进程并发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91"><span class="toc-text">4.3 多线程并发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-TCP%E6%95%B0%E6%8D%AE%E7%B2%98%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">5. TCP数据粘包的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-TCP"><span class="toc-text">5.1 TCP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">5.2 解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E5%8F%91%E9%80%81%E7%AB%AF"><span class="toc-text">5.2.1 发送端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E6%8E%A5%E6%94%B6%E7%AB%AF"><span class="toc-text">5.2.2 接收端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-text">6. 套接字通信类的封装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%9F%BA%E4%BA%8EC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-text">6.1 基于C语言的封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-text">6.1.1 函数声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-text">6.1.2 函数定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%9F%BA%E4%BA%8EC-%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-text">6.2 基于C++的封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E7%89%88%E6%9C%AC1"><span class="toc-text">6.2.1 版本1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-1-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">6.2.1.1 客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-text">6.2.1.2 服务器端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-%E7%89%88%E6%9C%AC2"><span class="toc-text">6.2.2 版本2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-1-%E9%80%9A%E4%BF%A1%E7%B1%BB"><span class="toc-text">6.2.2.1 通信类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B1%BB"><span class="toc-text">6.2.2.2 服务器类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-text">6.3 测试代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">6.3.1 客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-text">6.3.2 服务器端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-self"><span class="toc-text">6.4 测试代码(self)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-text">6.4.1 服务器端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-2-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">6.4.2 客户端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-IO%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%EF%BC%88%E5%A4%8D%E7%94%A8%EF%BC%89%E4%B9%8Bselect"><span class="toc-text">7. IO多路转接（复用）之select</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-IO%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5-%E5%A4%8D%E7%94%A8"><span class="toc-text">7.1 IO多路转接(复用)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-select"><span class="toc-text">7.2  select</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-text">7.2.1 函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-%E7%BB%86%E8%8A%82%E6%8F%8F%E8%BF%B0"><span class="toc-text">7.2.2 细节描述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86"><span class="toc-text">7.3  并发处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">7.3.1 处理流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-%E9%80%9A%E4%BF%A1%E4%BB%A3%E7%A0%81"><span class="toc-text">7.3.2 通信代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-IO%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%EF%BC%88%E5%A4%8D%E7%94%A8%EF%BC%89%E4%B9%8Bpoll"><span class="toc-text">8. IO多路转接（复用）之poll</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-poll%E5%87%BD%E6%95%B0"><span class="toc-text">8.1 poll函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-text">8.2 测试代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-IO%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%EF%BC%88%E5%A4%8D%E7%94%A8%EF%BC%89%E4%B9%8Bepoll"><span class="toc-text">9. IO多路转接（复用）之epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">9.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">9.2 操作函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-epoll%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">9.3 epoll的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-1-%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-text">9.3.1 操作步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-2-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">9.3.2 示例代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-epoll%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">9.4 epoll的工作模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-1-%E6%B0%B4%E5%B9%B3%E6%A8%A1%E5%BC%8F"><span class="toc-text">9.4.1 水平模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-2-%E8%BE%B9%E6%B2%BF%E6%A8%A1%E5%BC%8F"><span class="toc-text">9.4.2 边沿模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2-1-ET%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-text">9.4.2.1 ET模式的设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2-2-%E8%AE%BE%E7%BD%AE%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">9.4.2.2 设置非阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2-3-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">9.4.2.3 示例代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%9F%BA%E4%BA%8EUDP%E7%9A%84%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1"><span class="toc-text">10. 基于UDP的套接字通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">10.1 通信流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-1-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-text">10.1.1 服务器端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-2-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">10.1.2 客户端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E9%80%9A%E4%BF%A1%E5%87%BD%E6%95%B0"><span class="toc-text">10.2 通信函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E9%80%9A%E4%BF%A1%E4%BB%A3%E7%A0%81"><span class="toc-text">10.3 通信代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-1-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-text">10.3.1 服务器端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-2-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">10.3.2 客户端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-UDP%E7%89%B9%E6%80%A7%E4%B9%8B%E5%B9%BF%E6%92%AD"><span class="toc-text">11. UDP特性之广播</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E5%B9%BF%E6%92%AD%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">11.1 广播的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E8%AE%BE%E7%BD%AE%E5%B9%BF%E6%92%AD%E5%B1%9E%E6%80%A7"><span class="toc-text">11.2 设置广播属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E5%B9%BF%E6%92%AD%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">11.3 广播通信流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-%E9%80%9A%E4%BF%A1%E4%BB%A3%E7%A0%81"><span class="toc-text">11.4 通信代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-UDP%E7%89%B9%E6%80%A7%E4%B9%8B%E7%BB%84%E6%92%AD%EF%BC%88%E5%A4%9A%E6%92%AD%EF%BC%89"><span class="toc-text">12. UDP特性之组播（多播）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E7%BB%84%E6%92%AD%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">12.1 组播的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E8%AE%BE%E7%BD%AE%E7%BB%84%E6%92%AD%E5%B1%9E%E6%80%A7"><span class="toc-text">12.2 设置组播属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-1-%E5%8F%91%E9%80%81%E7%AB%AF"><span class="toc-text">12.2.1 发送端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-2-%E6%8E%A5%E6%94%B6%E7%AB%AF"><span class="toc-text">12.2.2 接收端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-%E7%BB%84%E6%92%AD%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">12.3 组播通信流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-1-%E5%8F%91%E9%80%81%E7%AB%AF"><span class="toc-text">12.3.1 发送端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-2-%E6%8E%A5%E6%94%B6%E7%AB%AF"><span class="toc-text">12.3.2 接收端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-%E9%80%9A%E4%BF%A1%E4%BB%A3%E7%A0%81"><span class="toc-text">12.4 通信代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-1-%E5%8F%91%E9%80%81%E7%AB%AF"><span class="toc-text">12.4.1 发送端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-2-%E6%8E%A5%E6%94%B6%E7%AB%AF"><span class="toc-text">12.4.2 接收端</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/05/03/ONVIF/" title="ONVIF"><img src="/pic/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ONVIF"/></a><div class="content"><a class="title" href="/2024/05/03/ONVIF/" title="ONVIF">ONVIF</a><time datetime="2024-05-03T15:59:37.000Z" title="发表于 2024-05-03 23:59:37">2024-05-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/01/Python/" title="Python"><img src="/pic/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python"/></a><div class="content"><a class="title" href="/2024/05/01/Python/" title="Python">Python</a><time datetime="2024-05-01T13:07:51.000Z" title="发表于 2024-05-01 21:07:51">2024-05-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/18/GB28181/" title="GB28181"><img src="/pic/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GB28181"/></a><div class="content"><a class="title" href="/2024/04/18/GB28181/" title="GB28181">GB28181</a><time datetime="2024-04-18T07:38:27.000Z" title="发表于 2024-04-18 15:38:27">2024-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/18/RTMP/" title="RTMP"><img src="/pic/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RTMP"/></a><div class="content"><a class="title" href="/2024/03/18/RTMP/" title="RTMP">RTMP</a><time datetime="2024-03-18T04:14:50.000Z" title="发表于 2024-03-18 12:14:50">2024-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/05/RTSP1/" title="RTSP"><img src="/pic/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RTSP"/></a><div class="content"><a class="title" href="/2023/12/05/RTSP1/" title="RTSP">RTSP</a><time datetime="2023-12-05T13:58:26.000Z" title="发表于 2023-12-05 21:58:26">2023-12-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By NineTSe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>