<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>锁,InnoDB引擎</title>
      <link href="/2023/10/22/%E9%94%81-InnoDB%E5%BC%95%E6%93%8E/"/>
      <url>/2023/10/22/%E9%94%81-InnoDB%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>回溯贪心算法篇</title>
      <link href="/2023/10/22/%E5%9B%9E%E6%BA%AF%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AF%87/"/>
      <url>/2023/10/22/%E5%9B%9E%E6%BA%AF%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>视图,存储过程,触发器</title>
      <link href="/2023/10/22/%E8%A7%86%E5%9B%BE-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>/2023/10/22/%E8%A7%86%E5%9B%BE-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>存储引擎,索引,SQL优化</title>
      <link href="/2023/10/22/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-SQL%E4%BC%98%E5%8C%96/"/>
      <url>/2023/10/22/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-SQL%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树篇</title>
      <link href="/2023/10/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87/"/>
      <url>/2023/10/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tips</title>
      <link href="/2023/10/22/tips-1/"/>
      <url>/2023/10/22/tips-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基本数据结构篇</title>
      <link href="/2023/10/22/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/"/>
      <url>/2023/10/22/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JSON和程序发布</title>
      <link href="/2023/10/22/JSON%E5%92%8C%E7%A8%8B%E5%BA%8F%E5%8F%91%E5%B8%83/"/>
      <url>/2023/10/22/JSON%E5%92%8C%E7%A8%8B%E5%BA%8F%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程和套接字通信</title>
      <link href="/2023/10/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/"/>
      <url>/2023/10/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>事件</title>
      <link href="/2023/10/22/%E4%BA%8B%E4%BB%B6/"/>
      <url>/2023/10/22/%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>控件</title>
      <link href="/2023/10/22/%E6%8E%A7%E4%BB%B6/"/>
      <url>/2023/10/22/%E6%8E%A7%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>窗口</title>
      <link href="/2023/10/22/%E7%AA%97%E5%8F%A3/"/>
      <url>/2023/10/22/%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础窗口类"><a href="#1-基础窗口类" class="headerlink" title="1. 基础窗口类"></a>1. 基础窗口类</h1><h2 id="1-1-QWidget"><a href="#1-1-QWidget" class="headerlink" title="1.1 QWidget"></a>1.1 QWidget</h2><blockquote><p>QWidget类是所有窗口类的父类(控件类是也属于窗口类), 并且QWidget类的父类的QObject,<br>也就意味着<code>所有的窗口类对象只要指定了父对象, 都可以实现内存资源的自动回收。</code><br>关于这个窗口类的属性介绍, 参考容器控件之QWidget。</p></blockquote><p><img src="/img/9.53.png" alt="在这里插入图片描述"></p><h3 id="1-1-1-设置父对象"><a href="#1-1-1-设置父对象" class="headerlink" title="1.1.1 设置父对象"></a>1.1.1 设置父对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QWidget::<span class="built_in">QWidget</span>(QWidget *parent = <span class="literal">nullptr</span>, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 给当前窗口设置父对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setParent</span><span class="params">(QWidget *parent)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setParent</span><span class="params">(QWidget *parent, Qt::WindowFlags f)</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的父对象, 没有父对象返回 nullptr</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QWidget::parentWidget</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-2-窗口位置"><a href="#1-1-2-窗口位置" class="headerlink" title="1.1.2 窗口位置"></a>1.1.2 窗口位置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------- 窗口位置 -------------</span></span><br><span class="line"><span class="comment">// 得到相对于当前窗口父窗口的几何信息, 边框也被计算在内</span></span><br><span class="line"><span class="function">QRect <span class="title">QWidget::frameGeometry</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到相对于当前窗口父窗口的几何信息, 不包括边框</span></span><br><span class="line"><span class="function"><span class="type">const</span> QRect &amp;<span class="title">geometry</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口的几何信息(位置和尺寸信息), 不包括边框</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGeometry</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGeometry</span><span class="params">(<span class="type">const</span> QRect &amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 移动窗口, 重新设置窗口的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">const</span> QPoint &amp;)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>窗口位置设定和位置获取的测试代码如下:</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前窗口的位置信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_positionBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QRect rect = <span class="keyword">this</span>-&gt;<span class="built_in">frameGeometry</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;左上角: &quot;</span> &lt;&lt; rect.<span class="built_in">topLeft</span>()</span><br><span class="line">             &lt;&lt; <span class="string">&quot;右上角: &quot;</span> &lt;&lt; rect.<span class="built_in">topRight</span>()</span><br><span class="line">             &lt;&lt; <span class="string">&quot;左下角: &quot;</span> &lt;&lt; rect.<span class="built_in">bottomLeft</span>()</span><br><span class="line">             &lt;&lt; <span class="string">&quot;右下角: &quot;</span> &lt;&lt; rect.<span class="built_in">bottomRight</span>()</span><br><span class="line">             &lt;&lt; <span class="string">&quot;宽度: &quot;</span> &lt;&lt; rect.<span class="built_in">width</span>()</span><br><span class="line">             &lt;&lt; <span class="string">&quot;高度: &quot;</span> &lt;&lt; rect.<span class="built_in">height</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新设置当前窗口的位置以及宽度, 高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_geometryBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">100</span> + <span class="built_in">rand</span>() % <span class="number">500</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">100</span> + <span class="built_in">rand</span>() % <span class="number">500</span>;</span><br><span class="line">    <span class="type">int</span> width = <span class="keyword">this</span>-&gt;<span class="built_in">width</span>() + <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> height = <span class="keyword">this</span>-&gt;<span class="built_in">height</span>() + <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">setGeometry</span>(x, y, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 move() 方法移动窗口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_moveBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QRect rect = <span class="keyword">this</span>-&gt;<span class="built_in">frameGeometry</span>();</span><br><span class="line">    <span class="built_in">move</span>(rect.<span class="built_in">topLeft</span>() + <span class="built_in">QPoint</span>(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-3-窗口尺寸"><a href="#1-1-3-窗口尺寸" class="headerlink" title="1.1.3 窗口尺寸"></a>1.1.3 窗口尺寸</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------- 窗口尺寸 -------------</span></span><br><span class="line"><span class="comment">// 获取当前窗口的尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">// 重新设置窗口的尺寸信息</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">const</span> QSize &amp;)</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最大尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">maximumSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最小尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">minimumSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口固定的尺寸信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedSize</span><span class="params">(<span class="type">const</span> QSize &amp;s)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedSize</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口的最大尺寸信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumSize</span><span class="params">(<span class="type">const</span> QSize &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumSize</span><span class="params">(<span class="type">int</span> maxw, <span class="type">int</span> maxh)</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口的最小尺寸信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumSize</span><span class="params">(<span class="type">const</span> QSize &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumSize</span><span class="params">(<span class="type">int</span> minw, <span class="type">int</span> minh)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前窗口的高度    </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最小高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumHeight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最大高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximumHeight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置固定的高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedHeight</span><span class="params">(<span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最大高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumHeight</span><span class="params">(<span class="type">int</span> maxh)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最小高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumHeight</span><span class="params">(<span class="type">int</span> minh)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前窗口的宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">width</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最小宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumWidth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最大宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximumWidth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置固定宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedWidth</span><span class="params">(<span class="type">int</span> w)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最大宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumWidth</span><span class="params">(<span class="type">int</span> maxw)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最小宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumWidth</span><span class="params">(<span class="type">int</span> minw)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-4-窗口标题和图标"><a href="#1-1-4-窗口标题和图标" class="headerlink" title="1.1.4 窗口标题和图标"></a>1.1.4 窗口标题和图标</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------- 窗口图标 -------------</span></span><br><span class="line"><span class="comment">// 得到当前窗口的图标</span></span><br><span class="line"><span class="function">QIcon <span class="title">windowIcon</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 构造图标对象, 参数为图片的路径</span></span><br><span class="line">QIcon::<span class="built_in">QIcon</span>(<span class="type">const</span> QString &amp;fileName);</span><br><span class="line"><span class="comment">// 设置当前窗口的图标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowIcon</span><span class="params">(<span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------- 窗口标题 -------------</span></span><br><span class="line"><span class="comment">// 得到当前窗口的标题</span></span><br><span class="line"><span class="function">QString <span class="title">windowTitle</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口的标题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowTitle</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-5-信号"><a href="#1-1-5-信号" class="headerlink" title="1.1.5 信号"></a>1.1.5 信号</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QWidget::setContextMenuPolicy(Qt::ContextMenuPolicy policy);</span></span><br><span class="line"><span class="comment">// 窗口的右键菜单策略 contextMenuPolicy() 参数设置为 Qt::CustomContextMenu, 按下鼠标右键发射该信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QWidget::customContextMenuRequested</span><span class="params">(<span class="type">const</span> QPoint &amp;pos)</span></span>;</span><br><span class="line"><span class="comment">// 窗口图标发生变化, 发射此信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QWidget::windowIconChanged</span><span class="params">(<span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"><span class="comment">// 窗口标题发生变化, 发射此信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QWidget::windowTitleChanged</span><span class="params">(<span class="type">const</span> QString &amp;title)</span></span>;</span><br></pre></td></tr></table></figure><p>基于窗口策略实现右键菜单具体操作参考 Qt右键菜单的添加和使用(本章第六部分)</p><hr><h3 id="1-1-6-槽函数"><a href="#1-1-6-槽函数" class="headerlink" title="1.1.6 槽函数"></a>1.1.6 槽函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------- 窗口显示 -------------</span></span><br><span class="line"><span class="comment">// 关闭当前窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">bool</span> <span class="title">QWidget::close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 隐藏当前窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::hide</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 显示当前创建以及其子窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 全屏显示当前窗口, 只对windows有效</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::showFullScreen</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 窗口最大化显示, 只对windows有效</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::showMaximized</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 窗口最小化显示, 只对windows有效</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::showMinimized</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 将窗口回复为最大化/最小化之前的状态, 只对windows有效</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::showNormal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------- 窗口状态 -------------</span></span><br><span class="line"><span class="comment">// 判断窗口是否可用</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QWidget::isEnabled</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 非槽函数</span></span><br><span class="line"><span class="comment">// 设置窗口是否可用, 不可用窗口无法接收和处理窗口事件</span></span><br><span class="line"><span class="comment">// 参数true-&gt;可用, false-&gt;不可用</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::setEnabled</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"><span class="comment">// 设置窗口是否可用, 不可用窗口无法接收和处理窗口事件</span></span><br><span class="line"><span class="comment">// 参数true-&gt;不可用, false-&gt;可用</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::setDisabled</span><span class="params">(<span class="type">bool</span> disable)</span></span>;</span><br><span class="line"><span class="comment">// 设置窗口是否可见, 参数为true-&gt;可见, false-&gt;不可见</span></span><br><span class="line">[slot] <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::setVisible</span><span class="params">(<span class="type">bool</span> visible)</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="1-2-QDialog"><a href="#1-2-QDialog" class="headerlink" title="1.2 QDialog"></a>1.2 QDialog</h2><h3 id="1-2-1-常用API"><a href="#1-2-1-常用API" class="headerlink" title="1.2.1 常用API"></a>1.2.1 常用API</h3><blockquote><p>对话框类是<code>QWidget</code>类的子类, 处理继承自父类的属性之外, 还有一些自己所特有的属性</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QDialog::<span class="built_in">QDialog</span>(QWidget *parent = <span class="literal">nullptr</span>, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模态显示窗口</span></span><br><span class="line">[<span class="keyword">virtual</span> slot] <span class="function"><span class="type">int</span> <span class="title">QDialog::exec</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 隐藏模态窗口, 并且解除模态窗口的阻塞, 将 exec() 的返回值设置为 QDialog::Accepted</span></span><br><span class="line">[<span class="keyword">virtual</span> slot] <span class="function"><span class="type">void</span> <span class="title">QDialog::accept</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 隐藏模态窗口, 并且解除模态窗口的阻塞, 将 exec() 的返回值设置为 QDialog::Rejected</span></span><br><span class="line">[<span class="keyword">virtual</span> slot] <span class="function"><span class="type">void</span> <span class="title">QDialog::reject</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 关闭对话框并将其结果代码设置为r。finished()信号将发出r;</span></span><br><span class="line"><span class="comment">// 如果r是QDialog::Accepted 或 QDialog::Rejected，则还将分别发出accept()或Rejected()信号。</span></span><br><span class="line">[<span class="keyword">virtual</span> slot] <span class="function"><span class="type">void</span> <span class="title">QDialog::done</span><span class="params">(<span class="type">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QDialog::accepted</span><span class="params">()</span></span>;</span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QDialog::rejected</span><span class="params">()</span></span>;</span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QDialog::finished</span><span class="params">(<span class="type">int</span> result)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-2-2-常用使用方法"><a href="#1-2-2-常用使用方法" class="headerlink" title="1.2.2 常用使用方法"></a>1.2.2 常用使用方法</h3><blockquote><p>场景介绍:</p><ol><li>有两个窗口, 主窗口和一个对话框子窗口</li><li>对话框窗口先显示, 根据用户操作选择是否显示主窗口</li></ol></blockquote><ul><li>关于对话框窗口类的操作</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对话框窗口中三个普通按钮按下之后对应的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDialog::on_acceptBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">accept</span>();  <span class="comment">// exec()函数返回值为QDialog::Accepted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDialog::on_rejectBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">reject</span>();  <span class="comment">// exec()函数返回值为QDialog::Rejected</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDialog::on_donBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// exec()函数返回值为 done() 的参数, 并根据参数发射出对应的信号</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">done</span>(<span class="number">666</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据用户针对对话框窗口的按钮操作, 进行相应的逻辑处理。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对话框对象</span></span><br><span class="line">MyDialog dlg;    </span><br><span class="line"><span class="type">int</span> ret = dlg.<span class="built_in">exec</span>();</span><br><span class="line"><span class="keyword">if</span>(ret == QDialog::Accepted)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;accept button clicked...&quot;</span>;</span><br><span class="line">    <span class="comment">// 显示主窗口</span></span><br><span class="line">    MainWindow* w = <span class="keyword">new</span> MainWindow;</span><br><span class="line">    w-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ret == QDialog::Rejected)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;reject button clicked...&quot;</span>;</span><br><span class="line">    <span class="comment">// 不显示主窗口</span></span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ret == 666</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;done button clicked...&quot;</span>;</span><br><span class="line">    <span class="comment">// 根据需求进行逻辑处理</span></span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-3-QDialog的子类"><a href="#1-3-QDialog的子类" class="headerlink" title="1.3 QDialog的子类"></a>1.3 QDialog的子类</h2><h3 id="1-3-1-QMessageBox"><a href="#1-3-1-QMessageBox" class="headerlink" title="1.3.1 QMessageBox"></a>1.3.1 QMessageBox</h3><blockquote><p><code>QMessageBox</code> 对话框类是 <code>QDialog</code> 类的子类<br>通过这个类可显示一些简单的提示框,用于展示警告、错误、问题等信息。<br>关于这个类只需掌握一些静态方法即可。</p></blockquote><h4 id="1-3-1-1-API-静态函数"><a href="#1-3-1-1-API-静态函数" class="headerlink" title="1.3.1.1 API - 静态函数"></a>1.3.1.1 API - 静态函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示一个模态对话框, 将参数 text 的信息展示到窗口中</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QMessageBox::about</span><span class="params">(QWidget *parent, <span class="type">const</span> QString &amp;title, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">- parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">- title: 对话框窗口的标题</span></span><br><span class="line"><span class="comment">- text: 对话框窗口中显示的提示信息</span></span><br><span class="line"><span class="comment">- buttons: 对话框窗口中显示的按钮(一个或多个)</span></span><br><span class="line"><span class="comment">- defaultButton</span></span><br><span class="line"><span class="comment">    1. defaultButton指定按下Enter键时使用的按钮。</span></span><br><span class="line"><span class="comment">    2. defaultButton必须引用在参数 buttons 中给定的按钮。</span></span><br><span class="line"><span class="comment">    3. 如果defaultButton是QMessageBox::NoButton, QMessageBox会自动选择一个合适的默认值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 显示一个信息模态对话框</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMessageBox::StandardButton <span class="title">QMessageBox::information</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">           QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> QString &amp;text, </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButtons buttons = Ok,</span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButton defaultButton = NoButton)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示一个错误模态对话框</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMessageBox::StandardButton <span class="title">QMessageBox::critical</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">           QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> QString &amp;text, </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButtons buttons = Ok,</span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButton defaultButton = NoButton)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示一个问题模态对话框</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMessageBox::StandardButton <span class="title">QMessageBox::question</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">           QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> QString &amp;text, </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButtons buttons = StandardButtons(Yes | No), </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButton defaultButton = NoButton)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示一个警告模态对话框</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMessageBox::StandardButton <span class="title">QMessageBox::warning</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">           QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> QString &amp;text, </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButtons buttons = Ok,</span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButton defaultButton = NoButton)</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-3-1-2-测试代码"><a href="#1-3-1-2-测试代码" class="headerlink" title="1.3.1.2 测试代码"></a>1.3.1.2 测试代码</h4><ul><li>测试代码片段</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_msgbox_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QMessageBox::<span class="built_in">about</span>(<span class="keyword">this</span>, <span class="string">&quot;about&quot;</span>,  <span class="string">&quot;这是一个简单的消息提示框!!!&quot;</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">critical</span>(<span class="keyword">this</span>, <span class="string">&quot;critical&quot;</span>, <span class="string">&quot;这是一个错误对话框-critical...&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = QMessageBox::<span class="built_in">question</span>(<span class="keyword">this</span>, <span class="string">&quot;question&quot;</span>, </span><br><span class="line">             <span class="string">&quot;你要保存修改的文件内容吗???&quot;</span>,                                 </span><br><span class="line">              QMessageBox::Save|QMessageBox::Cancel, </span><br><span class="line">              QMessageBox::Cancel);</span><br><span class="line">    <span class="keyword">if</span>(ret == QMessageBox::Save)</span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;information&quot;</span>, <span class="string">&quot;恭喜你保存成功了, o(*￣︶￣*)o!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ret == QMessageBox::Cancel)</span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="string">&quot;warning&quot;</span>, <span class="string">&quot;你放弃了保存, ┭┮﹏┭┮ !!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>得到的对话框窗口效果如下图:<br><img src="/img/9.54.png" alt="在这里插入图片描述"></li></ul><hr><h3 id="1-3-2-QFileDialog"><a href="#1-3-2-QFileDialog" class="headerlink" title="1.3.2 QFileDialog"></a>1.3.2 QFileDialog</h3><blockquote><p><code>QFileDialog</code> 对话框类是 <code>QDialog</code> 类的子类<br>通过这个类可以选择要打开&#x2F;保存的文件或者目录。<br>关于这个类只需掌握一些静态方法的使用即可。</p></blockquote><h4 id="1-3-2-1-API-静态函数"><a href="#1-3-2-1-API-静态函数" class="headerlink" title="1.3.2.1 API - 静态函数"></a>1.3.2.1 API - 静态函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通用参数:</span></span><br><span class="line"><span class="comment">  - parent: 当前对话框窗口的父对象也就是父窗口</span></span><br><span class="line"><span class="comment">  - caption: 当前对话框窗口的标题</span></span><br><span class="line"><span class="comment">  - dir: 当前对话框窗口打开的默认目录</span></span><br><span class="line"><span class="comment">  - options: 当前对话框窗口的一些可选项,枚举类型, 一般不需要进行设置, 使用默认值即可</span></span><br><span class="line"><span class="comment">  - filter: 过滤器, 在对话框中只显示满足条件的文件, 可以指定多个过滤器, 使用 ;; 分隔</span></span><br><span class="line"><span class="comment">    - 样式举例: </span></span><br><span class="line"><span class="comment">- Images (*.png *.jpg)</span></span><br><span class="line"><span class="comment">- Images (*.png *.jpg);;Text files (*.txt)</span></span><br><span class="line"><span class="comment">  - selectedFilter: 如果指定了多个过滤器, 通过该参数指定默认使用哪一个, 不指定默认使用第一个过滤器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 打开一个目录, 得到这个目录的绝对路径</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QFileDialog::getExistingDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                  QWidget *parent = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;caption = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;dir = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  QFileDialog::Options options = ShowDirsOnly)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开一个文件, 得到这个文件的绝对路径</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QFileDialog::getOpenFileName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">              QWidget *parent = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> QString &amp;caption = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;dir = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;filter = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  QString *selectedFilter = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  QFileDialog::Options options = Options())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开多个文件, 得到这多个文件的绝对路径</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QStringList <span class="title">QFileDialog::getOpenFileNames</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">              QWidget *parent = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;caption = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;dir = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;filter = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  QString *selectedFilter = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  QFileDialog::Options options = Options())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开一个目录, 使用这个目录来保存指定的文件</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QFileDialog::getSaveFileName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      QWidget *parent = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;caption = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;dir = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;filter = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  QString *selectedFilter = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  QFileDialog::Options options = Options())</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-3-2-2-测试代码"><a href="#1-3-2-2-测试代码" class="headerlink" title="1.3.2.2 测试代码"></a>1.3.2.2 测试代码</h4><ul><li>打开一个已存在的本地目录</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_filedlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString dirName = QFileDialog::<span class="built_in">getExistingDirectory</span>(<span class="keyword">this</span>, <span class="string">&quot;打开目录&quot;</span>, <span class="string">&quot;e:\\temp&quot;</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;打开目录&quot;</span>, <span class="string">&quot;您选择的目录是: &quot;</span> + dirName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>对话框效果如下:<br><img src="/img/9.55.png" alt="在这里插入图片描述"></p></li><li><p>打开一个本地文件</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_filedlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QString <span class="title">arg</span><span class="params">(<span class="string">&quot;Text files (*.txt)&quot;</span>)</span></span>;</span><br><span class="line">    QString fileName = QFileDialog::<span class="built_in">getOpenFileName</span>(</span><br><span class="line">              <span class="keyword">this</span>, <span class="string">&quot;Open File&quot;</span>, <span class="string">&quot;e:\\temp&quot;</span>,</span><br><span class="line">              <span class="string">&quot;Images (*.png *.jpg);;Text files (*.txt)&quot;</span>, &amp;arg);</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;打开文件&quot;</span>, <span class="string">&quot;您选择的文件是: &quot;</span> + fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对话框效果如下:</li></ul><p><img src="/img/9.56.png" alt="在这里插入图片描述"></p><ul><li>打开多个本地文件</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_filedlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStringList fileNames = QFileDialog::<span class="built_in">getOpenFileNames</span>(</span><br><span class="line">              <span class="keyword">this</span>, <span class="string">&quot;Open File&quot;</span>, <span class="string">&quot;e:\\temp&quot;</span>,</span><br><span class="line">              <span class="string">&quot;Images (*.png *.jpg);;Text files (*.txt)&quot;</span>);</span><br><span class="line">    QString names;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;fileNames.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        names += fileNames.<span class="built_in">at</span>(i) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;打开文件(s)&quot;</span>, <span class="string">&quot;您选择的文件是: &quot;</span> + names);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对话框效果如下:</li></ul><p><img src="/img/9.57.png" alt="在这里插入图片描述"></p><ul><li>打开保存文件对话框</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_filedlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString fileName = QFileDialog::<span class="built_in">getSaveFileName</span>(<span class="keyword">this</span>, <span class="string">&quot;保存文件&quot;</span>, <span class="string">&quot;e:\\temp&quot;</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;保存文件&quot;</span>, <span class="string">&quot;您指定的保存数据的文件是: &quot;</span> + fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对话框效果如下:</p><p><img src="/img/9.58.png" alt="在这里插入图片描述"></p><hr><h3 id="1-3-3-QFontDialog"><a href="#1-3-3-QFontDialog" class="headerlink" title="1.3.3 QFontDialog"></a>1.3.3 QFontDialog</h3><blockquote><p><code>QFontDialog</code>类是<code>QDialog</code>的子类<br>通过这个类我们可以得到一个进行字体属性设置的对话框窗口<br>和前边介绍的对话框类一样,只需调用这个类的静态成员函数就可以得到想要的窗口了。</p></blockquote><h4 id="1-3-3-1-QFont-字体类"><a href="#1-3-3-1-QFont-字体类" class="headerlink" title="1.3.3.1 QFont 字体类"></a>1.3.3.1 QFont 字体类</h4><blockquote><p>关于字体的属性信息, 在QT框架中被封装到了一个叫<code>QFont</code>的类中</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">  QFont::<span class="built_in">QFont</span>();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  参数:</span></span><br><span class="line"><span class="comment">    - family: 本地字库中的字体名, 通过 office 等文件软件可以查看</span></span><br><span class="line"><span class="comment">    - pointSize: 字体的字号</span></span><br><span class="line"><span class="comment">    - weight: 字体的粗细, 有效范围为 0 ~ 99</span></span><br><span class="line"><span class="comment">    - italic: 字体是否倾斜显示, 默认不倾斜</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  QFont::<span class="built_in">QFont</span>(<span class="type">const</span> QString &amp;family, <span class="type">int</span> pointSize = <span class="number">-1</span>, <span class="type">int</span> weight = <span class="number">-1</span>, <span class="type">bool</span> italic = <span class="literal">false</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置字体</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setFamily</span><span class="params">(<span class="type">const</span> QString &amp;family)</span></span>;</span><br><span class="line">  <span class="comment">// 根据字号设置字体大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setPointSize</span><span class="params">(<span class="type">int</span> pointSize)</span></span>;</span><br><span class="line">  <span class="comment">// 根据像素设置字体大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setPixelSize</span><span class="params">(<span class="type">int</span> pixelSize)</span></span>;</span><br><span class="line">  <span class="comment">// 设置字体的粗细程度, 有效范围: 0 ~ 99</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setWeight</span><span class="params">(<span class="type">int</span> weight)</span></span>;</span><br><span class="line">  <span class="comment">// 设置字体是否加粗显示</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setBold</span><span class="params">(<span class="type">bool</span> enable)</span></span>;</span><br><span class="line">  <span class="comment">// 设置字体是否要倾斜显示</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setItalic</span><span class="params">(<span class="type">bool</span> enable)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取字体相关属性(一般规律: 去掉设置函数的 set 就是获取相关属性对应的函数名)</span></span><br><span class="line">  <span class="function">QString <span class="title">QFont::family</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">QFont::italic</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">QFont::pixelSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">QFont::pointSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">QFont::bold</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">QFont::weight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>如果一个QFont对象被创建, 并且进行了初始化, 我们可以将这个属性设置给某个窗口, 或者设置给当前应用程序对象。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QWidget 类</span></span><br><span class="line"><span class="comment">// 得到当前窗口使用的字体</span></span><br><span class="line"><span class="function"><span class="type">const</span> QWidget::QFont&amp; <span class="title">font</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给当前窗口设置字体, 只对当前窗口类生效</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFont</span><span class="params">(<span class="type">const</span> QFont &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QApplication 类</span></span><br><span class="line"><span class="comment">// 得到当前应用程序对象使用的字体</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QFont <span class="title">QApplication::font</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 给当前应用程序对象设置字体, 作用于当前应用程序的所有窗口</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QApplication::setFont</span><span class="params">(<span class="type">const</span> QFont &amp;font, <span class="type">const</span> <span class="type">char</span> *className = <span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-3-3-2-QFontDialog类的静态API"><a href="#1-3-3-2-QFontDialog类的静态API" class="headerlink" title="1.3.3.2 QFontDialog类的静态API"></a>1.3.3.2 QFontDialog类的静态API</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否获得了有效字体信息, 指定一个布尔类型变量地址</span></span><br><span class="line"><span class="comment">  - initial: 字体对话框中默认选中并显示该字体信息, 用于对话框的初始化</span></span><br><span class="line"><span class="comment">  - parent: 字体对话框窗口的父对象</span></span><br><span class="line"><span class="comment">  - title: 字体对话框的窗口标题</span></span><br><span class="line"><span class="comment">  - options: 字体对话框选项, 使用默认属性即可, 一般不设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  [<span class="type">static</span>] <span class="function">QFont <span class="title">QFontDialog::getFont</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">bool</span> *ok, <span class="type">const</span> QFont &amp;initial, </span></span></span><br><span class="line"><span class="params"><span class="function">QWidget *parent = <span class="literal">nullptr</span>, <span class="type">const</span> QString &amp;title = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">QFontDialog::FontDialogOptions options = FontDialogOptions())</span></span>;</span><br><span class="line">  </span><br><span class="line">  [<span class="type">static</span>] <span class="function">QFont <span class="title">QFontDialog::getFont</span><span class="params">(<span class="type">bool</span> *ok, QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-3-3-3-测试代码"><a href="#1-3-3-3-测试代码" class="headerlink" title="1.3.3.3 测试代码"></a>1.3.3.3 测试代码</h4><blockquote><p>通过字体对话框选择字体, 并将选择的字体设置给当前窗口</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_fontdlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    <span class="comment">// 方式1</span></span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">    QFont ft = QFontDialog::<span class="built_in">getFont</span>(</span><br><span class="line">                &amp;ok, <span class="built_in">QFont</span>(<span class="string">&quot;微软雅黑&quot;</span>, <span class="number">12</span>, QFont::Bold), <span class="keyword">this</span>, <span class="string">&quot;选择字体&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;ok value is: &quot;</span> &lt;&lt; ok;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 方式2</span></span><br><span class="line">    QFont ft = QFontDialog::<span class="built_in">getFont</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 将选择的字体设置给当前窗口对象</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFont</span>(ft);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字体对话框效果展示:<br><img src="/img/9.59.png" alt="在这里插入图片描述"></p><hr><h3 id="1-3-4-QColorDialog"><a href="#1-3-4-QColorDialog" class="headerlink" title="1.3.4 QColorDialog"></a>1.3.4 QColorDialog</h3><blockquote><p><code>QColorDialog</code>类是<code>QDialog</code>的子类<br> 通过这个类我们可以得到一个选择颜色的对话框窗口<br> 和前边介绍的对话框类一样,只需调用这个类的静态成员函数就可以得到想要的窗口了。</p></blockquote><h4 id="1-3-4-1-颜色类-QColor"><a href="#1-3-4-1-颜色类-QColor" class="headerlink" title="1.3.4.1 颜色类 QColor"></a>1.3.4.1 颜色类 QColor</h4><blockquote><p>关于颜色的属性信息, 在QT框架中被封装到了一个叫<code>QColor</code>的类中<br>各种颜色都是基于红, 绿, 蓝这三种颜色调配而成的, 并且颜色还可以进行透明度设置, 默认是不透明的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QColor::<span class="built_in">QColor</span>(Qt::GlobalColor color);</span><br><span class="line">QColor::<span class="built_in">QColor</span>(<span class="type">int</span> r, <span class="type">int</span> g, <span class="type">int</span> b, <span class="type">int</span> a = ...);</span><br><span class="line">QColor::<span class="built_in">QColor</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数设置 red, green, blue, alpha, 取值范围都是 0-255</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setRed</span><span class="params">(<span class="type">int</span> red)</span></span>;<span class="comment">// 红色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setGreen</span><span class="params">(<span class="type">int</span> green)</span></span>;<span class="comment">// 绿色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setBlue</span><span class="params">(<span class="type">int</span> blue)</span></span>;<span class="comment">// 蓝色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setAlpha</span><span class="params">(<span class="type">int</span> alpha)</span></span>;<span class="comment">// 透明度, 默认不透明(255)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setRgb</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> g, <span class="type">int</span> b, <span class="type">int</span> a = <span class="number">255</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QColor::red</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QColor::green</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QColor::blue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QColor::alpha</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::getRgb</span><span class="params">(<span class="type">int</span> *r, <span class="type">int</span> *g, <span class="type">int</span> *b, <span class="type">int</span> *a = <span class="literal">nullptr</span>)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-3-4-2-静态API函数"><a href="#1-3-4-2-静态API函数" class="headerlink" title="1.3.4.2 静态API函数"></a>1.3.4.2 静态API函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 弹出颜色选择对话框, 并返回选中的颜色信息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">    - initial: 对话框中默认选中的颜色, 用于窗口初始化</span></span><br><span class="line"><span class="comment">    - parent: 给对话框窗口指定父对象</span></span><br><span class="line"><span class="comment">    - title: 对话框窗口的标题</span></span><br><span class="line"><span class="comment">    - options: 颜色对话框窗口选项, 使用默认属性即可, 一般不需要设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  [<span class="type">static</span>] <span class="function">QColor <span class="title">QColorDialog::getColor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> QColor &amp;initial = Qt::white, </span></span></span><br><span class="line"><span class="params"><span class="function">QWidget *parent = <span class="literal">nullptr</span>, <span class="type">const</span> QString &amp;title = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">QColorDialog::ColorDialogOptions options = ColorDialogOptions())</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-3-4-3-测试代码"><a href="#1-3-4-3-测试代码" class="headerlink" title="1.3.4.3 测试代码"></a>1.3.4.3 测试代码</h4><blockquote><p>场景描述:<br>    1. 在窗口上放一个标签控件<br>    2. 通过颜色对话框选择一个颜色, 将选中的颜色显示到标签控件上<br>    3. 将选中的颜色的 RGBA 值分别显示出来</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_colordlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QColor color = QColorDialog::<span class="built_in">getColor</span>();</span><br><span class="line">    <span class="function">QBrush <span class="title">brush</span><span class="params">(color)</span></span>;</span><br><span class="line">    <span class="function">QRect <span class="title">rect</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, ui-&gt;color-&gt;width(), ui-&gt;color-&gt;height())</span></span>;</span><br><span class="line">    <span class="function">QPixmap <span class="title">pix</span><span class="params">(rect.width(), rect.height())</span></span>;</span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(&amp;pix)</span></span>;</span><br><span class="line">    p.<span class="built_in">fillRect</span>(rect, brush);</span><br><span class="line">    ui-&gt;color-&gt;<span class="built_in">setPixmap</span>(pix);</span><br><span class="line">    QString text = <span class="built_in">QString</span>(<span class="string">&quot;red: %1, green: %2, blue: %3, 透明度: %4&quot;</span>)</span><br><span class="line">            .<span class="built_in">arg</span>(color.<span class="built_in">red</span>()).<span class="built_in">arg</span>(color.<span class="built_in">green</span>()).<span class="built_in">arg</span>(color.<span class="built_in">blue</span>()).<span class="built_in">arg</span>(color.<span class="built_in">alpha</span>());</span><br><span class="line">    ui-&gt;colorlabel-&gt;<span class="built_in">setText</span>(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>颜色对话框窗口效果展示</p><p><img src="/img/9.60.png" alt="在这里插入图片描述"></p><p>测试代码效果展示<br><img src="/img/9.61.png" alt="在这里插入图片描述"></p><hr><h3 id="1-3-5-QInputDialog"><a href="#1-3-5-QInputDialog" class="headerlink" title="1.3.5 QInputDialog"></a>1.3.5 QInputDialog</h3><blockquote><p><code>QInputDialog</code>类是<code>QDialog</code>的子类, 通过这个类我们可以得到一个输入对话框窗口<br>根据实际需求我们可以在这个输入窗口中输入整形, 浮点型, 字符串类型的数据<br>并且还可以显示下拉菜单供使用者选择。<br>和前边介绍的对话框类一样, 只需调用这个类的静态成员函数就可以得到想要的窗口了。</p></blockquote><h4 id="1-3-5-1-API-静态函数"><a href="#1-3-5-1-API-静态函数" class="headerlink" title="1.3.5.1 API - 静态函数"></a>1.3.5.1 API - 静态函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到一个可以输入浮点数的对话框窗口, 返回对话框窗口中输入的浮点数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - value: 对话框窗口中显示的浮点值, 默认为 0</span></span><br><span class="line"><span class="comment">  - min: 对话框窗口支持显示的最小数值</span></span><br><span class="line"><span class="comment">  - max: 对话框窗口支持显示的最大数值</span></span><br><span class="line"><span class="comment">  - decimals: 浮点数的精度, 默认保留小数点以后1位</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">double</span> <span class="title">QInputDialog::getDouble</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;label, <span class="type">double</span> value = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> min = <span class="number">-2147483647</span>, <span class="type">double</span> max = <span class="number">2147483647</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> decimals = <span class="number">1</span>, <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个可以输入整形数的对话框窗口, 返回对话框窗口中输入的整形数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - value: 对话框窗口中显示的整形值, 默认为 0</span></span><br><span class="line"><span class="comment">  - min: 对话框窗口支持显示的最小数值</span></span><br><span class="line"><span class="comment">  - max: 对话框窗口支持显示的最大数值</span></span><br><span class="line"><span class="comment">  - step: 步长, 通过对话框提供的按钮调节数值每次增长/递减的量</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">int</span> <span class="title">QInputDialog::getInt</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;label, <span class="type">int</span> value = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> min = <span class="number">-2147483647</span>, <span class="type">int</span> max = <span class="number">2147483647</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> step = <span class="number">1</span>, <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个带下来菜单的对话框窗口, 返回选择的菜单项上边的文本信息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - items: 字符串列表, 用于初始化窗口中的下拉菜单, 每个字符串对应一个菜单项</span></span><br><span class="line"><span class="comment">  - current: 通过菜单项的索引指定显示下拉菜单中的哪个菜单项, 默认显示第一个(编号为0)</span></span><br><span class="line"><span class="comment">  - editable: 设置菜单项上的文本信息是否可以进行编辑, 默认为true, 即可以编辑</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串</span></span><br><span class="line"><span class="comment">    - 如果有特殊需求, 可以参数帮助文档进行相关设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QInputDialog::getItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;label, <span class="type">const</span> QStringList &amp;items, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> current = <span class="number">0</span>, <span class="type">bool</span> editable = <span class="literal">true</span>, <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags(), </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::InputMethodHints inputMethodHints = Qt::ImhNone)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个可以输入多行数据的对话框窗口, 返回用户在窗口中输入的文本信息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - text: 指定显示到多行输入框中的文本信息, 默认是空字符串</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串</span></span><br><span class="line"><span class="comment">    - 如果有特殊需求, 可以参数帮助文档进行相关设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QInputDialog::getMultiLineText</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, <span class="type">const</span> QString &amp;label, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;text = QString(), <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags(), </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::InputMethodHints inputMethodHints = Qt::ImhNone)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个可以输入单行信息的对话框窗口, 返回用户在窗口中输入的文本信息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口 </span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - mode: 指定单行编辑框中数据的反馈模式, 是一个 QLineEdit::EchoMode 类型的枚举值</span></span><br><span class="line"><span class="comment">    - QLineEdit::Normal: 显示输入的字符。这是默认值</span></span><br><span class="line"><span class="comment">    - QLineEdit::NoEcho: 不要展示任何东西。这可能适用于连密码长度都应该保密的密码。</span></span><br><span class="line"><span class="comment">    - QLineEdit::Password: 显示与平台相关的密码掩码字符，而不是实际输入的字符。</span></span><br><span class="line"><span class="comment">    - QLineEdit::PasswordEchoOnEdit: 在编辑时按输入显示字符，否则按密码显示字符。</span></span><br><span class="line"><span class="comment">  - text: 指定显示到单行输入框中的文本信息, 默认是空字符串</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串</span></span><br><span class="line"><span class="comment">     - 如果有特殊需求, 可以参数帮助文档进行相关设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QInputDialog::getText</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, <span class="type">const</span> QString &amp;label,</span></span></span><br><span class="line"><span class="params"><span class="function">    QLineEdit::EchoMode mode = QLineEdit::Normal, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;text = QString(), <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags(), </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::InputMethodHints inputMethodHints = Qt::ImhNone)</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-3-5-2-测试代码"><a href="#1-3-5-2-测试代码" class="headerlink" title="1.3.5.2 测试代码"></a>1.3.5.2 测试代码</h4><ul><li>整形输入框</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_inputdlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = QInputDialog::<span class="built_in">getInt</span>(<span class="keyword">this</span>, <span class="string">&quot;年龄&quot;</span>, <span class="string">&quot;您的当前年龄: &quot;</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">2</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;年龄&quot;</span>, <span class="string">&quot;您的当前年龄: &quot;</span> + QString::<span class="built_in">number</span>(ret));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>窗口效果展示:</li></ul><p><img src="/img/9.62.png" alt="在这里插入图片描述"></p><ul><li>浮点型输入框</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_inputdlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> ret = QInputDialog::<span class="built_in">getDouble</span>(<span class="keyword">this</span>, <span class="string">&quot;工资&quot;</span>, <span class="string">&quot;您的工资: &quot;</span>, <span class="number">2000</span>, <span class="number">1000</span>, <span class="number">6000</span>, <span class="number">2</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;工资&quot;</span>, <span class="string">&quot;您的当前工资: &quot;</span> + QString::<span class="built_in">number</span>(ret));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>窗口效果展示:</li></ul><p><img src="/img/9.63.png" alt="在这里插入图片描述"></p><ul><li>带下拉菜单的输入框</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_inputdlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStringList items;</span><br><span class="line">    items &lt;&lt; <span class="string">&quot;苹果&quot;</span> &lt;&lt; <span class="string">&quot;橙子&quot;</span> &lt;&lt; <span class="string">&quot;橘子&quot;</span> &lt;&lt; <span class="string">&quot;葡萄&quot;</span> &lt;&lt; <span class="string">&quot;香蕉&quot;</span> &lt;&lt; <span class="string">&quot;哈密瓜&quot;</span>;</span><br><span class="line">    QString item = QInputDialog::<span class="built_in">getItem</span>(<span class="keyword">this</span>, <span class="string">&quot;请选择你喜欢的水果&quot;</span>, <span class="string">&quot;你最喜欢的水果:&quot;</span>, items, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;水果&quot;</span>, <span class="string">&quot;您最喜欢的水果是: &quot;</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>窗口效果展示:</li></ul><p><img src="/img/9.64.png" alt="在这里插入图片描述"></p><ul><li>多行字符串输入框</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_inputdlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString info = QInputDialog::<span class="built_in">getMultiLineText</span>(<span class="keyword">this</span>, <span class="string">&quot;表白&quot;</span>, <span class="string">&quot;您最想对漂亮小姐姐说什么呢?&quot;</span>, <span class="string">&quot;呦吼吼...&quot;</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;知心姐姐&quot;</span>, <span class="string">&quot;您最想对小姐姐说: &quot;</span> + info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>窗口效果展示:<br><img src="/img/9.65.png" alt="在这里插入图片描述"></p><ul><li>单行字符串输入框</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_inputdlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString text = QInputDialog::<span class="built_in">getText</span>(<span class="keyword">this</span>, <span class="string">&quot;密码&quot;</span>, <span class="string">&quot;请输入新的密码&quot;</span>, QLineEdit::Password, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;密码&quot;</span>, <span class="string">&quot;您设置的密码是: &quot;</span> + text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>窗口效果展示:</p><p><img src="/img/9.66.png" alt="在这里插入图片描述"></p><hr><h3 id="1-3-6-QProgressDialog"><a href="#1-3-6-QProgressDialog" class="headerlink" title="1.3.6 QProgressDialog"></a>1.3.6 QProgressDialog</h3><blockquote><p><code>QProgressDialog</code>类是<code>QDialog</code>的子类, 通过这个类我们可以得到一个带进度条的对话框窗口<br>这种类型的对话框窗口一般常用于文件拷贝、数据传输等实时交互的场景中。</p></blockquote><h4 id="1-3-6-1-常用API"><a href="#1-3-6-1-常用API" class="headerlink" title="1.3.6.1 常用API"></a>1.3.6.1 常用API</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - labelText: 对话框中显示的提示信息</span></span><br><span class="line"><span class="comment">  - cancelButtonText: 取消按钮上显示的文本信息</span></span><br><span class="line"><span class="comment">  - minimum: 进度条最小值</span></span><br><span class="line"><span class="comment">  - maximum: 进度条最大值</span></span><br><span class="line"><span class="comment">  - parent: 当前窗口的父对象</span></span><br><span class="line"><span class="comment">  - f: 当前进度窗口的flag属性, 使用默认属性即可, 无需设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QProgressDialog::<span class="built_in">QProgressDialog</span>(</span><br><span class="line">QWidget *parent = <span class="literal">nullptr</span>, </span><br><span class="line">Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line">QProgressDialog::<span class="built_in">QProgressDialog</span>(</span><br><span class="line"><span class="type">const</span> QString &amp;labelText, <span class="type">const</span> QString &amp;cancelButtonText, </span><br><span class="line"><span class="type">int</span> minimum, <span class="type">int</span> maximum, QWidget *parent = <span class="literal">nullptr</span>,</span><br><span class="line">Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置取消按钮显示的文本信息</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setCancelButtonText</span><span class="params">(<span class="type">const</span> QString &amp;cancelButtonText)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数和槽函数</span></span><br><span class="line"><span class="function">QString <span class="title">QProgressDialog::labelText</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setLabelText</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到进度条最小值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QProgressDialog::minimum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置进度条最小值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setMinimum</span><span class="params">(<span class="type">int</span> minimum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到进度条最大值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QProgressDialog::maximum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置进度条最大值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setMaximum</span><span class="params">(<span class="type">int</span> maximum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置进度条范围(最大和最小值)</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setRange</span><span class="params">(<span class="type">int</span> minimum, <span class="type">int</span> maximum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到进度条当前的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QProgressDialog::value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置进度条当前的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setValue</span><span class="params">(<span class="type">int</span> progress)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QProgressDialog::autoReset</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 当value() = maximum()时，进程对话框是否调用reset()，此属性默认为true。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setAutoReset</span><span class="params">(<span class="type">bool</span> reset)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QProgressDialog::autoClose</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 当value() = maximum()时，进程对话框是否调用reset()并且隐藏，此属性默认为true。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setAutoClose</span><span class="params">(<span class="type">bool</span> close)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断用户是否按下了取消键, 按下了返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wasCanceled</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置进度条</span></span><br><span class="line"><span class="comment">// 重置进度对话框。wascancelled()变为true，直到进程对话框被重置。进度对话框被隐藏。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::cancel</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 重置进度对话框。如果autoClose()为真，进程对话框将隐藏。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::reset</span><span class="params">()</span></span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号</span></span><br><span class="line"><span class="comment">// 当单击cancel按钮时，将发出此信号。默认情况下，它连接到cancel()槽。</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::canceled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置窗口的显示状态(模态, 非模态)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">Qt::NonModal  -&gt; 非模态</span></span><br><span class="line"><span class="comment">Qt::WindowModal-&gt; 模态, 阻塞父窗口</span></span><br><span class="line"><span class="comment">Qt::ApplicationModal -&gt; 模态, 阻塞应用程序中的所有窗口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setWindowModality</span><span class="params">(Qt::WindowModality windowModality)</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-3-6-2-测试代码"><a href="#1-3-6-2-测试代码" class="headerlink" title="1.3.6.2 测试代码"></a>1.3.6.2 测试代码</h4><blockquote><p>场景描述:<br>    1. 基于定时器模拟文件拷贝的场景<br>    2. 点击窗口按钮, 进度条窗口显示, 同时启动定时器<br>    3. 通过定时器信号, 按照固定频率更新对话框窗口进度条<br>    4. 当进度条当前值 &#x3D;&#x3D; 最大值, 关闭定时器, 关闭并析构进度对话框</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_progressdlg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建进度条对话框窗口对象</span></span><br><span class="line">    QProgressDialog *progress = <span class="keyword">new</span> <span class="built_in">QProgressDialog</span>(</span><br><span class="line">                <span class="string">&quot;正在拷贝数据...&quot;</span>, <span class="string">&quot;取消拷贝&quot;</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 2. 初始化并显示进度条窗口</span></span><br><span class="line">    progress-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;请稍后&quot;</span>);</span><br><span class="line">    progress-&gt;<span class="built_in">setWindowModality</span>(Qt::WindowModal);</span><br><span class="line">    progress-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 更新进度条</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    QTimer *timer = <span class="keyword">new</span> QTimer;</span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, [=]()</span><br><span class="line">    &#123;</span><br><span class="line">         progress-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line">         value++;</span><br><span class="line">         <span class="comment">// 当value &gt; 最大值的时候</span></span><br><span class="line">         <span class="keyword">if</span>(value &gt; progress-&gt;<span class="built_in">maximum</span>())</span><br><span class="line">         &#123;</span><br><span class="line">             timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">             value = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">delete</span> progress;</span><br><span class="line">             <span class="keyword">delete</span> timer;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(progress, &amp;QProgressDialog::canceled, <span class="keyword">this</span>, [=]()</span><br><span class="line">    &#123;</span><br><span class="line">        timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">        value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">delete</span> progress;</span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>进度窗口效果展示:<br><img src="/img/9.67.png" alt="在这里插入图片描述"></p></blockquote><hr><h2 id="1-4-QMainWindow"><a href="#1-4-QMainWindow" class="headerlink" title="1.4 QMainWindow"></a>1.4 QMainWindow</h2><blockquote><p>QMainWindow是标准基础窗口中结构最复杂的窗口, 其组成如下:</p><ul><li>提供了<code>菜单栏, 工具栏, 状态栏, 停靠窗口</code></li><li>菜单栏: 只能有一个, 位于窗口的最上方 </li><li>工具栏: 可以有多个, 默认提供了一个,窗口的上下左右都可以停靠 </li><li>状态栏: 只能有一个, 位于窗口最下方 </li><li>停靠窗口: 可以有多个, 默认没有提供, 窗口的上下左右都可以停靠</li></ul></blockquote><p><img src="/img/9.68.png" alt="在这里插入图片描述"></p><h3 id="1-4-1-菜单栏"><a href="#1-4-1-菜单栏" class="headerlink" title="1.4.1 菜单栏"></a>1.4.1 菜单栏</h3><ul><li>添加菜单项</li></ul><blockquote><p>关于顶级菜单可以直接在UI窗口中双击, 直接输入文本信息即可, 对应子菜单项也可以通过先双击在输入的方式完成添加,但是这种方式<code>不支持中文的输入</code>。</p></blockquote><p><img src="/img/9.69.png" alt="在这里插入图片描述"></p><ul><li>常用的添加方式</li></ul><blockquote><p>一般情况下, 我们都是先在外面创建出QAction对象, 然后再将其拖拽到某个菜单下边, 这样子菜单项的添加就完成了。</p></blockquote><p><img src="/img/9.70.png" alt="在这里插入图片描述"></p><ul><li>通过代码的方式添加菜单或者菜单项</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给菜单栏添加菜单</span></span><br><span class="line"><span class="function">QAction *<span class="title">QMenuBar::addMenu</span><span class="params">(QMenu *menu)</span></span>;</span><br><span class="line"><span class="function">QMenu *<span class="title">QMenuBar::addMenu</span><span class="params">(<span class="type">const</span> QString &amp;title)</span></span>;</span><br><span class="line"><span class="function">QMenu *<span class="title">QMenuBar::addMenu</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;title)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给菜单对象添加菜单项(QAction)</span></span><br><span class="line"><span class="function">QAction *<span class="title">QMenu::addAction</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="function">QAction *<span class="title">QMenu::addAction</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加分割线</span></span><br><span class="line"><span class="function">QAction *<span class="title">QMenu::addSeparator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>菜单项 QAction 事件的处理</li></ul><p><strong>单击菜单项, 该对象会发出一个信号</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击QAction对象发出该信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAction::triggered</span><span class="params">(<span class="type">bool</span> checked = <span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// save_action 是某个菜单项对象名, 点击这个菜单项会弹出一个对话框</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;save_action, &amp;QAction::triggered, <span class="keyword">this</span>, [=]()</span><br><span class="line">&#123;</span><br><span class="line">      QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;Triggered&quot;</span>, <span class="string">&quot;我是菜单项, 你不要调戏我...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="1-4-2-工具栏"><a href="#1-4-2-工具栏" class="headerlink" title="1.4.2 工具栏"></a>1.4.2 工具栏</h3><h4 id="1-4-2-1-添加工具按钮"><a href="#1-4-2-1-添加工具按钮" class="headerlink" title="1.4.2.1 添加工具按钮"></a>1.4.2.1 添加工具按钮</h4><blockquote><p>窗口中的工具栏我们经常见到, 并不会为此感到陌生, 如何往工具栏中添加工具按钮?<br>一共有两种方式</p></blockquote><ul><li><p>方式1：先创建QAction对象, 然后拖拽到工具栏中, 和添加菜单项的方式相同<br><img src="/img/9.71.png" alt="在这里插入图片描述"></p></li><li><p>方式2：如果不通过UI界面直接操作，那么就需要调用相关的API函数了</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在QMainWindow窗口中添加工具栏</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QMainWindow::addToolBar</span><span class="params">(Qt::ToolBarArea area, QToolBar *toolbar)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QMainWindow::addToolBar</span><span class="params">(QToolBar *toolbar)</span></span>;</span><br><span class="line"><span class="function">QToolBar *<span class="title">QMainWindow::addToolBar</span><span class="params">(<span class="type">const</span> QString &amp;title)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Qt控件放到工具栏中</span></span><br><span class="line"><span class="comment">// 工具栏类: QToolBar</span></span><br><span class="line"><span class="comment">// 添加的对象只要是QWidget或者启子类都可以被添加</span></span><br><span class="line"><span class="function">QAction *<span class="title">QToolBar::addWidget</span><span class="params">(QWidget *widget)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加QAction对象</span></span><br><span class="line"><span class="function">QAction *<span class="title">QToolBar::addAction</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="function">QAction *<span class="title">QToolBar::addAction</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加分隔线</span></span><br><span class="line"><span class="function">QAction *<span class="title">QToolBar::addSeparator</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>通过代码的方式对工具栏进行操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加第二个工具栏</span></span><br><span class="line">    QToolBar* toolbar = <span class="keyword">new</span> <span class="built_in">QToolBar</span>(<span class="string">&quot;toolbar&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addToolBar</span>(Qt::LeftToolBarArea, toolbar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给工具栏添加按钮和单行输入框</span></span><br><span class="line">    ui-&gt;toolBar-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;搜索&quot;</span>));</span><br><span class="line">    QLineEdit* edit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">    edit-&gt;<span class="built_in">setMaximumWidth</span>(<span class="number">200</span>);</span><br><span class="line">    edit-&gt;<span class="built_in">setFixedWidth</span>(<span class="number">100</span>);</span><br><span class="line">    ui-&gt;toolBar-&gt;<span class="built_in">addWidget</span>(edit);</span><br><span class="line">    <span class="comment">// 添加QAction类型的菜单项</span></span><br><span class="line">    ui-&gt;toolBar-&gt;<span class="built_in">addAction</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/er-dog&quot;</span>), <span class="string">&quot;二狗子&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="1-4-2-2-工具栏的属性设置"><a href="#1-4-2-2-工具栏的属性设置" class="headerlink" title="1.4.2.2 工具栏的属性设置"></a>1.4.2.2 工具栏的属性设置</h4><blockquote><p>在UI窗口的树状列表中, 找到工具栏节点, 就可以得到工具栏的属性设置面板了<br>这样就可根据个人需求对工具栏的属性进行设置和修改了。</p></blockquote><p><img src="/img/9.72.png" alt="在这里插入图片描述"></p><blockquote><p>在Qt控件的属性窗口中对应了一些属性, 这些属性大部分都应了一个设置函数</p><ul><li>在对应的类中函数名叫什么? <ul><li>规律: <code>set+属性名 == 函数名</code></li></ul></li><li>某些属性没有对应的函数, 只能在属性窗口中设置</li></ul></blockquote><hr><h3 id="1-4-3-状态栏"><a href="#1-4-3-状态栏" class="headerlink" title="1.4.3 状态栏"></a>1.4.3 状态栏</h3><blockquote><p>一般情况下, 需要在状态栏中添加某些控件, 显示某些属性, 用最多的就是添加标签 <code>QLabel</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型: QStatusBar</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QStatusBar::addWidget</span><span class="params">(QWidget *widget, <span class="type">int</span> stretch = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QStatusBar::clearMessage</span><span class="params">()</span></span>;</span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QStatusBar::showMessage</span><span class="params">(<span class="type">const</span> QString &amp;message, <span class="type">int</span> timeout = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>相关的操作代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态栏添加子控件</span></span><br><span class="line">    <span class="comment">// 按钮</span></span><br><span class="line">    QPushButton* button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮&quot;</span>);</span><br><span class="line">    ui-&gt;statusBar-&gt;<span class="built_in">addWidget</span>(button);</span><br><span class="line">    <span class="comment">// 标签</span></span><br><span class="line">    QLabel* label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    ui-&gt;statusBar-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-4-4-停靠窗口"><a href="#1-4-4-停靠窗口" class="headerlink" title="1.4.4 停靠窗口"></a>1.4.4 停靠窗口</h3><blockquote><p>停靠窗口可以通过鼠标拖动停靠到窗口的上、下、左、右，或者浮动在窗口上方。<br>如果需要这种类型的窗口必须手动添加<br><code>如果在非QMainWindow类型的窗口中添加了停靠窗口,那么这个窗口是不能移动和浮动的。</code><br> 浮动窗口在工具栏中， 直接将其拖拽到UI界面上即可。</p></blockquote><p><img src="/img/9.73.png" alt="在这里插入图片描述"></p><ul><li>停靠窗口也有一个属性面板, 我们可以在其对应属性面板中直接进行设置和修改相关属性。</li></ul><p><img src="/img/9.74.png" alt="在这里插入图片描述"></p><hr><h2 id="1-5-资源文件-qrc"><a href="#1-5-资源文件-qrc" class="headerlink" title="1.5 资源文件 .qrc"></a>1.5 资源文件 .qrc</h2><blockquote><p>资源文件顾名思义就是一个存储资源的文件，在Qt中引入资源文件好处在于他能提高应用程序的部署效率并且减少一些错误的发生。<br><code>在程序编译过程中，添加到资源文件中的文件也会以二进制的形式被打包到可执行程序中，这样这些资源就永远和可执行程序捆绑到一起了，不会出现加载资源却找不到的问题。</code><br>虽然资源文件优势很明显，但是它也不是万能的，资源文件中一般添加的都是比较小的资源，比如： 图片，配置文件，MP3等，如果是类似视频这类比较大的文件就不适合放到资源文件中了。</p></blockquote><ul><li>比如我们需要给某个窗口设置图标, 代码如下:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建图标对象</span></span><br><span class="line">QIcon::<span class="built_in">QIcon</span>(<span class="type">const</span> QString &amp;fileName);</span><br><span class="line"><span class="comment">// QWidget类的 公共成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowIcon</span><span class="params">(<span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给窗口设置图标</span></span><br><span class="line"><span class="comment">// 弊端: 发布的 exe 必须要加载 d:\\pic\\1.ico 如果当前主机对应的目录中没有图片, 图标就无法被加载</span></span><br><span class="line"><span class="comment">// 发布 exe 需要额外发布图片, 将其部署到某个目录中</span></span><br><span class="line"><span class="built_in">setWindowIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;d:\\pic\\1.ico&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><p>我们可以使用资源文件解决上述的弊端, 这样发布应用程序的时候直接发布exe就可以, 不需要再额外提供图片了。</p></blockquote><p>介绍一下关于资源文件的创建步骤:</p><p><img src="/img/9.75.png" alt="在这里插入图片描述"></p><p><img src="/img/9.76.png" alt="在这里插入图片描述"><br><img src="/img/9.77.png" alt="在这里插入图片描述"><br><img src="/img/9.78.png" alt="在这里插入图片描述"></p><ul><li>资源文件添加完毕之后, 继续给大家介绍资源文件的使用</li></ul><ol><li>使用<code>资源编辑器</code>打开资源文件</li></ol><p><img src="/img/9.79.png" alt="在这里插入图片描述"></p><ol start="2"><li>给资源添加前缀</li></ol><blockquote><p>一个资源文件中可以添加多个前缀, 前缀就是添加的资源在资源文件中的路径, 前缀根据实际需求制定即可, 路径以<code>/</code>开头</p></blockquote><p><img src="/img/9.80.png" alt="在这里插入图片描述"></p><ol start="3"><li>添加文件</li></ol><blockquote><p>前缀添加完毕, 就可以在某个前缀下边添加相关的资源了。</p></blockquote><p><img src="/img/9.81.png" alt="在这里插入图片描述"></p><ul><li>弹出以文件选择对话框, 选择资源文件<ul><li>资源文件放到什么地方?<ul><li><code>放到和 项目文件 .pro 同一级目录或者更深的目录中</code></li><li><code>错误的做法: 将资源文件放到 .pro文件的上级目录, 这样资源文件无法被加载到</code></li></ul></li></ul></li><li>可以给添加的资源文件设置别名, 设置别名之后原来的名字就不能使用了</li></ul><blockquote><p>温馨提示:</p><ol><li>在高版本的QtCreator中, 资源文件名字或者别名不支持中文</li><li>如果设置了中文会出现编译会报错</li><li>在此只是演示, 使用过程中需要额外注意该问题</li></ol></blockquote><p><img src="/img/9.82.png" alt="在这里插入图片描述"></p><ol start="4"><li>如何在程序中使用资源文件中的图片</li></ol><blockquote><p>将项目树中的资源文件节点展开</p></blockquote><p><img src="/img/9.83.png" alt="在这里插入图片描述"></p><blockquote><p>找到需要使用的资源图片节点, 鼠标右键, 弹出的菜单中选择<code>Copy Path ...</code></p></blockquote><p><img src="/img/9.84.png" alt="在这里插入图片描述"></p><hr><h2 id="1-6-在Qt窗口中添加右键菜单"><a href="#1-6-在Qt窗口中添加右键菜单" class="headerlink" title="1.6 在Qt窗口中添加右键菜单"></a>1.6 在Qt窗口中添加右键菜单</h2><p>如果想要在某一窗口中显示右键菜单, 其处理方式大体上有两种<br>这两种方式分别为基于<code>鼠标事件实现</code>和<code>基于窗口的菜单策略实现</code>。<br>其中第二种方式中又有三种不同的实现方式<br>因此想要在窗口中显示一个右键菜单共四种实现方式</p><h3 id="1-6-1-基于鼠标事件实现"><a href="#1-6-1-基于鼠标事件实现" class="headerlink" title="1.6.1 基于鼠标事件实现"></a>1.6.1 基于鼠标事件实现</h3><h4 id="1-6-1-1-实现思路"><a href="#1-6-1-1-实现思路" class="headerlink" title="1.6.1.1 实现思路"></a>1.6.1.1 实现思路</h4><blockquote><p>使用这种方式实现右键菜单的显示需要使用<code>事件处理器函数</code>, 在Qt中这类函数都是回调函数,<br>并且在自定义窗口类中我们还可以自定义事件处理器函数的行为（因为子类继承了父类的这个方法并且这类函数是虚函数）。 </p></blockquote><p>实现步骤如下：</p><ol><li>在当前窗口类中重写鼠标操作相关的的事件处理器函数，有两个可以选择</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两个事件二选一即可, 只是事件函数被调用的时机不同罢了</span></span><br><span class="line"><span class="comment">// 这个时机对右键菜单的显示没有任何影响</span></span><br><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>在数据表事件处理器函数内部判断是否按下了鼠标右键</p></li><li><p>如果按下了鼠标右键创建菜单对象(也可以提前先创建处理), 并将其显示出来</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关于QMenu类型的菜单显示需要调用的 API</span></span><br><span class="line"><span class="comment">// 参数 p 就是右键菜单需要显示的位置, 这个坐标需要使用屏幕坐标</span></span><br><span class="line"><span class="comment">// 该位置坐标一般通过调用 QCursor::pos() 直接就可以得到了</span></span><br><span class="line"><span class="function">QAction *<span class="title">QMenu::exec</span><span class="params">(<span class="type">const</span> QPoint &amp;p, QAction *action = <span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-6-1-2-代码实现"><a href="#1-6-1-2-代码实现" class="headerlink" title="1.6.1.2 代码实现"></a>1.6.1.2 代码实现</h4><blockquote><p>在头文件中添加要重写的鼠标事件处理器函数声明, 这里使用的是 <code>mousePressEvent()</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainWindow</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 鼠标按下, 该函数被Qt框架调用, 需要重写该函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在源文件中重写从父类继承的虚函数<code>mousePressEvent()</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 判断用户按下的是哪一个鼠标键</span></span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>() == Qt::RightButton)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 弹出一个菜单, 菜单项是 QAction 类型</span></span><br><span class="line">        QMenu menu;</span><br><span class="line">        QAction* act = menu.<span class="built_in">addAction</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        <span class="built_in">connect</span>(act, &amp;QAction::triggered, <span class="keyword">this</span>, [=]()</span><br><span class="line">        &#123;</span><br><span class="line">            QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;您选择的是C++...&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        menu.<span class="built_in">addAction</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        menu.<span class="built_in">addAction</span>(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">        menu.<span class="built_in">exec</span>(QCursor::<span class="built_in">pos</span>()); <span class="comment">// 右键菜单被模态显示出来了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-6-2-基于窗口的菜单策略实现"><a href="#1-6-2-基于窗口的菜单策略实现" class="headerlink" title="1.6.2 基于窗口的菜单策略实现"></a>1.6.2 基于窗口的菜单策略实现</h3><blockquote><p>这种方式是使用 Qt 中 <code>QWidget</code> 类中的右键菜单函数<br><code>QWidget::setContextMenuPolicy(Qt::ContextMenuPolicy policy)</code> 来实现,<br>因为这个函数的参数可以指定不同的值, 因此不同参数对应的具体的实现方式也不同。 </p></blockquote><p>这个函数的函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型:</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setContextMenuPolicy</span><span class="params">(Qt::ContextMenuPolicy policy)</span></span>;</span><br><span class="line">参数: </span><br><span class="line">  - Qt::NoContextMenu     --&gt; 不能实现右键菜单</span><br><span class="line">  - Qt::PreventContextMenu   --&gt; 不能实现右键菜单</span><br><span class="line">  - Qt::DefaultContextMenu   --&gt; 基于事件处理器函数 QWidget::<span class="built_in">contextMenuEvent</span>() 实现</span><br><span class="line">  - Qt::ActionsContextMenu   --&gt; 添加到当前窗口中所有 QAction 都会作为右键菜单项显示出来</span><br><span class="line">  - Qt::CustomContextMenu    --&gt; 基于 QWidget::<span class="built_in">customContextMenuRequested</span>() 信号实现</span><br></pre></td></tr></table></figure><h4 id="1-6-2-1-Qt-DefaultContextMenu"><a href="#1-6-2-1-Qt-DefaultContextMenu" class="headerlink" title="1.6.2.1 Qt::DefaultContextMenu"></a>1.6.2.1 Qt::DefaultContextMenu</h4><blockquote><p>使用这个策略实现右键菜单, 需要借助窗口类从父类继承的虚函<code>QWidget::contextMenuEvent()</code>并重写它来实现。</p></blockquote><ul><li>第一步是在窗口类的头文件中添加这个函数的声明</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainWindow</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 如果窗口设置了 Qt::DefaultContextMenu 策略, </span></span><br><span class="line">    <span class="comment">// 点击鼠标右键该函数被Qt框架调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">contextMenuEvent</span><span class="params">(QContextMenuEvent *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>第二步在这个窗口类的构造函数设置右键菜单策略</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.cpp</span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给窗口设置策略: Qt::DefaultContextMenu</span></span><br><span class="line">    <span class="comment">// 在窗口中按下鼠标右键, 这个事件处理器函数被qt框架调用 QWidget::contextMenuEvent()</span></span><br><span class="line">    <span class="built_in">setContextMenuPolicy</span>(Qt::DefaultContextMenu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>第三步在这个窗口类的源文件中重写事件处理器函数 contextMenuEvent()</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::contextMenuEvent</span><span class="params">(QContextMenuEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 弹出一个菜单, 菜单项是 QAction 类型</span></span><br><span class="line">    QMenu menu;</span><br><span class="line">    QAction* act = menu.<span class="built_in">addAction</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">    <span class="built_in">connect</span>(act, &amp;QAction::triggered, <span class="keyword">this</span>, [=]()</span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;您选择的是C++...&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    menu.<span class="built_in">addAction</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">    menu.<span class="built_in">addAction</span>(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">    menu.<span class="built_in">exec</span>(QCursor::<span class="built_in">pos</span>());<span class="comment">// 右键菜单被模态显示出来了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="1-6-2-2-Qt-ActionsContextMenu"><a href="#1-6-2-2-Qt-ActionsContextMenu" class="headerlink" title="1.6.2.2 Qt::ActionsContextMenu"></a>1.6.2.2 Qt::ActionsContextMenu</h4><blockquote><p>使用这个策略实现右键菜单, 是最简单的一种, 我们只需要创建一些 <code>QAction</code> 类型的对象并且将他们添加到当前的窗口中,当我们在窗口中点击鼠标右键这些QAction类型的菜单项就可以显示出来了。<br>虽然这种方法比较简单，但是它有一定的局限性，就是在一个窗口中不能根据不同的需求制作不同的右键菜单，这种方式只能得到一个唯一的右键菜单。<br>相关的处理代码如下：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.cpp</span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要将某个QAction添加给对应的窗口, 这个action就是这个窗口右键菜单中的一个菜单项了</span></span><br><span class="line">    <span class="comment">// 在窗口中点击鼠标右键, 就可以显示这个菜单</span></span><br><span class="line">    <span class="built_in">setContextMenuPolicy</span>(Qt::ActionsContextMenu);</span><br><span class="line">    <span class="comment">// 给当前窗口添加QAction对象</span></span><br><span class="line">    QAction* act1  = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">    QAction* act2 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">    QAction* act3  = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addAction</span>(act1);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addAction</span>(act2);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addAction</span>(act3);</span><br><span class="line">    <span class="built_in">connect</span>(act1, &amp;QAction::triggered, <span class="keyword">this</span>, [=]()</span><br><span class="line">    &#123;</span><br><span class="line">         QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;您选择的是C++...&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="1-6-2-3-Qt-CustomContextMenu"><a href="#1-6-2-3-Qt-CustomContextMenu" class="headerlink" title="1.6.2.3 Qt::CustomContextMenu"></a>1.6.2.3 Qt::CustomContextMenu</h4><blockquote><p>使用这个策略实现右键菜单, 当点击鼠标右键，窗口会产生一个 <code>QWidget::customContextMenuRequested()</code>信号<br>注意仅仅只是发射信号，意味着要自己写显示右键菜单的槽函数（slot），这个信号是QWidget唯一与右键菜单有关的信号。</p></blockquote><p>来看一下这个信号的函数原型:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意: 信号中的参数pos为当前窗口的坐标，并非屏幕坐标，右键菜单显示需要使用屏幕坐标</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QWidget::customContextMenuRequested</span><span class="params">(<span class="type">const</span> QPoint &amp;pos)</span></span></span><br></pre></td></tr></table></figure><p>代码实现也比较简单, 如下所示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.cpp</span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略 Qt::CustomContextMenu</span></span><br><span class="line">    <span class="comment">// 当在窗口中点击鼠标右键, 窗口会发出一个信号: QWidget::customContextMenuRequested()</span></span><br><span class="line">    <span class="comment">// 对应发射出的这个信号, 需要添加一个槽函数, 用来显示右键菜单</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setContextMenuPolicy</span>(Qt::CustomContextMenu);</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;MainWindow::customContextMenuRequested, <span class="keyword">this</span>, [=](<span class="type">const</span> QPoint &amp;pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 参数 pos 是鼠标按下的位置, 但是不能直接使用, 这个坐标不是屏幕坐标, 是当前窗口的坐标</span></span><br><span class="line">        <span class="comment">// 如果要使用这个坐标需要将其转换为屏幕坐标</span></span><br><span class="line">        QMenu menu;</span><br><span class="line">        QAction* act = menu.<span class="built_in">addAction</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        <span class="built_in">connect</span>(act, &amp;QAction::triggered, <span class="keyword">this</span>, [=]()</span><br><span class="line">        &#123;</span><br><span class="line">            QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;您选择的是C++...&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        menu.<span class="built_in">addAction</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        menu.<span class="built_in">addAction</span>(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">        <span class="comment">// menu.exec(QCursor::pos());</span></span><br><span class="line">        <span class="comment">// 将窗口坐标转换为屏幕坐标</span></span><br><span class="line">        QPoint newpt = <span class="keyword">this</span>-&gt;<span class="built_in">mapToGlobal</span>(pos);</span><br><span class="line">        menu.<span class="built_in">exec</span>(newpt);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上边的程序中, 我们通过窗口发射的信号得到了一个坐标类型的参数<br>注意<code>这个坐标是当前窗口的窗口坐标, 不是屏幕坐标,显示右键菜单需要使用屏幕坐标。</code></p></blockquote><p> 对应这个坐标的处理可以有两种方式：</p><ul><li><p>弃用，选择使用 <code>QCursor::pos()</code> 得到光标在屏幕的坐标位置</p></li><li><p>坐标转换, 将窗口坐标转换为屏幕坐标, 这里用到了一个函数 <code>mapToGlobal</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是当前窗口坐标, 返回值为屏幕坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QWidget::mapToGlobal</span><span class="params">(<span class="type">const</span> QPoint &amp;pos)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>不管使用以上哪种方式显示右键菜单, 显示出来之后的效果是一样的</p><p><img src="/img/9.85.png" alt="在这里插入图片描述"></p><p>最后如果想要让自己的右键菜单项显示图标, 可以调用这个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只显示文本字符串</span></span><br><span class="line"><span class="function">QAction *<span class="title">QMenu::addAction</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="comment">// 可以显示图标 + 文本字符串</span></span><br><span class="line"><span class="function">QAction *<span class="title">QMenu::addAction</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;text)</span></span>;</span><br></pre></td></tr></table></figure><hr><h1 id="2-窗口布局"><a href="#2-窗口布局" class="headerlink" title="2. 窗口布局"></a>2. 窗口布局</h1><h2 id="2-1-布局的样式"><a href="#2-1-布局的样式" class="headerlink" title="2.1 布局的样式"></a>2.1 布局的样式</h2><blockquote><p>Qt窗口布局是指将多个子窗口按照某种排列方式将其全部展示到对应的父窗口中的一种处理方式</p></blockquote><p>在Qt中常用的布局样式有三种，分别是：</p><table><thead><tr><th>布局样式</th><th>描述</th><th>行数</th><th>列数</th></tr></thead><tbody><tr><td>水平布局</td><td>布局中的所有的控件水平排列</td><td>1行</td><td>N列 (N&gt;&#x3D;1)</td></tr><tr><td>垂直布局</td><td>布局中的所有的控件垂直排列</td><td>N行 (N&gt;&#x3D;1)</td><td>1列</td></tr><tr><td>网格（栅格）布局</td><td>布局中的所有的控件垂直+水平排列</td><td>N行 (N&gt;&#x3D;1)</td><td>N列 (N&gt;&#x3D;1)</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">有问有答:</span><br><span class="line">    1. 控件的位置可以通过坐标指定, 为什么还要使用布局?</span><br><span class="line">    - 坐标指定的位置是固定的, 当窗口大小发生改变, 子窗口位置不会变化</span><br><span class="line">    - 使用坐标指定子窗口位置, 这个控件可能会被其他控件覆盖导致无法显示出来</span><br><span class="line">    - 使用布局的方式可以完美解决以上的问题</span><br><span class="line">    - 一般在制作窗口的过程中都是给子控件进行布局, 而不是指定固定坐标位置</span><br><span class="line">    2. 布局有局限性吗, 窗口结构复杂如何解决呢?</span><br><span class="line">        - 没有局限性, 并且布局的使用是非常灵活的</span><br><span class="line">    - 各种布局是可以无限嵌套使用的, 这样就可以制作成非常复杂的窗口了</span><br><span class="line">    - 思路是这样的: 给窗口设置布局, 在布局中添加窗口, 子窗口中再设置布局, </span><br><span class="line">      在子窗口布局中再次添加窗口, ......(无限循环)</span><br></pre></td></tr></table></figure><hr><h2 id="2-2-在UI窗口中设置布局"><a href="#2-2-在UI窗口中设置布局" class="headerlink" title="2.2 在UI窗口中设置布局"></a>2.2 在UI窗口中设置布局</h2><blockquote><p>在UI窗口中进行布局的设置一共有两种处理方式</p></blockquote><h3 id="2-2-1-方式1"><a href="#2-2-1-方式1" class="headerlink" title="2.2.1 方式1"></a>2.2.1 方式1</h3><blockquote><p>第一种方式是使用Qt提供的布局, 从工具箱中找到相关的布局, 然后将其拖拽到UI窗口中</p></blockquote><p><img src="/img/9.86.png" alt="在这里插入图片描述"></p><ul><li>将相应的控件放入到布局对应的红色框内部, 这些控件就按照布局的样式自动排列到一起了，是不是很方便，赶紧自己操作起来感受一下吧。</li></ul><p><img src="/img/9.87.png" alt="在这里插入图片描述"></p><ul><li>除此之外, 我们也可以修改当前布局, 需要先选中当前布局, 然后鼠标右键, 在右键菜单中找布局在其子菜单项中选择其他布局即可</li></ul><p><img src="/img/9.88.png" alt="在这里插入图片描述"></p><hr><h3 id="2-2-2-方式2"><a href="#2-2-2-方式2" class="headerlink" title="2.2.2 方式2"></a>2.2.2 方式2</h3><blockquote><p>第二种方式是直接在父窗口中对子部件进行布局, 如果窗口结构很复杂需要嵌套, 那么就需要先将这些子部件放到一个<code>容器类型</code>的窗口中,然后再对这个容器类型的窗口进行布局操作。</p></blockquote><ol><li>首先需要从工具栏中拖拽一个容器类型的窗口到UI界面上</li></ol><p><strong>一般首选QWidget原因是简单, 并且窗口显示之后看不到任何痕迹</strong></p><p><img src="/img/9.89.png" alt="在这里插入图片描述"></p><ol start="2"><li>将要布局的子控件放到这个QWidget中</li></ol><p><strong>控件拖放过程中无需在意位置和是否对齐, 没有布局之前显示杂乱无序是正常现象。</strong></p><p><img src="/img/9.90.png" alt="在这里插入图片描述"></p><ol start="3"><li>对这个QWidget进行布局</li></ol><p><strong>首选选中这个存储子部件的父容器窗口, 然后鼠标右键, 在右键菜单中找<code>布局</code>, 通过其子菜单就可以选择需要的布局方式了。布局之后所有的子部件就能够按照对应样式排列了(<code>如果是网格布局, 有时候需要使用鼠标调节一下</code>)</strong></p><p><img src="/img/9.91.png" alt="在这里插入图片描述"></p><blockquote><p>也可以通过窗口上方工具栏提供的布局按钮进行窗口布局</p></blockquote><p><img src="/img/9.92.png" alt="在这里插入图片描述"></p><hr><h3 id="2-2-3-弹簧的使用"><a href="#2-2-3-弹簧的使用" class="headerlink" title="2.2.3 弹簧的使用"></a>2.2.3 弹簧的使用</h3><p>弹簧也有对应的属性可以设置, 具体属性如下图所示:<br><img src="/img/9.93.png" alt="在这里插入图片描述"></p><blockquote><p>关于弹簧的sizeType属性, 有很多选项, 一般常用的只有两个:<br><code>Fixed</code>: 得到一个固定大小的弹簧<br><code>Expanding</code>: 得到一个可伸缩的弹簧, 默认弹簧撑到最大</p></blockquote><p><img src="/img/9.94.png" alt="在这里插入图片描述"></p><hr><h3 id="2-2-4-布局属性设置"><a href="#2-2-4-布局属性设置" class="headerlink" title="2.2.4 布局属性设置"></a>2.2.4 布局属性设置</h3><blockquote><p>当我们给窗口设置了布局之后, 选中当前窗口, 就可以看到在其对应的属性窗口中除了有窗口属性, 还有一个布局属性</p></blockquote><p>介绍一下这些属性:</p><p><img src="/img/9.95.png" alt="在这里插入图片描述"></p><hr><h3 id="2-2-5-布局的注意事项"><a href="#2-2-5-布局的注意事项" class="headerlink" title="2.2.5 布局的注意事项"></a>2.2.5 布局的注意事项</h3><blockquote><p>通过UI编辑窗口的树状列表我们可以对所有窗口的布局进行检查, 如果发现某个窗口没有布局, 一定要对其进行设置<br><code>如果某个窗口没有进行布局, 那么当这个窗口显示出来之后里边的子部件就可能无法被显示出来</code> </p></blockquote><p><img src="/img/9.96.png" alt="在这里插入图片描述"></p><blockquote><p>一个简单的登录窗口</p></blockquote><p><img src="/img/9.97.png" alt="在这里插入图片描述"></p><hr><h2 id="2-3-通过API设置布局"><a href="#2-3-通过API设置布局" class="headerlink" title="2.3 通过API设置布局"></a>2.3 通过API设置布局</h2><blockquote><p>在QT中, 布局也有对应的类, 布局类之间的关系如下:</p></blockquote><p><img src="/img/9.98.png" alt="在这里插入图片描述"></p><p>在上图中的布局类虽然很多, 常用的布局类有三个, 就前边给大家介绍的三种布局, 对应关系如下:</p><table><thead><tr><th>布局样式</th><th>类名</th></tr></thead><tbody><tr><td>水平布局</td><td>QHBoxLayout</td></tr><tr><td>垂直布局</td><td>QVBoxLayout</td></tr><tr><td>网格（栅格）布局</td><td>QGridLayout</td></tr></tbody></table><p>一般我们不使用这些布局类对窗口进行布局<br>但还是在这里介绍一下这些类中常用的一些API函数</p><h3 id="2-3-1-QLayout"><a href="#2-3-1-QLayout" class="headerlink" title="2.3.1 QLayout"></a>2.3.1 QLayout</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 在布局最后面添加一个窗口</span><br><span class="line">void QLayout::addWidget(QWidget *w);</span><br><span class="line">// 将某个窗口对象从布局中移除, 窗口对象如果不再使用需要自己析构</span><br><span class="line">void QLayout::removeWidget(QWidget *widget);</span><br><span class="line">// 设置布局的四个边界大小, 即: 左、上、右和下的边距。</span><br><span class="line">void QLayout::setContentsMargins(int left, int top, int right, int bottom);</span><br><span class="line">// 设置布局中各个窗口之间的间隙大小</span><br><span class="line">void setSpacing(int);</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-2-QHBoxLayout"><a href="#2-3-2-QHBoxLayout" class="headerlink" title="2.3.2 QHBoxLayout"></a>2.3.2 QHBoxLayout</h3><blockquote><p>这个类中的常用API都是从基类继承过来的</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 创建符窗口对象</span><br><span class="line">QWidget *window = new QWidget;</span><br><span class="line">// 创建若干个子窗口对象</span><br><span class="line">QPushButton *button1 = new QPushButton(<span class="string">&quot;One&quot;</span>);</span><br><span class="line">QPushButton *button2 = new QPushButton(<span class="string">&quot;Two&quot;</span>);</span><br><span class="line">QPushButton *button3 = new QPushButton(<span class="string">&quot;Three&quot;</span>);</span><br><span class="line">QPushButton *button4 = new QPushButton(<span class="string">&quot;Four&quot;</span>);</span><br><span class="line">QPushButton *button5 = new QPushButton(<span class="string">&quot;Five&quot;</span>);</span><br><span class="line"></span><br><span class="line">// 创建水平布局对象</span><br><span class="line">QHBoxLayout *layout = new QHBoxLayout;</span><br><span class="line">// 将子窗口添加到布局中</span><br><span class="line">layout-&gt;addWidget(button1);</span><br><span class="line">layout-&gt;addWidget(button2);</span><br><span class="line">layout-&gt;addWidget(button3);</span><br><span class="line">layout-&gt;addWidget(button4);</span><br><span class="line">layout-&gt;addWidget(button5);</span><br><span class="line"></span><br><span class="line">// 将水平布局设置给父窗口对象</span><br><span class="line">window-&gt;setLayout(layout);</span><br><span class="line">// 显示父窗口</span><br><span class="line">window-&gt;show();</span><br></pre></td></tr></table></figure><p>代码效果展示:</p><p><img src="/img/9.99.png" alt="在这里插入图片描述"></p><hr><h3 id="2-3-3-QVBoxLayout"><a href="#2-3-3-QVBoxLayout" class="headerlink" title="2.3.3 QVBoxLayout"></a>2.3.3 QVBoxLayout</h3><blockquote><p>这个类中的常用API都是从基类继承过来的</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 创建符窗口对象</span><br><span class="line">QWidget *window = new QWidget;</span><br><span class="line">// 创建若干个子窗口对象</span><br><span class="line">QPushButton *button1 = new QPushButton(<span class="string">&quot;One&quot;</span>);</span><br><span class="line">QPushButton *button2 = new QPushButton(<span class="string">&quot;Two&quot;</span>);</span><br><span class="line">QPushButton *button3 = new QPushButton(<span class="string">&quot;Three&quot;</span>);</span><br><span class="line">QPushButton *button4 = new QPushButton(<span class="string">&quot;Four&quot;</span>);</span><br><span class="line">QPushButton *button5 = new QPushButton(<span class="string">&quot;Five&quot;</span>);</span><br><span class="line"></span><br><span class="line">// 创建垂直布局对象</span><br><span class="line">QVBoxLayout *layout = new QVBoxLayout;</span><br><span class="line">// 将子窗口添加到布局中</span><br><span class="line">layout-&gt;addWidget(button1);</span><br><span class="line">layout-&gt;addWidget(button2);</span><br><span class="line">layout-&gt;addWidget(button3);</span><br><span class="line">layout-&gt;addWidget(button4);</span><br><span class="line">layout-&gt;addWidget(button5);</span><br><span class="line"></span><br><span class="line">// 将水平布局设置给父窗口对象</span><br><span class="line">window-&gt;setLayout(layout);</span><br><span class="line">// 显示父窗口</span><br><span class="line">window-&gt;show();</span><br></pre></td></tr></table></figure><p>代码效果展示:<br><img src="/img/9.100.png" alt="在这里插入图片描述"></p><hr><h3 id="2-3-4-QGridLayout"><a href="#2-3-4-QGridLayout" class="headerlink" title="2.3.4 QGridLayout"></a>2.3.4 QGridLayout</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 构造函数</span><br><span class="line">QGridLayout::QGridLayout();</span><br><span class="line">QGridLayout::QGridLayout(QWidget *parent);</span><br><span class="line"></span><br><span class="line">// 添加窗口对象到网格布局中</span><br><span class="line">/*</span><br><span class="line">参数:</span><br><span class="line">  - widget: 添加到布局中的窗口对象</span><br><span class="line">  - row: 添加到布局中的窗口对象位于第几行 (从0开始)</span><br><span class="line">  - column: 添加到布局中的窗口对象位于第几列 (从0开始)</span><br><span class="line">  - alignment: 窗口在布局中的对齐方式, 没有特殊需求使用默认值即可</span><br><span class="line">*/</span><br><span class="line">void QGridLayout::addWidget(</span><br><span class="line">QWidget *widget, int row, int column, </span><br><span class="line">Qt::Alignment alignment = Qt::Alignment());</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">参数:</span><br><span class="line">  - widget: 添加到布局中的窗口对象</span><br><span class="line">  - fromRow: 添加到布局中的窗口对象位于第几行 (从0开始)</span><br><span class="line">  - fromColumn: 添加到布局中的窗口对象位于第几列 (从0开始)</span><br><span class="line">  - rowSpan: 添加的窗口从 fromRow 行开始跨越的行数</span><br><span class="line">  - columnSpan: 添加的窗口从 fromColumn 列开始跨越的列数</span><br><span class="line">  - alignment: 窗口在布局中的对齐方式, 没有特殊需求使用默认值即可</span><br><span class="line">*/</span><br><span class="line">void QGridLayout::addWidget(</span><br><span class="line">QWidget *widget, int fromRow, int fromColumn, </span><br><span class="line">int rowSpan, int columnSpan, </span><br><span class="line">Qt::Alignment alignment = Qt::Alignment());</span><br><span class="line"></span><br><span class="line">// 设置 column 对应的列的最新宽度, 单位: 像素</span><br><span class="line">void QGridLayout::setColumnMinimumWidth(int column, int minSize);</span><br><span class="line"></span><br><span class="line">// 设置布局中水平方向窗口之间间隔的宽度</span><br><span class="line">void QGridLayout::setHorizontalSpacing(int spacing);</span><br><span class="line"></span><br><span class="line">// 设置布局中垂直方向窗口之间间隔的宽度</span><br><span class="line">void QGridLayout::setVerticalSpacing(int spacing);</span><br></pre></td></tr></table></figure><p>测试代码如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 创建父窗口对象</span><br><span class="line">QWidget* window = new QWidget;</span><br><span class="line">// 创建子窗口对象</span><br><span class="line">QPushButton *button1 = new QPushButton(<span class="string">&quot;One&quot;</span>);</span><br><span class="line">QPushButton *button2 = new QPushButton(<span class="string">&quot;Two&quot;</span>);</span><br><span class="line">QPushButton *button3 = new QPushButton(<span class="string">&quot;Three&quot;</span>);</span><br><span class="line">QPushButton *button4 = new QPushButton(<span class="string">&quot;Four&quot;</span>);</span><br><span class="line">QPushButton *button5 = new QPushButton(<span class="string">&quot;Five&quot;</span>);</span><br><span class="line">QPushButton *button6 = new QPushButton(<span class="string">&quot;Six&quot;</span>);</span><br><span class="line">// 多行文本编辑框</span><br><span class="line">QTextEdit* txedit = new QTextEdit;</span><br><span class="line">txedit-&gt;setText(<span class="string">&quot;我占用了两行两列的空间哦。&quot;</span>);</span><br><span class="line"></span><br><span class="line">QGridLayout* layout = new QGridLayout;</span><br><span class="line">// 按钮起始位置: 第1行, 第1列, 该按钮占用空间情况为1行1列</span><br><span class="line">layout-&gt;addWidget(button1, 0, 0);</span><br><span class="line">// 按钮起始位置: 第1行, 第2列, 该按钮占用空间情况为1行1列</span><br><span class="line">layout-&gt;addWidget(button2, 0, 1);</span><br><span class="line">// 按钮起始位置: 第1行, 第3列, 该按钮占用空间情况为1行1列</span><br><span class="line">layout-&gt;addWidget(button3, 0, 2);</span><br><span class="line">// 编辑框起始位置: 第2行, 第1列, 该按钮占用空间情况为2行2列</span><br><span class="line">layout-&gt;addWidget(txedit, 1, 0, 2, 2);</span><br><span class="line">// 按钮起始位置: 第2行, 第3列, 该按钮占用空间情况为1行1列</span><br><span class="line">layout-&gt;addWidget(button4, 1, 2);</span><br><span class="line">// 按钮起始位置: 第3行, 第3列, 该按钮占用空间情况为1行1列</span><br><span class="line">layout-&gt;addWidget(button5, 2, 2);</span><br><span class="line">// 按钮起始位置: 第4行, 第1列, 该按钮占用空间情况为1行3列</span><br><span class="line">layout-&gt;addWidget(button6, 3, 0, 1, 3);</span><br><span class="line"></span><br><span class="line">// 网格布局设置给父窗口对象</span><br><span class="line">window-&gt;setLayout(layout);</span><br><span class="line">// 显示父窗口</span><br><span class="line">window-&gt;show();  </span><br></pre></td></tr></table></figure><p>测试代码效果展示:</p><p><img src="/img/9.101.png" alt="在这里插入图片描述"></p><hr>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础数据类型和信号槽</title>
      <link href="/2023/10/22/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E4%BF%A1%E5%8F%B7%E6%A7%BD/"/>
      <url>/2023/10/22/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E4%BF%A1%E5%8F%B7%E6%A7%BD/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-Qt基本结构"><a href="#1-Qt基本结构" class="headerlink" title="1. Qt基本结构"></a>1. Qt基本结构</h1><h2 id="1-1-Qt本有项目"><a href="#1-1-Qt本有项目" class="headerlink" title="1.1 Qt本有项目"></a>1.1 Qt本有项目</h2><h3 id="1-1-1-项目文件（-pro）"><a href="#1-1-1-项目文件（-pro）" class="headerlink" title="1.1.1 项目文件（.pro）"></a>1.1.1 项目文件（.pro）</h3><blockquote><p>在创建的Qt项目中自动生成了一个后缀为 .pro 的项目文件，该文件中记录着项目的一些属性信息，具体信息如下：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在项目文件中, 注释需要使用 井号(#)</span></span><br><span class="line"><span class="comment"># 项目编译的时候需要加载哪些底层模块</span></span><br><span class="line">QT       += core gui </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果当前Qt版本大于4, 会添加一个额外的模块: widgets</span></span><br><span class="line"><span class="comment"># Qt 5中对gui模块进行了拆分, 将 widgets 独立出来了</span></span><br><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 使用c++11新特性</span></span><br><span class="line">CONFIG += c++11</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果在项目中调用了废弃的函数, 项目编译的时候会有警告的提示    </span></span><br><span class="line">DEFINES += QT_DEPRECATED_WARNINGS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目中的源文件</span></span><br><span class="line">SOURCES += \</span><br><span class="line">        main.cpp \</span><br><span class="line">        mainwindow.cpp</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 项目中的头文件</span></span><br><span class="line">HEADERS += \</span><br><span class="line">        mainwindow.h</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 项目中的窗口界面文件</span></span><br><span class="line">FORMS += \</span><br><span class="line">        mainwindow.ui</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-2-main-cpp"><a href="#1-1-2-main-cpp" class="headerlink" title="1.1.2 main.cpp"></a>1.1.2 main.cpp</h3><blockquote><p>在这个源文件中有程序的入口函数 <code>main()</code>，介绍下这个文件中自动生成的几行代码：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span><span class="comment">// 生成的窗口类头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span><span class="comment">// 应用程序类头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建应用程序对象, 在一个Qt项目中实例对象有且仅有一个</span></span><br><span class="line">    <span class="comment">// 类的作用: 检测触发的事件, 进行事件循环并处理</span></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">// 创建窗口类对象</span></span><br><span class="line">    MainWindow w;</span><br><span class="line">    <span class="comment">// 显示窗口</span></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">// 应用程序对象开始事件循环, 保证应用程序不退出</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-3-mainwindow-ui"><a href="#1-1-3-mainwindow-ui" class="headerlink" title="1.1.3 mainwindow.ui"></a>1.1.3 mainwindow.ui</h3><blockquote><p>在Qt中每一个窗口都对应一个可编辑的可视化界面（*.ui）, 这个界面对应的是一个xml格式的文件,<br>一般情况下不需要在xml格式下对这个文件进行编辑, 关于这个文件结构了解即可。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 双击这个文件看到的是一个窗口界面, 如果使用文本编辑器打开看到的是一个XML格式的文件--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 看不懂这种格式没关系, 我们不需要在这种模式下操作这个文件。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里只是给大家介绍这个文件的本质 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ui</span> <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">class</span>&gt;</span>MainWindow<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QMainWindow&quot;</span> <span class="attr">name</span>=<span class="string">&quot;MainWindow&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">x</span>&gt;</span>0<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">y</span>&gt;</span>0<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">width</span>&gt;</span>800<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">height</span>&gt;</span>600<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;windowTitle&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">string</span>&gt;</span>MainWindow<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QWidget&quot;</span> <span class="attr">name</span>=<span class="string">&quot;centralwidget&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QMenuBar&quot;</span> <span class="attr">name</span>=<span class="string">&quot;menubar&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QStatusBar&quot;</span> <span class="attr">name</span>=<span class="string">&quot;statusbar&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">resources</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">connections</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ui</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="1-1-4-mainwindow-h"><a href="#1-1-4-mainwindow-h" class="headerlink" title="1.1.4 mainwindow.h"></a>1.1.4 mainwindow.h</h3><blockquote><p>这个文件是窗口界面对应的类的头文件。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span><span class="comment">// Qt标准窗口类头文件</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="comment">// mainwindow.ui 文件中也有一个类叫 MainWindow, 将这个类放到命名空间 Ui 中</span></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">MainWindow</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT<span class="comment">// 这个宏是为了能够使用Qt中的信号槽机制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;<span class="comment">// 定义指针指向窗口的 UI 对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><hr><h3 id="1-1-5-mainwindow-cpp"><a href="#1-1-5-mainwindow-cpp" class="headerlink" title="1.1.5 mainwindow.cpp"></a>1.1.5 mainwindow.cpp</h3><blockquote><p>这个文件是窗口界面对应的类的源文件。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)<span class="comment">// 基于mainwindow.ui创建一个实例对象</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将 mainwindow.ui 的实例对象和 当前类的对象进行关联</span></span><br><span class="line">    <span class="comment">// 这样同名的连个类对象就产生了关联, 合二为一了</span></span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-2-Qt中的窗口类"><a href="#1-2-Qt中的窗口类" class="headerlink" title="1.2 Qt中的窗口类"></a>1.2 Qt中的窗口类</h2><blockquote><p>在通过Qt向导窗口基于窗口的应用程序的项目过程中倒数第二步选择跟随项目创建的第一个窗口的基类, 下拉菜单有三个选项, 分别为:<br><code>QMainWindow</code>、<code>QDialog</code>、<code>QWidget</code>如下图：</p></blockquote><h3 id="1-2-1基础窗口类"><a href="#1-2-1基础窗口类" class="headerlink" title="1.2.1基础窗口类"></a>1.2.1基础窗口类</h3><p><img src="/img/9.49.png" alt="在这里插入图片描述"></p><ul><li>常用的窗口类有3个<ul><li>在创建Qt窗口的时候, 需要让自己的窗口类继承上述三个窗口类的其中一个</li></ul></li><li>QWidget<ul><li>所有窗口类的基类</li><li>Qt中的控件(按钮, 输入框, 单选框…)也属于窗口, 基类都是QWidget</li><li>可以内嵌到其他窗口中: 没有边框</li><li>可以不内嵌单独显示: 独立的窗口, 有边框</li></ul></li><li>QDialog<ul><li>对话框类, 后边的章节会具体介绍这个窗口</li><li>不能内嵌到其他窗口中</li></ul></li><li>QMainWindow<ul><li>有工具栏, 状态栏, 菜单栏, 后边的章节会具体介绍这个窗口</li><li>不能内嵌到其他窗口中</li></ul></li></ul><hr><h3 id="1-2-2-窗口的显示"><a href="#1-2-2-窗口的显示" class="headerlink" title="1.2.2 窗口的显示"></a>1.2.2 窗口的显示</h3><ul><li>内嵌窗口<ul><li>依附于某一个大的窗口, 作为了大窗口的一部分</li><li>大窗口就是这个内嵌窗口的父窗口</li><li>父窗口显示的时候, 内嵌的窗口也就被显示出来了</li></ul></li><li>不内嵌窗口<ul><li>这类窗口有边框, 有标题栏</li><li>需要调用函数才可以显示</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QWidget是所有窗口类的基类, 调用这个提供的 show() 方法就可以显示将任何窗口显示出来</span></span><br><span class="line"><span class="comment">// 非模态显示</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::show</span><span class="params">()</span></span>;<span class="comment">// 显示当前窗口和它的子窗口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对话框窗口的非模态显示: 还是调用show() 方法</span></span><br><span class="line"><span class="comment">// 对话框窗口的模态显示</span></span><br><span class="line">[<span class="keyword">virtual</span> slot] <span class="function"><span class="type">int</span> <span class="title">QDialog::exec</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="1-3-内存回收"><a href="#1-3-内存回收" class="headerlink" title="1.3 内存回收"></a>1.3 内存回收</h2><blockquote><p>在Qt中创建对象的时候会提供一个 <code>Parent对象指针</code>（可以查看类的构造函数），parent是干什么的?<br>.<br>QObject是以对象树的形式组织起来的。<code>当你创建一个QObject对象时，会看到QObject的构造函数接收一个QObject指针作为参数，这个参数就是parent，也就是父对象指针。</code><br>这相当于，在创建QObject对象时，可以提供一个其父对象，我们创建的这个QObject对象会自动添加到其父对象的children()列表。当父对象析构的时候，这个列表中的所有对象也会被析构。（<code>这里的父对象并不是继承意义上的父类</code>）</p><p>QWidget是能够在屏幕上显示的一切组件的父类。QWidget继承自QObject，因此也继承了这种对象树关系。一个孩子自动地成为父组件的一个子组件。因此，它会显示在父组件的坐标系统中，被父组件的边界剪裁。例如，当用户关闭一个对话框的时候，应用程序将其删除，那么，我们希望属于这个对话框的按钮、图标等应该一起被删除。事实就是如此，因为这些都是对话框的子组件。<br>Qt 引入对象树的概念，在一定程度上解决了内存问题。</p><ul><li>当一个QObject对象在堆上创建的时候，Qt会同时为其创建一个对象树。不过，对象树中对象的顺序是没有定义的。这意味着，销毁这些对象的顺序也是未定义的。</li><li>任何对象树中的 QObject对象 delete 的时候，如果这个对象有 parent，则自动将其从 parent<br>的children()列表中删除；如果有孩子，则自动 delete 每一个孩子。Qt 保证没有QObject会被 delete两次，这是由析构顺序决定的。</li></ul></blockquote><p><img src="/img/9.50.png" alt="在这里插入图片描述"></p><p>综上所述, 我们可以得到一个结论: <code>Qt中有内存回收机制, 但是不是所有被new出的对象被自动回收, 满足条件才可以回收</code>, 如果想要在Qt中实现内存的自动回收, 需要满足以下两个条件:</p><ul><li>创建的对象必须是QObject类的子类(间接子类也可以)<ul><li>QObject类是没有父类的, Qt中有很大一部分类都是从这个类派生出去的<ul><li>Qt中使用频率很高的窗口类和控件都是 QObject 的直接或间接的子类</li><li>其他的类可以自己查阅Qt帮助文档</li></ul></li></ul></li><li>创建出的类对象, 必须要指定其父对象是谁, 一般情况下有两种操作方式:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1: 通过构造函数</span></span><br><span class="line"><span class="comment">// parent: 当前窗口的父对象, 找构造函数中的 parent 参数即可</span></span><br><span class="line">QWidget::<span class="built_in">QWidget</span>(QWidget *parent = Q_NULLPTR, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line">QTimer::<span class="built_in">QTimer</span>(QObject *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2: 通过setParent()方法</span></span><br><span class="line"><span class="comment">// 假设这个控件没有在构造的时候指定符对象, 可以调用QWidget的api指定父窗口对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setParent</span><span class="params">(QWidget *parent)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QObject::setParent</span><span class="params">(QObject *parent)</span></span>;</span><br></pre></td></tr></table></figure><hr><h1 id="2-Qt中的基础数据类型"><a href="#2-Qt中的基础数据类型" class="headerlink" title="2. Qt中的基础数据类型"></a>2. Qt中的基础数据类型</h1><p>主要介绍Qt中常用数据类型, 主要内容包括: <code>基础数据类型</code>, <code>Log日志输出</code>, <code>字符串类型</code>, <code>QVariant</code>, <code>位置和尺寸相关类型</code>, <code>日期和时间相关类型</code>。 </p><h2 id="2-1-基础类型"><a href="#2-1-基础类型" class="headerlink" title="2.1 基础类型"></a>2.1 基础类型</h2><p>因为Qt是一个C++ 框架, 因此C++中所有的语法和数据类型在Qt中都是被支持的, 但是Qt中也定义了一些属于自己的数据类型, 介绍一下这些基础的数类型。</p><p>QT基本数据类型定义在<code>#include &lt;QtGlobal&gt;</code> 中，QT基本数据类型有：</p><table><thead><tr><th>类型名称</th><th>注释</th><th>备注</th></tr></thead><tbody><tr><td>qint8</td><td>signed char</td><td>有符号8位数据</td></tr><tr><td>qint16</td><td>signed short</td><td>16位数据类型</td></tr><tr><td>qint32</td><td>signed short</td><td>32位有符号数据类型</td></tr><tr><td>qint64</td><td>long long int 或 (__int64)</td><td>64位有符号数据类型，Windows中定义为__int64</td></tr><tr><td>qintptr</td><td>qint32 或 qint64</td><td>指针类型 根据系统类型不同而不同，32位系统为qint32、64位系统为qint64</td></tr><tr><td>qlonglong</td><td>long long int 或 (__int64)</td><td>Windows中定义为__int64</td></tr><tr><td>qptrdiff</td><td>qint32 或 qint64</td><td>根据系统类型不同而不同，32位系统为qint32、64位系统为qint64</td></tr><tr><td>qreal</td><td>double 或 float</td><td>除非配置了-qreal float选项，否则默认为double</td></tr><tr><td>quint8</td><td>unsigned char</td><td>无符号8位数据类型</td></tr><tr><td>quint16</td><td>unsigned short</td><td>无符号16位数据类型</td></tr><tr><td>quint32</td><td>unsigned int</td><td>无符号32位数据类型</td></tr><tr><td>quint64</td><td>unsigned long long int 或 (unsigned __int64)</td><td>无符号64比特数据类型，Windows中定义为unsigned __int64</td></tr><tr><td>quintptr</td><td>quint32 或 quint64</td><td>根据系统类型不同而不同，32位系统为quint32、64位系统为quint64</td></tr><tr><td>qulonglong</td><td>unsigned long long int 或 (unsigned __int64)</td><td>Windows中定义为__int64</td></tr><tr><td>uchar</td><td>unsigned char</td><td>无符号字符类型</td></tr><tr><td>uint</td><td>unsigned int</td><td>无符号整型</td></tr><tr><td>ulong</td><td>unsigned long</td><td>无符号长整型</td></tr><tr><td>ushort</td><td>unsigned short</td><td>无符号短整型</td></tr></tbody></table><p><code>虽然在Qt中有属于自己的整形或者浮点型, 但是在变成过程中这些一般不用, 常用的类型关键字还是 C/C++中的 int, float, double 等。</code></p><hr><h2 id="2-2-log输出"><a href="#2-2-log输出" class="headerlink" title="2.2 log输出"></a>2.2 log输出</h2><h3 id="2-2-1-在调试窗口中输入日志"><a href="#2-2-1-在调试窗口中输入日志" class="headerlink" title="2.2.1 在调试窗口中输入日志"></a>2.2.1 在调试窗口中输入日志</h3><blockquote><p>在Qt中进行log输出, 一般不使用c中的<code>printf</code>, 也不是使用C++中的<code>cout</code><br>Qt框架提供了专门用于日志输出的类, 头文件名为<code>QDebug</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含了QDebug头文件, 直接通过全局函数 qDebug() 就可以进行日志输出了</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Date:&quot;</span> &lt;&lt; QDate::<span class="built_in">currentDate</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Types:&quot;</span> &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;String&quot;</span>) &lt;&lt; <span class="built_in">QChar</span>(<span class="string">&#x27;x&#x27;</span>)&lt;&lt;<span class="built_in">QRect</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">40</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Custom coordinate type:&quot;</span> &lt;&lt; coordinate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和全局函数 qDebug() 类似的日志函数还有: qWarning(), qInfo(), qCritical()</span></span><br><span class="line"><span class="type">int</span> number = <span class="number">666</span>;</span><br><span class="line"><span class="type">float</span> i = <span class="number">11.11</span>;</span><br><span class="line"><span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;Number:&quot;</span> &lt;&lt; number &lt;&lt; <span class="string">&quot;Other value:&quot;</span> &lt;&lt; i;</span><br><span class="line"><span class="built_in">qInfo</span>() &lt;&lt; <span class="string">&quot;Number:&quot;</span> &lt;&lt; number &lt;&lt; <span class="string">&quot;Other value:&quot;</span> &lt;&lt; i;</span><br><span class="line"><span class="built_in">qCritical</span>() &lt;&lt; <span class="string">&quot;Number:&quot;</span> &lt;&lt; number &lt;&lt; <span class="string">&quot;Other value:&quot;</span> &lt;&lt; i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;我是要成为海贼王的男人!!!&quot;</span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;我是隔壁的二柱子...&quot;</span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;我是鸣人, 我擅长嘴遁!!!&quot;</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-2-2-在终端窗口中输出日志"><a href="#2-2-2-在终端窗口中输出日志" class="headerlink" title="2.2.2 在终端窗口中输出日志"></a>2.2.2 在终端窗口中输出日志</h3><blockquote><p>使用上面的方法只能在项目调试过程中进行日志输出, 如果不是通过IDE进行程序调试, 而是直接执行可执行程序在这种情况下是没有日志输出窗口的,因此也就看不到任何的日志输出。</p><p>默认情况下日志信息是不会打印到终端窗口的, 如果想要实现这样的效果, 必须在项目文件中添加相关的属性信息</p></blockquote><p>打开项目文件（*.pro）找到配置项 config, 添加 console 控制台属性:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG += c++11 console</span><br></pre></td></tr></table></figure><hr><h2 id="2-3-字符串类型"><a href="#2-3-字符串类型" class="headerlink" title="2.3 字符串类型"></a>2.3 字符串类型</h2><p>在Qt中不仅支持C, C++中的字符串类型, 而且还在框架中定义了专属的字符串类型,<br>必须要掌握在Qt中关于这些类型的使用和相互之间的转换。</p><table><thead><tr><th>语言类型</th><th>字符串类型</th></tr></thead><tbody><tr><td>C</td><td><code>char*</code></td></tr><tr><td>C++</td><td><code>std::string</code>, <code>char*</code></td></tr><tr><td>Qt</td><td><code>QByteArray</code>, <code>QString</code></td></tr></tbody></table><h3 id="2-3-1-QByteArray"><a href="#2-3-1-QByteArray" class="headerlink" title="2.3.1 QByteArray"></a>2.3.1 QByteArray</h3><blockquote><p>在Qt中<code>QByteArray</code>可以看做是c语言中<code>char*</code>的升级版本。我们在使用这种类型的时候可通过这个类的构造函数申请一块动态内存，用于存储我们需要处理的字符串数据。<br>介绍一下这个类中常用的一些API函数</p></blockquote><p><strong>构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造空对象, 里边没有数据</span></span><br><span class="line">QByteArray::<span class="built_in">QByteArray</span>();</span><br><span class="line"><span class="comment">// 将data中的size个字符进行构造, 得到一个字节数组对象</span></span><br><span class="line"><span class="comment">// 如果 size==-1 函数内部自动计算字符串长度, 计算方式为: strlen(data)</span></span><br><span class="line">QByteArray::<span class="built_in">QByteArray</span>(<span class="type">const</span> <span class="type">char</span> *data, <span class="type">int</span> size = <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 构造一个长度为size个字节, 并且每个字节值都为ch的字节数组</span></span><br><span class="line">QByteArray::<span class="built_in">QByteArray</span>(<span class="type">int</span> size, <span class="type">char</span> ch);</span><br></pre></td></tr></table></figure><p><strong>数据操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在尾部追加数据</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::append</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::push_back</span><span class="params">(<span class="type">const</span> QByteArray &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头部添加数据</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::prepend</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::push_front</span><span class="params">(<span class="type">const</span> QByteArray &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据, 将ba插入到数组第 i 个字节的位置(从0开始)</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="comment">// 从大字符串中删除len个字符, 从第pos个字符的位置开始删除</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::remove</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> len)</span></span>;</span><br><span class="line"><span class="comment">// 从字符数组的尾部删除 n 个字节</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::chop</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 从字节数组的 pos 位置将数组截断 (前边部分留下, 后边部分被删除)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::truncate</span><span class="params">(<span class="type">int</span> pos)</span></span>;</span><br><span class="line"><span class="comment">// 将对象中的数据清空, 使其为null</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换</span></span><br><span class="line"><span class="comment">// 将字节数组中的 子字符串 before 替换为 after</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::replace</span><span class="params">(<span class="type">const</span> QByteArray &amp;before, <span class="type">const</span> QByteArray &amp;after)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>子字符串查找和判断</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断字节数组中是否包含子字符串 ba, 包含返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::contains</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::contains</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断字节数组中是否包含子字符 ch, 包含返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::contains</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字节数组是否以字符串 ba 开始, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::startsWith</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::startsWith</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断字节数组是否以字符 ch 开始, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::startsWith</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字节数组是否以字符串 ba 结尾, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::endsWith</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::endsWith</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断字节数组是否以字符 ch 结尾, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::endsWith</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong>遍历</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">QByteArray::begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">QByteArray::end</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组的方式进行遍历</span></span><br><span class="line"><span class="comment">// i的取值范围 0 &lt;= i &lt; size()</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">QByteArray::at</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="type">char</span> QByteArray::<span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>;</span><br></pre></td></tr></table></figure><p><strong>查看字节数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字节数组对象中字符的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字节数组对象中 子字符串ba 出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回字节数组对象中 字符串ch 出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong>类型转换</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将QByteArray类型的字符串 转换为 char* 类型</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">QByteArray::data</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">QByteArray::data</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int, short, long, float, double -&gt; QByteArray</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">short</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(qlonglong n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">float</span> n, <span class="type">char</span> f = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> prec = <span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> f = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> prec = <span class="number">6</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::number</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::number</span><span class="params">(qlonglong n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::number</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> f = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> prec = <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QByteArray -&gt; int, short, long, float, double</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::toInt</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">QByteArray::toShort</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">QByteArray::toLong</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">QByteArray::toFloat</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">QByteArray::toDouble</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::string -&gt; QByteArray</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::fromStdString</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span>;</span><br><span class="line"><span class="comment">// QByteArray -&gt; std::string</span></span><br><span class="line"><span class="function">std::string <span class="title">QByteArray::toStdString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有字符转换为大写</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QByteArray::toUpper</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 所有字符转换为小写</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QByteArray::toLower</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-2-QString"><a href="#2-3-2-QString" class="headerlink" title="2.3.2 QString"></a>2.3.2 QString</h3><blockquote><p>QString也是封装了字符串, 但是内部的编码为<code>utf8</code>, UTF-8属于Unicode字符集,<code>它固定使用多个字节（window为2字节, linux为3字节）来表示一个字符</code>，这样可以将世界上几乎所有语言的常用字符收录其中。<br>介绍一下这个类中常用的一些API函数。</p></blockquote><p><strong>构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个空字符串对象</span></span><br><span class="line">QString::<span class="built_in">QString</span>();</span><br><span class="line"><span class="comment">// 将 char* 字符串 转换为 QString 类型</span></span><br><span class="line">QString::<span class="built_in">QString</span>(<span class="type">const</span> <span class="type">char</span> *str);</span><br><span class="line"><span class="comment">// 将 QByteArray 转换为 QString 类型</span></span><br><span class="line">QString::<span class="built_in">QString</span>(<span class="type">const</span> QByteArray &amp;ba);</span><br><span class="line"><span class="comment">// 其他重载的同名构造函数可参考Qt帮助文档, 此处略</span></span><br></pre></td></tr></table></figure><p><strong>数据操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾部追加数据</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::append</span><span class="params">(<span class="type">const</span> QString &amp;str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::append</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::push_back</span><span class="params">(<span class="type">const</span> QString &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头部添加数据</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::prepend</span><span class="params">(<span class="type">const</span> QString &amp;str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::prepend</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::prepend</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::push_front</span><span class="params">(<span class="type">const</span> QString &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据, 将 str 插入到字符串第 position 个字符的位置(从0开始)</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::insert</span><span class="params">(<span class="type">int</span> position, <span class="type">const</span> QString &amp;str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::insert</span><span class="params">(<span class="type">int</span> position, <span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::insert</span><span class="params">(<span class="type">int</span> position, <span class="type">const</span> QByteArray &amp;str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="comment">// 从大字符串中删除len个字符, 从第pos个字符的位置开始删除</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::remove</span><span class="params">(<span class="type">int</span> position, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串的尾部删除 n 个字符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::chop</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 从字节串的 position 位置将字符串截断 (前边部分留下, 后边部分被删除)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::truncate</span><span class="params">(<span class="type">int</span> position)</span></span>;</span><br><span class="line"><span class="comment">// 将对象中的数据清空, 使其为null</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换</span></span><br><span class="line"><span class="comment">// 将字节数组中的 子字符串 before 替换为 after</span></span><br><span class="line"><span class="comment">// 参数 cs 为是否区分大小写, 默认区分大小写</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::replace</span><span class="params">(<span class="type">const</span> QString &amp;before, <span class="type">const</span> QString &amp;after, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>子字符串查找和判断</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 cs 为是否区分大小写, 默认区分大小写</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串中是否包含子字符串 str, 包含返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QString::contains</span><span class="params">(<span class="type">const</span> QString &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串是否以字符串 ba 开始, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QString::startsWith</span><span class="params">(<span class="type">const</span> QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串是否以字符串 ba 结尾, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QString::endsWith</span><span class="params">(<span class="type">const</span> QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong>遍历</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">QString::begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">QString::end</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组的方式进行遍历</span></span><br><span class="line"><span class="comment">// i的取值范围 0 &lt;= position &lt; size()</span></span><br><span class="line"><span class="function"><span class="type">const</span> QChar <span class="title">QString::at</span><span class="params">(<span class="type">int</span> position)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> QChar QString::<span class="keyword">operator</span>[]<span class="params">(<span class="type">int</span> position)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong>查看字节数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字节数组对象中字符的个数 (字符个数和字节个数是不同的概念)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字节串对象中 子字符串 str 出现的次数</span></span><br><span class="line"><span class="comment">// 参数 cs 为是否区分大小写, 默认区分大小写</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::count</span><span class="params">(<span class="type">const</span> QStringRef &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong>类型转换</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将int, short, long, float, double 转换为 QString 类型</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">short</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">float</span> n, <span class="type">char</span> format = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> precision = <span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> format = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> precision = <span class="number">6</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::number</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::number</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::number</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> format = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> precision = <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 QString 转换为 int, short, long, float, double 类型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::toInt</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">QString::toShort</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">QString::toLong</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">QString::toFloat</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">QString::toDouble</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将标准C++中的 std::string 类型 转换为 QString 类型</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::fromStdString</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span>;</span><br><span class="line"><span class="comment">// 将 QString 转换为 标准C++中的 std::string 类型</span></span><br><span class="line"><span class="function">std::string <span class="title">QString::toStdString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QString -&gt; QByteArray</span></span><br><span class="line"><span class="comment">// 转换为本地编码, 跟随操作系统</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QString::toLocal8Bit</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 转换为 Latin-1 编码的字符串 不支持中文</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QString::toLatin1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 转换为 utf8 编码格式的字符串 (常用)</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QString::toUtf8</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有字符转换为大写</span></span><br><span class="line"><span class="function">QString <span class="title">QString::toUpper</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 所有字符转换为小写</span></span><br><span class="line"><span class="function">QString <span class="title">QString::toLower</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong>字符串格式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString <span class="title">QString::arg</span><span class="params">(<span class="type">const</span> QString &amp;a, </span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">int</span> fieldWidth = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">          QChar fillChar = QLatin1Char( <span class="string">&#x27; &#x27;</span> ))</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QString <span class="title">QString::arg</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> fieldWidth = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">int</span> base = <span class="number">10</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">          QChar fillChar = QLatin1Char( <span class="string">&#x27; &#x27;</span> ))</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例程序</span></span><br><span class="line"><span class="type">int</span> i;                <span class="comment">// 假设该变量表示当前文件的编号</span></span><br><span class="line"><span class="type">int</span> total;            <span class="comment">// 假设该变量表示文件的总个数</span></span><br><span class="line">QString fileName;     <span class="comment">// 假设该变量表示当前文件的名字</span></span><br><span class="line"><span class="comment">// 使用以上三个变量拼接一个动态字符串</span></span><br><span class="line">QString status = <span class="built_in">QString</span>(<span class="string">&quot;Processing file %1 of %2: %3&quot;</span>)</span><br><span class="line">                  .<span class="built_in">arg</span>(i).<span class="built_in">arg</span>(total).<span class="built_in">arg</span>(fileName);</span><br></pre></td></tr></table></figure><hr><h2 id="2-4-QVariant"><a href="#2-4-QVariant" class="headerlink" title="2.4 QVariant"></a>2.4 QVariant</h2><blockquote><p>QVariant这个类很神奇，或者说方便。很多时候，需要几种不同的数据类型需要传递，如果用结构体，又不大方便，容器保存的也只是一种数据类型，而QVariant则可以统统搞定。<br>QVariant 这个类型充当着最常见的数据类型的联合。QVariant可以保存很多Qt的数据类型，包括<code>QBrush、QColor、QCursor、QDateTime、QFont、QKeySequence、QPalette、QPen、QPixmap、QPoint、QRect、QRegion、QSize和QString</code>，并且还有C++基本类型，如<code>int、float</code>等。</p></blockquote><h3 id="2-4-1-标准类型"><a href="#2-4-1-标准类型" class="headerlink" title="2.4.1 标准类型"></a>2.4.1 标准类型</h3><ul><li>将标准类型转换为QVariant类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这类转换需要使用QVariant类的构造函数, 由于比较多, 大家可自行查阅Qt帮助文档, 在这里简单写几个</span></span><br><span class="line">QVariant::<span class="built_in">QVariant</span>(<span class="type">int</span> val);</span><br><span class="line">QVariant::<span class="built_in">QVariant</span>(<span class="type">bool</span> val);</span><br><span class="line">QVariant::<span class="built_in">QVariant</span>(<span class="type">double</span> val);</span><br><span class="line">QVariant::<span class="built_in">QVariant</span>(<span class="type">const</span> <span class="type">char</span> *val);</span><br><span class="line">QVariant::<span class="built_in">QVariant</span>(<span class="type">const</span> QByteArray &amp;val);</span><br><span class="line">QVariant::<span class="built_in">QVariant</span>(<span class="type">const</span> QString &amp;val);</span><br><span class="line">......</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用设置函数也可以将支持的类型的数据设置到QVariant对象中</span></span><br><span class="line"><span class="comment">// 这里的 T 类型, 就是QVariant支持的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QVariant::setValue</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span>;</span><br><span class="line"><span class="comment">// 该函数行为和 setValue() 函数完全相同</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QVariant <span class="title">QVariant::fromValue</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span>;</span><br><span class="line"><span class="comment">// 例子:</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">QVariant v;</span><br><span class="line">v.<span class="built_in">setValue</span>(<span class="number">5</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">QVariant v = QVariant::<span class="built_in">fromValue</span>(<span class="number">5</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = v.<span class="built_in">toInt</span>();          <span class="comment">// i is now 5</span></span><br><span class="line">QString s = v.<span class="built_in">toString</span>();   <span class="comment">// s is now &quot;5&quot;</span></span><br></pre></td></tr></table></figure><ul><li>判断 QVariant中封装的实际数据类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数的返回值是一个枚举类型, 可通过这个枚举判断出实际是什么类型的数据</span></span><br><span class="line"><span class="function">Type <span class="title">QVariant::type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>返回值Type的部分枚举定义, 全部信息可查阅Qt帮助文档</p></blockquote><p><img src="/img/9.5n.png" alt="在这里插入图片描述"></p><ul><li>将QVariant对象转换为实际的数据类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果要实现该操作, 可以使用QVariant类提供的 toxxx() 方法, 全部转换可以参考Qt帮助文档</span></span><br><span class="line"><span class="comment">// 在此举列举几个常用函数:</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QVariant::toBool</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QByteArray <span class="title">QVariant::toByteArray</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">QVariant::toDouble</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">QVariant::toFloat</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QVariant::toInt</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QString <span class="title">QVariant::toString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><hr><h3 id="2-4-2-自定义类型"><a href="#2-4-2-自定义类型" class="headerlink" title="2.4.2 自定义类型"></a>2.4.2 自定义类型</h3><blockquote><p>除标准类型, 自定义的类型也可以使用<code>QVariant</code>类进行封装,<code>被QVariant存储的数据类型需有一个默认的构造函数和一个拷贝构造函数</code>。为实现此功能，首先必须使用<code>Q_DECLARE_METATYPE()</code>宏。<br>通常会将这个宏放在类的声明所在头文件的下面，原型为<br><code>Q_DECLARE_METATYPE(Type)</code></p></blockquote><p>使用步骤如下:</p><ul><li>第一步: 在头文件中声明</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    QString name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 自定义类型注册</span></span><br><span class="line"><span class="built_in">Q_DECLARE_METATYPE</span>(MyTest)</span><br></pre></td></tr></table></figure><ul><li>第二步: 在源文件中定义</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MyTest t;</span><br><span class="line">t.name = <span class="string">&quot;张三丰&quot;</span>;</span><br><span class="line">t.num = <span class="number">666</span>;</span><br><span class="line"><span class="comment">// 值的封装</span></span><br><span class="line">QVariant vt = QVariant::<span class="built_in">fromValue</span>(t);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值的读取</span></span><br><span class="line"><span class="keyword">if</span>(vt.<span class="built_in">canConvert</span>&lt;MyTest&gt;())</span><br><span class="line">&#123;</span><br><span class="line">    MyTest t = vt.<span class="built_in">value</span>&lt;MyTest&gt;();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; t.name &lt;&lt; <span class="string">&quot;, num: &quot;</span> &lt;&lt; t.num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上操作用到的<code>QVariant</code>类的API如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果当前QVariant对象可用转换为对应的模板类型 T, 返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QVariant::canConvert</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 将当前QVariant对象转换为实际的 T 类型</span></span><br><span class="line"><span class="function">T <span class="title">QVariant::value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="2-5-位置和尺寸"><a href="#2-5-位置和尺寸" class="headerlink" title="2.5 位置和尺寸"></a>2.5 位置和尺寸</h2><h3 id="2-5-1-QPoint"><a href="#2-5-1-QPoint" class="headerlink" title="2.5.1 QPoint"></a>2.5.1 QPoint</h3><blockquote><p>QPoint类封装了我们常用用到的坐标点 (x, y), 常用的 API如下:</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 构造一个坐标原点, 即(0, 0)</span></span><br><span class="line">QPoint::<span class="built_in">QPoint</span>();</span><br><span class="line"><span class="comment">// 参数为 x轴坐标, y轴坐标</span></span><br><span class="line">QPoint::<span class="built_in">QPoint</span>(<span class="type">int</span> xpos, <span class="type">int</span> ypos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置x轴坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPoint::setX</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">// 设置y轴坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPoint::setY</span><span class="params">(<span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到x轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QPoint::x</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到x轴坐标的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QPoint::rx</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 得到y轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QPoint::y</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到y轴坐标的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QPoint::ry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接通过坐标对象进行算术运算: 加减乘除</span></span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>*=(<span class="type">float</span> factor);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>*=(<span class="type">double</span> factor);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>*=(<span class="type">int</span> factor);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>+=(<span class="type">const</span> QPoint &amp;point);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>-=(<span class="type">const</span> QPoint &amp;point);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>/=(qreal divisor);</span><br></pre></td></tr></table></figure><hr><h3 id="2-5-2-QLine"><a href="#2-5-2-QLine" class="headerlink" title="2.5.2 QLine"></a>2.5.2 QLine</h3><blockquote><p>QLine是一个直线类, 封装了两个坐标点 (两点确定一条直线)</p></blockquote><p>常用API如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 构造一个空对象</span></span><br><span class="line">QLine::<span class="built_in">QLine</span>();</span><br><span class="line"><span class="comment">// 构造一条直线, 通过两个坐标点</span></span><br><span class="line">QLine::<span class="built_in">QLine</span>(<span class="type">const</span> QPoint &amp;p1, <span class="type">const</span> QPoint &amp;p2);</span><br><span class="line"><span class="comment">// 从点 (x1, y1) 到 (x2, y2)</span></span><br><span class="line">QLine::<span class="built_in">QLine</span>(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给直线对象设置坐标点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setPoints</span><span class="params">(<span class="type">const</span> QPoint &amp;p1, <span class="type">const</span> QPoint &amp;p2)</span></span>;</span><br><span class="line"><span class="comment">// 起始点(x1, y1), 终点(x2, y2)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setLine</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span>;</span><br><span class="line"><span class="comment">// 设置直线的起点坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setP1</span><span class="params">(<span class="type">const</span> QPoint &amp;p1)</span></span>;</span><br><span class="line"><span class="comment">// 设置直线的终点坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setP2</span><span class="params">(<span class="type">const</span> QPoint &amp;p2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回直线的起始点坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QLine::p1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回直线的终点坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QLine::p2</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值直线的中心点坐标, (p1() + p2()) / 2</span></span><br><span class="line"><span class="function">QPoint <span class="title">QLine::center</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值直线起点的 x 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::x1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值直线终点的 x 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::x2</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值直线起点的 y 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::y1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值直线终点的 y 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::y2</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用给定的坐标点平移这条直线</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::translate</span><span class="params">(<span class="type">const</span> QPoint &amp;offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::translate</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy)</span></span>;</span><br><span class="line"><span class="comment">// 用给定的坐标点平移这条直线, 返回平移之后的坐标点</span></span><br><span class="line"><span class="function">QLine <span class="title">QLine::translated</span><span class="params">(<span class="type">const</span> QPoint &amp;offset)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QLine <span class="title">QLine::translated</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直线对象进行比较</span></span><br><span class="line"><span class="type">bool</span> QLine::<span class="keyword">operator</span>!=(<span class="type">const</span> QLine &amp;line) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QLine::<span class="keyword">operator</span>==(<span class="type">const</span> QLine &amp;line) <span class="type">const</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-5-3-QSize"><a href="#2-5-3-QSize" class="headerlink" title="2.5.3 QSize"></a>2.5.3 QSize</h3><blockquote><p>在QT中QSize类用来形容长度和宽度</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 构造空对象, 对象中的宽和高都是无效的</span></span><br><span class="line">QSize::<span class="built_in">QSize</span>();</span><br><span class="line"><span class="comment">// 使用宽和高构造一个有效对象</span></span><br><span class="line">QSize::<span class="built_in">QSize</span>(<span class="type">int</span> width, <span class="type">int</span> height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSize::setWidth</span><span class="params">(<span class="type">int</span> width)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置高度</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSize::setHeight</span><span class="params">(<span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QSize::width</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到宽度的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QSize::rwidth</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 得到高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QSize::height</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到高度的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QSize::rheight</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换高度和宽度的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSize::transpose</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 交换高度和宽度的值, 返回交换之后的尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">QSize::transposed</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行算法运算: 加减乘除</span></span><br><span class="line">QSize &amp;QSize::<span class="keyword">operator</span>*=(qreal factor);</span><br><span class="line">QSize &amp;QSize::<span class="keyword">operator</span>+=(<span class="type">const</span> QSize &amp;size);</span><br><span class="line">QSize &amp;QSize::<span class="keyword">operator</span>-=(<span class="type">const</span> QSize &amp;size);</span><br><span class="line">QSize &amp;QSize::<span class="keyword">operator</span>/=(qreal divisor);</span><br></pre></td></tr></table></figure><hr><h3 id="2-5-4-QRect"><a href="#2-5-4-QRect" class="headerlink" title="2.5.4 QRect"></a>2.5.4 QRect</h3><blockquote><p>在Qt中使用 QRect类来描述一个矩形</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 构造一个空对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>();</span><br><span class="line"><span class="comment">// 基于左上角坐标, 和右下角坐标构造一个矩形对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>(<span class="type">const</span> QPoint &amp;topLeft, <span class="type">const</span> QPoint &amp;bottomRight);</span><br><span class="line"><span class="comment">// 基于左上角坐标, 和 宽度, 高度构造一个矩形对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>(<span class="type">const</span> QPoint &amp;topLeft, <span class="type">const</span> QSize &amp;size);</span><br><span class="line"><span class="comment">// 通过 左上角坐标(x, y), 和 矩形尺寸(width, height) 构造一个矩形对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置矩形的尺寸信息, 左上角坐标不变</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setSize</span><span class="params">(<span class="type">const</span> QSize &amp;size)</span></span>;</span><br><span class="line"><span class="comment">// 设置矩形左上角坐标为(x,y), 大小为(width, height)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="comment">// 设置矩形宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setWidth</span><span class="params">(<span class="type">int</span> width)</span></span>;</span><br><span class="line"><span class="comment">// 设置矩形高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setHeight</span><span class="params">(<span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值矩形左上角坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::topLeft</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形右上角坐标</span></span><br><span class="line"><span class="comment">// 该坐标点值为: QPoint(left() + width() -1, top())</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::topRight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形左下角坐标</span></span><br><span class="line"><span class="comment">// 该坐标点值为: QPoint(left(), top() + height() - 1)</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::bottomLeft</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形右下角坐标</span></span><br><span class="line"><span class="comment">// 该坐标点值为: QPoint(left() + width() -1, top() + height() - 1)</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::bottomRight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形中心点坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::center</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回矩形上边缘y轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::top</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::y</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值矩形下边缘y轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::bottom</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形左边缘 x轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::x</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::left</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形右边缘x轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::right</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回矩形的高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::width</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形的宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::height</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形的尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">QRect::size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="2-6-日期和时间"><a href="#2-6-日期和时间" class="headerlink" title="2.6 日期和时间"></a>2.6 日期和时间</h2><h3 id="2-6-1-QDate"><a href="#2-6-1-QDate" class="headerlink" title="2.6.1 QDate"></a>2.6.1 QDate</h3><blockquote><p>QDate类可以封装日期信息也可以通过这个类得到日期相关的信息, 包括:<code>年, 月, 日</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QDate::<span class="built_in">QDate</span>();</span><br><span class="line">QDate::<span class="built_in">QDate</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 重新设置日期对象中的日期</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QDate::setDate</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span>;</span><br><span class="line"><span class="comment">// 给日期对象添加 ndays 天</span></span><br><span class="line"><span class="function">QDate <span class="title">QDate::addDays</span><span class="params">(qint64 ndays)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给日期对象添加 nmonths 月</span></span><br><span class="line"><span class="function">QDate <span class="title">QDate::addMonths</span><span class="params">(<span class="type">int</span> nmonths)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给日期对象添加 nyears 月</span></span><br><span class="line"><span class="function">QDate <span class="title">QDate::addYears</span><span class="params">(<span class="type">int</span> nyears)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到日期对象中的年/月/日</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QDate::year</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QDate::month</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QDate::day</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDate::getDate</span><span class="params">(<span class="type">int</span> *year, <span class="type">int</span> *month, <span class="type">int</span> *day)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期对象格式化</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    d    - The day as a number without a leading zero (1 to 31)</span></span><br><span class="line"><span class="comment">    dd   - The day as a number with a leading zero (01 to 31)</span></span><br><span class="line"><span class="comment">    ddd - The abbreviated localized day name (e.g. &#x27;Mon&#x27; to &#x27;Sun&#x27;). Uses the system locale to localize the name, i.e. QLocale::system().</span></span><br><span class="line"><span class="comment">    dddd - The long localized day name (e.g. &#x27;Monday&#x27; to &#x27;Sunday&#x27;). Uses the system locale to localize the name, i.e. QLocale::system().</span></span><br><span class="line"><span class="comment">    M    - The month as a number without a leading zero (1 to 12)</span></span><br><span class="line"><span class="comment">    MM   - The month as a number with a leading zero (01 to 12)</span></span><br><span class="line"><span class="comment">    MMM - The abbreviated localized month name (e.g. &#x27;Jan&#x27; to &#x27;Dec&#x27;). Uses the system locale to localize the name, i.e. QLocale::system().</span></span><br><span class="line"><span class="comment">    MMMM - The long localized month name (e.g. &#x27;January&#x27; to &#x27;December&#x27;). Uses the system locale to localize the name, i.e. QLocale::system().</span></span><br><span class="line"><span class="comment">    yy   - The year as a two digit number (00 to 99)</span></span><br><span class="line"><span class="comment">    yyyy - The year as a four digit number. If the year is negative, a minus sign is prepended, making five characters.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">QString <span class="title">QDate::toString</span><span class="params">(<span class="type">const</span> QString &amp;format)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符重载 ==&gt; 日期比较</span></span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>!=(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>&lt;(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="built_in">operator</span>&lt;=(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>==(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>&gt;(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态函数 -&gt; 得到本地的当前日期</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QDate <span class="title">QDate::currentDate</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-6-2-QTime"><a href="#2-6-2-QTime" class="headerlink" title="2.6.2 QTime"></a>2.6.2 QTime</h3><blockquote><p>QTime类可以封装时间信息也可以通过这个类得到时间相关的信息, 包括:<code>时, 分, 秒, 毫秒</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QTime::<span class="built_in">QTime</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    h ==&gt; 取值范围： 0 ~ 23</span></span><br><span class="line"><span class="comment">    m and s ==&gt; 取值范围： 0 ~ 59</span></span><br><span class="line"><span class="comment">    ms ==&gt; 取值范围： 0 ~ 999</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">QTime::<span class="built_in">QTime</span>(<span class="type">int</span> h, <span class="type">int</span> m, <span class="type">int</span> s = <span class="number">0</span>, <span class="type">int</span> ms = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// Returns true if the set time is valid; otherwise returns false.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTime::setHMS</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> m, <span class="type">int</span> s, <span class="type">int</span> ms = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">QTime <span class="title">QTime::addSecs</span><span class="params">(<span class="type">int</span> s)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QTime <span class="title">QTime::addMSecs</span><span class="params">(<span class="type">int</span> ms)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line">  <span class="function">QTime <span class="title">n</span><span class="params">(<span class="number">14</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;                <span class="comment">// n == 14:00:00</span></span><br><span class="line">  QTime t;</span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">70</span>);                <span class="comment">// t == 14:01:10</span></span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">-70</span>);               <span class="comment">// t == 13:58:50</span></span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">10</span> * <span class="number">60</span> * <span class="number">60</span> + <span class="number">5</span>);  <span class="comment">// t == 00:00:05</span></span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">-15</span> * <span class="number">60</span> * <span class="number">60</span>);     <span class="comment">// t == 23:00:00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从时间对象中取出 时/分/秒/毫秒</span></span><br><span class="line"><span class="comment">// Returns the hour part (0 to 23) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::hour</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// Returns the minute part (0 to 59) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::minute</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// Returns the second part (0 to 59) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::second</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// Returns the millisecond part (0 to 999) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::msec</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间格式化</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    -- 时 --</span></span><br><span class="line"><span class="comment">    h==&gt;The hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)</span></span><br><span class="line"><span class="comment">    hh==&gt;The hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)</span></span><br><span class="line"><span class="comment">    H==&gt;The hour without a leading zero (0 to 23, even with AM/PM display)</span></span><br><span class="line"><span class="comment">    HH==&gt;The hour with a leading zero (00 to 23, even with AM/PM display)</span></span><br><span class="line"><span class="comment">    -- 分 --</span></span><br><span class="line"><span class="comment">    m==&gt;The minute without a leading zero (0 to 59)</span></span><br><span class="line"><span class="comment">    mm==&gt;The minute with a leading zero (00 to 59)</span></span><br><span class="line"><span class="comment">    -- 秒 --</span></span><br><span class="line"><span class="comment">    s==&gt;The whole second, without any leading zero (0 to 59)</span></span><br><span class="line"><span class="comment">    ss==&gt;The whole second, with a leading zero where applicable (00 to 59)</span></span><br><span class="line"><span class="comment">    -- 毫秒 --</span></span><br><span class="line"><span class="comment">    zzz==&gt;The fractional part of the second, to millisecond precision, </span></span><br><span class="line"><span class="comment">including trailing zeroes where applicable (000 to 999).</span></span><br><span class="line"><span class="comment">    -- 上午或者下午</span></span><br><span class="line"><span class="comment">    AP or A==&gt;使用AM/PM(大写) 描述上下午, 中文系统显示汉字</span></span><br><span class="line"><span class="comment">    ap or a==&gt;使用am/pm(小写) 描述上下午, 中文系统显示汉字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">QString <span class="title">QTime::toString</span><span class="params">(<span class="type">const</span> QString &amp;format)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阶段性计时</span></span><br><span class="line"><span class="comment">// 过时的API函数</span></span><br><span class="line"><span class="comment">// 开始计时</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTime::start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 计时结束</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::elapsed</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 重新计时</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::restart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用的API函数</span></span><br><span class="line"><span class="comment">// QElapsedTimer 类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QElapsedTimer::start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">qint64 <span class="title">QElapsedTimer::restart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">qint64 <span class="title">QElapsedTimer::elapsed</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符重载 ==&gt; 时间比较</span></span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>!=(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>&lt;(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="built_in">operator</span>&lt;=(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>==(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>&gt;(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态函数 -&gt; 得到当前时间</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QTime <span class="title">QTime::currentTime</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-6-3-QDateTime"><a href="#2-6-3-QDateTime" class="headerlink" title="2.6.3 QDateTime"></a>2.6.3 QDateTime</h3><blockquote><p>QDateTime类可以封装日期和时间信息也可以通过这个类得到日期和时间相关的信息, 包括:<code>年, 月, 日, 时, 分, 秒,毫秒</code>。<br>其实这个类就是<code>QDate</code> 和 <code>QTime</code> 这两个类的结合体。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QDateTime::<span class="built_in">QDateTime</span>();</span><br><span class="line">QDateTime::<span class="built_in">QDateTime</span>(<span class="type">const</span> QDate &amp;date, <span class="type">const</span> QTime &amp;time, Qt::TimeSpec spec = Qt::LocalTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 设置日期</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDateTime::setDate</span><span class="params">(<span class="type">const</span> QDate &amp;date)</span></span>;</span><br><span class="line"><span class="comment">// 设置时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDateTime::setTime</span><span class="params">(<span class="type">const</span> QTime &amp;time)</span></span>;</span><br><span class="line"><span class="comment">// 给当前日期对象追加 年/月/日/秒/毫秒, 参数可以是负数</span></span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addYears</span><span class="params">(<span class="type">int</span> nyears)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addMonths</span><span class="params">(<span class="type">int</span> nmonths)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addDays</span><span class="params">(qint64 ndays)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addSecs</span><span class="params">(qint64 s)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addMSecs</span><span class="params">(qint64 msecs)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到对象中的日期</span></span><br><span class="line"><span class="function">QDate <span class="title">QDateTime::date</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到对象中的时间</span></span><br><span class="line"><span class="function">QTime <span class="title">QDateTime::time</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期和时间格式, 格式字符参考QDate 和 QTime 类的 toString() 函数</span></span><br><span class="line"><span class="function">QString <span class="title">QDateTime::toString</span><span class="params">(<span class="type">const</span> QString &amp;format)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符重载 ==&gt; 日期时间对象的比较</span></span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>!=(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>&lt;(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="built_in">operator</span>&lt;=(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>==(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>&gt;(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态函数</span></span><br><span class="line"><span class="comment">// 得到当前时区的日期和时间(本地设置的时区对应的日期和时间)</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QDateTime <span class="title">QDateTime::currentDateTime</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-6-4-定时器类QTimer"><a href="#2-6-4-定时器类QTimer" class="headerlink" title="2.6.4 定时器类QTimer"></a>2.6.4 定时器类QTimer</h3><p>在进行窗口程序的处理过程中, 经常要周期性的执行某些操作, 或者制作一些动画效果，看似比较复杂的问题使用定时器就可以完美的解决这些问题<br>Qt中提供了定时器方式,介绍一下Qt中的定时器类 <code>QTimer</code> 的使用方法。</p><p>要使用它，只需创建一个QTimer类对象，然后调用其 <code>start()</code> 函数开启定时器，此后QTimer对象就会周期性的发出 <code>timeout()</code> 信号。我们先来了解一下这个类的相关API。</p><h4 id="2-6-4-1-public-slot-function"><a href="#2-6-4-1-public-slot-function" class="headerlink" title="2.6.4.1 public&#x2F;slot function"></a>2.6.4.1 public&#x2F;slot function</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 如果指定了父对象, 创建的堆内存可以自动析构</span></span><br><span class="line">QTimer::<span class="built_in">QTimer</span>(QObject *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置定时器时间间隔为 msec 毫秒</span></span><br><span class="line"><span class="comment">// 默认值是0，一旦窗口系统事件队列中的所有事件都已经被处理完，一个时间间隔为0的QTimer就会触发</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::setInterval</span><span class="params">(<span class="type">int</span> msec)</span></span>;</span><br><span class="line"><span class="comment">// 获取定时器的时间间隔, 返回值单位: 毫秒</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTimer::interval</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定的时间间隔启动或者重启定时器, 需要调用 setInterval() 设置时间间隔</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QTimer::start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 启动或重新启动定时器，超时间隔为msec毫秒。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QTimer::start</span><span class="params">(<span class="type">int</span> msec)</span></span>;</span><br><span class="line"><span class="comment">// 停止定时器。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QTimer::stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置定时器精度</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数: </span></span><br><span class="line"><span class="comment">    - Qt::PreciseTimer -&gt; 精确的精度, 毫秒级</span></span><br><span class="line"><span class="comment">    - Qt::CoarseTimer  -&gt; 粗糙的精度, 和1毫秒的误差在5%的范围内, 默认精度</span></span><br><span class="line"><span class="comment">    - Qt::VeryCoarseTimer -&gt; 非常粗糙的精度, 精度在1秒左右</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::setTimerType</span><span class="params">(Qt::TimerType atype)</span></span>;</span><br><span class="line"><span class="function">Qt::TimerType <span class="title">QTimer::timerType</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">// 获取当前定时器的精度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果定时器正在运行，返回true; 否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTimer::isActive</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断定时器是否只触发一次</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTimer::isSingleShot</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置定时器是否只触发一次, 参数为true定时器只触发一次, 为false定时器重复触发, 默认为false</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::setSingleShot</span><span class="params">(<span class="type">bool</span> singleShot)</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="2-6-4-2-signals"><a href="#2-6-4-2-signals" class="headerlink" title="2.6.4.2 signals"></a>2.6.4.2 signals</h4><p>这个类的信号只有一个, 当定时器超时时，该信号就会被发射出来。<br>给这个信号通过<code>conect()</code>关联一个槽函数, 就可以在槽函数中处理超时事件了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QTimer::timeout</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="2-6-4-3-static-public-function"><a href="#2-6-4-3-static-public-function" class="headerlink" title="2.6.4.3 static public function"></a>2.6.4.3 static public function</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其他同名重载函数可以自己查阅帮助文档</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能: 在msec毫秒后发射一次信号, 并且只发射一次</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">- msec:     在msec毫秒后发射信号</span></span><br><span class="line"><span class="comment">- receiver: 接收信号的对象地址</span></span><br><span class="line"><span class="comment">- method:   槽函数地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QTimer::singleShot</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> msec, <span class="type">const</span> QObject *receiver, </span></span></span><br><span class="line"><span class="params"><span class="function">        PointerToMemberFunction method)</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="2-6-4-4-定时器使用举例"><a href="#2-6-4-4-定时器使用举例" class="headerlink" title="2.6.4.4 定时器使用举例"></a>2.6.4.4 定时器使用举例</h4><ul><li>周期性定时器</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建定时器对象</span></span><br><span class="line">QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改定时器对象的精度</span></span><br><span class="line">timer-&gt;<span class="built_in">setTimerType</span>(Qt::PreciseTimer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮 loopBtn 的点击事件</span></span><br><span class="line"><span class="comment">// 点击按钮启动或者关闭定时器, 定时器启动, 周期性得到当前时间</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;loopBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 启动定时器</span></span><br><span class="line">    <span class="keyword">if</span>(timer-&gt;<span class="built_in">isActive</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        timer-&gt;<span class="built_in">stop</span>();  <span class="comment">// 关闭定时器</span></span><br><span class="line">        ui-&gt;loopBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;loopBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;关闭&quot;</span>);</span><br><span class="line">        timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>); <span class="comment">// 1000ms == 1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, [=]()</span><br><span class="line">&#123;</span><br><span class="line">    QTime tm = QTime::<span class="built_in">currentTime</span>();</span><br><span class="line">    <span class="comment">// 格式化当前得到的系统时间</span></span><br><span class="line">    QString tmstr = tm.<span class="built_in">toString</span>(<span class="string">&quot;hh:mm:ss.zzz&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置要显示的时间</span></span><br><span class="line">    ui-&gt;curTime-&gt;<span class="built_in">setText</span>(tmstr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>一次性定时器</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击按钮 onceBtn 只发射一次信号</span></span><br><span class="line"><span class="comment">// 点击按钮一次, 发射一个信号, 得到某一个时间点的时间</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;onceBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 获取2s以后的系统时间, 不创建定时器对象, 直接使用类的静态方法</span></span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">2000</span>, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        QTime tm = QTime::<span class="built_in">currentTime</span>();</span><br><span class="line">        <span class="comment">// 格式化当前得到的系统时间</span></span><br><span class="line">        QString tmstr = tm.<span class="built_in">toString</span>(<span class="string">&quot;hh:mm:ss.zzz&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置要显示的时间</span></span><br><span class="line">        ui-&gt;onceTime-&gt;<span class="built_in">setText</span>(tmstr);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h1 id="3-信号槽"><a href="#3-信号槽" class="headerlink" title="3. 信号槽"></a>3. 信号槽</h1><p>介绍Qt中的信号槽, 主要内容包括: <code>信号槽的本质</code>, <code>信号槽的关系</code>, <code>标准信号槽的使用</code>, <code>自定义信号槽的使用</code>, <code>信号槽的拓展</code> 。 </p><h2 id="3-1-信号和槽概述"><a href="#3-1-信号和槽概述" class="headerlink" title="3.1 信号和槽概述"></a>3.1 信号和槽概述</h2><blockquote><p>信号槽是 Qt框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式(发布-订阅模式)。<br>当某个<code>事件</code>发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。<br>如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。<br>也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。</p></blockquote><h3 id="3-1-1-信号的本质"><a href="#3-1-1-信号的本质" class="headerlink" title="3.1.1 信号的本质"></a>3.1.1 信号的本质</h3><blockquote><p>信号是由于用户对窗口或控件进行了某些操作，导致窗口或控件产生了某个特定事件，这时候Qt对应的窗口类会发出某个信号，以此对用户的挑选做出反应。</p></blockquote><p>因此根据上述的描述我们得到一个结论 – <code>信号的本质就是事件</code>，比如：</p><ul><li><p>按钮单击、双击</p></li><li><p>窗口刷新</p></li><li><p>鼠标移动、鼠标按下、鼠标释放</p></li><li><p>键盘输入</p></li></ul><p>那么在Qt中信号是通过什么形式呈现给使用者的呢？</p><ul><li>我们对哪个窗口进行操作, 哪个窗口就可以捕捉到这些被触发的事件。</li><li>对于使用者来说触发了一个事件我们就可以得到Qt框架给我们发出的某个特定信号。</li><li><code>信号的呈现形式就是函数</code>， 也就是说某个事件产生了， Qt框架就会调用某个对应的信号函数， 通知使用者。</li></ul><p><code>在QT中信号的发出者是某个实例化的类对象，对象内部可以进行相关事件的检测。</code></p><hr><h3 id="3-1-2-槽的本质"><a href="#3-1-2-槽的本质" class="headerlink" title="3.1.2 槽的本质"></a>3.1.2 槽的本质</h3><p>在Qt中槽函数是一类特殊的功能的函数，在编码过程中也可以作为类的普通成员函数来使用。<br>之所以称之为槽函数是因为它们还有一个职责就是对Qt框架中产生的信号进行处理。</p><p>在Qt中槽函数的所有者也是某个类的实例对象。</p><hr><h3 id="3-1-3-信号和槽的关系"><a href="#3-1-3-信号和槽的关系" class="headerlink" title="3.1.3 信号和槽的关系"></a>3.1.3 信号和槽的关系</h3><p>在Qt中信号和槽函数都是独立的个体，本身没有任何联系，但是由于某种特性需求我们可以将二者连接到一起。在Qt中我们需要使用<code>QOjbect</code>类中的<code>connect</code>函数进二者的关联。</p><blockquote><p>连接信号和槽的<code>connect()</code>函数原型如下, 其中<code>PointerToMemberFunction</code>是一个指向函数地址的指针</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *sender, PointerToMemberFunction signal, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> QObject *receiver, PointerToMemberFunction method, </span></span></span><br><span class="line"><span class="params"><span class="function">Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br><span class="line">参数:</span><br><span class="line">  - sender:   发出信号的对象</span><br><span class="line">  - signal:   属于sender对象, 信号是一个函数, 这个参数的类型是函数</span><br><span class="line">              指针, 信号函数地址</span><br><span class="line">  - receiver: 信号接收者</span><br><span class="line">  - method:   属于receiver对象, 当检测到sender发出了signal信号, </span><br><span class="line">              receiver对象调用method方法，信号发出之后的处理动作</span><br><span class="line"> </span><br><span class="line"><span class="comment">//  参数 signal 和 method 都是函数地址, 因此简化之后的 connect() 如下:</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="type">const</span> QObject *sender, &amp;QObject::signal, </span><br><span class="line">        <span class="type">const</span> QObject *receiver, &amp;QObject::method);</span><br></pre></td></tr></table></figure><p>使用connect()进行信号槽连接的注意事项:</p><ul><li>connect函数相对于做了信号处理动作的注册</li><li>调用conenct函数的sender对象的信号并没有产生, 因此receiver对象的method也不会被调用</li><li>method槽函数本质是一个回调函数, 调用的时机是信号产生之后, 调用是Qt框架来执行的</li><li>connect中的sender和recever两个指针必须被实例化了, 否则conenct不会成功</li></ul><hr><h2 id="3-2-标准信号槽使用"><a href="#3-2-标准信号槽使用" class="headerlink" title="3.2 标准信号槽使用"></a>3.2 标准信号槽使用</h2><h3 id="3-2-1-标准信号-槽"><a href="#3-2-1-标准信号-槽" class="headerlink" title="3.2.1 标准信号&#x2F;槽"></a>3.2.1 标准信号&#x2F;槽</h3><blockquote><p>在Qt提供的很多标准类中都可以对用户触发的某些特定事件进行检测, 因此当用户做了这些操作之后, 事件被触发类的内部就会产生对应的信号,这些信号都是Qt类内部自带的, 因此称之为标准信号。<br>同样的，在Qt的很多类内部为我了提供了很多功能函数，并且这些函数也可以作为触发的信号的处理动作，有这类特性的函数在Qt中称之为标准槽函数。<br>系统自带的信号和槽通常如何查找呢，这个就需要利用帮助文档了，比如在帮助文档中查询按钮的点击信号，那么需要在帮助文档中输入<code>QPushButton</code><br>首先我们可以在<code>Contents</code>中寻找关键字<code>signals</code>，信号的意思，但是我们发现并没有找到，这时候我们应该看当前类从父类继承下来了哪些信号</p></blockquote><p><img src="/img/9.51.png" alt="在这里插入图片描述"></p><blockquote><p>因此我们去他的父类<code>QAbstractButton</code>中就可以找到该关键字，点击<code>signals</code>索引到系统自带的信号有如下几个</p></blockquote><p><img src="/img/9.52.png" alt="在这里插入图片描述"></p><hr><h3 id="3-2-2-使用"><a href="#3-2-2-使用" class="headerlink" title="3.2.2 使用"></a>3.2.2 使用</h3><blockquote><p>掌握标准信号、槽的查找方式之后以及<code>connect()</code>函数的作用之后, 一个简单的例子了解使用方式。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">功能实现： 点击窗口上的按钮, 关闭窗口</span><br><span class="line">功能分析:</span><br><span class="line">- 按钮: 信号发出者          -&gt; QPushButton 类型</span><br><span class="line">- 窗口: 信号的接收者和处理者  -&gt; QWidget 类型</span><br></pre></td></tr></table></figure><blockquote><p>需要使用的标准信号槽函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单击按钮发出的信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::clicked</span><span class="params">(<span class="type">bool</span> checked = <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 关闭窗口的槽函数</span></span></span><br><span class="line"><span class="function">[slot] <span class="type">bool</span> <span class="title">QWidget::close</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>对于上边的需求只需要一句代码, 只需要写一句代码就能实现了</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单击按钮关闭窗口</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;closewindow, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::close);</span><br></pre></td></tr></table></figure><p><code>connect()操作一般写在窗口的构造函数中, 相当于在事件产生之前在qt框架中先进行注册, 这样在程序运行过程中假设产生了按钮的点击事件, 框架就会调用信号接收者对象对应的槽函数了, 如果信号不产生, 槽函数也就一直不会被调用。</code></p><hr><h2 id="3-3-自定义信号槽使用"><a href="#3-3-自定义信号槽使用" class="headerlink" title="3.3 自定义信号槽使用"></a>3.3 自定义信号槽使用</h2><blockquote><p>Qt框架提供的信号槽在某些特定场景下是无法满足我们的项目需求的，因此我们还设计自己需要的的信号和槽，同样还是使用connect()对自定义的信号槽进行连接。</p></blockquote><p>如果想要在QT类中自定义信号槽, 需要满足一些条件, 并且有些事项也需要注意:</p><ul><li>要编写新的类并且让其继承Qt的某些标准类</li><li>这个新的子类必须从QObject类或者是QObject子类进行派生</li><li>在定义类的头文件中加入 Q_OBJECT 宏</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在头文件派生类的时候，首先像下面那样引入Q_OBJECT宏：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMainWindow</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-3-1-自定义信号"><a href="#3-3-1-自定义信号" class="headerlink" title="3.3.1 自定义信号"></a>3.3.1 自定义信号</h3><blockquote><p>在Qt中信号的本质是事件, 但是在框架中也是以函数的形式存在的, 只不过信号对应的函数只有声明,没有定义。如果Qt中的标准信号不能满足我们的需求，可以在程序中进行信号的自定义，当自定义信号对应的事件产生之后，认为的将这个信号发射出去即可（其实就是调用一下这个信号函数）。</p></blockquote><p>下边给大家阐述一下, 自定义信号的要求和注意事项:</p><ol><li>信号是类的成员函数</li><li>返回值必须是 void 类型</li><li>信号的名字可以根据实际情况进行指定</li><li>参数可以随意指定, 信号也支持重载</li><li>信号需要使用 signals 关键字进行声明, 使用方法类似于public等关键字</li><li>信号函数只需要声明, 不需要定义(没有函数体实现)</li><li>在程序中发射自定义信号: 发送信号的本质就是调用信号函数<ul><li>习惯性在信号函数前加关键字: emit, 但是可以省略不写</li><li>emit只是显示的声明一下信号要被发射了, 没有特殊含义</li><li>底层 emit &#x3D;&#x3D; #define emit</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 举例: 信号重载</span></span><br><span class="line"><span class="comment">// Qt中的类想要使用信号槽机制必须要从QObject类派生(直接或间接派生都可以)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testsignal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 参数的作用是数据传递, 谁调用信号函数谁就指定实参</span></span><br><span class="line"><span class="comment">// 实参最终会被传递给槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testsignal</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="3-3-2-自定义槽"><a href="#3-3-2-自定义槽" class="headerlink" title="3.3.2 自定义槽"></a>3.3.2 自定义槽</h3><blockquote><p>槽函数就是信号的处理动作，在Qt中槽函数可以作为普通的成员函数来使用。如果标准槽函数提供的功能满足不了需求，可以自己定义槽函数进行某些特殊功能的实现。自定义槽函数和自定义的普通函数写法是一样的。</p></blockquote><p>下边给大家阐述一下, 自定义槽的要求和注意事项:</p><ol><li><p>返回值必须是 void 类型</p></li><li><p>槽也是函数, 因此也支持重载</p></li><li><p>槽函数需要指定多少个参数, 需要看连接的信号的参数个数</p></li><li><p>槽函数的参数是用来接收信号传递的数据的, 信号传递的数据就是信号的参数</p><ul><li>举例:<ul><li>信号函数: void testsig(int a, double b);</li><li>槽函数: void testslot(int a, double b);</li></ul></li><li>总结:<ul><li>槽函数的参数应该和对应的信号的参数个数, 从左到右类型依次对应</li><li>信号的参数可以大于等于槽函数的参数个数 &#x3D;&#x3D; 信号传递的数据被忽略了<ul><li>信号函数: void testsig(int a, double b);</li><li>槽函数: void testslot(int a);</li></ul></li></ul></li></ul></li><li><p>Qt中槽函数的类型是多样的<br>Qt中的槽函数可以是类的成员函数、全局函数、静态函数、Lambda表达式（匿名函数）</p></li><li><p>槽函数可以使用关键字进行声明: slots (Qt5中slots可以省略不写)</p></li></ol><ul><li>public slots:</li><li>private slots: –&gt; 这样的槽函数不能在类外部被调用</li><li>protected slots: –&gt; 这样的槽函数不能在类外部被调用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 槽函数书写格式举例</span></span><br><span class="line"><span class="comment">// 类中的这三个函数都可以作为槽函数来使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testSlot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">testFunc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testSlot</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​</p><blockquote><p>根据特定场景自定义信号槽:</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class GirlFriend</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GirlFriend</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hungry</span><span class="params">()</span></span>;            <span class="comment">// 不能表达出想要吃什么</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hungry</span><span class="params">(QString msg)</span></span>;<span class="comment">// 可以通过参数表达想要吃什么</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class Me</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Me</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Me</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="comment">// 槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eatMeal</span><span class="params">()</span></span>;             <span class="comment">// 不能知道信号发出者要吃什么</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eatMeal</span><span class="params">(QString msg)</span></span>;  <span class="comment">// 可以知道信号发出者要吃什么</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-4-信号槽拓展"><a href="#3-4-信号槽拓展" class="headerlink" title="3.4 信号槽拓展"></a>3.4 信号槽拓展</h2><h3 id="3-4-1-信号槽使用拓展"><a href="#3-4-1-信号槽使用拓展" class="headerlink" title="3.4.1 信号槽使用拓展"></a>3.4.1 信号槽使用拓展</h3><ul><li>一个信号可以连接多个槽函数, 发送一个信号有多个处理动作<ul><li>需要写多个connect（）连接</li><li>槽函数的执行顺序是随机的, 和connect函数的调用顺序没有关系</li><li>信号的接收者可以是一个对象, 也可以是多个对象</li></ul></li><li>一个槽函数可以连接多个信号, 多个不同的信号, 处理动作是相同的<ul><li>需要写多个connect（）连接</li></ul></li><li>信号可以连接信号</li></ul><blockquote><p>信号接收者可不处理接收的信号, 而是继续发射新的信号，这相当于传递了数据, 并没有对数据进行处理</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(<span class="type">const</span> QObject *sender, &amp;QObject::signal, </span><br><span class="line">        <span class="type">const</span> QObject *receiver, &amp;QObject::siganl-<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><ul><li>信号槽是可以断开的</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(<span class="type">const</span> QObject *sender, &amp;QObject::signal, </span><br><span class="line">        <span class="type">const</span> QObject *receiver, &amp;QObject::method);</span><br></pre></td></tr></table></figure><hr><h3 id="3-4-2-信号槽的连接方式"><a href="#3-4-2-信号槽的连接方式" class="headerlink" title="3.4.2 信号槽的连接方式"></a>3.4.2 信号槽的连接方式</h3><ul><li>Qt5的连接方式</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法:</span></span><br><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *sender, PointerToMemberFunction signal, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> QObject *receiver, PointerToMemberFunction method, </span></span></span><br><span class="line"><span class="params"><span class="function">Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号和槽函数也就是第2,4个参数传递的是地址, 编译器在编译过程中会对数据的正确性进行检测</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="type">const</span> QObject *sender, &amp;QObject::signal, </span><br><span class="line">        <span class="type">const</span> QObject *receiver, &amp;QObject::method);</span><br></pre></td></tr></table></figure><ul><li>Qt4的连接方式</li></ul><blockquote><p>这种旧的信号槽连接方式在Qt5中是支持的, 但是不推荐使用, 因为这种方式在进行信号槽连接的时候,信号槽函数通过宏<code>SIGNAL</code>和<code>SLOT</code>转换为字符串类型。<br>因为信号槽函数的转换是通过宏来进行转换的，因此传递到宏函数内部的数据不会被进行检测，如果使用者传错了数据，编译器也不会报错，但实际上信号槽的连接已经不对了，只有在程序运行起来之后才能发现问题，而且问题不容易被定位。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Qt4的信号槽连接方式</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *sender, <span class="type">const</span> <span class="type">char</span> *signal, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *receiver, <span class="type">const</span> <span class="type">char</span> *method, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(<span class="type">const</span> QObject *sender,<span class="built_in">SIGNAL</span>(信号函数名(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...)),</span><br><span class="line">        <span class="type">const</span> QObject *receiver,<span class="built_in">SLOT</span>(槽函数名(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...)));</span><br></pre></td></tr></table></figure><p><code>Qt4中声明槽函数必须要使用 slots 关键字, 不能省略。</code></p><ul><li>应用举例</li></ul><blockquote><p>场景描述：<br>    - 我肚子饿了, 我要吃东西。  </p><p>分析：<br>     - 信号的发出者是我自己, 信号的接收者也是我自己</p></blockquote><blockquote><p>先定义出一个Qt的类。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Me</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    <span class="comment">// Qt4中的槽函数必须这样声明, qt5中的关键字 slots 可以被省略</span></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(QString somthing)</span></span>;</span><br><span class="line">    signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hungury</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hungury</span><span class="params">(QString somthing)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于上边的类写出解决方案</span></span><br><span class="line"><span class="comment">// 处理如下逻辑: 我饿了, 我要吃东西</span></span><br><span class="line"><span class="comment">// 分析: 信号的发出者是我自己, 信号的接收者也是我自己</span></span><br><span class="line">Me m;</span><br><span class="line"><span class="comment">// Qt4处理方式</span></span><br><span class="line"><span class="built_in">connect</span>(&amp;m, <span class="built_in">SIGNAL</span>(<span class="built_in">eat</span>()), &amp;m, <span class="built_in">SLOT</span>(<span class="built_in">hungury</span>()));</span><br><span class="line"><span class="built_in">connect</span>(&amp;m, <span class="built_in">SIGNAL</span>(<span class="built_in">eat</span>(QString)), &amp;m, <span class="built_in">SLOT</span>(<span class="built_in">hungury</span>(QString)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Qt5处理方式</span></span><br><span class="line"><span class="built_in">connect</span>(&amp;m, &amp;Me::eat, &amp;m, &amp;Me::hungury);<span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>Qt5处理方式错误原因分析：</p><p><code>上边的写法之所以错误是因为这个类中信号槽都是重载过的, 信号和槽都是通过函数名去关联函数的地址, 但是这个同名函数对应两块不同的地址, 一个带参, 一个不带参, 因此编译器就不知道去关联哪块地址了, 所以如果我们在这种时候通过以上方式进行信号槽连接, 编译器就会报错。</code></p><p>解决方案：</p><ul><li>可以通过定义函数指针的方式指定出函数的具体参数，这样就可以确定函数的具体地址了。</li><li>定义函数指针指向重载的某个信号或者槽函数，在connect（）函数中将函数指针名字作为实参就可以了。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 举例：</span></span><br><span class="line"><span class="built_in">void</span> (Me::*func1)(QString) = &amp;Me::eat;<span class="comment">// func1指向带参的信号</span></span><br><span class="line"><span class="built_in">void</span> (Me::*func2)() = &amp;Me::hungury;<span class="comment">// func2指向不带参的槽函数</span></span><br></pre></td></tr></table></figure><p>Qt正确的处理方式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数指针指向重载的某一个具体的信号地址</span></span><br><span class="line"><span class="built_in">void</span> (Me::*mysignal)(QString) = &amp;Me::eat;</span><br><span class="line"><span class="comment">// 定义函数指针指向重载的某一个具体的槽函数地址</span></span><br><span class="line"><span class="built_in">void</span> (Me::*myslot)(QString) = &amp;Me::hungury;</span><br><span class="line"><span class="comment">// 使用定义的函数指针完成信号槽的连接</span></span><br><span class="line"><span class="built_in">connect</span>(&amp;m, mysignal, &amp;m, myslot);</span><br></pre></td></tr></table></figure><p>总结</p><ul><li>Qt4的信号槽连接方式因为使用了宏函数, 宏函数对用户传递的信号槽不会做错误检测, 容易出bug</li><li>Qt5的信号槽连接方式, 传递的是信号槽函数的地址, 编译器会做错误检测, 减少了bug的产生</li><li>当信号槽函数被重载之后, Qt4的信号槽连接方式不受影响</li><li>当信号槽函数被重载之后, Qt5中需要给被重载的信号或者槽定义函数指针</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号槽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>套接字通信</title>
      <link href="/2023/10/22/%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/"/>
      <url>/2023/10/22/%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-套接字-socket"><a href="#1-套接字-socket" class="headerlink" title="1. 套接字-socket"></a>1. 套接字-socket</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><ul><li>局域网和广域网<ul><li>局域网：局域网将一定区域内的各种计算机、外部设备和数据库连接起来形成计算机通信的私有网络。</li><li>广域网：又称<strong>广域网</strong>、<strong>外网</strong>、<strong>公网</strong>。<br>  是连接不同地区局域网或城域网计算机通信的远程公共网络。</li></ul></li><li>IP（Internet Protocol）：本质是一个整形数，用于表示计算机在网络中的地址。<br>IP协议版本有两个：IPv4和IPv6<ul><li>IPv4（Internet Protocol version4）：<ul><li>使用一个32位的整形数描述一个IP地址，4个字节，int型</li><li>也可以使用一个点分十进制字符串描述这个IP地址： <code>192.168.130.198</code></li><li>分成了4份，每份1字节，8bit（char），最大值为 255<ul><li>0.0.0.0 是最小的IP地址</li><li>255.255.255.255是最大的IP地址</li></ul></li><li>按照IPv4协议计算，可以使用的IP地址共有 2^32^ 个</li></ul></li><li>IPv6（Internet Protocol version6）：<ul><li>使用一个128位的整形数描述一个IP地址，16个字节</li><li>也可以使用一个字符串描述这个IP地址：2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b</li><li>分成了8份，每份2字节，每一部分以16进制的方式表示</li><li>按照IPv6协议计算，可以使用的IP地址共有 2^128^ 个</li></ul></li></ul></li><li>查看IP地址</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># linux</span></span><br><span class="line">$ ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># windows</span></span><br><span class="line">$ ipconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试网络是否畅通</span></span><br><span class="line"><span class="comment"># 主机a: 192.168.1.11</span></span><br><span class="line"><span class="comment"># 当前主机: 192.168.1.12</span></span><br><span class="line">$ ping 192.168.1.11     <span class="comment"># 测试是否可用连接局域网</span></span><br><span class="line">$ ping www.baidu.com    <span class="comment"># 测试是否可用连接外网</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 特殊的IP地址: 127.0.0.1  ==&gt; 和本地的IP地址是等价的</span></span><br><span class="line"><span class="comment"># 假设当前电脑没有联网, 就没有IP地址, 又要做网络测试, 可用使用 127.0.0.1 进行本地测试</span></span><br></pre></td></tr></table></figure><ul><li>端口<br>端口的作用是定位到主机上的某一个进程，通过这个端口进程就可接受到对应的网络数据。</li></ul><blockquote><p>比如: 在电脑上运行了微信和QQ, 小明通过客户端给我的的微信发消息, 电脑上的微信就收到了消息, 为什么?</p><p>运行在电脑上的微信和QQ都绑定了不同的端口 通过IP地址可以定位到某一台主机<br>通过端口就可以定位到主机上的某一个进程<br>通过指定的IP和端口，发送数据的时候对端就能接受到数据了</p></blockquote><p>端口也是一个整形数 <code>unsigned short</code> ，一个16位整形数，有效端口的取值范围是：<br><code>0 ~ 65535</code>(0 ~ 2^16^-1)</p><blockquote><p>计算机中所有的进程都需要关联一个端口吗?<br>不需要，如果这个进程不需要网络通信，那么这个进程就不需要绑定端口的<br>.<br>一个端口可以被重复使用吗?<br>一个端口只能给某一个进程使用，多个进程不能同时使用同一端口</p></blockquote><ul><li>OSI&#x2F;ISO 网络分层模型<br>OSI（Open System Interconnect），即开放式系统互联。<br>一般都叫OSI参考模型，是ISO（国际标准化组织组织）在1985年研究的网络互联模型。</li></ul><p><img src="/img/9.21.png" alt="在这里插入图片描述"></p><blockquote><ul><li>物理层：负责最后将信息编码成电流脉冲或其它信号用于网上传输 </li><li>数据链路层:<ul><li>数据链路层通过物理网络链路供数据传输。</li><li>规定了0和1的分包形式，确定了网络数据包的形式；</li></ul></li><li>网络层 <ul><li>网络层负责在源和终点之间建立连接;</li><li>此处需要确定计算机的位置，通过IPv4，IPv6格式的IP地址来找到对应的主机</li></ul></li><li>传输层 </li><li>传输层向高层提供可靠的端到端的网络数据流服务。<ul><li>每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信</li></ul></li><li>会话层 </li><li>会话层建立、管理和终止表示层与实体之间的通信会话；<ul><li>建立一个连接（自动的手机信息、自动的网络寻址）;</li></ul></li><li>表示层:<ul><li>对应用层数据编码和转化, 确保以一个系统应用层发送的信息 可以被另一个系统应用层识别;</li></ul></li></ul></blockquote><hr><h2 id="1-2-网络协议"><a href="#1-2-网络协议" class="headerlink" title="1.2 网络协议"></a>1.2 网络协议</h2><p>网络协议指的是计算机网络中互相通信的对等实体之间交换信息时所必须遵守的规则的集合。<br>一般系统网络协议包括五个部分：通信环境，传输服务，词汇表，信息的编码格式，时序、规则和过程。<br>通过几幅图了解下常用的网络协议的格式：</p><ul><li>TCP协议 -&gt; 传输层协议</li></ul><p><img src="/img/9.22.png" alt="在这里插入图片描述"></p><ul><li>UDP协议 -&gt; 传输层协议</li></ul><p><img src="/img/9.23.png" alt="在这里插入图片描述"></p><ul><li><p>IP协议(IPV4) -&gt; 网络层协议<br><img src="/img/9.24.png" alt="在这里插入图片描述"></p></li><li><p>以太网帧协议 -&gt; 网络接口层协议</p></li></ul><p><img src="/img/9.25.png" alt="在这里插入图片描述"></p><ul><li>数据的封装<br><img src="/img/9.26.png" alt="在这里插入图片描述"></li></ul><p>在网络通信的时候, 我们需负责的应用层数据的处理(最上层)</p><ul><li>应用层的数据可以使用某些协议进行封装, 也可以不封装</li><li>我们需要调用发送数据的接口函数，将数据发送出去</li><li>我们调用的API做底层数据处理<ul><li>传输层使用传输层协议打包数据</li><li>网络层使用网络层协议打包数据</li><li>网络接口层使用网络接口层协议打包数据</li><li>数据被发送到internet</li></ul></li><li>接收端接收到发送端的数据<ul><li>我们调用接收数据的函数接收数据</li><li>调用的API做相关的底层处理:<ul><li>网络接口层拆包 &#x3D;&#x3D;&gt; 网络层的包</li><li>网络层拆包 &#x3D;&#x3D;&gt; 网络层的包</li><li>传输层拆包 &#x3D;&#x3D;&gt; 传输层数据</li></ul></li><li>如果应用层也使用了协议对数据进行了封装，数据的包的解析需要我们做</li></ul></li></ul><hr><h2 id="1-3-socket编程"><a href="#1-3-socket编程" class="headerlink" title="1.3 socket编程"></a>1.3 socket编程</h2><p>Socket套接字由远景研究规划局（Advanced Research Projects Agency, ARPA）资助加里福尼亚大学伯克利分校的一个研究组研发。<br>其目的是将TCP&#x2F;IP协议相关软件移植到UNIX类系统中。设计者开发了一个接口，以便应用程序能简单地调用该接口通信。<br>这个接口不断完善，最终形成了Socket套接字。Linux系统采用了Socket套接字，因此，Socket接口就被广泛使用，到现在已经成为事实上的标准。<br>与套接字相关的函数被包含在头文件<code>sys/socket.h</code>中。</p><p>套接字对我们来说就是一套网络通信的接口，使用这套接口就可以完成网络通信。<br>网络通信的主体主要分为两部分：<code>客户端</code>和<code>服务器端</code>。<br>在客户端和服务器通信的时候需要频繁提到三个概念：<code>IP</code>、<code>端口</code>、<code>通信数据</code></p><h3 id="1-3-1-字节序"><a href="#1-3-1-字节序" class="headerlink" title="1.3.1 字节序"></a>1.3.1 字节序</h3><p>在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编&#x2F;译码从而导致通信失败。</p><p><code>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序 也就是说对于单字符来说是没有字节序问题的，字符串是单字符的集合，因此字符串也没有字节序问题。</code></p><p>目前在各种体系的计算机中通常采用的字节存储机制主要有两种：<code>Big-Endian</code> 和 <code>Little-Endian</code></p><p>下面先从字节序说起。</p><blockquote><p>大小端的这个名词最早出现在《格列佛游记》中，里边记载了两个征战的强国，你不会想到的是，他们打仗竟然和剥鸡蛋的顺序有关。很多人认为，剥鸡蛋时应该打破鸡蛋较大的一端，这群人被称作“大端（Big endian）派”。可是那时皇帝儿子小时候吃鸡蛋的时候碰巧将一个手指弄破了。所以，当时的皇帝就下令剥鸡蛋必须打破鸡蛋较小的一端，违令者重罚，由此产生了“小端（Little endian）派”。<br>老百姓们对这项命令极其反感，由此引发了6次叛乱，其中一个皇帝送了命，另一个丢了王位。据估计，先后几次有11000人情愿受死也不肯去打破鸡蛋较小的一端！</p></blockquote><ul><li><p>Little-Endian -&gt; 主机字节序 (小端)</p><ul><li>数据的<code>低位字节</code>存储到内存的<code>低地址位</code>, 数据的<code>高位字节</code>存储到内存的<code>高地址位</code></li><li>我们使用的PC机，数据的存储默认使用的是小端</li></ul></li><li><p>Big-Endian -&gt; 网络字节序 (大端)</p><ul><li>数据的<code>低位字节</code>存储到内存的<code>高地址位</code>, 数据的<code>高位字节</code>存储到内存的<code>低地址位</code></li><li>套接字通信过程中操作的数据都是大端存储的，包括：接收&#x2F;发送的数据,IP地址,端口</li></ul></li><li><p>字节序举例</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有一个16进制的数, 有32位 (int): 0xab5c01ff</span></span><br><span class="line"><span class="comment">// 字节序, 最小的单位: char 字节, int 有4个字节, 需要将其拆分为4份</span></span><br><span class="line"><span class="comment">// 一个字节 unsigned char, 最大值是 255(十进制) ==&gt; ff(16进制) </span></span><br><span class="line">                 内存低地址位                内存的高地址位</span><br><span class="line">---------------------------------------------------------------------------&gt;</span><br><span class="line">小端:         <span class="number">0xff</span>        <span class="number">0x01</span>        <span class="number">0x5c</span>        <span class="number">0xab</span></span><br><span class="line">大端:         <span class="number">0xab</span>        <span class="number">0x5c</span>        <span class="number">0x01</span>        <span class="number">0xff</span></span><br></pre></td></tr></table></figure><p><img src="/img/9.27.png" alt="在这里插入图片描述"></p><ul><li>函数</li></ul><blockquote><p>BSD Socket提供了封装好的转换接口，方便我们使用。<br>包括从主机字节序到网络字节序的转换函数：htons、htonl；<br>从网络字节序到主机字节序的转换函数：ntohs、ntohl。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// u:unsigned</span></span><br><span class="line"><span class="comment">// 16: 16位, 32:32位</span></span><br><span class="line"><span class="comment">// h: host, 主机字节序</span></span><br><span class="line"><span class="comment">// n: net, 网络字节序</span></span><br><span class="line"><span class="comment">// s: short</span></span><br><span class="line"><span class="comment">// l: int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这套api主要用于 网络通信过程中 IP 和 端口 的 转换</span></span><br><span class="line"><span class="comment">// 将一个短整形从主机字节序 -&gt; 网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;</span><br><span class="line"><span class="comment">// 将一个整形从主机字节序 -&gt; 网络字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个短整形从网络字节序 -&gt; 主机字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span></span><br><span class="line"><span class="comment">// 将一个整形从网络字节序 -&gt; 主机字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-3-2-IP地址转换"><a href="#1-3-2-IP地址转换" class="headerlink" title="1.3.2 IP地址转换"></a>1.3.2 IP地址转换</h3><p>虽然IP地址本质是一个整形数，但是在使用的过程中都是通过一个字符串来描述<br>下面的函数描述了如何将一个字符串类型的IP地址进行大小端转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主机字节序的IP地址转换为网络字节序</span></span><br><span class="line"><span class="comment">// 主机字节序的IP地址是字符串, 网络字节序IP地址是整形</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>; </span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>af: 地址族(IP地址的家族包括ipv4和ipv6)协议<ul><li>AF_INET: ipv4格式的ip地址</li><li>AF_INET6: ipv6格式的ip地址</li></ul></li><li>src: 传入参数, 对应要转换的点分十进制的ip地址: 192.168.1.100</li><li>dst: 传出参数, 函数调用完成, 转换得到的大端整形IP被写入到这块内存中</li></ul></li><li>返回值：成功返回1，失败返回0或者-1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将大端的整形数, 转换为小端的点分十进制的IP地址        </span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>af: 地址族协议<ul><li>AF_INET: ipv4格式的ip地址</li><li>AF_INET6: ipv6格式的ip地址</li></ul></li><li>src: 传入参数, 这个指针指向的内存中存储了大端的整形IP地址</li><li>dst: 传出参数, 存储转换得到的小端的点分十进制的IP地址</li><li>size: 修饰dst参数的, 标记dst指向的内存中最多可以存储多少个字节</li></ul></li><li>返回值:<ul><li>成功: 指针指向第三个参数对应的内存地址, 通过返回值也可以直接取出转换得到的IP字符串</li><li>失败: NULL</li></ul></li></ul><p>还有一组函数也能进程IP地址大小端的转换，但是只能处理ipv4的ip地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点分十进制IP -&gt; 大端整形</span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大端整形 -&gt; 点分十进制IP</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="1-3-3-sockaddr-数据结构"><a href="#1-3-3-sockaddr-数据结构" class="headerlink" title="1.3.3 sockaddr 数据结构"></a>1.3.3 sockaddr 数据结构</h3><p><img src="/img/9.28.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在写数据的时候不好用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sa_family;       <span class="comment">// 地址族协议, ipv4</span></span><br><span class="line"><span class="type">char</span>        sa_data[<span class="number">14</span>];     <span class="comment">// 端口(2字节) + IP地址(4字节) + 填充(8字节)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>  <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>    <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(struct sockaddr) == sizeof(struct sockaddr_in)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;<span class="comment">/* 地址族协议: AF_INET */</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;         <span class="comment">/* 端口, 2字节-&gt; 大端  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">/* IP地址, 4字节 -&gt; 大端  */</span></span><br><span class="line">    <span class="comment">/* 填充 8字节 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) - <span class="keyword">sizeof</span>(sin_family) -</span><br><span class="line">               <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><hr><h3 id="1-3-4-套接字函数"><a href="#1-3-4-套接字函数" class="headerlink" title="1.3.4 套接字函数"></a>1.3.4 套接字函数</h3><p>使用套接字通信函数需要包含头文件<code>&lt;arpa/inet.h&gt;</code>，包含了这个头文件<code>&lt;sys/socket.h&gt;</code>就不用在包含了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>domain: 使用的地址族协议<ul><li>AF_INET: 使用IPv4格式的ip地址</li><li>AF_INET6: 使用IPv4格式的ip地址</li></ul></li><li>type:<ul><li>SOCK_STREAM: 使用流式的传输协议</li><li>SOCK_DGRAM: 使用报式(报文)的传输协议</li></ul></li><li>protocol: 一般写0即可, 使用默认的协议<ul><li>SOCK_STREAM: 流式传输默认使用的是tcp</li><li>SOCK_DGRAM: 报式传输默认使用的udp</li></ul></li></ul></li><li>返回值:<ul><li>成功: 可用于套接字通信的文件描述符</li><li>失败: -1</li></ul></li></ul><p>函数的返回值是一个文件描述符，通过这个文件描述符可以操作内核中的某一块内存，网络通信是基于这个文件描述符来完成的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将文件描述符和本地的IP与端口进行绑定   </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd: 监听的文件描述符, 通过socket()调用得到的返回值</li><li>addr: 传入参数, 要绑定的IP和端口信息需要初始化到这个结构体中，IP和端口要转换为网络字节序</li><li>addrlen: 参数addr指向的内存大小, sizeof(struct sockaddr)</li></ul></li><li>返回值：成功返回0，失败返回-1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给监听的套接字设置监听</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd: 文件描述符, 可以通过调用socket()得到，在监听之前必须要绑定 bind()</li><li>backlog: 同时能处理的最大连接要求，最大值为128</li></ul></li><li>返回值：函数调用成功返回0，调用失败返回 -1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待并接受客户端的连接请求, 建立新的连接, 会得到一个新的文件描述符(通信的)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd: 监听的文件描述符</li><li>addr: 传出参数, 里边存储了建立连接的客户端的地址信息</li><li>addrlen: 传入传出参数，用于存储addr指向的内存大小</li></ul></li><li>返回值：函数调用成功，得到一个文件描述符, 用于和建立连接的这个客户端通信<br>  调用失败返回 -1</li></ul><p><code>这个函数是一个阻塞函数，当没有新的客户端连接请求的时候，该函数阻塞；当检测到有新的客户端连接请求时，阻塞解除，新连接就建立了，得到的返回值也是一个文件描述符，基于这个文件描述符就可以和客户端通信了。</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd: 用于通信的文件描述符, accept() 函数的返回值</li><li>buf: 指向一块有效内存, 用于存储接收是数据</li><li>size: 参数buf指向的内存的容量</li><li>flags: 特殊的属性, 一般不使用, 指定为 0</li></ul></li><li>返回值:<ul><li>大于0：实际接收的字节数</li><li>等于0：对方断开了连接</li><li>-1：接收数据失败了</li></ul></li></ul><p><code>如果连接没有断开，接收端接收不到数据，接收数据的函数会阻塞等待数据到达，数据到达后函数解除阻塞，开始接收数据， 当发送端断开连接，接收端无法接收到任何数据，但是这时候就不会阻塞了，函数直接返回0。</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送数据的函数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>fd: 通信的文件描述符, accept() 函数的返回值</li><li>buf: 传入参数, 要发送的字符串</li><li>len: 要发送的字符串的长度</li><li>flags: 特殊的属性, 一般不使用, 指定为 0</li></ul></li><li>返回值：<ul><li>大于0：实际发送的字节数，和参数len是相等的</li><li><pre><code>-1：发送数据失败了</code></pre></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功连接服务器之后, 客户端会自动随机绑定一个端口</span></span><br><span class="line"><span class="comment">// 服务器端调用accept()的函数, 第二个参数存储的就是客户端的IP和端口信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd: 通信的文件描述符, 通过调用socket()函数就得到了</li><li>addr: 存储了要连接的服务器端的地址信息: iP 和 端口，这个IP和端口也需要转换为大端然后再赋值</li><li>addrlen: addr指针指向的内存的大小 sizeof(struct sockaddr)</li></ul></li><li>返回值：连接成功返回0，连接失败返回-1</li></ul><hr><h2 id="1-4-TCP通信流程"><a href="#1-4-TCP通信流程" class="headerlink" title="1.4 TCP通信流程"></a>1.4 TCP通信流程</h2><p>TCP是一个面向连接的，安全的，流式传输协议，这个协议是一个传输层协议。</p><ul><li>面向连接：是一个双向连接，通过三次握手完成，断开连接需要通过四次挥手完成。</li><li>安全：tcp通信过程中,会对发送的每一数据包都会进行校验, 如果发现数据丢失, 会自动重传</li><li>流式传输：发送端和接收端处理数据的速度，数据的量都可以不一致<br><img src="/img/9.29.png" alt="在这里插入图片描述"></li></ul><h3 id="1-4-1-服务器端通信流程"><a href="#1-4-1-服务器端通信流程" class="headerlink" title="1.4.1 服务器端通信流程"></a>1.4.1 服务器端通信流程</h3><ol><li>创建用于监听的套接字, 这个套接字是一个文件描述符</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lfd = socket();</span><br></pre></td></tr></table></figure><ol start="2"><li>将得到的监听的文件描述符和本地的IP 端口进行绑定</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind();</span><br></pre></td></tr></table></figure><ol start="3"><li>设置监听(成功之后开始监听, 监听的是客户端的连接)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen();</span><br></pre></td></tr></table></figure><ol start="4"><li>等待并接受客户端的连接请求, 建立新的连接, 会得到一个新的文件描述符(通信的)，没有新连接请求就阻塞</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cfd = accept();</span><br></pre></td></tr></table></figure><ol start="5"><li>通信，读写操作默认都是阻塞的</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line">read(); / recv();</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">write(); / send();</span><br></pre></td></tr></table></figure><ol start="6"><li>断开连接, 关闭套接字</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close();</span><br></pre></td></tr></table></figure><blockquote><p>在tcp的服务器端, 有两类文件描述符</p><ul><li>监听的文件描述符 <ul><li>只需要有一个</li><li>不负责和客户端通信, 负责检测客户端的连接请求, 检测到之后调用accept就可以建立新的连接</li></ul></li><li>通信的文件描述符<ul><li>负责和建立连接的客户端通信</li><li>如果有N个客户端和服务器建立了新的连接,通信的文件描述符就有N个，每个客户端和服务器都对应一个通信的文件描述符</li></ul></li></ul></blockquote><p><img src="/img/9.30.png" alt="在这里插入图片描述"></p><ul><li>文件描述符对应的内存结构：<ul><li><code>一个文件文件描述符对应两块内存, 一块内存是读缓冲区, 一块内存是写缓冲区</code></li><li>读数据: <code>通过文件描述符将内存中的数据读出, 这块内存称之为读缓冲区</code></li><li>写数据: <code>通过文件描述符将数据写入到某块内存中, 这块内存称之为写缓冲区</code></li></ul></li><li>监听的文件描述符:<ul><li>客户端的连接请求会发送到服务器端监听的文件描述符的读缓冲区中</li><li>读缓冲区中有数据, 说明有新的客户端连接</li><li>调用accept()函数, 这个函数会检测监听文件描述符的读缓冲区<ul><li>检测不到数据, 该函数阻塞</li><li>如果检测到数据, 解除阻塞, 新的连接建立</li></ul></li></ul></li><li>通信的文件描述符:<ul><li>客户端和服务器端都有通信的文件描述符</li><li>发送数据：调用函数 write() &#x2F; send()，数据进入到内核中<ul><li>数据并没有被发送出去, 而是将数据写入到了通信的文件描述符对应的写缓冲区中</li><li>内核检测到通信的文件描述符写缓冲区中有数据, 内核会将数据发送到网络中</li></ul></li><li>接收数据: 调用的函数 read() &#x2F; recv(), 从内核读数据<ul><li>数据如何进入到内核我们不需要处理, 数据进入到通信的文件描述符的读缓冲区中</li><li>数据进入到内核, 必须使用通信的文件描述符, 将数据从读缓冲区中读出即可</li></ul></li></ul></li></ul><blockquote><p>基于tcp的服务器端通信代码:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将socket()返回值和本地的IP端口绑定到一起</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="comment">// INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏可以代表任意一个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏一般用于本地的绑定操作</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 这个宏的值为0 == 0.0.0.0</span></span><br><span class="line"><span class="comment">//    inet_pton(AF_INET, &quot;192.168.237.131&quot;, &amp;addr.sin_addr.s_addr);</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 阻塞等待并接受客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印客户端的地址信息</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">24</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP地址: %s, 端口: %d\n&quot;</span>,</span><br><span class="line">           inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, <span class="keyword">sizeof</span>(ip)),</span><br><span class="line">           ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 和客户端通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">            write(cfd, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-4-2-客户端的通信流程"><a href="#1-4-2-客户端的通信流程" class="headerlink" title="1.4.2 客户端的通信流程"></a>1.4.2 客户端的通信流程</h3><blockquote><p>在单线程的情况下客户端通信的文件描述符有一个, 没有监听的文件描述符</p></blockquote><ol><li>创建一个通信的套接字</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cfd = socket();</span><br></pre></td></tr></table></figure><ol start="2"><li>连接服务器, 需要知道服务器绑定的IP和端口</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect();</span><br></pre></td></tr></table></figure><ol start="3"><li>通信</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line">read(); / recv();</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">write(); / send();</span><br></pre></td></tr></table></figure><ol start="4"><li>断开连接, 关闭文件描述符(套接字)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close();</span><br></pre></td></tr></table></figure><blockquote><p>基于tcp通信的客户端通信代码:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.237.131&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 和服务器端通信</span></span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;你好, 服务器...%d\n&quot;</span>, number++);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器say: %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);   <span class="comment">// 每隔1s发送一条数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-5-扩展阅读"><a href="#1-5-扩展阅读" class="headerlink" title="1.5  扩展阅读"></a>1.5  扩展阅读</h2><p>在Window中也提供了套接字通信的API，这些API函数与Linux平台的API函数几乎相同，以至于很多人认为套接字通信的API函数库只有一套，看一下这些Windows平台的套接字函数：</p><h3 id="1-5-1-初始化套接字环境"><a href="#1-5-1-初始化套接字环境" class="headerlink" title="1.5.1 初始化套接字环境"></a>1.5.1 初始化套接字环境</h3><p>使用Windows中的套接字函数需要额外包含对应的头文件以及加载响应的动态库：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用包含的头文件 </span></span><br><span class="line">include &lt;winsock2.h&gt;</span><br><span class="line"><span class="comment">// 使用的套接字库 </span></span><br><span class="line">ws2_32.dll       </span><br></pre></td></tr></table></figure><p>在Windows中使用套接字需要先加载套接字库（套接字环境），最后需要释放套接字资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化Winsock库</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR。</span></span><br><span class="line">WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>wVersionRequested: 使用的Windows Socket的版本, 一般使用的版本是 2.2<ul><li>初始化这个 MAKEWORD(2, 2);参数</li></ul></li><li>lpWSAData：一个WSADATA结构指针, 这是一个传入参数<ul><li>创建一个 WSADATA 类型的变量, 将地址传递给该函数的第二个参数</li></ul></li></ul></li></ul><p>注销Winsock相关库，函数调用成功返回0，失败返回 SOCKET_ERROR。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">WSACleanup</span> <span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>使用举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WSAData wsa;</span><br><span class="line"><span class="comment">// 初始化套接字库</span></span><br><span class="line">WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .......</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注销Winsock相关库</span></span><br><span class="line">WSACleanup();</span><br></pre></td></tr></table></figure><hr><h3 id="1-5-2-套接字通信函数"><a href="#1-5-2-套接字通信函数" class="headerlink" title="1.5.2 套接字通信函数"></a>1.5.2 套接字通信函数</h3><p>基于Linux的套接字通信流程是最全面的一套通信流程，如果是在某个框架中进行套接字通信，通信流程只会更简单，直接使用window的套接字api进行套接字通信，和Linux平台上的通信流程完全相同。</p><h4 id="1-5-2-1-结构体"><a href="#1-5-2-1-结构体" class="headerlink" title="1.5.2.1 结构体"></a>1.5.2.1 结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/////////////////////////////// Windows ///////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">　　<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span>&#123;</span> <span class="type">unsigned</span> <span class="type">char</span> s_b1,s_b2, s_b3,s_b4;&#125; S_un_b;</span><br><span class="line">　　<span class="class"><span class="keyword">struct</span>&#123;</span> <span class="type">unsigned</span> <span class="type">short</span> s_w1, s_w2;&#125; S_un_w;</span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">long</span> S_addr;<span class="comment">// 存储IP地址</span></span><br><span class="line">　　&#125; S_un;</span><br><span class="line">&#125;IN_ADDR;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">　　<span class="type">short</span> <span class="type">int</span> sin_family; <span class="comment">/* Address family */</span></span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sin_port; <span class="comment">/* Port number */</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* Internet address */</span></span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">/* Same size as struct sockaddr */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////// Linux ////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>  <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>    <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(struct sockaddr) == sizeof(struct sockaddr_in)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;     <span class="comment">/* 地址族协议: AF_INET */</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;         <span class="comment">/* 端口, 2字节-&gt; 大端  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">/* IP地址, 4字节 -&gt; 大端  */</span></span><br><span class="line">    <span class="comment">/* 填充 8字节 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) - <span class="keyword">sizeof</span>(sin_family) -</span><br><span class="line">                      <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><hr><h4 id="1-5-2-2-大小端转换函数"><a href="#1-5-2-2-大小端转换函数" class="headerlink" title="1.5.2.2 大小端转换函数"></a>1.5.2.2 大小端转换函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主机字节序 -&gt; 网络字节序</span></span><br><span class="line">u_short <span class="title function_">htons</span> <span class="params">(u_short hostshort )</span>;</span><br><span class="line">u_long <span class="title function_">htonl</span> <span class="params">( u_long hostlong)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络字节序 -&gt; 主机字节序</span></span><br><span class="line">u_short <span class="title function_">ntohs</span> <span class="params">(u_short netshort )</span>;</span><br><span class="line">u_long <span class="title function_">ntohl</span> <span class="params">( u_long netlong)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// linux函数, window上没有这两个函数</span></span><br><span class="line">inet_ntop(); </span><br><span class="line">inet_pton();</span><br><span class="line"></span><br><span class="line"><span class="comment">// windows 和 linux 都使用, 只能处理ipv4的ip地址</span></span><br><span class="line"><span class="comment">// 点分十进制IP -&gt; 大端整形</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> FAR * cp)</span>;<span class="comment">// windows</span></span><br><span class="line"><span class="type">in_addr_t</span>     <span class="title function_">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;<span class="comment">// linux</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大端整形 -&gt; 点分十进制IP</span></span><br><span class="line"><span class="comment">// window, linux相同</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure><hr><h4 id="1-5-2-3-套接字函数"><a href="#1-5-2-3-套接字函数" class="headerlink" title="1.5.2.3 套接字函数"></a>1.5.2.3 套接字函数</h4><blockquote><p>window的api中套接字对应的类型是 SOCKET 类型, linux中是 int 类型, 本质是一样的</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个套接字</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回套接字, 失败返回INVALID_SOCKET</span></span><br><span class="line">SOCKET <span class="title function_">socket</span><span class="params">(<span class="type">int</span> af,<span class="type">int</span> type,<span class="type">int</span> protocal)</span>;</span><br><span class="line">参数:</span><br><span class="line">    - af: 地址族协议</span><br><span class="line">        - ipv4: AF_INET (windows/linux)</span><br><span class="line">        - PF_INET (windows)</span><br><span class="line">        - AF_INET == PF_INET</span><br><span class="line">   - type: 和linux一样</span><br><span class="line">       - SOCK_STREAM</span><br><span class="line">        - SOCK_DGRAM</span><br><span class="line">   - protocal: 一般写<span class="number">0</span> 即可</span><br><span class="line">       - 在windows上的另一种写法</span><br><span class="line">           - IPPROTO_TCP, 使用指定的流式协议中的tcp协议</span><br><span class="line">           - IPPROTO_UDP, 使用指定的报式协议中的udp协议</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 关键字: FAR NEAR, 这两个关键字在32/64位机上是没有意义的, 指定的内存的寻址方式</span></span><br><span class="line"><span class="comment">// 套接字绑定本地IP和端口</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR</span></span><br><span class="line"><span class="type">int</span> bind(SOCKET s,<span class="type">const</span> <span class="keyword">struct</span> sockaddr FAR* name, <span class="type">int</span> namelen);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置监听</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(SOCKET s,<span class="type">int</span> backlog)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待并接受客户端连接</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回用于的套接字，失败返回INVALID_SOCKET。</span></span><br><span class="line">SOCKET <span class="title function_">accept</span> <span class="params">( SOCKET s, <span class="keyword">struct</span> sockaddr FAR* addr, <span class="type">int</span> FAR* addrlen )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接服务器</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span> <span class="params">(SOCKET s,<span class="type">const</span> <span class="keyword">struct</span> sockaddr FAR* name,<span class="type">int</span> namelen )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Qt中connect用户信号槽的连接, 如果要使用windows api 中的 connect 需要在函数名前加::</span></span><br><span class="line">::connect(sock, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="comment">// 返回值: 成功时返回接收的字节数，收到EOF时为0，失败时返回SOCKET_ERROR。</span></span><br><span class="line"><span class="comment">//==0 代表对方已经断开了连接</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recv</span> <span class="params">(SOCKET s,<span class="type">char</span> FAR* buf,<span class="type">int</span> len,<span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回传输字节数，失败返回SOCKET_ERROR。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">send</span> <span class="params">(SOCKET s,<span class="type">const</span> <span class="type">char</span> FAR * buf, <span class="type">int</span> len,<span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭套接字</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closesocket</span> <span class="params">(SOCKET s)</span>;<span class="comment">// 在linux中使用的函数是: int close(int fd);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------- udp 通信函数 -------------------------</span></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recvfrom</span><span class="params">(SOCKET s,<span class="type">char</span> FAR *buf,<span class="type">int</span> len,<span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">         <span class="keyword">struct</span> sockaddr FAR *from,<span class="type">int</span> FAR *fromlen)</span>;</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendto</span><span class="params">(SOCKET s,<span class="type">const</span> <span class="type">char</span> FAR *buf,<span class="type">int</span> len,<span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">       <span class="type">const</span> <span class="keyword">struct</span> sockaddr FAR *to,<span class="type">int</span> tolen)</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="2-三次握手-四次挥手"><a href="#2-三次握手-四次挥手" class="headerlink" title="2. 三次握手,四次挥手"></a>2. 三次握手,四次挥手</h1><p>TCP协议是一个安全的、面向连接的、流式传输协议，所谓的面向连接就是三次握手<br>对于我们来说只需要在客户端调用<code>connect()</code>函数，三次握手就自动进行了。<br>通过下图看TCP协议的格式</p><h2 id="2-1-tcp协议介绍"><a href="#2-1-tcp协议介绍" class="headerlink" title="2.1 tcp协议介绍"></a>2.1 tcp协议介绍</h2><p><img src="/img/9.31.png" alt="在这里插入图片描述"></p><p>在Tcp协议中，比较重要的字段有：</p><ul><li><p>源端口：表示发送端端口号，字段长 16 位，2个字节</p></li><li><p>目的端口：表示接收端端口号，字段长 16 位，2个字节</p></li><li><p>序号（sequence number）：字段长 32 位，占4个字节，序号的范围为 [0，4284967296]。</p><ul><li>由于TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按顺序编号</li><li>首部中的序号字段则是指本报文段所发送的数据的第一个字节的序号，这是随机生成的。</li><li>序号是循环使用的，当序号增加到最大值时，下一个序号就又回到了0</li></ul></li><li><p>确认序号（acknowledgement number）：占32位（4字节），表示收到的下一个报文段的第一个数据字节的序号，如果确认序号为N，序号为S，则表明到序号N-S为止的所有数据字节都已经被正确地接收到了。</p></li><li><p>8个标志位（Flag）:</p><ul><li>CWR：CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小；</li><li>ECE：若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1；</li><li>URG：该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关；</li><li><code>ACK</code>：该位设为 1，确认应答的字段有效，TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1；</li><li>PSH：该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存；</li><li>RST：该位设为 1，表示 TCP 连接出现异常必须强制断开连接；</li><li><code>SYN</code>：用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；</li><li><code>FIN</code>：该位设为 1，表示今后不再有数据发送，希望断开连接。</li></ul></li><li><p>窗口大小：该字段长 16 位，表示从确认序号所指位置开始能够接收的数据大小，TCP 不允许发送超过该窗口大小的数据。</p></li></ul><hr><h2 id="2-2-三次握手"><a href="#2-2-三次握手" class="headerlink" title="2.2 三次握手"></a>2.2 三次握手</h2><p>Tcp连接是双向连接，客户端和服务器需要分别向对方发送连接请求，并且建立连接，三次握手成功之后，二者之间的双向连接也就成功建立了。如果要保证三次握手顺利完成，必须要满足以下条件：</p><ul><li>服务器端：已经启动，并且启动了监听（被动接受连接的一端）</li><li>客户端：基于服务器端监听的IP和端口，向服务器端发起连接请求（主动发起连接的一端）<br><img src="/img/9.32.png" alt="在这里插入图片描述"></li></ul><p>三次握手具体过程如下：</p><p>第一次握手：</p><ul><li>客户端：客户端向服务器端发起连接请求将报文中的SYN字段置为1，生成随机序号x，seq&#x3D;x</li><li>服务器端：接收客户端发送的请求数据，解析tcp协议，校验SYN标志位是否为1，并得到序号 x</li></ul><p>第二次握手：</p><ul><li>服务器端：给客户端回复数据<ol><li>回复ACK, 将tcp协议ACK对应的标志位设置为1，表示同意了客户端建立连接的请求</li><li>回复了 ack&#x3D;x+1, 这是确认序号<ul><li>x: 客户端生成的随机序号</li><li>1: 客户端给服务器发送的数据的量, SYN标志位存储到某一个字节中, 因此按照一个字节计算，表示客户端给服务器发送的1个字节服务器收到了。</li></ul></li><li>将tcp协议中的SYN对应的标志位设置为 1, 服务器向客户端发起了连接请求</li><li>服务器端生成了一个随机序号 y, 发送给了客户端</li></ol></li><li>客户端：接收回复的数据，并解析tcp协议<ol><li>校验ACK标志位，为1表示服务器接收了客户端的连接请求</li><li>数据校验，确认发送给服务器的数据服务器收到了没有，计算公式如下：<br>发送的数据的量 &#x3D; 使用服务器回复的确认序号 - 客户端生成的随机序号 &#x3D;&#x3D;&#x3D;&gt; 1&#x3D;x+1-x</li><li>校验SYN标志位，为1表示服务器请求和客户端建立连接</li><li>得到服务器生成的随机序号: y</li></ol></li></ul><p>第三次握手：</p><ul><li>客户端：发送数据给服务器<ol><li>将tcp协议中ACK标志位设置为1，表示同意了服务器的连接请求</li><li>给服务器回复了一个确认序号 ack &#x3D; y+1<ul><li>y：服务器端生成的随机序号</li><li>1：服务器给客户端发送的数据量，服务器给客户端发送了ACK和SYN, 都存储在这一个字节中</li></ul></li><li>发送给服务器的序号就是上一次从服务器端收的确认序号因此 seq &#x3D; x+1</li></ol></li><li>服务器端：接收数据, 并解析tcp协议<ol><li>查看ACK对应的标志位是否为1, 如果是1代表, 客户端同意了服务器的连接请求</li><li>数据校验，确认发送给客户端的数据客户端收到了没有，计算公式如下：<br>给客户端发送的数据量 &#x3D; 确认序号 - 服务器生成的随机序号 &#x3D;&#x3D;&#x3D;&gt; 1&#x3D;y+1-y</li><li>得到客户端发送的序号：x+1</li></ol></li></ul><hr><h2 id="2-2-TCP四次挥手"><a href="#2-2-TCP四次挥手" class="headerlink" title="2.2 TCP四次挥手"></a>2.2 TCP四次挥手</h2><p>四次挥手是断开连接的过程，需要双向断开，关于由哪一端先断开连接是没有要求的。通信的两端如果想要断开连接就需要调用<code>close()</code>函数，当两端都调用了该函数，四次挥手也就完成了。</p><ul><li><p>客户端和服务器断开连接 -&gt; 单向断开</p></li><li><p>服务器和客户端断开连接 -&gt; 单向断开</p></li></ul><p>进行了两次单向断开，双向断开就完成了，每进行一次单向断开，就会完成两次挥手的动作。<br><img src="/img/9.33.png" alt="在这里插入图片描述"></p><p>基于上图的例子对四次挥手的具体过程进行阐述（实际上那端先断开连接都是允许的）：</p><p>第一次挥手:</p><ul><li>主动断开连接的一方：发送断开连接的请求<ol><li>将tcp协议中FIN标志位设置为1，表示请求断开连接</li><li>发送序号x给对端，seq&#x3D;x，基于这个序号用于客户端数据校验的计算</li></ol></li><li>被动断开连接的一方：接收请求数据, 并解析TCP协议<ol><li>校验FIN标志位是否为1</li><li>收到了序号 x，基于这个数据计算回复的确认序号 ack 的值</li></ol></li></ul><p>第二次挥手:</p><ul><li>被动断开连接的一方：回复数据<ol><li>同意了对方断开连接的请求，将ACK标志位设置为1</li><li>回复 ack&#x3D;x+1，表示成功接受了客户端发送的一个字节数据</li><li>向客户端发送序号 seq&#x3D;y，基于这个序号用于服务器端数据校验的计算</li></ol></li><li>主动断开连接的一方：接收回复数据, 并解析TCP协议<ol><li>校验ACK标志位，如果为1表示断开连接的请求对方已经同意了</li><li>校验 ack确认发送的数据服务器是否收到了，发送的数据 &#x3D; ack - x &#x3D; x + 1 -x &#x3D; 1</li></ol></li></ul><p>第三次挥手:</p><ul><li>被动断开连接的一方：将tcp协议中FIN标志位设置为1，表示请求断开连接</li><li>主动断开连接的一方：接收请求数据, 并解析TCP协议，校验FIN标志位是否为1</li></ul><p>第四次挥手:</p><ul><li>主动断开连接的一方：回复数据<ol><li>将tcp协议中ACK对应的标志位设置为1，表示同意了断开连接的请求</li><li>ack&#x3D;y+1，表示服务器发送给客户端的一个字节客户端接收到了</li><li>序号 seq&#x3D;h，此时的h应该等于 x+1，也就是第三次挥手时服务器回复的确认序号ack的值</li></ol></li><li>被动断开连接的一方：收到回复的ACK, 此时双向连接双向断开, 通信的两端没有任何关系了</li></ul><hr><h2 id="2-3-流量控制"><a href="#2-3-流量控制" class="headerlink" title="2.3 流量控制"></a>2.3 流量控制</h2><p>流量控制可以让发送端根据接收端的实际接受能力控制发送的数据量。<br>它的具体操作是，<code>接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不会超过该大小的数据，该限制大小即为窗口大小，即窗口大小由接收端主机决定。</code></p><p>TCP 首部中，专门有一个字段来通知窗口大小，接收主机将自己可以接收的缓冲区大小放在该字段中通知发送端。<br><code>当接收端的缓冲区面临数据溢出时，窗口大小的值也是随之改变，设置为一个更小的值通知发送端，从而控制数据的发送量，这样达到流量的控制</code>。这个控制流程的窗口也可以称作滑动窗口。</p><p>此图为一个单向的数据发送:<br><img src="/img/9.34.png" alt="在这里插入图片描述"></p><p>左侧是数据发送端：对应的是发送端的写缓冲区(内存)，通过一个环形队列进行数据管理</p><ul><li>白色格子: 空闲的内存, 可以写数据</li><li>粉色的格子: 被写入到内存, 但是还没有被发送出去的数据</li><li>灰色的格子: 代表已经被发送出去的数据</li></ul><p>右侧是数据接收端：对应的是接收端的读缓冲区，存储发送端发送过来的数据</p><ul><li>白色格子：空闲的内存, 可以继续接收数据, 滑动窗口的值记录的就是白色的格子的大小<ul><li>随着接收的数据越来越多, 白色格子越来越少, 滑动窗口的值越来越小</li><li>如果白色格子没有了, 滑动窗口变为0, 这时候, 发送端就被阻塞了</li></ul></li><li>粉色格子：接收的数据，但是这个数据还没有从内核中读走，使用read() &#x2F; recv()<ul><li>粉色格子变少了, 可用空间就变多了, 滑动窗口的值就变大了</li><li>如果滑动窗口的值从0变为大于0, 接收端又重新有容量接收数据了, 发送端的阻塞自动解除，继续发送数据</li></ul></li></ul><p>基于TCP通信的流程图，记录了从三次握手 -&gt; 数据通信 -&gt; 四次挥手的全过程：<br><img src="/img/9.35.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fast sender: 客户端</span></span><br><span class="line"><span class="comment"># slow recerver: 服务器</span></span><br><span class="line"><span class="comment"># win: 滑动窗口大小</span></span><br><span class="line"><span class="comment"># mss: maximum segment size, 单条数据的最大长度</span></span><br></pre></td></tr></table></figure><p>第1步：第一次握手，发送连接请求SYN到服务器端</p><ul><li>0(0)：0表示客户端生成的随机序号，(0)表示客户端没有额外给服务器发送数据, 因此数据的量为0</li><li>win4096: 客户端告诉服务器, 能接收的数据(缓存)的最大量为4k</li><li>mss1460: 客户端可以处理的单条最大字节数是1460字节</li></ul><p>第2步：第二次握手</p><ul><li>ACK: 服务器同意了客户端的连接请求<ul><li>SYN: 服务器请求和客户端建立连接</li></ul></li><li>8000(0)：8000是服务器端生成的随机序号，(0)表示服务器没有额外给客户端发送数据, 因此数据的量为0</li><li>1: 发送给客户端的确认序号<ul><li>确认序号 &#x3D; 客户端生成的随机序号 + 客户端给服务器发送的数据量(字节数) &#x3D;&#x3D;&#x3D;&gt; 1&#x3D;0+1</li><li>表示客户端给服务器发送的1个字节服务器收到了</li></ul></li><li>win6144: 服务器告诉客户端我能最多缓存 6k数据</li><li>mss1024: 服务器能处理的单条数据最大长度是 1k</li></ul><p>第3步: 第三次握手</p><ul><li>ACK: 客户端同意了服务器的连接请求</li><li>8001: 发送给服务器的确认序号<ul><li>确认序号 &#x3D; 服务器生成的随机序号 + 服务器给客户端发送的数据量 &#x3D;&#x3D;&#x3D;&gt; 8001 &#x3D; 8000 + 1</li><li>客户端告诉服务器, 你给我发送的1个字节的数据我收到了</li></ul></li><li>win4096: 告诉服务器客户端能缓存的最大数据量是4k</li></ul><p>第4~9步: 客户端给服务器发送数据</p><ul><li><p>1(1024)：1 （1-0）表示之前一共给服务器发送了1个字节，(1024)表示这次要发送的数据量为 1k</p></li><li><p>1025(1024)：1025（1025-0）表示之前一共给服务器发送了1025个字节，(1024)表示这次要发送的数据量为 1k</p></li><li><p>2049(1024)：2049（2049-0）表示之前一共给服务器发送了2049个字节，(1024)表示这次要发送的数据量为 1k</p></li><li><p>第9步完成之后，服务器的滑动窗口变为0，接收数据的缓存被写满了，发送端阻塞</p></li></ul><p>第10步:</p><ul><li><p>ack6145: 服务器给客户端回复数据，6145是确认序号, 代表实际接收的字节数<br>服务器实际接收的字节数 &#x3D; 确认序号 - 客户端生成的随机序号 &#x3D;&#x3D;&#x3D;&gt; 6145 &#x3D; 6145 - 0</p></li><li><p>win2048：服务器告诉客户端我的缓存还有2k，也就是还有4k还在缓存中没有被读走</p></li></ul><p>第11步：win4096表示滑动窗口变为4k，代表还可以接收4k数据，还有2k在缓存中</p><p>第12步：客户端又给服务器发送了1k数据</p><p>第13步: 第一次挥手，FIN表示客户端主动和服务器断开连接，并且发送了1k数据到服务器端</p><p>第14步: 第二次挥手，回复ACK, 同意断开连接</p><p>第15, 16步: 服务器端从读缓冲区中读数据, 第16步数据读完, 滑动窗口变成最大的6k</p><p>第17步: 第三次挥手</p><ul><li><p>FIN: 服务器请求和客户端断开连接</p></li><li><p>8001(0): 服务器一共给客户端发送的字节数 8001 - 8000 &#x3D; 1个字节，携带的数据量为0（FIN不计算在内）</p></li><li><p>ack8194: 服务器收到了客户端的多少个字节: 8194 - 0 &#x3D; 8194个字节</p></li></ul><p>第18步: 第四次挥手</p><ul><li>ACK: 客户端同意了服务器断开连接的请求</li><li>8002: 确认序号, 可以计算出服务器给客户端发送了多少数据，8002 - 8000 &#x3D; 2 个字节</li></ul><hr><h1 id="3-TCP状态转换"><a href="#3-TCP状态转换" class="headerlink" title="3. TCP状态转换"></a>3. TCP状态转换</h1><h2 id="3-1-TCP状态转换"><a href="#3-1-TCP状态转换" class="headerlink" title="3.1 TCP状态转换"></a>3.1 TCP状态转换</h2><p>在TCP进行三次握手，或者四次挥手的过程中，通信的服务器和客户端内部会发送状态上的变化，发生的状态变化在程序中是看不到的，这个状态的变化也不需要我们去维护，但在某些情况下进行程序的调试会去查看相关的状态信息，先来看三次握手过程中的状态转换。</p><p><img src="/img/9.36.png" alt="在这里插入图片描述"></p><h3 id="3-1-1-三次握手"><a href="#3-1-1-三次握手" class="headerlink" title="3.1.1 三次握手"></a>3.1.1 三次握手</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在第一次握手之前，服务器端必须先启动，并且已经开始了监听</span><br><span class="line">  - 服务器端先调用了 listen() 函数, 开始监听</span><br><span class="line">  - 服务器启动监听前后的状态变化: 没有状态 ---&gt; LISTEN</span><br></pre></td></tr></table></figure><p>当服务器监听启动之后，由客户端发起的三次握手过程中状态转换如下：</p><p>第一次握手:</p><ul><li>客户端：调用了<code>connect()</code> 函数，状态变化：<code>没有状态 -&gt; SYN_SENT</code></li><li>服务器：收到连接请求SYN，状态变化：<code>LISTEN -&gt; SYN_RCVD</code></li></ul><p>第二次握手:</p><ul><li>服务器：给客户端回复ACK，并且请求和客户端建立连接，状态无变化，依然是 SYN_RCVD</li><li>客户端：接收数据，收到了ACK，状态变化：<code>SYN_SENT -&gt; ESTABLISHED</code></li></ul><p>第三次握手:</p><ul><li>客户端：给服务器回复ACK，同意建立连接，状态没有变化，还是 ESTABLISHED</li><li>服务器：收到了ACK，状态变化：<code>SYN_RCVD -&gt; ESTABLISHED</code></li></ul><p><code>三次握手完成之后，客户端和服务器都变成了同一种状态，这种状态叫：ESTABLISHED，表示双向连接已经建立， 可以通信了。在通过过程中，正常的通信状态就是 ESTABLISHED。</code></p><hr><h3 id="3-1-2-四次挥手"><a href="#3-1-2-四次挥手" class="headerlink" title="3.1.2 四次挥手"></a>3.1.2 四次挥手</h3><p>关于四次挥手对于客户端和服务器哪段先断开连接没有要求，根据实际情况处理即可。下面根据上图中的实例描述一下四次挥手过程中TCP的状态转换（上图中主动断开连接的一方是客户端）：</p><p>第一次挥手:</p><ul><li><p>客户端：调用<code>close()</code> 函数，将tcp协议中的FIN设置为1，请求和服务器断开连接，<br>状态变化:<code>ESTABLISHED -&gt; FIN_WAIT_1</code></p></li><li><p>服务器：收到断开连接请求，状态变化: <code>ESTABLISHED -&gt; CLOSE_WAIT</code></p></li></ul><p>第二次挥手:</p><ul><li>服务器：回复ACK，同意断开连接的请求，状态没有变化，还是 CLOSE_WAIT</li><li>客户端：收到ACK，状态变化：<code>FIN_WAIT_1 -&gt; FIN_WAIT_2</code></li></ul><p>第三次挥手:</p><ul><li>服务器端：调用close() 函数，发送FIN给客户端，请求断开连接，状态变化：<code>CLOSE_WAIT -&gt; LAST_ACK</code></li><li>客户端：收到FIN，状态变化：<code>FIN_WAIT_2 -&gt; TIME_WAIT</code></li></ul><p>第四次挥手:</p><ul><li>客户端：回复ACK给服务器，状态是没有变化的，状态变化：<code>TIME_WAIT -&gt; 没有状态</code></li><li>服务器端：收到ACK，双向连接断开，状态变化：<code>LAST_ACK -&gt; 无状态(没有了)</code></li></ul><hr><h3 id="3-1-3-状态转换"><a href="#3-1-3-状态转换" class="headerlink" title="3.1.3 状态转换"></a>3.1.3 状态转换</h3><p>在下图中同样是描述TCP通信过程中的客户端和服务器端的状态转换<br>只需要看两条主线：红色实线和绿色虚线。关于黑色的实线对应的是一些特殊情况下的状态切换，在此不做任何分析。</p><p>因为三次握手是由客户端发起的，据此分析红色实线表示的客户端的状态，绿色虚线表示的是服务器端的状态。<br><img src="/img/9.37.png" alt="在这里插入图片描述"></p><ul><li>客户端：<ul><li>第一次握手：发送SYN，<code>没有状态 -&gt; SYN_SENT</code></li><li>第二次握手：收到回复的ACK，<code>SYN_SENT -&gt; ESTABLISHED</code></li><li>主动断开连接，第一次挥手发送FIN，状态<code>ESTABLISHED -&gt; FIN_WAIT_1</code></li><li>第二次挥手，收到ACK，状态<code>FIN_WAIT_1 -&gt; FIN_WAIT_2</code></li><li>第三次挥手，收到FIN，状态<code>FIN_WAIT_2 -&gt; TIME_WAIT</code></li><li>第四次挥手，回复ACK，等待2倍报文时长之后，状态<code>TIME_WAIT -&gt; 没有状态</code></li></ul></li><li>服务器端：<ul><li>启动监听，<code>没有状态 -&gt; LISTEN</code></li><li>第一次握手，收到SYN，状态<code>LISTEN -&gt; SYN_RCVD</code></li><li>第三次握手，收到ACK，状态<code>SYN_RCVD -&gt; ESTABLISHED</code></li><li>收到断开连接请求，第一次挥手状态 <code>ESTABLISHED -&gt; CLOSE_WAIT</code></li><li>第三次挥手，发送FIN请求和客户端断开连接，状态<code>CLOSE_WAIT -&gt; LAST_ACK</code></li><li>第四次挥手，收到ACK，状态<code>LAST_ACK -&gt; 无状态(没有了)</code></li></ul></li></ul><p>在TCP通信的时候，当主动断开连接的一方接收到被动断开连接的一方发送的FIN和最终的ACK后（第三次挥手完成），连接的主动关闭方必须处于<code>TIME_WAIT</code>状态并持续<code>2MSL(Maximum Segment Lifetime)</code>时间，这样就能够让TCP连接的主动关闭方在它发送的ACK丢失的情况下重新发送最终的ACK。</p><p>一倍报文寿命(MSL)大概时长为30s，因此两倍报文寿命一般在1分钟作用。</p><p><code>主动关闭方重新发送的最终ACK，是因为被动关闭方重传了它的FIN。事实上，被动关闭方总是重传FIN直到它收到一个最终的ACK。</code></p><hr><h3 id="3-1-4-相关命令"><a href="#3-1-4-相关命令" class="headerlink" title="3.1.4 相关命令"></a>3.1.4 相关命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ netstat 参数</span><br><span class="line">$ netstat -apn| grep 关键字</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li><code>-a</code> (all)显示所有选项</li><li><code>-p</code> 显示建立相关链接的程序名</li><li><code>-n</code> 拒绝显示别名，能显示数字的全部转化成数字。</li><li><code>-l</code> 仅列出有在 Listen (监听) 的服务状态</li><li><code>-t </code>(tcp)仅显示tcp相关选项</li><li><code>-u</code> (udp)仅显示udp相关选项</li></ul></li></ul><hr><h2 id="3-2-半关闭"><a href="#3-2-半关闭" class="headerlink" title="3.2 半关闭"></a>3.2 半关闭</h2><p>TCP连接只有一方发送了FIN，另一方没有发出FIN包，仍然可以在一个方向上正常发送数据，这中状态可以称之为半关闭或者半连接。当四次挥手完成两次的时候，就相当于实现了半关闭，在程序中只需要在某一端直接调用 close() 函数即可。套接字通信默认是双工的，也就是双向通信，如果进行了半关闭就变成了单工，数据只能单向流动了。比如下面的这个例子：</p><ul><li>服务器端:<ul><li>调用了close() 函数，因此不能发数据，只能接收数据</li><li>关闭了服务器端的写操作，现在只能进行读操作 –&gt; 变成了读端</li></ul></li><li>客户端:<ul><li>没有调用close()，客户端和服务器的连接还保持着</li><li>客户端可以给服务器发送数据，也可以接收服务器发送的数据 （但是，服务器已经丧失了发送数据的能力），因此客户端也只能发送数据，接收不到数据 –&gt; 变成了写端</li></ul></li></ul><p>按照上述流程做了半关闭之后，从双工变成了单工，数据单向流动的方向: 客户端 —–&gt; 服务器端。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 专门处理半关闭的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 可以有选择的关闭读/写, close()函数只能关闭写操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd: 要操作的文件描述符</li><li>how:<ul><li>SHUT_RD: 关闭文件描述符对应的读操作</li><li>SHUT_WR: 关闭文件描述符对应的写操作</li><li>SHUT_RDWR: 关闭文件描述符对应的读写操作</li></ul></li></ul></li><li>返回值：函数调用成功返回0，失败返回-1</li></ul><hr><h2 id="3-3-端口复用"><a href="#3-3-端口复用" class="headerlink" title="3.3 端口复用"></a>3.3 端口复用</h2><p>在网络通信中，一个端口只能被一个进程使用，不能多个进程共用同一个端口。我们在进行套接字通信的时候，如果按顺序执行如下操作：先启动服务器程序，再启动客户端程序，然后关闭服务器进程，再退出客户端进程，最后再启动服务器进程，就会出如下错误信息：<code>bind error: Address already in use</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二次启动服务器进程</span></span><br><span class="line">$ ./server </span><br><span class="line"><span class="built_in">bind</span> error: Address already <span class="keyword">in</span> use</span><br><span class="line"></span><br><span class="line">$ netstat -apn|grep 9999</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        0      0 127.0.0.1:9999          127.0.0.1:50178         TIME_WAIT   -   </span><br></pre></td></tr></table></figure><p>通过<code>netstat</code>查看TCP状态，发现上一个服务器进程其实还没有真正退出。<br>因为服务器进程是主动断开连接的进程, 最后状态变成了 <code>TIME_WAIT</code>状态，这个进程会等待<code>2msl(大约1分钟)</code>才会退出，如果该进程不退出，其绑定的端口就不会释放，再次启动新的进程还是使用这个未释放的端口，<code>端口被重复使用</code>，<code>bind error: Address already in use</code></p><p>如果想要解决上述问题，就必须要设置端口复用，使用的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数是一个多功能函数, 可以设置套接字选项</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd：用于监听的文件描述符</li><li>level：设置端口复用需要使用 SOL_SOCKET 宏</li><li>optname：要设置什么属性（下边的两个宏都可以设置端口复用）<ul><li>SO_REUSEADDR</li><li>SO_REUSEPORT</li></ul></li><li>optval：设置是去除端口复用属性还是设置端口复用属性，实际应该使用 int 型变量<ul><li>0：不设置</li><li>1：设置</li></ul></li><li>optlen：optval指针指向的内存大小 sizeof(int)</li></ul></li></ul><blockquote><p>这个函数应该添加到服务器端代码中，具体应放在绑定之前设置端口复用</p></blockquote><ol><li>创建监听的套接字</li><li>设置端口复用</li><li>绑定</li><li>设置监听</li><li>等待并接受客户端连接</li><li>通信</li><li>断开连接</li></ol><p>参考代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">// 本地多有的ＩＰ</span></span><br><span class="line">    <span class="comment">// 127.0.0.1</span></span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr.s_addr);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd_set reads, tmp;</span><br><span class="line">    FD_ZERO(&amp;reads);</span><br><span class="line">    FD_SET(lfd, &amp;reads);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = reads;</span><br><span class="line">        <span class="type">int</span> ret = select(maxfd+<span class="number">1</span>, &amp;tmp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(lfd, &amp;tmp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cfd = accept(lfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            FD_SET(cfd, &amp;reads);</span><br><span class="line">            maxfd = cfd &gt; maxfd ? cfd : maxfd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=lfd+<span class="number">1</span>; i&lt;=maxfd; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(i, &amp;tmp))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">int</span> len = read(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client say: %s\n&quot;</span>, buf);</span><br><span class="line">                    write(i, buf, len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接\n&quot;</span>);</span><br><span class="line">                    FD_CLR(i, &amp;reads);</span><br><span class="line">                    close(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="4-服务器并发"><a href="#4-服务器并发" class="headerlink" title="4. 服务器并发"></a>4. 服务器并发</h1><h2 id="4-1-单线程-进程"><a href="#4-1-单线程-进程" class="headerlink" title="4.1 单线程&#x2F;进程"></a>4.1 单线程&#x2F;进程</h2><p>在TCP通信过程中，服务器端启动之后可以同时和多个客户端建立连接，并进行网络通信，但是在介绍TCP通信流程的时候，提供的服务器代码却不能完成这样的需求<br>看之前的服务器代码的处理思路，分析弊端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 2. 将socket()返回值和本地的IP端口绑定到一起</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="comment">// INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏可以代表任意一个IP地址</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 这个宏的值为0 == 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="comment">// 4. 阻塞等待并接受客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">    <span class="comment">// 5. 和客户端通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">            write(cfd, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中用到了三个会引起程序阻塞的函数，分别是：</p><ul><li><code>accept()</code>：如果服务器端没有新客户端连接，阻塞当前进程&#x2F;线程，如果检测到新连接解除阻塞，建立连接</li><li><code>read()</code>：如果通信的套接字对应的读缓冲区没有数据，阻塞当前进程&#x2F;线程，检测到数据解除阻塞，接收数据</li><li><code>write()</code>：如果通信的套接字写缓冲区被写满了，阻塞当前进程&#x2F;线程（比较少见）</li></ul><p>如果需要和发起新的连接请求的客户端建立连接，那么就必须在服务器端通过一个循环调用<code>accept()</code>函数，另外已经和服务器建立连接的客户端需要和服务器通信，发送数据时的阻塞可以忽略，当接收不到数据时程序也会被阻塞，这时候就会非常矛盾，被<code>accept()</code>阻塞就无法通信，被<code>read()</code>阻塞就无法和客户端建立新连接。<br>基于上述处理方式，在单线程&#x2F;单进程场景下，服务器是无法处理多连接的<br>解决方案也有很多，常用的有三种：</p><ol><li>使用多线程实现</li><li>使用多进程实现</li><li>使用IO多路转接（复用）实现</li><li>使用IO多路转接 + 多线程实现</li></ol><hr><h2 id="4-2-多进程并发"><a href="#4-2-多进程并发" class="headerlink" title="4.2 多进程并发"></a>4.2 多进程并发</h2><p>如果要编写多进程版的并发服务器程序，首先要考虑，创建出的多个进程都是什么角色，这样就可以在程序中对号入座了。在Tcp服务器端一共有两个角色，分别是：监听和通信，监听是一个持续的动作，如果有新连接就建立连接，如果没有新连接就阻塞。关于通信是需要和多个客户端同时进行的，因此需要多个进程，这样才能达到互不影响的效果。进程也有两大类：父进程和子进程，通过分析我们可以这样分配进程：</p><ul><li>父进程：<ul><li>负责监听，处理客户端的连接请求，也就是在父进程中循环调用<code>accept()</code>函数</li><li>创建子进程：建立一个新的连接，就创建一个新的子进程，让这个子进程和对应的客户端通信</li><li>回收子进程资源：子进程退出回收其内核PCB资源，防止出现僵尸进程</li></ul></li><li>子进程：负责通信，基于父进程建立新连接之后得到的文件描述符，和对应的客户端完成数据的接收和发送。<ul><li>发送数据：<code>send() / write()</code></li><li>接收数据：<code>recv() / read()</code></li></ul></li></ul><p>在多进程版的服务器端程序中，多个进程是有血缘关系，对应有血缘关系的进程来说，还需要想明白他们有哪些资源是可以被继承的，哪些资源是独占的，以及一些其他细节：</p><ul><li><p>子进程是父进程的拷贝，在子进程的内核区PCB中，文件描述符也是可以被拷贝的，因此在父进程可以使用的文件描述符在子进程中也有一份，并且可以使用它们做和父进程一样的事情。</p></li><li><p>父子进程有用各自的独立的虚拟地址空间，因此所有的资源都是独占的</p></li><li><p>为了节省系统资源，对于只有在父进程才能用到的资源，可以在子进程中将其释放掉，父进程亦如此。</p></li><li><p>由于需要在父进程中做accept()操作，并且要释放子进程资源，如果想要更高效一下可以使用信号的方式处理<br><img src="/img/9.38.png" alt="在这里插入图片描述"></p></li></ul><p>多进程版并发TCP服务器示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">callback</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(pid &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程正在运行, 或者子进程被回收完毕了\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">childWork</span><span class="params">(<span class="type">int</span> cfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将socket()返回值和本地的IP端口绑定到一起</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="comment">// INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏可以代表任意一个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏一般用于本地的绑定操作</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 这个宏的值为0 == 0.0.0.0</span></span><br><span class="line">    <span class="comment">//    inet_pton(AF_INET, &quot;192.168.237.131&quot;, &amp;addr.sin_addr.s_addr);</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号的捕捉</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = callback;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受多个客户端连接, 对需要循环调用 accept</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 4. 阻塞等待并接受客户端连接</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// accept调用被信号中断了, 解除阻塞, 返回了-1</span></span><br><span class="line">                <span class="comment">// 重新调用一次accept</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印客户端的地址信息</span></span><br><span class="line">        <span class="type">char</span> ip[<span class="number">24</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP地址: %s, 端口: %d\n&quot;</span>,</span><br><span class="line">               inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, <span class="keyword">sizeof</span>(ip)),</span><br><span class="line">               ntohs(cliaddr.sin_port));</span><br><span class="line">        <span class="comment">// 新的连接已经建立了, 创建子进程, 让子进程和这个客户端通信</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 子进程 -&gt; 和客户端通信</span></span><br><span class="line">            <span class="comment">// 通信的文件描述符cfd被拷贝到子进程中</span></span><br><span class="line">            <span class="comment">// 子进程不负责监听</span></span><br><span class="line">            close(lfd);</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> ret = childWork(cfd);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt;=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 退出子进程</span></span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 父进程不和客户端通信</span></span><br><span class="line">            close(cfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 和客户端通信</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">childWork</span><span class="params">(<span class="type">int</span> cfd)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="type">int</span> len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">        write(cfd, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例代码中，父子进程中分别关掉了用不到的文件描述符（父进程不需要通信，子进程也不需要监听）。如果客户端主动断开连接，那么服务器端负责和客户端通信的子进程也就退出了，子进程退出之后会给父进程发送一个叫做<code>SIGCHLD</code>的信号，在父进程中通过<code>sigaction()</code>函数捕捉了该信号，通过回调函数<code>callback()</code>中的<code>waitpid()</code>对退出的子进程进行了资源回收。</p><p>还有一个细节，这是父进程的处理代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// accept调用被信号中断了, 解除阻塞, 返回了-1</span></span><br><span class="line">                <span class="comment">// 重新调用一次accept</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果父进程调用<code>accept()</code> 函数没有检测到新的客户端连接，父进程就阻塞在这儿了，这时候有子进程退出了，发送信号给父进程，父进程就捕捉到了这个信号<code>SIGCHLD</code><br>由于信号的优先级很高，会打断代码正常的执行流程，因此父进程的阻塞被中断，转而去处理这个信号对应的函数<code>callback()</code>，处理完毕<br>再次回到<code>accept()</code>位置，但是这是已经无法阻塞了，函数直接返回-1，此时函数调用失败，错误描述为<code>accept: Interrupted system call</code>，对应的错误号为<code>EINTR</code>，由于代码是被信号中断导致的错误，所以可以在程序中对这个错误号进行判断，让父进程重新调用<code>accept()</code>，继续阻塞或者接受客户端的新连接。</p><hr><h2 id="4-3-多线程并发"><a href="#4-3-多线程并发" class="headerlink" title="4.3 多线程并发"></a>4.3 多线程并发</h2><p>编写多线程版的并发服务器程序和多进程思路差不多，考虑明白了对号入座即可。多线程中的线程有两大类：主线程（父线程）和子线程，他们分别要在服务器端处理监听和通信流程。</p><ul><li>主线程：<ul><li>负责监听，处理客户端的连接请求，也就是在父进程中循环调用<code>accept()</code>函数</li><li>创建子线程：建立一个新的连接，就创建一个新的子进程，让这个子进程和对应的客户端通信</li><li>回收子线程资源：由于回收需要调用阻塞函数，这样就会影响<code>accept()</code>，直接做<code>线程分离</code>即可。</li></ul></li><li>子线程：负责通信，基于主线程建立新连接之后得到的文件描述符，和对应的客户端完成数据的接收和发送。<ul><li>发送数据：<code>send() / write()</code></li><li>接收数据：<code>recv() / read()</code></li></ul></li></ul><p>在多线程版的服务器端程序中，多个线程共用同一个地址空间，有些数据是共享的，有些数据的独占的，分析其中的一些细节：</p><ul><li>同一地址空间中的多个线程的栈空间是独占的</li><li>多个线程共享全局数据区，堆区，以及内核区的文件描述符等资源，因此<code>需要注意数据覆盖</code>问题，并且在多个线程访问共享资源的时候，还需要进行线程同步。<br><img src="/img/9.39.png" alt="在这里插入图片描述"></li></ul><p>多线程版Tcp服务器示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> fd;                      <span class="comment">// 通信</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;               <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span>     <span class="comment">// 地址信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span> <span class="title">infos</span>[128];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span>* <span class="title">info</span> =</span> (<span class="keyword">struct</span> SockInfo*)arg;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> ret = read(info-&gt;fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端已经关闭连接...\n&quot;</span>);</span><br><span class="line">            info-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;接收数据失败...\n&quot;</span>);</span><br><span class="line">            info-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            write(info-&gt;fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于监听的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;          <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">8989</span>);        <span class="comment">// 字节序应该是网络字节序</span></span><br><span class="line">    addr.sin_addr.s_addr =  INADDR_ANY; <span class="comment">// == 0, 获取IP的操作交给了内核</span></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.设置监听</span></span><br><span class="line">    ret = listen(fd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 等待, 接受连接请求</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据初始化</span></span><br><span class="line">    <span class="type">int</span> max = <span class="keyword">sizeof</span>(infos) / <span class="keyword">sizeof</span>(infos[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        bzero(&amp;infos[i], <span class="keyword">sizeof</span>(infos[i]));</span><br><span class="line">        infos[i].fd = <span class="number">-1</span>;</span><br><span class="line">        infos[i].tid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程监听, 子进程通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span>* <span class="title">pinfo</span>;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;max; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(infos[i].fd == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pinfo = &amp;infos[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == max<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> connfd = accept(fd, (<span class="keyword">struct</span> sockaddr*)&amp;pinfo-&gt;addr, &amp;len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent thread, connfd: %d\n&quot;</span>, connfd);</span><br><span class="line">        <span class="keyword">if</span>(connfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pinfo-&gt;fd = connfd;</span><br><span class="line">        pthread_create(&amp;pinfo-&gt;tid, <span class="literal">NULL</span>, working, pinfo);</span><br><span class="line">        pthread_detach(pinfo-&gt;tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd);  <span class="comment">// 监听</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编写多线程版并发服务器代码的时候，需要注意父子线程共用同一个地址空间中的文件描述符，因此每当在主线程中建立一个新的连接，都需要将得到文件描述符值保存起来，不能在同一变量上进行覆盖，这样做丢失了之前的文件描述符值也就不知道怎么和客户端通信了。</p><p>在上面示例代码中是将成功建立连接之后得到的用于通信的文件描述符值保存到了一个全局数组中，每个子线程需要和不同的客户端通信，需要的文件描述符值也就不一样，只要保证存储每个有效文件描述符值的变量对应不同的内存地址，在使用的时候就不会发生数据覆盖的现象，造成通信数据的混乱了。</p><hr><h1 id="5-TCP数据粘包的处理"><a href="#5-TCP数据粘包的处理" class="headerlink" title="5. TCP数据粘包的处理"></a>5. TCP数据粘包的处理</h1><h2 id="5-1-TCP"><a href="#5-1-TCP" class="headerlink" title="5.1 TCP"></a>5.1 TCP</h2><p>在前面介绍套接字通信的时候说到了<code>TCP</code>是传输层协议，它是一个面向连接的、安全的、流式传输协议。因为数据的传输是基于流的所以发送端和接收端每次处理的数据的量，处理数据的频率可以不是对等的，可以按照自身需求来进行决策。</p><p>TCP协议是优势非常明显，但假设我们有需求：</p><blockquote><p>客户端和服务器之间要进行基于TCP的套接字通信</p><ul><li>通信过程中客户端会每次会不定期给服务器发送一个不定长度的有特定含义的字符串。</li><li>通信的服务器端每次都需要接收到客户端这个不定长度的字符串，并对其进行解析</li></ul></blockquote><p>根据上面的描述，服务器在接收数据的时候有如下几种情况：</p><ol><li>一次接收到了客户端发送过来的一个完整的数据包</li><li>一次接收到了客户端发送过来的N个数据包，由于每个包的长度不定，无法将各个数据包拆开</li><li>一次接收到了一个或者N个数据包 + 下一个数据包的一部分，无法将数据包拆开</li><li>一次收到了半个数据包，下一次接收数据的时候收到了剩下的一部分+下个数据包的一部分</li><li>另外，还有一些不可抗拒的因素：比如客户端和服务器端的网速不一样，发送和接收的数据量也会不一致</li></ol><p>对于以上描述的现象很多时候我们将其称之为<code>TCP的粘包问题</code>，<code>本身TCP就是面向连接的流式传输协议，特性如此，我们却说是TCP这个协议出了问题，这是使用者的无知。多个数据包粘连到一起无法拆分是需求过于复杂造成的，是我们的问题而不是协议的问题。</code></p><p>服务器端如果想保证每次都能接收到客户端发送过来的这个不定长度的数据包，如何解决？</p><ol><li>使用标准的应用层协议（比如：http、https）来封装要传输的不定长的数据包</li><li>在每条数据的尾部添加特殊字符, 如果遇到特殊字符, 代表当条数据接收完毕了<ul><li>有缺陷: 效率低, 需要一个字节一个字节接收, 接收一个字节判断一次</li></ul></li><li>在发送数据块之前, 在数据块最前边添加一个固定大小的数据头, 这时候数据由两部分组成：数据头+数据块<ul><li>数据头：存储当前数据包的总字节数，接收端先接收数据头，然后在根据数据头接收对应大小的字节</li><li>数据块：当前数据包的内容</li></ul></li></ol><hr><h2 id="5-2-解决方案"><a href="#5-2-解决方案" class="headerlink" title="5.2 解决方案"></a>5.2 解决方案</h2><p>如果使用TCP进行套接字通信，如果发送的数据包粘连到一起导致接收端无法解析，我们通常使用添加包头的方式解决这个问题。<br>关于数据包的包头大小可以根据自己的实际需求进行设定，这里没特殊需求，因此规定包头的固定大小为4个字节，用于存储当前数据块的总字节数。<br><img src="/img/9.40.png" alt="在这里插入图片描述"></p><h3 id="5-2-1-发送端"><a href="#5-2-1-发送端" class="headerlink" title="5.2.1 发送端"></a>5.2.1 发送端</h3><p>对于发送端来说，数据的发送分为4步：</p><ol><li>根据待发送的数据长度N动态申请一块固定大小的内存：N+4（4是包头占用的字节数）</li><li>将待发送数据的总长度写入申请的内存的前四字节中，<code>此处需要将其转换为网络字节序(大端)</code></li><li>将待发送的数据拷贝到包头后边的地址空间中，将完整的数据包发送出去<code>（字符串没有字节序问题）</code></li><li>释放申请的堆内存。</li></ol><p>由于发送端每次都需要将这个数据包完整的发送出去，因此可以设计一个发送函数，如果当前数据包中的数据没有发送完就让它一直发送，处理代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数描述: 发送指定的字节数</span></span><br><span class="line"><span class="comment">函数参数:</span></span><br><span class="line"><span class="comment">    - fd: 通信的文件描述符(套接字)</span></span><br><span class="line"><span class="comment">    - msg: 待发送的原始数据</span></span><br><span class="line"><span class="comment">    - size: 待发送的原始数据的总字节数</span></span><br><span class="line"><span class="comment">函数返回值: 函数调用成功返回发送的字节数, 发送失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* buf = msg;</span><br><span class="line">    <span class="type">int</span> count = size;</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> len = send(fd, buf, count, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buf += len;</span><br><span class="line">        count -= len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个功能函数之后就可以发送带有包头的数据块了，具体处理动作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数描述: 发送带有数据头的数据包</span></span><br><span class="line"><span class="comment">函数参数:</span></span><br><span class="line"><span class="comment">    - cfd: 通信的文件描述符(套接字)</span></span><br><span class="line"><span class="comment">    - msg: 待发送的原始数据</span></span><br><span class="line"><span class="comment">    - len: 待发送的原始数据的总字节数</span></span><br><span class="line"><span class="comment">函数返回值: 函数调用成功返回发送的字节数, 发送失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendMsg</span><span class="params">(<span class="type">int</span> cfd, <span class="type">char</span>* msg, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(msg == <span class="literal">NULL</span> || len &lt;= <span class="number">0</span> || cfd &lt;=<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 申请内存空间: 数据长度 + 包头4字节(存储数据长度)</span></span><br><span class="line">   <span class="type">char</span>* data = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len+<span class="number">4</span>);</span><br><span class="line">   <span class="type">int</span> bigLen = htonl(len);</span><br><span class="line">   <span class="built_in">memcpy</span>(data, &amp;bigLen, <span class="number">4</span>);</span><br><span class="line">   <span class="built_in">memcpy</span>(data+<span class="number">4</span>, msg, len);</span><br><span class="line">   <span class="comment">// 发送数据</span></span><br><span class="line">   <span class="type">int</span> ret = writen(cfd, data, len+<span class="number">4</span>);</span><br><span class="line">   <span class="comment">// 释放内存</span></span><br><span class="line">   <span class="built_in">free</span>(data);</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>字符串没有字节序问题，但是数据头不是字符串是整形，因此需从主机字节序转换为网络字节序再发送。</code></p><hr><h3 id="5-2-2-接收端"><a href="#5-2-2-接收端" class="headerlink" title="5.2.2 接收端"></a>5.2.2 接收端</h3><p>了解了套接字的发送端如何发送数据，接收端的处理步骤也就清晰了，具体过程如下：</p><ol><li>首先接收4字节数据，并将其从网络字节序转换为主机字节序，这样就得到了即将要接收的数据的总长度</li><li>根据得到的长度申请固定大小的堆内存，用于存储待接收的数据</li><li>根据得到的数据块长度接收固定数目的数据保存到申请的堆内存中</li><li>处理接收的数据</li><li>释放存储数据的堆内存</li></ol><p>从数据包头解析出要接收的数据长度之后，还需要将这个数据块完整的接收到本地才能进行后续的数据处理，因此需要编写一个接收数据的功能函数，保证能够得到一个完整的数据包数据<br>处理函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数描述: 接收指定的字节数</span></span><br><span class="line"><span class="comment">函数参数:</span></span><br><span class="line"><span class="comment">    - fd: 通信的文件描述符(套接字)</span></span><br><span class="line"><span class="comment">    - buf: 存储待接收数据的内存的起始地址</span></span><br><span class="line"><span class="comment">    - size: 指定要接收的字节数</span></span><br><span class="line"><span class="comment">函数返回值: 函数调用成功返回发送的字节数, 发送失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* pt = buf;</span><br><span class="line">    <span class="type">int</span> count = size;</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> len = recv(fd, pt, count, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> size - count;</span><br><span class="line">        &#125;</span><br><span class="line">        pt += len;</span><br><span class="line">        count -= len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数搞定之后，就可以轻松地接收带包头的数据块了，接收函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数描述: 接收带数据头的数据包</span></span><br><span class="line"><span class="comment">函数参数:</span></span><br><span class="line"><span class="comment">    - cfd: 通信的文件描述符(套接字)</span></span><br><span class="line"><span class="comment">    - msg: 一级指针的地址，函数内部会给这个指针分配内存，用于存储待接收的数据，这块内存需要使用者释放</span></span><br><span class="line"><span class="comment">函数返回值: 函数调用成功返回接收的字节数, 发送失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recvMsg</span><span class="params">(<span class="type">int</span> cfd, <span class="type">char</span>** msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="comment">// 1. 读数据头</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    readn(cfd, (<span class="type">char</span>*)&amp;len, <span class="number">4</span>);</span><br><span class="line">    len = ntohl(len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据块大小: %d\n&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据读出的长度分配内存，+1 -&gt; 这个字节存储\0</span></span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ret = readn(cfd, buf, len);</span><br><span class="line">    <span class="keyword">if</span>(ret != len)</span><br><span class="line">    &#123;</span><br><span class="line">        close(cfd);</span><br><span class="line">        <span class="built_in">free</span>(buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    *msg = buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在进行套接字通信的时候通过调用封装的<code>sendMsg()</code>和<code>recvMsg()</code>就可以发送和接收带数据头的数据包了，而且完美地解决了粘包的问题。</p><hr><h1 id="6-套接字通信类的封装"><a href="#6-套接字通信类的封装" class="headerlink" title="6. 套接字通信类的封装"></a>6. 套接字通信类的封装</h1><p>在掌握了基于TCP的套接字通信流程之后，为了方便使用，提高编码效率，可以对通信操作进行封装，先基于C语言进行面向过程的函数封装，再基于C++进行面向对象的类封装。</p><h2 id="6-1-基于C语言的封装"><a href="#6-1-基于C语言的封装" class="headerlink" title="6.1 基于C语言的封装"></a>6.1 基于C语言的封装</h2><p>基于TCP的套接字通信分为两部分：服务器端通信和客户端通信。只要掌握了通信流程，封装出对应的功能函数也就不在话下了，回顾一下通信流程：</p><ul><li>服务器端<ol><li>创建用于监听的套接字</li><li>将用于监听的套接字和本地的IP以及端口进行绑定</li><li>启动监听</li><li>等待并接受新的客户端连接，连接建立得到用于通信的套接字和客户端的IP、端口信息</li><li>使用得到的通信的套接字和客户端通信（接收和发送数据）</li><li>通信结束，关闭套接字（监听 + 通信）</li></ol></li><li>客户端<ol><li>创建用于通信的套接字</li><li>使用服务器端绑定的IP和端口连接服务器</li><li>使用通信的套接字和服务器通信（发送和接收数据）</li><li>通信结束，关闭套接字（通信）</li></ol></li></ul><h3 id="6-1-1-函数声明"><a href="#6-1-1-函数声明" class="headerlink" title="6.1.1 函数声明"></a>6.1.1 函数声明</h3><p>通过通信流程可以看出服务器和客户端有些操作步骤是相同的，因此封装的功能函数是可以共用的，相关的通信函数声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////////////////////////// </span></span><br><span class="line"><span class="comment">//////////////////// 服务器 ///////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bindSocket</span><span class="params">(<span class="type">int</span> lfd, <span class="type">unsigned</span> <span class="type">short</span> port)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setListen</span><span class="params">(<span class="type">int</span> lfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">acceptConn</span><span class="params">(<span class="type">int</span> lfd, <span class="keyword">struct</span> sockaddr_in *addr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////// </span></span><br><span class="line"><span class="comment">//////////////////// 客户端 ///////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connectToHost</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////// </span></span><br><span class="line"><span class="comment">///////////////////// 共用 ////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">createSocket</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sendMsg</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* msg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">recvMsg</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* msg, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">closeSocket</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><p>关于函数readn()和writen()的作用 参考 TCP数据粘包处理</p><hr><h3 id="6-1-2-函数定义"><a href="#6-1-2-函数定义" class="headerlink" title="6.1.2 函数定义"></a>6.1.2 函数定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建监套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">createSocket</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;套接字创建成功, fd=%d\n&quot;</span>, fd);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定本地的IP和端口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bindSocket</span><span class="params">(<span class="type">int</span> lfd, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(port);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0 = 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;套接字绑定成功, ip: %s, port: %d\n&quot;</span>,</span><br><span class="line">           inet_ntoa(saddr.sin_addr), port);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置监听</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setListen</span><span class="params">(<span class="type">int</span> lfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;设置监听成功...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞并等待客户端的连接</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">acceptConn</span><span class="params">(<span class="type">int</span> lfd, <span class="keyword">struct</span> sockaddr_in *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cfd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(addr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cfd = accept(lfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">        cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)addr, &amp;addrlen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功和客户端建立连接...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> cfd; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recvMsg</span><span class="params">(<span class="type">int</span> cfd, <span class="type">char</span>** msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(msg == <span class="literal">NULL</span> || cfd &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="comment">// 1. 读数据头</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    readn(cfd, (<span class="type">char</span>*)&amp;len, <span class="number">4</span>);</span><br><span class="line">    len = ntohl(len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据块大小: %d\n&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据读出的长度分配内存</span></span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ret = readn(cfd, buf, len);</span><br><span class="line">    <span class="keyword">if</span>(ret != len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    *msg = buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendMsg</span><span class="params">(<span class="type">int</span> cfd, <span class="type">char</span>* msg, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(msg == <span class="literal">NULL</span> || len &lt;= <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 申请内存空间: 数据长度 + 包头4字节(存储数据长度)</span></span><br><span class="line">   <span class="type">char</span>* data = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len+<span class="number">4</span>);</span><br><span class="line">   <span class="type">int</span> bigLen = htonl(len);</span><br><span class="line">   <span class="built_in">memcpy</span>(data, &amp;bigLen, <span class="number">4</span>);</span><br><span class="line">   <span class="built_in">memcpy</span>(data+<span class="number">4</span>, msg, len);</span><br><span class="line">   <span class="comment">// 发送数据</span></span><br><span class="line">   <span class="type">int</span> ret = writen(cfd, data, len+<span class="number">4</span>);</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接服务器</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connectToHost</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2. 连接服务器IP port</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;saddr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功和服务器建立连接...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closeSocket</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = close(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收指定的字节数</span></span><br><span class="line"><span class="comment">// 函数调用成功返回 size</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nread = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = size;</span><br><span class="line">    <span class="type">char</span>* p = buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((nread = read(fd, p, left)) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p += nread;</span><br><span class="line">            left -= nread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nread == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送指定的字节数</span></span><br><span class="line"><span class="comment">// 函数调用成功返回 size</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> left = size;</span><br><span class="line">    <span class="type">int</span> nwrite = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p = msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((nwrite = write(fd, msg, left)) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p += nwrite;</span><br><span class="line">            left -= nwrite;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nwrite == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="6-2-基于C-的封装"><a href="#6-2-基于C-的封装" class="headerlink" title="6.2 基于C++的封装"></a>6.2 基于C++的封装</h2><p>编写C++程序应当遵循面向对象三要素：封装、继承、多态。简单地说就是封装之后的类可以隐藏掉某些属性使操作更简单并且类的功能要单一，如果要代码重用可以进行类之间的继承，如果要让函数的使用更加灵活可以使用多态。<br>因此，我们需要封装两个类：客户端类和服务器端的类。</p><h3 id="6-2-1-版本1"><a href="#6-2-1-版本1" class="headerlink" title="6.2.1 版本1"></a>6.2.1 版本1</h3><p>根据面向对象的思想，整个通信过程不管是监听还是通信的套接字都是可以封装到类的内部并且将其隐藏掉，这样相关操作函数的参数也就随之减少了，使用者用起来也更简便。</p><h4 id="6-2-1-1-客户端"><a href="#6-2-1-1-客户端" class="headerlink" title="6.2.1.1 客户端"></a>6.2.1.1 客户端</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TcpClient</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TcpClient</span>();</span><br><span class="line">    ~<span class="built_in">TcpClient</span>();</span><br><span class="line">    <span class="comment">// int connectToHost(int fd, const char* ip, unsigned short port);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">connectToHost</span><span class="params">(string ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int sendMsg(int fd, const char* msg);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sendMsg</span><span class="params">(string msg)</span></span>;</span><br><span class="line">    <span class="comment">// int recvMsg(int fd, char* msg, int size);</span></span><br><span class="line">    <span class="function">string <span class="title">recvMsg</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// int createSocket();</span></span><br><span class="line">    <span class="comment">// int closeSocket(int fd);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// int readn(int fd, char* buf, int size);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line">    <span class="comment">// int writen(int fd, const char* msg, int size);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">writen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cfd;<span class="comment">// 通信的套接字</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过对客户端的操作进行封装，我们可以看到有如下的变化：</p><ol><li>文件描述被隐藏了，封装到了类的内部已经无法进行外部访问</li><li>功能函数的参数变少了，因为类成员函数可以直接使用类内部的成员变量。</li><li>创建和销毁套接字的函数去掉了，这两个操作可以分别放到构造和析构函数内部进行处理。</li><li>在C++中可以适当的将char* 替换为 string 类，这样操作字符串就更简便一些。</li></ol><hr><h4 id="6-2-1-2-服务器端"><a href="#6-2-1-2-服务器端" class="headerlink" title="6.2.1.2 服务器端"></a>6.2.1.2 服务器端</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TcpServer</span>();</span><br><span class="line">    ~<span class="built_in">TcpServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int bindSocket(int lfd, unsigned short port) + int setListen(int lfd)</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">setListen</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line">    <span class="comment">// int acceptConn(int lfd, struct sockaddr_in *addr);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">acceptConn</span><span class="params">(<span class="keyword">struct</span> sockaddr_in *addr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int sendMsg(int fd, const char* msg);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sendMsg</span><span class="params">(string msg)</span></span>;</span><br><span class="line">    <span class="comment">// int recvMsg(int fd, char* msg, int size);</span></span><br><span class="line">    <span class="function">string <span class="title">recvMsg</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// int createSocket();</span></span><br><span class="line">    <span class="comment">// int closeSocket(int fd);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// int readn(int fd, char* buf, int size);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line">    <span class="comment">// int writen(int fd, const char* msg, int size);</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">writen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> lfd;<span class="comment">// 监听的套接字</span></span><br><span class="line">    <span class="type">int</span> cfd;<span class="comment">// 通信的套接字</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过对服务器端的操作进行封装，我们可以看到这个类和客户端的类结构以及封装思路是差不多的，并且两个类的内部有些操作的重叠的：接收和发送通信数据的函数<code>recvMsg()</code>、<code>sendMsg()</code>，以及内部函数<code>readn()</code>、<code>writen()</code>。<br>不仅如此服务器端的类设计成这样样子是有缺陷的：<code>服务器端一般需要和多个客户端建立连接，因此通信的套接字就需要有N个，但是在上面封装的类里边只有一个。</code></p><p>如何解决服务器和客户端的代码冗余和服务器不能跟多客户端通信的问题？</p><p><code>减负。可以将服务器的通信功能去掉，只留下监听并建立新连接一个功能。将客户端类变成一个专门用于套接字通信的类即可。服务器端整个流程使用服务器类+通信类来处理；客户端整个流程通过通信的类来处理。</code></p><hr><h3 id="6-2-2-版本2"><a href="#6-2-2-版本2" class="headerlink" title="6.2.2 版本2"></a>6.2.2 版本2</h3><p>根据对第一个版本的分析，可以对以上代码做如下修改：</p><h4 id="6-2-2-1-通信类"><a href="#6-2-2-1-通信类" class="headerlink" title="6.2.2.1 通信类"></a>6.2.2.1 通信类</h4><p>套接字通信类既可以在客户端使用，也可以在服务器端使用，职责是接收和发送数据包。</p><p>类声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TcpSocket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TcpSocket</span>();</span><br><span class="line">    <span class="built_in">TcpSocket</span>(<span class="type">int</span> socket);</span><br><span class="line">    ~<span class="built_in">TcpSocket</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">connectToHost</span><span class="params">(string ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sendMsg</span><span class="params">(string msg)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">recvMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">writen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_fd;<span class="comment">// 通信的套接字</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>(<span class="type">int</span> socket)</span><br><span class="line">&#123;</span><br><span class="line">    m_fd = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::~<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_fd &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::connectToHost</span><span class="params">(string ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 连接服务器IP port</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip.<span class="built_in">data</span>(), &amp;saddr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(m_fd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;成功和服务器建立连接...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::sendMsg</span><span class="params">(string msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 申请内存空间: 数据长度 + 包头4字节(存储数据长度)</span></span><br><span class="line">    <span class="type">char</span>* data = <span class="keyword">new</span> <span class="type">char</span>[msg.<span class="built_in">size</span>() + <span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> bigLen = <span class="built_in">htonl</span>(msg.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">memcpy</span>(data, &amp;bigLen, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(data + <span class="number">4</span>, msg.<span class="built_in">data</span>(), msg.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">writen</span>(data, msg.<span class="built_in">size</span>() + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">delete</span>[]data;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">TcpSocket::recvMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="comment">// 1. 读数据头</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">readn</span>((<span class="type">char</span>*)&amp;len, <span class="number">4</span>);</span><br><span class="line">    len = <span class="built_in">ntohl</span>(len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;数据块大小: &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据读出的长度分配内存</span></span><br><span class="line">    <span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">readn</span>(buf, len);</span><br><span class="line">    <span class="keyword">if</span> (ret != len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="function">string <span class="title">retStr</span><span class="params">(buf)</span></span>;</span><br><span class="line">    <span class="keyword">delete</span>[]buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nread = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = size;</span><br><span class="line">    <span class="type">char</span>* p = buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = <span class="built_in">read</span>(m_fd, p, left)) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p += nread;</span><br><span class="line">            left -= nread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::writen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = size;</span><br><span class="line">    <span class="type">int</span> nwrite = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p = msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nwrite = <span class="built_in">write</span>(m_fd, msg, left)) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p += nwrite;</span><br><span class="line">            left -= nwrite;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nwrite == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第二个版本的套接字通信类中一共有两个构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>(<span class="type">int</span> socket)</span><br><span class="line">&#123;</span><br><span class="line">    m_fd = socket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>无参构造一般在客户端使用，通过这个套接字对象再和服务器进行连接，之后就可以通信了</code></li><li><code>有参构造主要在服务器端使用，当服务器端得到了一个用于通信的套接字对象之后，就可以基于这个套接字直接通信，因此不需要再次进行连接操作。</code></li></ul><hr><h4 id="6-2-2-2-服务器类"><a href="#6-2-2-2-服务器类" class="headerlink" title="6.2.2.2 服务器类"></a>6.2.2.2 服务器类</h4><p>服务器类主要用于套接字通信的服务器端，并且没有通信能力，当服务器和客户端的新连接建立之后，需要通过<code>TcpSocket</code>类的带参构造将通信的描述符包装成一个通信对象，这样就可以使用这个对象和客户端通信了。</p><p>类声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TcpServer</span>();</span><br><span class="line">    ~<span class="built_in">TcpServer</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">setListen</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line">    <span class="function">TcpSocket* <span class="title">acceptConn</span><span class="params">(<span class="keyword">struct</span> sockaddr_in* addr = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_fd;<span class="comment">// 监听的套接字</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">TcpServer::<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpServer::~<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(m_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpServer::setListen</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0 = 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(m_fd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;套接字绑定成功, ip: &quot;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">inet_ntoa</span>(saddr.sin_addr)</span><br><span class="line">        &lt;&lt; <span class="string">&quot;, port: &quot;</span> &lt;&lt; port &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(m_fd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;设置监听成功...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TcpSocket* <span class="title">TcpServer::acceptConn</span><span class="params">(sockaddr_in* addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">    <span class="type">int</span> cfd = <span class="built_in">accept</span>(m_fd, (<span class="keyword">struct</span> sockaddr*)addr, &amp;addrlen);</span><br><span class="line">    <span class="keyword">if</span> (cfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功和客户端建立连接...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TcpSocket</span>(cfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调整可以发现，套接字服务器类功能更加单一了，这样设计即解决了代码冗余问题，还能使这两个类更容易维护。</p><hr><h2 id="6-3-测试代码"><a href="#6-3-测试代码" class="headerlink" title="6.3 测试代码"></a>6.3 测试代码</h2><h3 id="6-3-1-客户端"><a href="#6-3-1-客户端" class="headerlink" title="6.3.1 客户端"></a>6.3.1 客户端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    TcpSocket tcp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器IP port</span></span><br><span class="line">    <span class="type">int</span> ret = tcp.<span class="built_in">connectToHost</span>(<span class="string">&quot;192.168.237.131&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="type">int</span> fd1 = <span class="built_in">open</span>(<span class="string">&quot;english.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="built_in">sizeof</span>(tmp));</span><br><span class="line">    <span class="keyword">while</span> ((length = <span class="built_in">read</span>(fd1, tmp, <span class="built_in">sizeof</span>(tmp))) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        tcp.<span class="built_in">sendMsg</span>(<span class="built_in">string</span>(tmp, length));</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;send Msg: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; tmp &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="built_in">sizeof</span>(tmp));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-2-服务器端"><a href="#6-3-2-服务器端" class="headerlink" title="6.3.2 服务器端"></a>6.3.2 服务器端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SockInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    TcpServer* s;</span><br><span class="line">    TcpSocket* tcp;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">working</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SockInfo</span>* pinfo = <span class="built_in">static_cast</span>&lt;<span class="keyword">struct</span> SockInfo*&gt;(arg);</span><br><span class="line">    <span class="comment">// 连接建立成功, 打印客户端的IP和端口信息</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP: %s, 端口: %d\n&quot;</span>,</span><br><span class="line">        <span class="built_in">inet_ntop</span>(AF_INET, &amp;pinfo-&gt;addr.sin_addr.s_addr, ip, <span class="built_in">sizeof</span>(ip)),</span><br><span class="line">        <span class="built_in">ntohs</span>(pinfo-&gt;addr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 通信</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收数据: .....\n&quot;</span>);</span><br><span class="line">        string msg = pinfo-&gt;tcp-&gt;<span class="built_in">recvMsg</span>();</span><br><span class="line">        <span class="keyword">if</span> (!msg.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; msg &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> pinfo-&gt;tcp;</span><br><span class="line">    <span class="keyword">delete</span> pinfo;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    TcpServer s;</span><br><span class="line">    <span class="comment">// 2. 绑定本地的IP port并设置监听</span></span><br><span class="line">    s.<span class="built_in">setListen</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="comment">// 3. 阻塞并等待客户端的连接</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        SockInfo* info = <span class="keyword">new</span> SockInfo;</span><br><span class="line">        TcpSocket* tcp = s.<span class="built_in">acceptConn</span>(&amp;info-&gt;addr);</span><br><span class="line">        <span class="keyword">if</span> (tcp == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;重试....&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        info-&gt;s = &amp;s;</span><br><span class="line">        info-&gt;tcp = tcp;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, working, info);</span><br><span class="line">        <span class="built_in">pthread_detach</span>(tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="6-4-测试代码-self"><a href="#6-4-测试代码-self" class="headerlink" title="6.4 测试代码(self)"></a>6.4 测试代码(self)</h2><h3 id="6-4-1-服务器端"><a href="#6-4-1-服务器端" class="headerlink" title="6.4.1 服务器端"></a>6.4.1 服务器端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpSocket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">TcpSocket</span>();</span><br><span class="line"><span class="built_in">TcpSocket</span>(<span class="type">int</span> socket);</span><br><span class="line">~<span class="built_in">TcpSocket</span>();</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ConnectToHost</span><span class="params">(string ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SendMsg</span><span class="params">(string msg)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">ReadMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">written</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="type">int</span> m_fd; <span class="comment">//通信的套接字</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>(<span class="type">int</span> socket)</span><br><span class="line">&#123;</span><br><span class="line">m_fd = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::~<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_fd &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">close</span>(m_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::ConnectToHost</span><span class="params">(string ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sockaddr_in addr;</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET, ip.<span class="built_in">data</span>(), &amp;addr.sin_addr.s_addr);</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">connect</span>(m_fd, (sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;connect sucessfully&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::written</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> readplace = <span class="number">0</span>; <span class="comment">//开始读取数据的坐标</span></span><br><span class="line"><span class="type">int</span> remain = size;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* space = buf;</span><br><span class="line"><span class="keyword">while</span> (remain &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((readplace = <span class="built_in">write</span>(m_fd, space, remain)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">space += readplace;</span><br><span class="line">remain -= readplace;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (readplace == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::SendMsg</span><span class="params">(string msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[msg.<span class="built_in">size</span>() + <span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> sizeflag = <span class="built_in">htonl</span>(msg.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">memcpy</span>(buf, &amp;sizeflag, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(buf + <span class="number">4</span>, msg.<span class="built_in">data</span>(), msg.<span class="built_in">size</span>());</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">written</span>(buf, msg.<span class="built_in">size</span>() + <span class="number">4</span>);</span><br><span class="line"><span class="keyword">delete</span>[] buf;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> readplace = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> remain = size;</span><br><span class="line"><span class="type">char</span>* space = buf;</span><br><span class="line"><span class="keyword">while</span> (remain &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((readplace = <span class="built_in">read</span>(m_fd, space, remain)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">space += readplace;   <span class="comment">//space指针后移,以下次读取</span></span><br><span class="line">remain -= readplace;  <span class="comment">//读取大小跟随减小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (readplace == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">TcpSocket::ReadMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">readn</span>((<span class="type">char</span>*)&amp;len, <span class="number">4</span>); <span class="comment">//从描述符里面读取前四位,将大端数据放入len</span></span><br><span class="line">len = <span class="built_in">ntohl</span>(len);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;the size of msg : &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始接受真正的数据</span></span><br><span class="line"><span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">readn</span>(buf, len);</span><br><span class="line"><span class="keyword">if</span> (ret != len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br><span class="line">buf[len] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//自行加入结束符,因此多开辟一字节空间</span></span><br><span class="line"><span class="function">string <span class="title">returnstr</span><span class="params">(buf)</span></span>;</span><br><span class="line"><span class="keyword">delete</span>[] buf;</span><br><span class="line"><span class="keyword">return</span> returnstr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">TcpServer</span>();</span><br><span class="line">~<span class="built_in">TcpServer</span>();</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SetListen</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"><span class="function">TcpSocket* <span class="title">AcceptConnect</span><span class="params">(sockaddr_in* addr = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> l_fd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TcpServer::<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">l_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpServer::~<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">close</span>(l_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpServer::SetListen</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sockaddr_in addr;</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY; </span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">bind</span>(l_fd, (sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bind sucessfully &quot;</span>&lt;&lt; endl</span><br><span class="line">&lt;&lt;<span class="string">&quot;ip : &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(addr.sin_addr) &lt;&lt; endl</span><br><span class="line">&lt;&lt; <span class="string">&quot;port : &quot;</span> &lt;&lt; port &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">listen</span>(l_fd, <span class="number">128</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;set listen sucessfully&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TcpSocket* <span class="title">TcpServer::AcceptConnect</span><span class="params">(sockaddr_in* addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (addr == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">socklen_t</span> addrlen = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line"><span class="type">int</span> m_fd = <span class="built_in">accept</span>(l_fd, (sockaddr*)addr, &amp;addrlen);</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (m_fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;accept sucessfully&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TcpSocket</span>(m_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SocketPackage</span></span><br><span class="line">&#123;</span><br><span class="line">TcpServer* lsntcp;</span><br><span class="line">TcpSocket* msgtcp;</span><br><span class="line">sockaddr_in addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Working</span><span class="params">(<span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SocketPackage* pkg = <span class="built_in">static_cast</span>&lt;SocketPackage*&gt;(args);</span><br><span class="line"><span class="type">char</span> ip[<span class="number">32</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;client ip : &quot;</span> &lt;&lt; <span class="built_in">inet_ntop</span>(AF_INET, &amp;pkg-&gt;addr.sin_addr.s_addr, ip, <span class="built_in">sizeof</span>(ip)) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;client port : &quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(pkg-&gt;addr.sin_port) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通信</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;client say :: &quot;</span>;</span><br><span class="line">string msg = pkg-&gt;msgtcp-&gt;<span class="built_in">ReadMsg</span>();</span><br><span class="line"><span class="keyword">if</span> (!msg.<span class="built_in">empty</span>())</span><br><span class="line">cout &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> pkg-&gt;msgtcp;</span><br><span class="line"><span class="keyword">delete</span> pkg;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TcpServer server;</span><br><span class="line">server.<span class="built_in">SetListen</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始通信</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">SocketPackage* pkg = <span class="keyword">new</span> SocketPackage;</span><br><span class="line">TcpSocket* msgret = server.<span class="built_in">AcceptConnect</span>(&amp;pkg-&gt;addr);</span><br><span class="line"><span class="keyword">if</span> (msgret == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;new fail again&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建线程</span></span><br><span class="line">pkg-&gt;lsntcp = &amp;server;</span><br><span class="line">pkg-&gt;msgtcp = msgret;</span><br><span class="line"><span class="function">thread <span class="title">child</span><span class="params">(Working,pkg)</span></span>;</span><br><span class="line">child.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-4-2-客户端"><a href="#6-4-2-客户端" class="headerlink" title="6.4.2 客户端"></a>6.4.2 客户端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpSocket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">TcpSocket</span>();</span><br><span class="line"><span class="built_in">TcpSocket</span>(<span class="type">int</span> socket);</span><br><span class="line">~<span class="built_in">TcpSocket</span>();</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ConnectToHost</span><span class="params">(string ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SendMsg</span><span class="params">(string msg)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">ReadMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">written</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="type">int</span> m_fd; <span class="comment">//通信的套接字</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>(<span class="type">int</span> socket)</span><br><span class="line">&#123;</span><br><span class="line">m_fd = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpSocket::~<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(m_fd &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">close</span>(m_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::ConnectToHost</span><span class="params">(string ip, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sockaddr_in addr;</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET, ip.<span class="built_in">data</span>(), &amp;addr.sin_addr.s_addr);</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">connect</span>(m_fd, (sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;connect sucessfully&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::written</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> readplace = <span class="number">0</span>; <span class="comment">//开始读取数据的坐标</span></span><br><span class="line"><span class="type">int</span> remain = size;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* space = buf;</span><br><span class="line"><span class="keyword">while</span> (remain &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((readplace = <span class="built_in">write</span>(m_fd, space, remain)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">space += readplace;</span><br><span class="line">remain -= readplace;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (readplace == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::SendMsg</span><span class="params">(string msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[msg.<span class="built_in">size</span>() + <span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> sizeflag = <span class="built_in">htonl</span>(msg.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">memcpy</span>(buf, &amp;sizeflag, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(buf + <span class="number">4</span>, msg.<span class="built_in">data</span>(), msg.<span class="built_in">size</span>());</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">written</span>(buf, msg.<span class="built_in">size</span>() + <span class="number">4</span>);</span><br><span class="line"><span class="keyword">delete</span>[] buf;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::readn</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> readplace = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> remain = size;</span><br><span class="line"><span class="type">char</span>* space = buf;</span><br><span class="line"><span class="keyword">while</span> (remain &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (readplace = <span class="built_in">read</span>(m_fd, space, remain) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">space += readplace;   <span class="comment">//space指针后移,以下次读取</span></span><br><span class="line">remain -= readplace;  <span class="comment">//读取大小跟随减小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (readplace == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">TcpSocket::ReadMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">readn</span>((<span class="type">char</span>*)&amp;len,<span class="number">4</span>); <span class="comment">//从描述符里面读取前四位,将大端数据放入len</span></span><br><span class="line">len = <span class="built_in">ntohl</span>(len);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;the size of msg : &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始接受真正的数据</span></span><br><span class="line"><span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[len+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">readn</span>(buf, len);</span><br><span class="line"><span class="keyword">if</span> (ret != len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br><span class="line">buf[len] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//自行加入结束符,因此多开辟一字节空间</span></span><br><span class="line"><span class="function">string <span class="title">returnstr</span><span class="params">(buf)</span></span>;</span><br><span class="line"><span class="keyword">delete</span>[] buf;</span><br><span class="line"><span class="keyword">return</span> returnstr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TcpSocket client;</span><br><span class="line"><span class="type">int</span> ret = client.<span class="built_in">ConnectToHost</span>(<span class="string">&quot;192.168.200.129&quot;</span>, <span class="number">10000</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始发数据</span></span><br><span class="line"><span class="type">int</span> tmpfd = <span class="built_in">open</span>(<span class="string">&quot;english.txt&quot;</span>, O_RDWR);</span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = <span class="built_in">read</span>(tmpfd, buf, <span class="built_in">sizeof</span>(buf))) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">client.<span class="built_in">SendMsg</span>(<span class="built_in">string</span>(buf,len));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;client send msg : &quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">300</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="7-IO多路转接（复用）之select"><a href="#7-IO多路转接（复用）之select" class="headerlink" title="7. IO多路转接（复用）之select"></a>7. IO多路转接（复用）之select</h1><h2 id="7-1-IO多路转接-复用"><a href="#7-1-IO多路转接-复用" class="headerlink" title="7.1 IO多路转接(复用)"></a>7.1 IO多路转接(复用)</h2><p>IO多路转接也称为IO多路复用，它是一种网络通信的手段（机制）<br>通过这种方式可以<code>同时监测多个文件描述符并且这个过程是阻塞的，一旦检测到有文件描述符就绪（ 可以读数据或者可以写数据）程序的阻塞就会被解除，之后就可以基于这些（一个或多个）就绪的文件描述符进行通信了。</code><br>通过这种方式在单线程&#x2F;进程的场景下也可以在服务器端实现并发。<br>常见的IO多路转接方式有：<code>select</code>、<code>poll</code>、<code>epoll</code>。</p><p>下面先对多线程&#x2F;多进程并发和IO多路转接的并发处理流程进行对比（服务器端）：</p><ul><li>多线程&#x2F;多进程并发<ul><li>主线程&#x2F;父进程：调用 <code>accept()</code>监测客户端连接请求<ul><li>如果没有新的客户端的连接请求，当前线程&#x2F;进程会阻塞</li><li>如果有新的客户端连接请求解除阻塞，建立连接</li></ul></li><li>子线程&#x2F;子进程：和建立连接的客户端通信<ul><li>调用 <code>read() / recv()</code>接收客户端发送的通信数据，如果没有通信数据，当前线程&#x2F;进程会阻塞，数据到达之后阻塞自动解除</li><li>调用 <code>write() / send()</code> 给客户端发送数据，如果写缓冲区已满，当前线程&#x2F;进程会阻塞，否则将待发送数据写入写缓冲区中</li></ul></li></ul></li><li>IO多路转接并发<ul><li>使用IO多路转接函数委托内核检测服务器端所有的文件描述符（通信和监听两类），这个检测过程会导致进程&#x2F;线程的阻塞，如果检测到已就绪的文件描述符阻塞解除，并将这些已就绪的文件描述符传出</li><li>根据类型对传出的所有已就绪文件描述符进行判断，并做出不同的处理<ul><li>监听的文件描述符：和客户端建立连接<ul><li>此时调用<code>accept()</code>是不会导致程序阻塞的，因为监听的文件描述符是已就绪的（有新请求）</li></ul></li><li>通信的文件描述符：调用通信函数和已建立连接的客户端通信<ul><li>调用 <code>read() / recv()</code> 不会阻塞程序，因为通信的文件描述符是就绪的，读缓冲区内已有数据</li><li>调用 <code>write() / send()</code> 不会阻塞程序，因为通信的文件描述符是就绪的，写缓冲区不满，可以往里面写数据</li></ul></li><li>对这些文件描述符继续进行下一轮的检测（循环往复。。。）</li></ul></li></ul></li></ul><p><code>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</code></p><hr><h2 id="7-2-select"><a href="#7-2-select" class="headerlink" title="7.2  select"></a>7.2  select</h2><h3 id="7-2-1-函数原型"><a href="#7-2-1-函数原型" class="headerlink" title="7.2.1 函数原型"></a>7.2.1 函数原型</h3><p>使用select这种IO多路转接方式需要调用一个同名函数<code>select</code><br>这个函数是跨平台的，<code>Linux、Mac、Windows</code>都是支持的。通过调用这个函数可以委托内核帮助我们检测若干个文件描述符的状态，<code>其实就是检测这些文件描述符对应的读写缓冲区的状态</code>：</p><ul><li>读缓冲区：检测里边有没有数据，如果有数据该缓冲区对应的文件描述符就绪</li><li>写缓冲区：检测写缓冲区是否可以写(有没有容量)，如果有容量可以写，缓冲区对应的文件描述符就绪</li><li>读写异常：检测读写缓冲区是否有异常，如果有该缓冲区对应的文件描述符就绪</li></ul><p>委托检测的文件描述符被遍历检测完毕之后，已就绪的这些满足条件的文件描述符会通过<code>select()</code>的参数分3个集合传出,我们得到这几个集合之后就可以分情况依次处理了。</p><p>下面来看一下这个函数的函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span>      tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">           fd_set *exceptfds, <span class="keyword">struct</span> timeval * timeout)</span>;</span><br></pre></td></tr></table></figure><ul><li>函数参数：<ul><li>nfds：委托内核检测的这三个集合中最大的文件描述符 + 1<ul><li>内核需要线性遍历这些集合中的文件描述符，这个值是循环结束的条件</li><li>在Window中这个参数是无效的，指定为-1即可</li></ul></li><li>readfds：文件描述符的集合, 内核只检测这个集合中文件描述符对应的读缓冲区<ul><li>传入传出参数，读集合一般情况下都是需要检测的，这样才知道通过哪个文件描述符接收数据</li></ul></li><li>writefds：文件描述符的集合, 内核只检测这个集合中文件描述符对应的写缓冲区<ul><li>传入传出参数，如果不需要使用这个参数可以指定为NULL</li></ul></li><li>exceptfds：文件描述符的集合, 内核检测集合中文件描述符是否有异常状态<ul><li>传入传出参数，如果不需要使用这个参数可以指定为NULL</li></ul></li><li>timeout：超时时长，用来强制解除select()函数的阻塞的<ul><li>NULL：函数检测不到就绪的文件描述符会一直阻塞。</li><li>等待固定时长（秒）：函数检测不到就绪的文件描述符，在指定时长之后强制解除阻塞，函数返回0</li><li>不等待：函数不会阻塞，直接将该参数对应的结构体初始化为0即可。</li></ul></li></ul></li><li>函数返回值：<ul><li>大于0：成功，返回集合中已就绪的文件描述符的总个数</li><li>等于-1：函数调用失败</li><li>等于0：超时，没有检测到就绪的文件描述符</li></ul></li></ul><p>另外初始化<code>fd_set</code>类型的参数还需要使用相关的一些列操作函数，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将文件描述符fd从set集合中删除 == 将fd对应的标志位设置为0        </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 判断文件描述符fd是否在set集合中 == 读一下fd对应的标志位到底是0还是1</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将文件描述符fd添加到set集合中 == 将fd对应的标志位设置为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将set集合中, 所有文件文件描述符对应的标志位设置为0, 集合中没有添加任何文件描述符</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="7-2-2-细节描述"><a href="#7-2-2-细节描述" class="headerlink" title="7.2.2 细节描述"></a>7.2.2 细节描述</h3><p>在<code>select()</code>函数中第2、3、4个参数都是<code>fd_set</code>类型，它表示一个文件描述符的集合，类似于信号集 <code>sigset_t</code>，这个类型的数据有128个字节，也就是1024个标志位，和内核中文件描述符表中的文件描述符个数是一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(fd_set) = <span class="number">128</span> 字节 * <span class="number">8</span> = <span class="number">1024</span> bit      <span class="comment">// int [32]</span></span><br></pre></td></tr></table></figure><p>这不是巧合，是故意为之。这块内存中的每一个bit 和 文件描述符表中的每一个文件描述符是一一对应的关系，这样就可以使用最小的存储空间将要表达的意思描述出来了。</p><p>下图中的fd_set中存储了要委托内核检测读缓冲区的文件描述符集合。</p><ul><li>如果集合中的标志位为0代表不检测这个文件描述符状态</li><li>如果集合中的标志位为1代表检测这个文件描述符状态<br><img src="/img/9.41.png" alt="在这里插入图片描述"></li></ul><p>内核在遍历这个读集合的过程中，如果被检测的文件描述符对应的读缓冲区中没有数据，内核将修改这个文件描述符在读集合<code>fd_set</code>中对应的标志位，改为<code>0</code>，如果有数据那么这个标志位的值不变，还是<code>1</code>。</p><p><img src="/img/9.42.png" alt="在这里插入图片描述"></p><p>当<code>select()</code>函数解除阻塞之后，被内核修改过的读集合通过参数传出，此时集合中只要标志位的值为<code>1</code>，那么它对应的文件描述符肯定是就绪的，我们就可以基于这个文件描述符和客户端建立新连接或者通信了。</p><hr><h2 id="7-3-并发处理"><a href="#7-3-并发处理" class="headerlink" title="7.3  并发处理"></a>7.3  并发处理</h2><h3 id="7-3-1-处理流程"><a href="#7-3-1-处理流程" class="headerlink" title="7.3.1 处理流程"></a>7.3.1 处理流程</h3><p>如果在服务器基于select实现并发，其处理流程如下：</p><ol><li>创建监听的套接字 lfd &#x3D; socket();</li><li>将监听的套接字和本地的IP和端口绑定 bind()</li><li>给监听的套接字设置监听 listen()</li><li>创建一个文件描述符集合 fd_set，用于存储需要检测读事件的所有的文件描述符<ul><li>通过 FD_ZERO() 初始化</li><li>通过 FD_SET() 将监听的文件描述符放入检测的读集合中</li></ul></li><li>循环调用select()，周期性的对所有的文件描述符进行检测</li><li>select() 解除阻塞返回，得到内核传出的满足条件的就绪的文件描述符集合<ul><li>通过FD_ISSET() 判断集合中的标志位是否为 1<ul><li>如果这个文件描述符是监听的文件描述符，调用 accept() 和客户端建立连接<ul><li>将得到的新的通信的文件描述符，通过FD_SET() 放入到检测集合中</li></ul></li><li>如果这个文件描述符是通信的文件描述符，调用通信函数和客户端通信<ul><li>如果客户端和服务器断开了连接，使用FD_CLR()将这个文件描述符从检测集合中删除</li><li>如果没有断开连接，正常通信即可</li></ul></li></ul></li></ul></li><li>重复第6步<br><img src="/img/9.43.png" alt="在这里插入图片描述"></li></ol><hr><h3 id="7-3-2-通信代码"><a href="#7-3-2-通信代码" class="headerlink" title="7.3.2 通信代码"></a>7.3.2 通信代码</h3><blockquote><p>服务器端代码如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的fd</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    listen(lfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的fd的状态检测委托给内核检测</span></span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line">    <span class="comment">// 初始化检测的读集合</span></span><br><span class="line">    fd_set rdset;</span><br><span class="line">    fd_set rdtemp;</span><br><span class="line">    <span class="comment">// 清零</span></span><br><span class="line">    FD_ZERO(&amp;rdset);</span><br><span class="line">    <span class="comment">// 将监听的lfd设置到检测的读集合中</span></span><br><span class="line">    FD_SET(lfd, &amp;rdset);</span><br><span class="line">    <span class="comment">// 通过select委托内核检测读集合中的文件描述符状态, 检测read缓冲区有没有数据</span></span><br><span class="line">    <span class="comment">// 如果有数据, select解除阻塞返回</span></span><br><span class="line">    <span class="comment">// 应该让内核持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 默认阻塞</span></span><br><span class="line">        <span class="comment">// rdset 中是委托内核检测的所有的文件描述符</span></span><br><span class="line">        rdtemp = rdset;</span><br><span class="line">        <span class="type">int</span> num = select(maxfd+<span class="number">1</span>, &amp;rdtemp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// rdset中的数据被内核改写了, 只保留了发生变化的文件描述的标志位上的1, 没变化的改为0</span></span><br><span class="line">        <span class="comment">// 只要rdset中的fd对应的标志位为1 -&gt; 缓冲区有数据了</span></span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="comment">// 有没有新连接</span></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(lfd, &amp;rdtemp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 接受连接请求, 这个调用不阻塞</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">            <span class="type">int</span> cliLen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">            <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;cliLen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 得到了有效的文件描述符</span></span><br><span class="line">            <span class="comment">// 通信的文件描述符添加到读集合</span></span><br><span class="line">            <span class="comment">// 在下一轮select检测的时候, 就能得到缓冲区的状态</span></span><br><span class="line">            FD_SET(cfd, &amp;rdset);</span><br><span class="line">            <span class="comment">// 重置最大的文件描述符</span></span><br><span class="line">            maxfd = cfd &gt; maxfd ? cfd : maxfd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有新连接, 通信</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;maxfd+<span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">// 判断从监听的文件描述符之后到maxfd这个范围内的文件描述符是否读缓冲区有数据</span></span><br><span class="line">            <span class="keyword">if</span>(i != lfd &amp;&amp; FD_ISSET(i, &amp;rdtemp))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="comment">// 一次只能接收10个字节, 客户端一次发送100个字节</span></span><br><span class="line">                <span class="comment">// 一次是接收不完的, 文件描述符对应的读缓冲区中还有数据</span></span><br><span class="line">                <span class="comment">// 下一轮select检测的时候, 内核还会标记这个文件描述符缓冲区有数据 -&gt; 再读一次</span></span><br><span class="line">                <span class="comment">// 循环会一直持续, 知道缓冲区数据被读完位置</span></span><br><span class="line">                <span class="type">int</span> len = read(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端关闭了连接...\n&quot;</span>);</span><br><span class="line">                    <span class="comment">// 将检测的文件描述符从读集合中删除</span></span><br><span class="line">                    FD_CLR(i, &amp;rdset);</span><br><span class="line">                    close(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 收到了数据</span></span><br><span class="line">                    <span class="comment">// 发送数据</span></span><br><span class="line">                    write(i, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 异常</span></span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，创建了两个<code>fd_set</code>变量，用于保存要检测的读集合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化检测的读集合</span></span><br><span class="line">fd_set rdset;</span><br><span class="line">fd_set rdtemp;</span><br></pre></td></tr></table></figure><blockquote><p><code>rdset</code>用于保存要检测的原始数据，这个变量不能作为参数传递给select函数，因为在函数内部这个变量中的值会被内核修改，函数调用完毕返回之后，里边就不是原始数据了，大部分情况下是值为1的标志位变少了，不可能每一轮检测，所有的文件描述符都是就行的状态。因此需要通过&#96;rdtemp&#96;&#96;变量将原始数据传递给内核，select()<br>调用完毕之后再将内核数据传出，这两个变量的功能是不一样的。</p></blockquote><p>客户端代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;     <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);   <span class="comment">// 服务器监听的端口, 字节序应该是网络字节序</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        <span class="comment">// sprintf(recvBuf, &quot;data: %d\n&quot;, i++);</span></span><br><span class="line">        fgets(recvBuf, <span class="keyword">sizeof</span>(recvBuf), <span class="built_in">stdin</span>);</span><br><span class="line">        write(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果客户端没有发送数据, 默认阻塞</span></span><br><span class="line">        read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>, recvBuf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端不需要使用IO多路转接进行处理，因为客户端和服务器的对应关系是 1：N，也就是说客户端是比较专一的，只能和一个连接成功的服务器通信。</p><p>虽然使用select这种IO多路转接技术可以降低系统开销，提高程序效率，但是它也有局限性：</p><ol><li>待检测集合（第2、3、4个参数）需要频繁的在用户区和内核区之间进行数据的拷贝，效率低</li><li>内核对于select传递进来的待检测集合的检测方式是线性的<ul><li>如果集合内待检测的文件描述符很多，检测效率会比较低</li><li>如果集合内待检测的文件描述符相对较少，检测效率会比较高</li></ul></li><li><code>使用select能够检测的最大文件描述符个数有上限，默认是1024，这是在内核中被写死了的。</code></li></ol><hr><h1 id="8-IO多路转接（复用）之poll"><a href="#8-IO多路转接（复用）之poll" class="headerlink" title="8. IO多路转接（复用）之poll"></a>8. IO多路转接（复用）之poll</h1><h2 id="8-1-poll函数"><a href="#8-1-poll函数" class="headerlink" title="8.1 poll函数"></a>8.1 poll函数</h2><p>poll的机制与select类似，与select在本质上没有多大差别，使用方法也类似，下面的是对于二者的对比：</p><ul><li>内核对应文件描述符的检测也是以线性的方式进行轮询，根据描述符的状态进行处理</li><li>poll和select检测的文件描述符集合会在检测过程中频繁的进行用户区和内核区的拷贝，它的开销随着文件描述符数量的增加而线性增大，从而效率也会越来越低。</li><li>select检测的文件描述符个数上限是1024，poll没有最大文件描述符数量的限制</li><li>select可以跨平台使用，poll只能在Linux平台使用</li></ul><p>poll函数的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 每个委托poll检测的fd都对应这样一个结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* 文件描述符实际发生的事件 -&gt; 传出 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>[100];</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><ul><li>函数参数：<ul><li>fds: 这是一个struct pollfd类型的数组, 里边存储了待检测的文件描述符的信息，这个数组中有三个成员：<ul><li>fd：委托内核检测的文件描述符</li><li>events：委托内核检测的fd事件（输入、输出、错误），每一个事件有多个取值</li><li>revents：这是一个传出参数，数据由内核写入，存储内核检测之后的结果</li></ul></li><li>nfds: 这是第一个参数数组中最后一个有效元素的下标 + 1（也可以指定参数1数组的元素总个数）</li><li>timeout: 指定poll函数的阻塞时长<ul><li>-1：一直阻塞，直到检测的集合中有就绪的文件描述符（有事件产生）解除阻塞</li><li>0：不阻塞，不管检测集合中有没有已就绪的文件描述符，函数马上返回</li><li>大于0：阻塞指定的毫秒（ms）数之后，解除阻塞</li></ul></li></ul></li><li>函数返回值：<ul><li>失败： 返回-1</li><li>成功：返回一个大于0的整数，表示检测的集合中已就绪的文件描述符的总个数</li></ul></li></ul><p><img src="/img/9.44.png" alt="在这里插入图片描述"></p><hr><h2 id="8-2-测试代码"><a href="#8-2-测试代码" class="headerlink" title="8.2 测试代码"></a>8.2 测试代码</h2><p><strong>服务器端</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 绑定 ip, port</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 等待连接 -&gt; 循环</span></span><br><span class="line">    <span class="comment">// 检测 -&gt; 读缓冲区, 委托内核去处理</span></span><br><span class="line">    <span class="comment">// 数据初始化, 创建自定义的文件描述符集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1024];</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1024</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxfd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 委托内核检测</span></span><br><span class="line">        ret = poll(fds, maxfd+<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测的度缓冲区有变化</span></span><br><span class="line">        <span class="comment">// 有新连接</span></span><br><span class="line">        <span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 接收连接请求</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sockcli</span>;</span></span><br><span class="line">            <span class="type">int</span> len = <span class="keyword">sizeof</span>(sockcli);</span><br><span class="line">            <span class="comment">// 这个accept是不会阻塞的</span></span><br><span class="line">            <span class="type">int</span> connfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;sockcli, &amp;len);</span><br><span class="line">            <span class="comment">// 委托内核检测connfd的读缓冲区</span></span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1024</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(fds[i].fd == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    fds[i].fd = connfd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxfd = i &gt; maxfd ? i : maxfd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通信, 有客户端发送数据过来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=maxfd; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果在集合中, 说明读缓冲区有数据</span></span><br><span class="line">            <span class="keyword">if</span>(fds[i].revents &amp; POLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">                <span class="type">int</span> ret = read(fds[i].fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;对方已经关闭了连接...\n&quot;</span>);</span><br><span class="line">                    close(fds[i].fd);</span><br><span class="line">                    fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">                    write(fds[i].fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的测试代码可以得知，使用poll和select进行IO多路转接的处理思路是完全相同的，但是使用poll编写的代码看起来会更直观一些，select使用的位图的方式来标记要委托内核检测的文件描述符（每个比特位对应一个唯一的文件描述符），并且对这个<code>fd_set</code>类型的位图变量进行读写还需要借助一系列的宏函数，操作比较麻烦。而poll直接将要检测的文件描述符的相关信息封装到了一个结构体<code>struct pollfd</code>中，我们可以直接读写这个结构体变量。</p><p>另外poll的第二个参数有两种赋值方式，但是都和第一个参数的数组有关系：</p><ul><li>使用参数1数组的元素个数</li><li>使用参数1数组中存储的最后一个有效元素对应的下标值 + 1</li></ul><p>内核会根据第二个参数传递的值对参数1数组中的文件描述符进行线性遍历，这一点和select也是类似的。</p><p><strong>客户端</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;  <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);   <span class="comment">// 服务器监听的端口, 字节序应该是网络字节序</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        <span class="comment">// sprintf(recvBuf, &quot;data: %d\n&quot;, i++);</span></span><br><span class="line">        fgets(recvBuf, <span class="keyword">sizeof</span>(recvBuf), <span class="built_in">stdin</span>);</span><br><span class="line">        write(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果客户端没有发送数据, 默认阻塞</span></span><br><span class="line">        read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>, recvBuf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端不需要使用IO多路转接进行处理，因为客户端和服务器的对应关系是 1：N，也就是说客户端是比较专一的，只能和一个连接成功的服务器通信。</p><hr><h1 id="9-IO多路转接（复用）之epoll"><a href="#9-IO多路转接（复用）之epoll" class="headerlink" title="9. IO多路转接（复用）之epoll"></a>9. IO多路转接（复用）之epoll</h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><p>epoll 全称 eventpoll，是 linux 内核实现IO多路转接&#x2F;复用（IO multiplexing）的一个实现。IO多路转接的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。epoll是select和poll的升级版，相较于这两个前辈，epoll改进了工作方式，因此它更加高效。</p><ul><li>对于待检测集合select和poll是基于线性方式处理的，epoll是基于红黑树来管理待检测集合的。</li><li>select和poll每次都会线性扫描整个待检测集合，集合越大速度越慢，epoll使用的是回调机制，效率高，处理效率也不会随着检测集合的变大而下降</li><li>select和poll工作过程中存在内核&#x2F;用户空间数据的频繁拷贝问题，在epoll中内核和用户区使用的是共享内存（基于mmap内存映射区实现），省去了不必要的内存拷贝。</li><li>我们需要对select和poll返回的集合进行判断才能知道哪些文件描述符是就绪的，通过epoll可以直接得到已就绪的文件描述符集合，无需再次检测</li><li>使用epoll没有最大文件描述符的限制，仅受系统中进程能打开的最大文件数目限制</li></ul><p>当多路复用的文件数量庞大、IO流量频繁的时候，一般不太适合使用select()和poll()，这种情况下select()和poll()表现较差，推荐使用epoll()。</p><hr><h2 id="9-2-操作函数"><a href="#9-2-操作函数" class="headerlink" title="9.2 操作函数"></a>9.2 操作函数</h2><p>在epoll中一共提供是三个API函数，分别处理不同的操作，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建epoll实例，通过一棵红黑树管理待检测集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// 管理红黑树上的文件描述符(添加、修改、删除)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="comment">// 检测epoll树中是否有就绪的文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p>select&#x2F;poll低效的原因之一是将“添加&#x2F;维护待检测任务”和“阻塞进程&#x2F;线程”两个步骤合二为一。每次调用select都需要这两步操作，然而大多数应用场景中，需要监视的socket个数相对固定，并不需要每次都修改。epoll将这两个操作分开，先用<code>epoll_ctl()</code>维护等待队列，再调用<code>epoll_wait()</code>阻塞进程（解耦）。通过下图的对比显而易见，epoll的效率得到了提升。<br><img src="/img/9.45.png" alt="在这里插入图片描述"></p><p><code>epoll_create()</code>函数的作用是创建一个红黑树模型的实例，用于管理待检测的文件描述符的集合。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><ul><li>函数参数 size：在Linux内核2.6.8版本以后，这个参数是被忽略的，只需要指定一个大于0的数值就可以了。</li><li>函数返回值：<ul><li>失败：返回-1</li><li>成功：返回一个有效的文件描述符，通过这个文件描述符就可以访问创建的epoll实例了</li></ul></li></ul><p><code>epoll_ctl()</code>函数的作用是管理红黑树实例上的节点，可以进行添加、删除、修改操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联合体, 多个变量共用同一块内存        </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line"> <span class="type">void</span>        *ptr;</span><br><span class="line"><span class="type">int</span>          fd;<span class="comment">// 通常情况下使用这个成员, 和epoll_ctl的第三个参数相同即可</span></span><br><span class="line"><span class="type">uint32_t</span>     u32;</span><br><span class="line"><span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line"><span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure><ul><li>函数参数：<ul><li>epfd：epoll_create() 函数的返回值，通过这个参数找到epoll实例</li><li>op：这是一个枚举值，控制通过该函数执行什么操作<ul><li><code>EPOLL_CTL_ADD</code>：往epoll模型中添加新的节点</li><li><code>EPOLL_CTL_MOD</code>：修改epoll模型中已经存在的节点</li><li><code>EPOLL_CTL_DEL</code>：删除epoll模型中的指定的节点</li></ul></li><li>fd：文件描述符，即要添加&#x2F;修改&#x2F;删除的文件描述符</li><li>event：epoll事件，用来修饰第三个参数对应的文件描述符的，指定检测这个文件描述符的什么事件<ul><li><pre><code>events：委托epoll检测的事件</code></pre><ul><li><code>EPOLLIN</code>：读事件, 接收数据, 检测读缓冲区，如果有数据该文件描述符就绪</li><li><code>EPOLLOUT</code>：写事件, 发送数据, 检测写缓冲区，如果可写该文件描述符就绪</li><li><code>EPOLLERR</code>：异常事件</li></ul></li><li><pre><code>data：用户数据变量，这是一个联合体类型，通常情况下使用里边的`fd`成员，用于存储待检测的文件描述符的值，在调用`epoll_wait()`函数的时候这个值会被传出。</code></pre></li></ul></li></ul></li><li>函数返回值：<ul><li>失败：返回-1</li><li>成功：返回0<br><code>epoll_wait()</code>函数的作用是检测创建的epoll实例中有没有就绪的文件描述符。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><ul><li>函数参数：<ul><li>epfd：epoll_create() 函数的返回值, 通过这个参数找到epoll实例</li><li>events：传出参数, 这是一个结构体数组的地址, 里边存储了已就绪的文件描述符的信息</li><li>maxevents：修饰第二个参数, 结构体数组的容量（元素个数）</li><li>timeout：如果检测的epoll实例中没有已就绪的文件描述符，该函数阻塞的时长, 单位ms 毫秒<ul><li>0：函数不阻塞，不管epoll实例中有没有就绪的文件描述符，函数被调用后都直接返回</li><li>大于0：如果epoll实例中没有已就绪的文件描述符，函数阻塞对应的毫秒数再返回</li><li>-1：函数一直阻塞，直到epoll实例中有已就绪的文件描述符之后才解除阻塞</li></ul></li></ul></li><li>函数返回值：<ul><li>成功：<ul><li>等于0：函数是阻塞被强制解除了, 没有检测到满足条件的文件描述符</li><li>大于0：检测到的已就绪的文件描述符的总个数</li></ul></li><li>失败：返回-1</li></ul></li></ul><hr><h2 id="9-3-epoll的使用"><a href="#9-3-epoll的使用" class="headerlink" title="9.3 epoll的使用"></a>9.3 epoll的使用</h2><h3 id="9-3-1-操作步骤"><a href="#9-3-1-操作步骤" class="headerlink" title="9.3.1 操作步骤"></a>9.3.1 操作步骤</h3><p>在服务器端使用epoll进行IO多路转接的操作步骤如下：</p><ol><li>创建监听的套接字</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>设置端口复用（可选）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure><ol start="3"><li>使用本地的IP与端口和监听的套接字进行绑定</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br></pre></td></tr></table></figure><ol start="4"><li>给监听的套接字设置监听</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen(lfd, <span class="number">128</span>);</span><br></pre></td></tr></table></figure><ol start="5"><li>创建epoll实例对象</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><ol start="6"><li>将用于监听的套接字添加到epoll实例中</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">ev.events = EPOLLIN;    <span class="comment">// 检测lfd读读缓冲区是否有数据</span></span><br><span class="line">ev.data.fd = lfd;</span><br><span class="line"><span class="type">int</span> ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br></pre></td></tr></table></figure><ol start="7"><li>检测添加到epoll实例中的文件描述符是否已就绪，并将这些已就绪的文件描述符进行处理</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = epoll_wait(epfd, evs, size, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure><ul><li>如果是监听的文件描述符，和新客户端建立连接，将得到的文件描述符添加到epoll实例中</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cfd = accept(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line">ev.data.fd = cfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br></pre></td></tr></table></figure><ul><li>如果是通信的文件描述符，和对应的客户端通信，如果连接已断开，将该文件描述符从epoll实例中删除</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = recv(curfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">    close(curfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    send(curfd, buf, len, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>重复第7步的操作</li></ol><hr><h3 id="9-3-2-示例代码"><a href="#9-3-2-示例代码" class="headerlink" title="9.3.2 示例代码"></a>9.3.2 示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">// 本地多有的ＩＰ</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="comment">// 所有的文件描述符对应读写缓冲区状态都是委托内核进行检测的epoll</span></span><br><span class="line">    <span class="comment">// 创建一个epoll模型</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往epoll实例中添加需要检测的节点, 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = EPOLLIN;    <span class="comment">// 检测lfd读读缓冲区是否有数据</span></span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[1024];</span></span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(evs) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line">    <span class="comment">// 持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用一次, 检测一次</span></span><br><span class="line">        <span class="type">int</span> num = epoll_wait(epfd, evs, size, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出当前的文件描述符</span></span><br><span class="line">            <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line">            <span class="comment">// 判断这个文件描述符是不是用于监听的</span></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 建立新的连接</span></span><br><span class="line">                <span class="type">int</span> cfd = accept(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">                ev.events = EPOLLIN;    <span class="comment">// 读缓冲区是否有数据</span></span><br><span class="line">                ev.data.fd = cfd;</span><br><span class="line">                ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl-accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理通信的文件描述符</span></span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="type">int</span> len = recv(curfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端已经断开了连接\n&quot;</span>);</span><br><span class="line">                    <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">                    send(curfd, buf, len, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在服务器端循环调用<code>epoll_wait()</code>的时候，就会得到一个就绪列表，并通过该函数的第二个参数传出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[1024];</span></span><br><span class="line"><span class="type">int</span> num = epoll_wait(epfd, evs, size, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure><p>每当<code>epoll_wait()</code>函数返回一次，在<code>evs</code>中最多可以存储<code>size</code>个已就绪的文件描述符信息，但是在这个数组中实际存储的有效元素个数为<code>num</code>个，如果在这个epoll实例的红黑树中已就绪的文件描述符很多，并且<code>evs</code>数组无法将这些信息全部传出，那么这些信息会在下一次<code>epoll_wait()</code>函数返回的时候被传出。</p><p>通过<code>evs</code>数组被传递出的每一个有效元素里边都包含了已就绪的文件描述符的相关信息，这些信息并不是凭空得来的，这取决于我们在往epoll实例中添加节点的时候，往节点中初始化了哪些数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line"><span class="comment">// 节点初始化</span></span><br><span class="line">ev.events = EPOLLIN;    </span><br><span class="line">ev.data.fd = lfd;<span class="comment">// 使用了联合体中 fd 成员</span></span><br><span class="line"><span class="comment">// 添加待检测节点到epoll实例中</span></span><br><span class="line"><span class="type">int</span> ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br></pre></td></tr></table></figure><p>在添加节点的时候，需要对这个<code>struct epoll_event</code>类型的节点进行初始化，当这个节点对应的文件描述符变为已就绪状态，这些被传入的初始化信息就会被原样传出，这个对应关系必须要搞清楚。</p><hr><h2 id="9-4-epoll的工作模式"><a href="#9-4-epoll的工作模式" class="headerlink" title="9.4 epoll的工作模式"></a>9.4 epoll的工作模式</h2><h3 id="9-4-1-水平模式"><a href="#9-4-1-水平模式" class="headerlink" title="9.4.1 水平模式"></a>9.4.1 水平模式</h3><p>水平模式可以简称为LT模式，<code>LT（level triggered）是缺省的工作方式，并且同时支持block和no-block socket</code>。在这种做法中，内核通知使用者哪些文件描述符已经就绪，之后就可以对这些已就绪的文件描述符进行IO操作了。<code>如果我们不作任何操作，内核还是会继续通知使用者。</code></p><p><strong>水平模式的特点：</strong></p><ul><li>读事件：<code>如果文件描述符对应的读缓冲区还有数据，读事件就会被触发，epoll_wait()解除阻塞</code><ul><li>当读事件被触发，epoll_wait()解除阻塞，之后就可以接收数据了</li><li>如果接收数据的buf很小，不能全部将缓冲区数据读出，那么读事件会继续被触发，直到数据被全部读出，如果接收数据的内存相对较大，读数据的效率也会相对较高（减少了读数据的次数）</li><li><code>因为读数据是被动的，必须通过读事件才能知道有数据到达了，因此对于读事件的检测是必须的</code></li></ul></li><li>写事件：<code>如果文件描述符对应的写缓冲区可写，写事件就会被触发，epoll_wait()解除阻塞</code><ul><li>当写事件被触发，epoll_wait()解除阻塞，之后就可以将数据写入到写缓冲区了</li><li><code>写事件的触发发生在写数据之前而不是之后</code>，被写入到写缓冲区中的数据是由内核自动发送出去的</li><li>如果写缓冲区没有被写满，写事件会一直被触发</li><li><code>因为写数据是主动的，并且写缓冲区一般情况下都是可写的（缓冲区不满），因此对于写事件的检测不是必须的</code></li></ul></li></ul><hr><h3 id="9-4-2-边沿模式"><a href="#9-4-2-边沿模式" class="headerlink" title="9.4.2 边沿模式"></a>9.4.2 边沿模式</h3><p>边沿模式可简称为ET模式，<code>ET（edge-triggered）是高速工作方式，只支持no-block socket</code>。在这种模式下，<code>当文件描述符从未就绪变为就绪时，内核会通过epoll通知使用者。然后它会假设使用者知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知（only once）</code>。<br>如果我们对这个文件描述符做IO操作，从而导致它再次变成未就绪，当这个未就绪的文件描述符再次变成就绪状态，内核会再次进行通知，并且还是只通知一次。<br><code>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。</code></p><p><strong>边沿模式的特点:</strong></p><ul><li>读事件：<code>当读缓冲区有新的数据进入，读事件被触发一次，没有新数据不会触发该事件</code><ul><li>如果有新数据进入到读缓冲区，读事件被触发，epoll_wait()解除阻塞</li><li>读事件被触发，可以通过调用read()&#x2F;recv()函数将缓冲区数据读出<ul><li><code>如果数据没有被全部读走，并且没有新数据进入，读事件不会再次触发，只通知一次</code></li><li><code>如果数据被全部读走或只读走一部分，此时有新数据进入，读事件被触发，且只通知一次</code></li></ul></li></ul></li><li>写事件：<code>当写缓冲区状态可写，写事件只会触发一次</code><ul><li>如果写缓冲区被检测到可写，写事件被触发，epoll_wait()解除阻塞</li><li>写事件被触发，就可以通过调用write()&#x2F;send()函数，将数据写入到写缓冲区中<ul><li>写缓冲区从不满到被写满，期间写事件只会被触发一次</li><li>写缓冲区从满到不满，状态变为可写，写事件只会被触发一次</li></ul></li></ul></li></ul><p>综上所述：<code>epoll的边沿模式下 epoll_wait()检测到文件描述符有新事件才会通知，如果不是新的事件就不通知，通知的次数比水平模式少，效率比水平模式要高。</code></p><hr><h4 id="9-4-2-1-ET模式的设置"><a href="#9-4-2-1-ET模式的设置" class="headerlink" title="9.4.2.1 ET模式的设置"></a>9.4.2.1 ET模式的设置</h4><p>边沿模式不是默认的epoll模式，需要额外进行设置。epoll设置边沿模式是非常简单的，epoll管理的红黑树示例中每个节点都是<code>struct epoll_event</code>类型，只需要将<code>EPOLLET</code>添加到结构体的<code>events</code>成员中即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">ev.events = EPOLLIN | EPOLLET;<span class="comment">// 设置边沿模式</span></span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = epoll_wait(epfd, evs, size, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取出当前的文件描述符</span></span><br><span class="line">    <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line">    <span class="comment">// 判断这个文件描述符是不是用于监听的</span></span><br><span class="line">    <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 建立新的连接</span></span><br><span class="line">        <span class="type">int</span> cfd = accept(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">        <span class="comment">// 读缓冲区是否有数据, 并且将文件描述符设置为边沿模式</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">        ev.events = EPOLLIN | EPOLLET;   </span><br><span class="line">        ev.data.fd = cfd;</span><br><span class="line">        ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_ctl-accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="9-4-2-2-设置非阻塞"><a href="#9-4-2-2-设置非阻塞" class="headerlink" title="9.4.2.2 设置非阻塞"></a>9.4.2.2 设置非阻塞</h4><p>对于写事件的触发一般情况下是不需要进行检测的，因为写缓冲区大部分情况下都是有足够的空间可以进行数据的写入。对于读事件的触发就必须要检测了，因为服务器也不知道客户端什么时候发送数据，如果使用epoll的边沿模式进行读事件的检测，有新数据达到只会通知一次，那么必须要保证得到通知后将数据全部从读缓冲区中读出。那么，应该如何读这些数据呢？</p><ul><li>方式1：准备一块特别大的内存，用于存储从读缓冲区中读出的数据，但是这种方式有很大的弊端：<ul><li>内存的大小没有办法界定，太大浪费内存，太小又不够用</li><li>系统能够分配的最大堆内存也是有上限的，栈内存就更不必多言了</li></ul></li><li>方式2：循环接收数据</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = recv(curfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 数据处理...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做也是有弊端的，因为套接字操作默认是阻塞的，当读缓冲区数据被读完之后，读操作就阻塞了也就是调用的<code>read()/recv()</code>函数被阻塞了，当前进程&#x2F;线程被阻塞之后就无法处理其他操作了。</p><p>要解决阻塞问题，就将套接字默认的阻塞行为修改为非阻塞，需使用<code>fcntl()</code>函数进行处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置完成之后, 读写都变成了非阻塞模式</span></span><br><span class="line"><span class="type">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">flag |= O_NONBLOCK;                                                        </span><br><span class="line">fcntl(cfd, F_SETFL, flag);</span><br></pre></td></tr></table></figure><p>通过上述分析就可以得出一个结论：<code>epoll在边沿模式下，必须要将套接字设置为非阻塞模式</code>，但是，这样就会引发另外的一个bug，在非阻塞模式下，循环地将读缓冲区数据读到本地内存中，当缓冲区数据被读完了，调用的<code>read()/recv()</code>函数还会继续从缓冲区中读数据，此时函数调用就失败了，返回-1，对应的全局变量 errno 值为 <code>EAGAIN</code> 或者 <code>EWOULDBLOCK</code>如果打印错误信息会得到如下的信息：<code>Resource temporarily unavailable</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非阻塞模式下recv() / read()函数返回值 len == -1</span></span><br><span class="line"><span class="type">int</span> len = recv(curfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(errno == EAGAIN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数据读完了...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="9-4-2-3-示例代码"><a href="#9-4-2-3-示例代码" class="headerlink" title="9.4.2.3 示例代码"></a>9.4.2.3 示例代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">// 本地多有的ＩＰ</span></span><br><span class="line">    <span class="comment">// 127.0.0.1</span></span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr.s_addr);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="comment">// 所有的文件描述符对应读写缓冲区状态都是委托内核进行检测的epoll</span></span><br><span class="line">    <span class="comment">// 创建一个epoll模型</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往epoll实例中添加需要检测的节点, 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = EPOLLIN;    <span class="comment">// 检测lfd读读缓冲区是否有数据</span></span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[1024];</span></span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(evs) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line">    <span class="comment">// 持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用一次, 检测一次</span></span><br><span class="line">        <span class="type">int</span> num = epoll_wait(epfd, evs, size, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;==== num: %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出当前的文件描述符</span></span><br><span class="line">            <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line">            <span class="comment">// 判断这个文件描述符是不是用于监听的</span></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 建立新的连接</span></span><br><span class="line">                <span class="type">int</span> cfd = accept(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">// 将文件描述符设置为非阻塞</span></span><br><span class="line">                <span class="comment">// 得到文件描述符的属性</span></span><br><span class="line">                <span class="type">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">                flag |= O_NONBLOCK;</span><br><span class="line">                fcntl(cfd, F_SETFL, flag);</span><br><span class="line">                <span class="comment">// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">                <span class="comment">// 通信的文件描述符检测读缓冲区数据的时候设置为边沿模式</span></span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;    <span class="comment">// 读缓冲区是否有数据</span></span><br><span class="line">                ev.data.fd = cfd;</span><br><span class="line">                ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl-accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理通信的文件描述符</span></span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">5</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="comment">// 循环读数据</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> len = recv(curfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 非阻塞模式下和阻塞模式是一样的 =&gt; 判断对方是否断开连接</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">                        <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">                        epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                        close(curfd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 通信</span></span><br><span class="line">                        <span class="comment">// 接收的数据打印到终端</span></span><br><span class="line">                        write(STDOUT_FILENO, buf, len);</span><br><span class="line">                        <span class="comment">// 发送数据</span></span><br><span class="line">                        send(curfd, buf, len, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// len == -1</span></span><br><span class="line">                        <span class="keyword">if</span>(errno == EAGAIN)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;数据读完了...\n&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">                            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="10-基于UDP的套接字通信"><a href="#10-基于UDP的套接字通信" class="headerlink" title="10. 基于UDP的套接字通信"></a>10. 基于UDP的套接字通信</h1><p>udp是一个面向无连接的，不安全的，报式传输层协议，udp的通信过程默认也是阻塞的。</p><ul><li><p>UDP通信不需要建立连接 ，因此不需要进行connect()操作</p></li><li><p>UDP通信过程中，每次都需要指定数据接收端的IP和端口，和发快递差不多</p></li><li><p>UDP不对收到的数据进行排序，在UDP报文的首部中并没有关于数据顺序的信息</p></li><li><p>UDP对接收到的数据报不回复确认信息,发送端不知道数据是否被正确接收,也不会重发数据。</p></li><li><p>如果发生了数据丢失，不存在丢一半的情况，如果丢当前这个数据包就全部丢失了</p></li></ul><h2 id="10-1-通信流程"><a href="#10-1-通信流程" class="headerlink" title="10.1 通信流程"></a>10.1 通信流程</h2><p>使用UDP进行通信，服务器和客户端的处理步骤比TCP要简单很多，并且两端是对等的 （通信的处理流程几乎是一样的），也就是说并没有严格意义上的客户端和服务器端。UDP的通信流程如下：<br><img src="/img/9.46.png" alt="在这里插入图片描述"></p><h3 id="10-1-1-服务器端"><a href="#10-1-1-服务器端" class="headerlink" title="10.1.1 服务器端"></a>10.1.1 服务器端</h3><p><strong>假设服务器端是接收数据的角色：</strong></p><ol><li>创建通信的套接字</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>使用通信的套接字和本地的IP和端口绑定，IP和端口需要转换为大端(可选)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind();</span><br></pre></td></tr></table></figure><ol start="3"><li>通信</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line">recvfrom();</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">sendto();</span><br></pre></td></tr></table></figure><ol start="4"><li>关闭套接字（文件描述符）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure><hr><h3 id="10-1-2-客户端"><a href="#10-1-2-客户端" class="headerlink" title="10.1.2 客户端"></a>10.1.2 客户端</h3><p><strong>假设客户端是发送数据的角色：</strong></p><ol><li>创建通信的套接字</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>通信</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line">recvfrom();</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">sendto();</span><br></pre></td></tr></table></figure><ol start="3"><li>关闭套接字（文件描述符）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure><p>在UDP通信过程中，<code>哪一端是接收数据的角色，那么这个接收端就必须绑定一个固定的端口</code>，如果某一端不需要接收数据，这个绑定操作就可省略不写，通信的套接字会自动绑定一个随机端口。</p><hr><h2 id="10-2-通信函数"><a href="#10-2-通信函数" class="headerlink" title="10.2 通信函数"></a>10.2 通信函数</h2><p>基于UDP进行套接字通信，创建套接字的函数还是<code>socket()</code>但是第二个参数的值需要指定为<code>SOCK_DGRAM</code>，通过该参数指定要创建一个基于报式传输协议的套接字，最后一个参数指定为0表示使用报式协议中的UDP协议。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>domain：地址族协议，AF_INET -&gt; IPv4，AF_INET6-&gt; IPv6</li><li>type：使用的传输协议类型，报式传输协议需要指定为 SOCK_DGRAM</li><li>protocol：指定为0，表示使用的默认报式传输协议为 UDP</li></ul></li><li>返回值：函数调用成功返回一个可用的文件描述符（大于0），调用失败返回-1</li></ul><p>另外进行UDP通信，通信过程虽然默认还是阻塞的，但是通信函数和TCP不同<br>操作函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据, 如果没有数据,该函数阻塞</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd: 基于udp的通信的文件描述符</li><li>buf: 指针指向的地址用来存储接收的数据</li><li>len: buf指针指向的内存的容量, 最多能存储多少字节</li><li>flags: 设置套接字属性，一般使用默认属性，指定为0即可</li><li>src_addr: 发送数据的一端的地址信息，IP和端口都存储在这里边, 是大端存储的<ul><li>如果这个参数中的信息对当前业务处理没有用处, 可以指定为NULL, 不保存这些信息</li></ul></li><li>addrlen: 类似于accept() 函数的最后一个参数, 是一个传入传出参数<ul><li>传入的是src_addr参数指向的内存的大小, 传出的也是这块内存的大小</li><li>如果src_addr参数指定为NULL, 这个参数也指定为NULL即可</li></ul></li></ul></li><li>返回值：成功返回接收的字节数，失败返回-1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送数据函数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd: 基于udp的通信的文件描述符</li><li>buf: 这个指针指向的内存中存储了要发送的数据</li><li>len: 要发送的数据的实际长度</li><li>flags: 设置套接字属性，一般使用默认属性，指定为0即可</li><li>dest_addr: 接收数据的一端对应的地址信息, 大端的IP和端口</li><li>addrlen: 参数 dest_addr 指向的内存大小</li></ul></li><li>返回值：函数调用成功返回实际发送的字节数，调用失败返回-1</li></ul><hr><h2 id="10-3-通信代码"><a href="#10-3-通信代码" class="headerlink" title="10.3 通信代码"></a>10.3 通信代码</h2><p>在UDP通信过程中，服务器和客户端都可以作为数据的发送端和数据接收端，假设服务器端是被动接收数据，客户端是主动发送数据，那么在服务器端就必须绑定固定的端口了。</p><h3 id="10-3-1-服务器端"><a href="#10-3-1-服务器端" class="headerlink" title="10.3.1 服务器端"></a>10.3.1 服务器端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通信的套接字和本地的IP与端口绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);    <span class="comment">// 大端</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">char</span> ipbuf[<span class="number">64</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> rlen = recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP地址: %s, 端口: %d\n&quot;</span>,</span><br><span class="line">               inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ipbuf, <span class="keyword">sizeof</span>(ipbuf)),</span><br><span class="line">               ntohs(cliaddr.sin_port));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回复数据</span></span><br><span class="line">        <span class="comment">// 数据回复给了发送数据的客户端</span></span><br><span class="line">        sendto(fd, buf, rlen, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为数据接收端，服务器端通过<code>bind()</code>函数绑定了固定的端口，然后基于这个固定的端口通过<code>recvfrom()</code>函数接收客户端发送的数据，同时通过这个函数也得到了数据发送端的地址信息（recvfrom的第三个参数），这样就可以通过得到的地址信息通过<code>sendto()</code>函数给客户端回复数据了。</p><hr><h3 id="10-3-2-客户端"><a href="#10-3-2-客户端" class="headerlink" title="10.3.2 客户端"></a>10.3.2 客户端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化服务器地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);    <span class="comment">// 大端</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.1.100&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">char</span> ipbuf[<span class="number">64</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 2. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, udp %d....\n&quot;</span>, num++);</span><br><span class="line">        <span class="comment">// 发送数据, 数据发送给了服务器</span></span><br><span class="line">        sendto(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;服务器say: %s\n&quot;</span>, buf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为数据发送端，客户端不需要绑定固定端口，客户端使用的端口是随机绑定的（也可以调用bind()函数手动进行绑定）。客户端在接收服务器端回复的数据的时候需要调用<code>recvfrom()</code>函数，因为客户端在发送数据之前就已经知道服务器绑定的固定的IP和端口信息了，所以接收服务器数据的时候就可以不保存服务器端的地址信息，直接将函数的最后两个参数指定为NULL即可。</p><hr><h1 id="11-UDP特性之广播"><a href="#11-UDP特性之广播" class="headerlink" title="11. UDP特性之广播"></a>11. UDP特性之广播</h1><h2 id="11-1-广播的特点"><a href="#11-1-广播的特点" class="headerlink" title="11.1 广播的特点"></a>11.1 广播的特点</h2><p>广播的UDP的特性之一，<code>通过广播可以向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息</code>，每个广播消息都包含一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全部为1 （即点分十进制IP的最后一部分是255）。点分十进制的IP地址每一部分是1字节，最大值为255，比如：<code>192.168.1.100</code></p><ul><li>前两部分192.168表示当前网络是局域网</li><li>第三部分1表示局域网中的某一个网段，最大值为 255</li><li>第四部分100用于标记当前网段中的某一台主机，最大值为255</li><li>每个网段都有一个特殊的广播地址，即：192.168.xxx.255</li></ul><p>广播分为两端，即数据发送端和数据接收端，通过广播的方式发送数据，发送端和接收端的关系是 1:N</p><ul><li><p>发送广播消息的一端，通过广播地址，可以将消息同时发送到局域网的多台主机上（数据接收端）</p></li><li><p>在发送广播消息的时候，必须要把数据发送到广播地址上</p></li><li><p>广播只能在局域网内使用，广域网是无法使用UDP进行广播的</p></li><li><p>只要发送端在发送广播消息，数据接收端就能收到广播消息，消息的接收是无法拒绝的，除非将接收端的进程关闭，就接收不到了。</p></li></ul><p>UDP的广播和日常的广播是一样的，都是一种快速传播消息的方式，因此<code>广播的开销很小</code>，发送端使用一个广播地址，就可以将数据发送到多个接收数据的终端上，如果不使用广播，就需要进行多次发送才能将数据分别发送到不同的主机上。</p><hr><h2 id="11-2-设置广播属性"><a href="#11-2-设置广播属性" class="headerlink" title="11.2 设置广播属性"></a>11.2 设置广播属性</h2><p>基于UDP虽然可以进行数据的广播，但是这个属性默认是关闭的，如果需要对数据进行广播，那么需要在广播端代码中开启广播属性，需要通过套接字选项函数进行设置，该函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sockfd：进行UDP通信的文件描述符</li><li>level: 套接字级别，需要设置为 SOL_SOCKET</li><li>optname：选项名，此处要设置udp的广播属性，该参数需要指定为：SO_BROADCAST</li><li>optval：如果是设置广播属性，该指针实际指向一块int类型的内存<ul><li>该整型值为0：关闭广播属性</li><li>该整形值为1：打开广播属性</li></ul></li><li>optlen：optval指针指向的内存大小，即：sizeof(int)</li></ul></li><li>返回值：函数调用成功返回0，失败返回-1</li></ul><hr><h2 id="11-3-广播通信流程"><a href="#11-3-广播通信流程" class="headerlink" title="11.3 广播通信流程"></a>11.3 广播通信流程</h2><p>如果使用UDP在局域网范围内进行消息的广播，一般情况下广播端只发送数据，接收端只接受广播消息。因此在数据接收端需要绑定固定的端口，广播端则不需要手动绑定固定端口，自动随机绑定即可。</p><p><img src="/img/9.47.png" alt="在这里插入图片描述"></p><p><strong>数据发送端</strong></p><ol><li>创建通信的套接字</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>主动发送数据不需要手动绑定固定端口（自动随机分配就可以了），因此直接设置广播属性</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt  = <span class="number">1</span>;</span><br><span class="line">setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure><ol start="3"><li>使用广播地址发送广播数据到接收端绑定的固定端口上</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendto();</span><br></pre></td></tr></table></figure><ol start="4"><li>关闭套接字（文件描述符）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure><p><strong>数据接收端</strong></p><ol><li>创建通信的套接字</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>因为是被动接收数据的一端，所以必须要绑定固定的端口和本地IP地址</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind();</span><br></pre></td></tr></table></figure><ol start="3"><li>接收广播消息</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recvfrom();</span><br></pre></td></tr></table></figure><ol start="4"><li>关闭套接字（文件描述符）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure><hr><h2 id="11-4-通信代码"><a href="#11-4-通信代码" class="headerlink" title="11.4 通信代码"></a>11.4 通信代码</h2><p><strong>广播端</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置广播属性</span></span><br><span class="line">    <span class="type">int</span> opt  = <span class="number">1</span>;</span><br><span class="line">    setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">9999</span>); <span class="comment">// 接收端需要绑定9999端口</span></span><br><span class="line">    <span class="comment">// 只要主机在237网段, 并且绑定了9999端口, 这个接收端就能收到广播消息</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.237.255&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, client...%d\n&quot;</span>, num++);</span><br><span class="line">        <span class="comment">// 数据广播</span></span><br><span class="line">        sendto(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发送的广播的数据: %s\n&quot;</span>, buf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：发送广播消息一端必须要开启UDP的广播属性，并且发送消息的地址必须是当前发送端所在网段的广播地址，这样才能通过调用一个消息发送函数将消息同时发送N台接收端主机上。</p></blockquote><p><strong>接收端</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通信的套接字和本地的IP与端口绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);    <span class="comment">// 大端</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收广播消息</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">// 阻塞等待数据达到</span></span><br><span class="line">        recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收到的广播消息: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于接收广播消息的一端，必须要绑定固定的端口，并由广播端将广播消息发送到这个端口上，因此所有接收端都应绑定相同的端口，这样才能同时收到广播数据。</p></blockquote><hr><h1 id="12-UDP特性之组播（多播）"><a href="#12-UDP特性之组播（多播）" class="headerlink" title="12. UDP特性之组播（多播）"></a>12. UDP特性之组播（多播）</h1><h2 id="12-1-组播的特点"><a href="#12-1-组播的特点" class="headerlink" title="12.1 组播的特点"></a>12.1 组播的特点</h2><p>组播也可以称之为多播这也是UDP的特性之一。<code>组播是主机间一对多的通讯模式，是一种允许一个或多个组播源发送同一报文到多个接收者的技术</code>。组播源将一份报文发送到特定的组播地址，组播地址不同于单播地址，它并不属于特定某个主机，而是属于一组主机。一个组播地址表示一个群组，需要接收组播报文的接收者都加入这个群组。</p><ul><li>广播只能在局域网访问内使用，组播既可以在局域网中使用，也可以用于广域网</li><li>在发送广播消息的时候，连接到局域网的客户端不管想不想都会接收到广播数据，组播可以控制发送端的消息能够被哪些接收端接收，更灵活和人性化。</li><li>广播使用的是广播地址，组播需要使用组播地址。</li><li>广播和组播属性默认都是关闭的，如果使用需要通过setsockopt()函数进行设置。</li></ul><p>组播需要使用组播地址，在 IPv4 中它的范围从 <code>224.0.0.0</code> 到 <code>239.255.255.255</code>，并被划分为局部链接多播地址、预留多播地址和管理权限多播地址三类:</p><table><thead><tr><th>IP地址</th><th>说明</th></tr></thead><tbody><tr><td>224.0.0.0~224.0.0.255</td><td>局部链接多播地址：是为路由协议和其它用途保留的地只能用于局域网中，路由器是不会转发的地址 224.0.0.0不能用，是保留地址</td></tr><tr><td>224.0.1.0~224.0.1.255</td><td>为用户可用的组播地址（临时组地址），可以用于 Internet 上的。</td></tr><tr><td>224.0.2.0~238.255.255.255</td><td>用户可用的组播地址（临时组地址），全网范围内有效</td></tr><tr><td>239.0.0.0~239.255.255.255</td><td>为本地管理组播地址，仅在特定的本地范围内有效</td></tr></tbody></table><p>组播地址不属于任何服务器或个人，它有点类似一个微信群号，任何成员（<strong>组播源</strong>）往微信群（<strong>组播IP</strong>）发送消息（<strong>组播数据</strong>），这个群里的成员（组播接收者）都会接收到此消息。</p><hr><h2 id="12-2-设置组播属性"><a href="#12-2-设置组播属性" class="headerlink" title="12.2 设置组播属性"></a>12.2 设置组播属性</h2><p>如果使用组播进行数据的传输，不管是消息发送端还是接收端，都需要进行相关的属性设置，设置函数使用的是同一个，即：<code>setsockopt()。</code></p><h3 id="12-2-1-发送端"><a href="#12-2-1-发送端" class="headerlink" title="12.2.1 发送端"></a>12.2.1 发送端</h3><p>发送组播消息的一端需要设置组播属性，具体的设置方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>sockfd：用于UDP通信的套接字</li><li>level：套接字级别，设置组播属性需要将该参数指定为：IPPTOTO_IP</li><li>optname: 套接字选项名，设置组播属性需要将该参数指定为：IP_MULTICAST_IF</li><li>optval：设置组播属性，这个指针需要指向一个struct in_addr{} 类型的结构体地址，这个结构体地址用于存储组播地址，并且组播IP地址的存储方式是大端的。</li><li>optlen：optval指针指向的内存大小，即：sizeof(struct in_addr)</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;<span class="comment">// unsigned int</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li>返回值：函数调用成功返回0，调用失败返回-1</li></ul><hr><h3 id="12-2-2-接收端"><a href="#12-2-2-接收端" class="headerlink" title="12.2.2 接收端"></a>12.2.2 接收端</h3><p>因为一个组播地址表示一个群组，所以需要接收组播报文的接收者都加入这个群组，和想要接收群消息就必须要先入群是一个道理。加入到这个组播群组的方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数:</p><ul><li><p>sockfd：基于udp的通信的套接字</p></li><li><p>level：套接字级别，加入到多播组该参数需要指定为：<code>IPPTOTO_IP</code></p></li><li><p>optname：套接字选项名，加入到多播组该参数需要指定为：<code>IP_ADD_MEMBERSHIP</code></p></li><li><p>optval：加入到多播组，这个指针应该指向一个<code>struct ip_mreqn&#123;&#125;</code>类型的结构体地址</p></li><li><p>optlen：optval指向的内存大小，即：<code>sizeof(struct ip_mreqn)</code></p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>  <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;<span class="comment">// unsigned int</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span>   <span class="comment">// 组播地址/多播地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_address</span>;</span>     <span class="comment">// 本地地址</span></span><br><span class="line">    <span class="type">int</span>   imr_ifindex;              <span class="comment">// 网卡的编号, 每个网卡都有一个编号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 必须通过网卡名字才能得到网卡的编号: 可以通过 ifconfig 命令查看网卡名字</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将网卡名转换为网卡的编号, 参数是网卡的名字, 比如: &quot;ens33&quot;</span></span><br><span class="line"><span class="comment">// 返回值就是网卡的编号</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">if_nametoindex</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ifname)</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="12-3-组播通信流程"><a href="#12-3-组播通信流程" class="headerlink" title="12.3 组播通信流程"></a>12.3 组播通信流程</h2><p>发送组播消息的一端需要将数据发送到组播地址和固定的端口上，想要接收组播消息的终端需要绑定对应的固定端口然后加入到组播的群组，最终就可以实现数据的共享。</p><p><img src="/img/9.48.png" alt="在这里插入图片描述"></p><h3 id="12-3-1-发送端"><a href="#12-3-1-发送端" class="headerlink" title="12.3.1 发送端"></a>12.3.1 发送端</h3><ol><li>创建通信的套接字</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>主动发送数据的一端不需要手动绑定端口（自动随机分配就可以了），设置UDP组播属性</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置组播属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">opt</span>;</span></span><br><span class="line"><span class="comment">// 将组播地址初始化到这个结构体成员中</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;239.0.1.10&quot;</span>, &amp;opt.s_addr);</span><br><span class="line">setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure><ol start="3"><li>使用组播地址发送组播消息到固定的端口（接收端需要绑定这个端口）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendto();</span><br></pre></td></tr></table></figure><ol start="4"><li>关闭套接字（文件描述符）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure><hr><h3 id="12-3-2-接收端"><a href="#12-3-2-接收端" class="headerlink" title="12.3.2 接收端"></a>12.3.2 接收端</h3><ol><li>创建通信的套接字</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>绑定固定的端口，发送端应该将数据发送到接收端绑定的端口上</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind();</span><br></pre></td></tr></table></figure><ol start="3"><li>加入到组播的群组中，入群之后就可以接受组播消息了。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入到多播组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">opt</span>;</span></span><br><span class="line"><span class="comment">// 要加入到哪个多播组, 通过组播地址来区分</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;239.0.1.10&quot;</span>, &amp;opt.imr_multiaddr.s_addr);</span><br><span class="line">opt.imr_address.s_addr = INADDR_ANY;</span><br><span class="line">opt.imr_ifindex = if_nametoindex(<span class="string">&quot;ens33&quot;</span>);</span><br><span class="line">setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure><ol start="4"><li>接收组播数据</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recvfrom();</span><br></pre></td></tr></table></figure><ol start="5"><li>关闭套接字（文件描述符）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure><hr><h2 id="12-4-通信代码"><a href="#12-4-通信代码" class="headerlink" title="12.4 通信代码"></a>12.4 通信代码</h2><h3 id="12-4-1-发送端"><a href="#12-4-1-发送端" class="headerlink" title="12.4.1 发送端"></a>12.4.1 发送端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置组播属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">opt</span>;</span></span><br><span class="line">    <span class="comment">// 将组播地址初始化到这个结构体成员中即可</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.1.10&quot;</span>, &amp;opt.s_addr);</span><br><span class="line">    setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">9999</span>); <span class="comment">// 接收端需要绑定9999端口</span></span><br><span class="line">    <span class="comment">// 发送组播消息, 需要使用组播地址, 和设置组播属性使用的组播地址一致就可以</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.1.10&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, client...%d\n&quot;</span>, num++);</span><br><span class="line">        <span class="comment">// 数据广播</span></span><br><span class="line">        sendto(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发送的组播的数据: %s\n&quot;</span>, buf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在组播数据的发送端，需要先设置组播属性，发送的数据是通过sendto()函数发送到某一个组播地址上，并且在程序中数据发送到了接收端的9999端口，因此接收端程序必须要绑定这个端口才能收到组播消息。</p></blockquote><hr><h3 id="12-4-2-接收端"><a href="#12-4-2-接收端" class="headerlink" title="12.4.2 接收端"></a>12.4.2 接收端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通信的套接字和本地的IP与端口绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);    <span class="comment">// 大端</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 加入到多播组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">opt</span>;</span></span><br><span class="line">    <span class="comment">// 要加入到哪个多播组, 通过组播地址来区分</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.1.10&quot;</span>, &amp;opt.imr_multiaddr.s_addr);</span><br><span class="line">    opt.imr_address.s_addr = INADDR_ANY;</span><br><span class="line">    opt.imr_ifindex = if_nametoindex(<span class="string">&quot;ens33&quot;</span>);</span><br><span class="line">    setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收广播消息</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">// 阻塞等待数据达到</span></span><br><span class="line">        recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收到的组播消息: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：作为组播消息的接收端，必须要先绑定一个固定端口（发送端就可以把数据发送到这个固定的端口上了），然后加入到组播的群组中（一个组播地址可以看做是一个群组），这样就可以接收到组播消息了。</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 套接字通信 </tag>
            
            <tag> IO多路转接复用 </tag>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程</title>
      <link href="/2023/10/22/%E8%BF%9B%E7%A8%8B/"/>
      <url>/2023/10/22/%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-进程控制"><a href="#1-进程控制" class="headerlink" title="1. 进程控制"></a>1. 进程控制</h1><h2 id="1-1-进程概述"><a href="#1-1-进程概述" class="headerlink" title="1.1 进程概述"></a>1.1 进程概述</h2><p>从严格意义上来讲，程序和进程是两个不同的概念，他们的状态，占用的系统资源都是不同的。</p><ul><li>程序：就是磁盘上的可执行文件文件, 并且只占用磁盘上的空间，是一个静态的概念。</li><li>进程：被执行之后的程序叫做进程，不占用磁盘空间，需要消耗系统的内存，CPU资源，每个运行的进程的都对应一个属于自己的虚拟地址空间，这是一个动态的概念。</li></ul><h3 id="1-1-1-并行和并发"><a href="#1-1-1-并行和并发" class="headerlink" title="1.1.1 并行和并发"></a>1.1.1 并行和并发</h3><ul><li><p>CPU时间片<br>CPU在某个时间点只能处理一个任务，但是操作系统都支持多任务的，那么在计算机CPU只有一个的情况下是怎么完成多任务处理的呢？每个人分一点，但是又不叫吃饱。<br>CPU会给每个进程被分配一个时间段，进程得到这个时间片之后才可以运行，使各个程序从表面上看是同时进行的。<br>如果在时间片结束时进程还在运行，CPU的使用权将被收回，该进程将会被中断挂起等待下一个时间片。<br>如果进程在时间片结束前阻塞或结束,则CPU当即进行切换,这样就可避免CPU资源的浪费。<br>因此可以得知，在我们使用的计算机中启动的多个程序，从宏观上看是同时运行的，从微观上看由于CPU一次只能处理一个进程，所有它们是轮流执行的，只不过切换速度太快，感觉不到，因此CPU的核数越多计算机的处理效率越高。</p></li><li><p>并发和并行<br>这两个概念都可笼统的解释为：多个进程同时运行. 但是他们两个的同时并不是一个概念。Erlang 之父 Joe Armstrong 用一张小孩能看懂的图解释了并发与并行的区别：<br><img src="/img/9.1.png" alt="在这里插入图片描述"></p></li></ul><blockquote><p>并发：第一幅图是并发。</p></blockquote><ul><li>并发的同时运行是一个假象，咖啡机也好CPU也好在某一个时间点只能为某一个个体来服务，因此不可能同时处理多任务，这是通过上图的咖啡机&#x2F;计算机的CPU快速的时间片切换实现的。</li><li>并发是针对某一个硬件资源而言的，在某个时间段之内处理的任务的总量，量越大效率越高。</li><li>并发也可以理解为是不断努力自我升华的结果。</li></ul><blockquote><p>并行：第二幅图是并行。</p></blockquote><ul><li>并行的多进程同时运行是真实存在的，可以在同一时刻同时运行多个进程</li><li>并行需要依赖多个硬件资源，单个是无法实现的（图中有两台咖啡机）。</li><li>并行可以理解为出生就有天然的硬件优势，资源多办事效率就高。</li></ul><hr><h3 id="1-1-2-PCB"><a href="#1-1-2-PCB" class="headerlink" title="1.1.2 PCB"></a>1.1.2 PCB</h3><blockquote><p><strong>PCB - 进程控制块（Processing Control Block）</strong>，Linux内核的进程控制块本质上是一个叫做 <code>task_struct</code> 的结构体。<br>在这个结构体中记录了进程运行相关的一些信息，介绍一些常用的信息：</p></blockquote><ul><li><p>进程id：每一个进程都一个唯一的进程ID，类型为 <code>pid_t</code>, 本质是一个整形数</p></li><li><p>进程的状态：进程有不同的状态, 状态是一直在变化的，有就绪,运行,挂起,停止等状态。</p></li><li><p>进程对应的虚拟地址空间的信息。</p></li><li><p>描述控制终端的信息，进程在哪个终端启动默认就和哪个终端绑定。</p></li><li><p>当前工作目录：默认情况下, 启动进程的目录就是当前的工作目录</p></li><li><p>umask掩码：在创建新文件的时候，通过这个掩码屏蔽某些用于对文件的操作权限。</p></li><li><p>文件描述符表：每个被分配的文件描述符都对应一个已经打开的磁盘文件</p></li><li><p>和信号相关的信息：在Linux中 调用函数, 键盘快捷键, 执行shell命令等操作都会产生信号。</p><ul><li>阻塞信号集：记录当前进程中阻塞哪些已产生的信号，使其不能被处理</li></ul></li><li><p>未决信号集：记录在当前进程中产生的哪些信号还没有被处理掉。</p></li><li><p>用户id和组id：当前进程属于哪个用户, 属于哪个用户组</p></li><li><p>会话（Session）和进程组：多个进程的集合叫进程组，多个进程组的集合叫会话。</p></li><li><p>进程可以使用的资源上限：可以使用shell命令<code>ulimit -a</code>查看详细信息。</p></li></ul><hr><h3 id="1-1-4-进程状态"><a href="#1-1-4-进程状态" class="headerlink" title="1.1.4 进程状态"></a>1.1.4 进程状态</h3><p>进程一共有五种状态分别为：<code>创建态</code>，<code>就绪态</code>，<code>运行态</code>，<code>阻塞态(挂起态)</code>，<code>退出态(终止态)</code><br>其中 创建态 和 退出态 维持的时间是非常 短 的，稍纵即逝。<br>我们需将就绪态, 运行态, 挂起态，三者之间的状态切换搞明白。<br><img src="/img/9.2.png" alt="在这里插入图片描述"></p><ul><li>就绪态: 等待CPU资源<ul><li>进程被创建出来了，有运行的资格但是还没有运行，需要抢CPU时间片</li><li>得到CPU时间片，进程开始运行，从就绪态转换为运行态。</li><li>进程的CPU时间片用完了, 再次失去CPU, 从运行态转换为就绪态。</li></ul></li><li>运行态：获取到CPU资源的进程，进程只有在这种状态下才能运行<ul><li>运行态不会一直持续，进程的CPU时间片用完之后, 再次失去CPU，从运行态转换为就绪态</li><li>只要进程还没有退出，就会在就绪态和运行态之间不停的切换。</li></ul></li><li>阻塞态：进程被强制放弃CPU，并且没有抢夺CPU时间片的资格<ul><li>比如: 在程序中调用了某些函数（比如: sleep()），进程又运行态转换为阻塞态（挂起态）</li><li>当某些条件被满足了（比如：slee() 睡醒了），进程的阻塞状态也就被解除了，进程从阻塞态转换为就绪态。</li></ul></li><li>退出态: 进程被销毁, 占用的系统资源被释放了<ul><li>任何状态的进程都可以直接转换为退出态。</li></ul></li></ul><hr><h3 id="1-1-5-进程命令"><a href="#1-1-5-进程命令" class="headerlink" title="1.1.5 进程命令"></a>1.1.5 进程命令</h3><p>在研究如何创建进程之前，先来看一下如何在终端中通过命令完成进程相关的操作。</p><ul><li>查看进程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux</span><br><span class="line">- a: 查看所有终端的信息</span><br><span class="line">- u: 查看用户相关的信息</span><br><span class="line">- x: 显示和终端无关的进程信息</span><br></pre></td></tr></table></figure><p><img src="/img/9.3.png" alt="在这里插入图片描述"></p><p>如果特别想知道每个参数控制着哪些信息, 可以通过 <code>ps a</code>, <code>ps u</code>, <code>ps x</code>分别查看。</p><ul><li>杀死进程</li></ul><p><code>kill</code>命令可以发送某个信号到对应的进程，进程收到某些信号之后默认的处理动作就是退出进程，如果要给进程发送信号，可以先查看一下Linux给我们提供了哪些标准信号。</p><blockquote><p>查看Linux中的标准信号:</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><blockquote><p>9号信号（SIGKILL）的行为是无条件杀死进程，想要杀死哪个进程就可以把这个信号发送给这个进程，操作如下：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无条件杀死进程, 进程ID通过 ps aux 可以查看(PID)</span></span><br><span class="line">$ <span class="built_in">kill</span> -9 进程ID</span><br><span class="line">$ <span class="built_in">kill</span> -SIGKILL 进程ID</span><br></pre></td></tr></table></figure><hr><h2 id="1-2-进程创建"><a href="#1-2-进程创建" class="headerlink" title="1.2 进程创建"></a>1.2 进程创建</h2><h3 id="1-2-1-函数"><a href="#1-2-1-函数" class="headerlink" title="1.2.1 函数"></a>1.2.1 函数</h3><blockquote><p>Linux中进程ID为 <code>pid_t</code> 类型，其本质是一个正整数<br>通过上边的ps aux命令已经得到了验证。PID为1的进程是Linux系统中创建的第一个进程。</p></blockquote><ul><li>获取当前进程的进程ID（PID）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>获取当前进程的父进程 ID（PPID）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>创建一个新的进程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Linux中看似创建一个新的进程非常简单，函数连参数都没有<br>实际上如果想要真正理解这个函数还是要下功夫。</p></blockquote><hr><h3 id="1-2-2-fork-剖析"><a href="#1-2-2-fork-剖析" class="headerlink" title="1.2.2 fork() 剖析"></a>1.2.2 fork() 剖析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>启动磁盘上的应用程序, 得到一个进程, 如果在这个启动的进程中调用<code>fork()</code>函数，就会得到一个新的进程，我们习惯将其称之为<code>子进程</code>。<br>前面说过每个进程都对应一个属于自己的虚拟地址空间，<code>子进程的地址空间是基于父进程的地址空间拷贝出来的</code>，虽然是拷贝但是两个地址空间中存储的信息不可能是完全相同的，下图是拷贝之后父子进程各自的虚拟地址空间：<br><img src="/img/9.4.png" alt="在这里插入图片描述"></p><ul><li>相同点：<br><code>拷贝完成之后（注意这个时间点），两个地址空间中的用户区数据是相同的</code>。<br>用户区数据主要数据包括：<ul><li>代码区：默认情况下父子进程地址空间中的源代码始终相同。</li><li>全局数据区：父进程中的全局变量和变量值全部被拷贝一份放到了子进程地址空间中</li><li>堆区：父进程中的堆区变量和变量值全部被拷贝一份放到了子进程地址空间中</li><li>动态库加载区（内存映射区）：父进程中数据信息被拷贝一份放到了子进程地址空间中</li><li>栈区：父进程中的栈区变量和变量值全部被拷贝一份放到了子进程地址空间中</li><li>环境变量：默认情况下，父子进程地址空间中的环境变量始终相同。</li><li>文件描述符表: <code>父进程中被分配的文件描述符都会拷贝到子进程中，在子进程中可以使用它们打开对应的文件</code></li></ul></li><li>区别：<ul><li>父子进程各自的虚拟地址空间是相互独立的，不会互相干扰和影响。</li><li>父子进程地址空间中代码区代码虽然相同，但是父子进程执行的代码逻辑可能是不同的。</li><li>由于父子进程可能执行不同的代码逻辑，因此地址空间拷贝完成之后，<code>全局数据区, 栈区, 堆区, 动态库加载区(内存映射区)</code>数据会各自发生变化，由于地址空间是相互独立的，因此不会互相覆盖数据。</li><li>由于每个进都有自己的进程ID，因此内核区存储的父子进程ID是不同的。</li><li>进程启动之后进入就绪态，运行需要争抢CPU时间片而且可能执行不同的业务逻辑，所以父子进程的状态可能是不同的。</li><li>fork() 调用成功之后，会返回两个值，父子进程的返回值是不同的。<ul><li><code>该函数调用成功之后，从一个虚拟地址空间变成了两个虚拟地址空间，每个地址空间中都会将 fork() 的返回值记录下来</code>这就是为什么会得到两个返回值的原因。</li><li>父进程的虚拟地址空间中将该返回值标记为一个大于0的数（其实记录的是子进程的进程ID）</li><li>子进程的虚拟地址空间中将该返回值标记 0</li><li>在程序中需要通过 fork() 的返回值来判断当前进程是子进程还是父进程。</li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在父进程中创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前进程fork()的返回值: %d\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程执行的逻辑</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程执行的逻辑</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid = %d, 我爹是: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// pid == -1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建子进程失败了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不加判断, 父子进程都会执行这个循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-3-父子进程"><a href="#1-3-父子进程" class="headerlink" title="1.3 父子进程"></a>1.3 父子进程</h2><h3 id="1-3-1-进程执行位置"><a href="#1-3-1-进程执行位置" class="headerlink" title="1.3.1 进程执行位置"></a>1.3.1 进程执行位置</h3><p>在父进程中成功创建了子进程，子进程就拥有父进程代码区的所有代码，那么子进程中的代码是在什么位置开始运行的呢？<br><code>父进程是从main()函数开始运行的，子进程是在父进程中调用fork()函数之后被创建, 子进程就从fork()之后开始向下执行代码。</code><br><img src="/img/9.5.png" alt="在这里插入图片描述"></p><p>上图中演示了父子进程中代码的执行流程，可以看到如果在程序中对fork()的返回值做了判断，就可以控制父子进程的行为，如果没有做任何判断这个代码块父子进程都可以执行。<br>在编写多进程程序的时候，一定要将代码想象成多份进行分析，因为直观上看代码就一份，但实际上数据都是多份，且多份数据中变量名都相同，但是他们的值却不一定相同。</p><hr><h3 id="1-3-2-循环创建子进程"><a href="#1-3-2-循环创建子进程" class="headerlink" title="1.3.2 循环创建子进程"></a>1.3.2 循环创建子进程</h3><p>掌握了进程创建函数之后，实现一个简单的功能，在一个父进程中循环创建3个子进程，也就是最后需要得到4个进程，1个父进程，3个子进程<br>为了方便验证程序的正确性，要求在程序中打印出每个进程的进程ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// process_loop.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前进程pid: %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行上面的代码，得到了如下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">$ gcc process_loop.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">$ ./a.out</span><br><span class="line"><span class="comment"># 最终得到了 8个进程</span></span><br><span class="line">当前进程pid: 18774     ------ 1</span><br><span class="line">当前进程pid: 18774     ------ 1</span><br><span class="line">当前进程pid: 18774     ------ 1</span><br><span class="line">当前进程pid: 18777     ------ 2</span><br><span class="line">当前进程pid: 18776     ------ 3</span><br><span class="line">当前进程pid: 18776     ------ 3</span><br><span class="line">当前进程pid: 18775     ------ 4</span><br><span class="line">当前进程pid: 18775     ------ 4</span><br><span class="line">当前进程pid: 18775     ------ 4</span><br><span class="line">当前进程pid: 18778     ------ 5</span><br><span class="line">当前进程pid: 18780     ------ 6</span><br><span class="line">当前进程pid: 18779     ------ 7</span><br><span class="line">当前进程pid: 18779     ------ 7</span><br><span class="line">当前进程pid: 18781     ------ 8</span><br></pre></td></tr></table></figure><p>通过程序打印的信息发现程序循环了三次，最终得到了8个进程，也就是创建出了7个子进程,没有在程序中加条件控制，所有的代码父子进程都是有资格执行的。<br><img src="/img/9.6.png" alt="在这里插入图片描述"></p><p>上图中的树状结构，蓝色节点代表父进程：</p><ul><li>循环第一次 i &#x3D; 0，创建出一个子进程，即红色节点，子进程变量值来自父进程拷贝，因此 i&#x3D;0</li><li>循环第二次 i &#x3D; 1，蓝色父进程和红色子进程都去创建子进程，得到两个紫色进程，子进程变量值来自父进程拷贝，因此 i&#x3D;1</li><li>循环第三次 i &#x3D; 2，蓝色父进程和红色、紫色子进程都去创建子进程，因此得到4个绿色子进程，子进程变量值来自父进程拷贝，因此 i&#x3D;2</li><li>循环第四次 i &#x3D; 3，所有进程都不满足条件 <code>for(int i=0; i&lt;3; ++i)</code>因此不进入循环，退出了。</li></ul><p>解决方案:可以只让父进程创建子进程，如果是子进程不让其继续创建子进程，只需在程序中添加关于父子进程的判断即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要在上边的程序中控制不让子进程, 再创建子进程即可</span></span><br><span class="line"><span class="comment">// process_loop.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 在循环中创建子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不让子进程执行循环, 直接跳出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前进程pid: %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后编译并执行程序，查看最终结果，可以看到最后确实得到了4个不同的进程<br>pid最小的为父进程，其余为子进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">$ gcc process_loop.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">$ ./a.out</span><br><span class="line">当前进程pid: 2727</span><br><span class="line">当前进程pid: 2730</span><br><span class="line">当前进程pid: 2729</span><br><span class="line">当前进程pid: 2728</span><br></pre></td></tr></table></figure><blockquote><p>在多进程序中，进程的执行顺序是没有规律的，因为所有的进程都需要在就绪态争抢CPU时间片，抢到了就执行，抢不到就不执行<br>默认进程的优先级是相同的，操作系统不会让某一个进程一直抢不到CPU时间片。</p></blockquote><hr><h3 id="1-3-3-终端显示问题"><a href="#1-3-3-终端显示问题" class="headerlink" title="1.3.3 终端显示问题"></a>1.3.3 终端显示问题</h3><p>在执行多进程程序的时候，经常会遇到下图中的问题<br>看似进程还没有执行完成，貌似因为什么被阻塞了，实际上终端是正常的，通过键盘输入一些命令，终端也能接受输入并输出相关信息，那为什么终端会显示成这样呢？<br><img src="/img/9.7.png" alt="在这里插入图片描述"></p><ol><li><p>a.out 进程启动之后，共创建了3个子进程，其实 a.out 也是有父进程的就是当前的终端</p></li><li><p>终端只能检测到 a.out 进程的状态，a.out执行期间终端切换到后台，a.out执行完毕之后终端切换回前台</p></li><li><p>当终端切换到前之后，a.out的子进程还没有执行完毕，当子进程输出的信息就显示到终端命令提示符的后边了，导致终端显示有问题，但是此时终端是可以接收键盘输入的，只是看起来不美观而已。</p></li><li><p>想要解决这个问题，需要让所有子进程退出之后再退出父进程，比如：在父进程代码中调用 sleep()</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sleep(<span class="number">3</span>);<span class="comment">// 让父进程睡一会儿</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-3-4-进程数数"><a href="#1-3-4-进程数数" class="headerlink" title="1.3.4 进程数数"></a>1.3.4 进程数数</h3><p>当父进程创建一个子进程，那么父子进程之间可以通过全局变量互动，实现交替数数的功能吗?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// number.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量</span></span><br><span class="line"><span class="type">int</span> number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建子进程之前 number = %d\n&quot;</span>, number);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="comment">// 父子进程都会执行这一行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前进程fork()的返回值: %d\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid = %d, number = %d\n&quot;</span>, getpid(), ++number);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程的父进程(终端进程), pid = %d\n&quot;</span>, getppid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        number += <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid = %d, number = %d\n&quot;</span>, getpid(), number);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程的父进程, pid = %d\n&quot;</span>, getppid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译程序并测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ gcc number.c</span><br><span class="line">$ ./a.out </span><br><span class="line">创建子进程之前 number = 10</span><br><span class="line">当前进程fork()的返回值: 3513</span><br><span class="line">当前进程fork()的返回值: 0</span><br><span class="line">我是子进程, pid = 3513, number = 110</span><br><span class="line">子进程的父进程, pid = 3512</span><br><span class="line"></span><br><span class="line">我是父进程, pid = 3512, number = 11</span><br><span class="line"><span class="comment">#没有接着子进程的110继续数,父子进程各玩各的,测试失败</span></span><br><span class="line">父进程的父进程(终端进程), pid = 2175</span><br></pre></td></tr></table></figure><blockquote><p>通过验证得到结论：两个进程中是不能通过全局变量实现数据交互的<br>因为每个进程都有自己的地址空间，两个同名全局变量存储在不同的虚拟地址空间中，二者没有任何关联性。<br>如果要进行进程间通信需要使用：管道，共享内存，本地套接字，内存映射区，消息队列等方式。</p></blockquote><hr><h2 id="1-4-execl和execlp函数"><a href="#1-4-execl和execlp函数" class="headerlink" title="1.4 execl和execlp函数"></a>1.4 execl和execlp函数</h2><p>在项目开发过程中，有时候有这种需求，需要通过现在运行的进程启动磁盘上的另一个可执行程序，也就是通过一个进程启动另一个进程，这种情况下我们可以使用 <code>exec族函数</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">          <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">           <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">           <span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">            <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure><p><code>这些函数执行成功后不会返回</code>，因为调用进程的实体，包括<code>代码段</code>，<code>数据段</code>和<code>堆栈</code>等都已经被新的内容取代（也就是说用户区数据基本全部被替换掉了），只留下进程ID等一些表面上的信息仍保持原样.<br>只有调用失败了，它们才会返回一个 -1，从原程序的调用点接着往下执行。</p><blockquote><p>也就是说exec族函数并没有创建新进程的能力<br>让启动的新进程寄生到自己虚拟地址空间之内，并挖空了自己的地址空间用户区，把新启动的进程数据填充进去。</p></blockquote><p>exec族函数中最常用的有两个<code>execl()</code>和<code>execlp()</code>，这两个函数是对其他4个函数做了进一步的封装，介绍一下。</p><hr><h3 id="1-4-1-execl"><a href="#1-4-1-execl" class="headerlink" title="1.4.1 execl()"></a>1.4.1 execl()</h3><p>该函数可用于执行任意一个可执行程序，<code>函数需要通过指定的文件路径才能找到这个可执行程序。</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 变参函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li><code>path</code>: 要启动的可执行程序的路径, 推荐使用绝对路径</li><li><code>arg</code>: ps aux 查看进程的时候, 启动的进程的名字, 可以随意指定, 一般和要启动的可执行程序名相同</li><li><code>...</code>: 要执行的命令需要的参数，可以写多个，最后以 NULL 结尾，表示参数指定完了。</li></ul></li><li>返回值：如果这个函数执行成功, 没有返回值，如果执行失败, 返回 -1</li></ul><hr><h3 id="1-4-2-execlp"><a href="#1-4-2-execlp" class="headerlink" title="1.4.2 execlp()"></a>1.4.2 execlp()</h3><p>该函数常用于执行已经设置了环境变量的可执行程序，函数中的 <code>p</code> 就是<code>path</code>，也是说这个函数会自动搜索系统的环境变量<code>PATH</code><br>因此使用这个函数执行可执行程序不需要指定路径，只需要指定出名字即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p == path</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li><code>file</code>: 可执行程序的名字<ul><li>在环境变量PATH中，可执行程序可以不加路径</li><li>没有在环境变量PATH中, 可执行程序需要指定绝对路径</li></ul></li><li><code>arg</code>: ps aux 查看进程的时候, 启动的进程的名字, 可以随意指定, 一般和要启动的可执行程序名相同</li><li><code>...</code>: 要执行的命令需要的参数，可以写多个，最后以 NULL 结尾，表示参数指定完了。</li></ul></li><li>返回值：如果这个函数执行成功, 没有返回值，如果执行失败, 返回 -1</li></ul><hr><h3 id="1-4-3-函数的使用"><a href="#1-4-3-函数的使用" class="headerlink" title="1.4.3 函数的使用"></a>1.4.3 函数的使用</h3><p>一般不会在进程中直接调用，如果直接调用这个进程的代码区代码被替换也就不能按照原来的流程工作了。<br><code>一般在调用这些函数的时候都会先创建一个子进程，在子进程中调用 exec 族函数，子进程的用户区数据被替换掉开始执行新的程序中的代码逻辑，但是父进程不受任何影响仍然可以继续正常工作。</code></p><p>execl() 或者 execlp() 函数的使用方法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="comment">// 在子进程中执行磁盘上的可执行程序</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 磁盘上的可执行程序 /bin/ps</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">        execl(<span class="string">&quot;/bin/ps&quot;</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 也可以这么写</span></span><br><span class="line">        <span class="comment">// execl(&quot;/bin/ps&quot;, &quot;title&quot;, &quot;a&quot;, &quot;u&quot;, &quot;x&quot;, NULL);  </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 也可以这么写</span></span><br><span class="line">        <span class="comment">// execl(&quot;ps&quot;, &quot;title&quot;, &quot;a&quot;, &quot;u&quot;, &quot;x&quot;, NULL);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 如果成功,当前子进程的代码区被ps中的代码区代码替换</span></span><br><span class="line">        <span class="comment">// 下面的所有代码都不会执行</span></span><br><span class="line">        <span class="comment">// 如果函数调用失败了,才会继续执行下面的代码</span></span><br><span class="line">        perror(<span class="string">&quot;execl&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++++++++++++++++++++++++\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++++++++++++++++++++++++\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++++++++++++++++++++++++\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++++++++++++++++++++++++\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++++++++++++++++++++++++\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++++++++++++++++++++++++\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程.....\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/9.8.png" alt="在这里插入图片描述"></p><hr><h2 id="1-5-进程控制"><a href="#1-5-进程控制" class="headerlink" title="1.5  进程控制"></a>1.5  进程控制</h2><p>进程控制主要是指<code>进程的退出</code>, <code>进程的回收</code>和进程的特殊状态 <code>孤儿进程</code>和<code>僵尸进程</code>。</p><h3 id="1-5-1-结束进程"><a href="#1-5-1-结束进程" class="headerlink" title="1.5.1 结束进程"></a>1.5.1 结束进程</h3><p>想要直接退出某个进程可以在程序的任何位置调用<code>exit()</code>或者<code>_exit()</code>函数。<br>函数的参数相当于退出码, 如果参数值为 0 程序退出之后的状态码就是0, 如果是100退出的状态码就是100。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 专门退出进程的函数, 在任何位置调用都可以</span></span><br><span class="line"><span class="comment">// 标准C库函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux的系统函数</span></span><br><span class="line"><span class="comment">// 可以这么理解, 在linux中 exit() 函数 封装了 _exit()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure><p>在 main 函数中直接使用 <code>return</code> 也可以退出进程,<br>假如是在一个普通函数中调用 return 只能返回到调用者的位置，而不能退出进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ***** return 必须要在main()函数中调用, 才能退出进程 *****</span></span><br><span class="line"><span class="comment">// 举例:</span></span><br><span class="line"><span class="comment">// 没有问题的例子</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 进程退出了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////// 不能退出的例子 //////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">666</span>;<span class="comment">// 返回到调用者调用该函数的位置, 返回到 main() 函数的第19行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用这个函数, 当前进程不能退出</span></span><br><span class="line">    <span class="type">int</span> ret = func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-5-2-孤儿进程"><a href="#1-5-2-孤儿进程" class="headerlink" title="1.5.2 孤儿进程"></a>1.5.2 孤儿进程</h3><p>在一个启动的进程中创建子进程，这时候父子进程同时运行，但是父进程由于某种原因先退出了，子进程还在运行，这时候这个子进程就可以被称之为孤儿进程。</p><p>操作系统是非常关爱运行的每一个进程的，当检测到某一个进程变成了孤儿进程，这时候系统中就会有一个固定的进程领养这个孤儿进程。<br>如果使用Linux没有桌面终端，这个领养孤儿进程的进程就是 init 进程（PID&#x3D;1）<br>如果有桌面终端，这个领养孤儿进程就是桌面进程。</p><p>那么问题来了，系统为什么要领养这个孤儿进程呢？<br><code>在子进程退出的时候, 进程中的用户区可以自己释放, 但是进程内核区的pcb资源自己无法释放，必须要由父进程来释放子进程的pcb资源，孤儿进程被领养之后，这件事爹就可以代劳，避免系统资源的浪费。</code></p><p>下面这段代码就可以得到一个孤儿进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);<span class="comment">// 强迫子进程睡眠1s, 这个期间, 父进程退出, 当前进程变成了孤儿进程</span></span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 程序输出的结果</span></span><br><span class="line">$ ./a.out </span><br><span class="line">我是父进程, pid=22459</span><br><span class="line">我是子进程, pid=22460, 父进程ID: 1<span class="comment"># 父进程向退出, 子进程变成孤儿进程, 子进程被1号进程回收</span></span><br></pre></td></tr></table></figure><hr><h3 id="1-5-3-僵尸进程"><a href="#1-5-3-僵尸进程" class="headerlink" title="1.5.3 僵尸进程"></a>1.5.3 僵尸进程</h3><p>在一个启动的进程中创建子进程，这时候就有了父子两个进程，父进程正常运行, 子进程先与父进程结束, 子进程无法释放自己的PCB资源, 需要父进程来做这个件事儿, 但是如果父进程也不管, 这时候子进程就变成了僵尸进程。</p><blockquote><p>僵尸进程不能将它看成是一个正常的进程，这个进程已经死亡，用户区资源已经被释放，只是还占用一些内核资源（PCB）。</p></blockquote><p>运行下面的代码就可以得到一个僵尸进程了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 需要保证父进程一直在运行</span></span><br><span class="line">        <span class="comment">// 一直运行不退出, 并且也做回收, 就会出现僵尸进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程, 执行这句代码之后, 子进程退出了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ps aux 查看进程信息</span></span><br><span class="line"><span class="comment"># Z+ --&gt; 这个进程是僵尸进程, defunct, 表示进程已经死亡</span></span><br><span class="line">robin     22598  0.0  0.0   4352   624 pts/2    S+   10:11   0:00 ./app</span><br><span class="line">robin     22599  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] &lt;defunct&gt; <span class="comment"># 子进程</span></span><br><span class="line">robin     22600  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] &lt;defunct&gt; <span class="comment"># 子进程</span></span><br><span class="line">robin     22601  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] &lt;defunct&gt; <span class="comment"># 子进程</span></span><br><span class="line">robin     22602  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] &lt;defunct&gt; <span class="comment"># 子进程</span></span><br><span class="line">robin     22603  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] &lt;defunct&gt; <span class="comment"># 子进程</span></span><br></pre></td></tr></table></figure><blockquote><p>消灭僵尸进程的方法是杀死这个僵尸进程的父进程，这样僵尸进程的资源就被系统回收了.<br><code>kill -9僵尸进程PID的方式是不能消灭僵尸进程的</code>，这个命令只对活着的进程有效，僵尸进程已经死了，鞭尸是不能解决问题的。</p></blockquote><hr><h3 id="1-5-4-进程回收"><a href="#1-5-4-进程回收" class="headerlink" title="1.5.4 进程回收"></a>1.5.4 进程回收</h3><p>为了避免僵尸进程的产生，一般我们会在父进程中进行子进程的资源回收<br>回收方式有两种，一种是阻塞方式<code>wait()</code>，一种是非阻塞方式<code>waitpid()</code>。</p><h4 id="1-5-4-1-wait"><a href="#1-5-4-1-wait" class="headerlink" title="1.5.4.1 wait()"></a>1.5.4.1 wait()</h4><p>这是个阻塞函数，如果没有子进程退出, 函数会一直阻塞等待<br>当检测到子进程退出了, 该函数阻塞解除回收子进程资源。<br>这个函数被调用一次, 只能回收一个子进程的资源，如有多个子进程需要资源回收, 函数需被调用多次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">// man 2 wait</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：传出参数，通过传递出的信息判断回收的进程是怎么退出的，如果不需要该信息可以指定为 NULL。取出整形变量中的数据需要使用一些宏函数，具体操作方式如下：<ul><li><code>WIFEXITED(status)</code>: 返回1, 进程是正常退出的</li><li><code>WEXITSTATUS(status)</code>：得到进程退出时候的状态码，相当于 return 后边的数值, 或者 exit()函数的参数</li><li><code>WIFSIGNALED(status)</code>: 返回1, 进程是被信号杀死了</li><li><code>WTERMSIG(status)</code>: 获得进程是被哪个信号杀死的，会得到信号的编号</li></ul></li><li>返回值:<ul><li>成功：返回被回收的子进程的进程ID</li><li>失败: -1<ul><li>没有子进程资源可以回收了, 函数的阻塞会自动解除, 返回-1</li><li>回收子进程资源的时候出现了异常</li></ul></li></ul></li></ul><p>下面代码演示了如何通过 wait()回收多个子进程资源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait 函数回收子进程资源</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 需要保证父进程一直在运行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 回收子进程的资源</span></span><br><span class="line">            <span class="comment">// 子进程由多个, 需要循环回收子进程资源</span></span><br><span class="line">            <span class="type">pid_t</span> ret = wait(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;成功回收了子进程资源, 子进程PID: %d\n&quot;</span>, ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;回收失败, 或者是已经没有子进程了...\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程, 执行这句代码之后, 子进程退出了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="1-5-4-2-waitpid"><a href="#1-5-4-2-waitpid" class="headerlink" title="1.5.4.2 waitpid()"></a>1.5.4.2 waitpid()</h4><p>waitpid() 函数可以看做是 wait() 函数的升级版，通过该函数可以控制回收子进程资源的方式是阻塞还是非阻塞，另外还可以通过该函数进行精准打击，可以精确指定回收某个或者某一类或者是全部子进程资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">// man 2 waitpid</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">// 这个函数可以设置阻塞, 也可以设置为非阻塞</span></span><br><span class="line"><span class="comment">// 这个函数可以指定回收哪些子进程的资源</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li><p>pid:</p><ul><li>-1：回收所有的子进程资源, 和wait()是一样的, 无差别回收，并不是一次性就可以回收多个, 也是需要循环回收的</li><li>大于0：指定回收某一个进程的资源 ，pid是要回收的子进程的进程ID</li><li>0：回收当前进程组的所有子进程ID</li><li>小于 -1：pid 的绝对值代表进程组ID，表示要回收这个进程组的所有子进程资源</li></ul></li><li><p>status: NULL, 和wait的参数是一样的</p></li><li><p>options: 控制函数是阻塞还是非阻塞</p><ul><li>0: 函数行为是阻塞的 &#x3D;&#x3D;&gt; 和wait一样</li><li>WNOHANG: 函数行为是非阻塞的</li></ul></li></ul></li><li>返回值<ul><li>如果函数是非阻塞的, 并且子进程还在运行, 返回0</li><li>成功: 得到子进程的进程ID</li><li>失败: -1<ul><li>没有子进程资源可以回收了, 函数如果是阻塞的, 阻塞会解除, 直接返回-1</li><li>回收子进程资源的时候出现了异常</li></ul></li></ul></li></ul><p>下面代码演示了如何通过 <code>waitpid()</code>阻塞回收多个子进程资源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和wait() 行为一样, 阻塞</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 需要保证父进程一直在运行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 回收子进程的资源</span></span><br><span class="line">            <span class="comment">// 子进程由多个, 需要循环回收子进程资源</span></span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="type">pid_t</span> ret = waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>);  <span class="comment">// == wait(NULL);</span></span><br><span class="line">            <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;成功回收了子进程资源, 子进程PID: %d\n&quot;</span>, ret);</span><br><span class="line">                                <span class="comment">// 判断进程是不是正常退出</span></span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;子进程退出时候的状态码: %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;子进程是被这个信号杀死的: %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;回收失败, 或者是已经没有子进程了...\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程, 执行这句代码之后, 子进程退出了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;===我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面代码演示了如何通过 <code>waitpid()</code>非阻塞回收多个子进程资源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非阻塞处理</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 需要保证父进程一直在运行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 回收子进程的资源</span></span><br><span class="line">            <span class="comment">// 子进程由多个, 需要循环回收子进程资源</span></span><br><span class="line">            <span class="comment">// 子进程退出了就回收, </span></span><br><span class="line">            <span class="comment">// 没退出就不回收, 返回0</span></span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="type">pid_t</span> ret = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG);  <span class="comment">// 非阻塞</span></span><br><span class="line">            <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;成功回收了子进程资源, 子进程PID: %d\n&quot;</span>, ret);</span><br><span class="line">                <span class="comment">// 判断进程是不是正常退出</span></span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;子进程退出时候的状态码: %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;子进程是被这个信号杀死的: %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;子进程还没有退出, 不做任何处理...\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;回收失败, 或者是已经没有子进程了...\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid=%d\n&quot;</span>, getpid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程, 执行这句代码之后, 子进程退出了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;===我是子进程, pid=%d, 父进程ID: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="2-管道"><a href="#2-管道" class="headerlink" title="2. 管道"></a>2. 管道</h1><h2 id="2-1-管道"><a href="#2-1-管道" class="headerlink" title="2.1 管道"></a>2.1 管道</h2><p>管道的是进程间通信（IPC - InterProcess Communication）的一种方式，管道的本质其实就是内核中的一块内存(或者叫内核缓冲区)<br>这块缓冲区中的数据存储在一个环形队列中，因为管道在内核里边，因此我们不能直接对其进行任何操作。<br><img src="/img/9.9.png" alt="在这里插入图片描述"></p><p>因为管道数据是通过队列来维护的，我们先来分析一个管道中数据的特点：</p><ul><li><p>管道对应的内核缓冲区大小是固定的，默认为4k（也就是队列最大能存储4k数据）</p></li><li><p>管道分为两部分：读端和写端（队列的两端），数据从写端进入管道，从读端流出管道。</p></li><li><p>管道中的数据只能读一次，做一次读操作之后数据也就没有了（读数据相当于出队列）。</p></li><li><p>管道是单工的：数据只能单向流动, 数据从写端流向读端。</p></li><li><p>对管道的操作（读、写）默认是阻塞的</p><ul><li>读管道：管道中没有数据，读操作被阻塞，当管道中有数据之后阻塞才能解除</li><li>写管道：管道被写满了，写数据的操作被阻塞，当管道变为不满的状态，写阻塞解除</li></ul></li></ul><p>管道在内核中, 不能直接对其进行操作，通过什么方式去读写管道呢？<br>其实管道操作就是文件IO操作，内核中管道的两端分别对应两个文件描述符<br>通过写端的文件描述符把数据写入到管道中，通过读端的文件描述符将数据从管道中读出来。<br>读写管道的函数就是Linux中的文件IO函数 read&#x2F;write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读管道</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="comment">// 写管道的函数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>分析一下为什么可以使用管道进行进程间通信，看一下图片：<br><img src="/img/9.10.png" alt="在这里插入图片描述"></p><p>在上图中假设父进程一系列操作:可以通过文件描述符表中的文件描述符fd3写管道，通过fd4读管道，然后再<code>通过 fork() 创建出子进程，那么在父进程中被分配的文件描述符 fd3， fd4也就被拷贝到子进程中，子进程通过 fd3可以将数据写入到内核的管道中，通过fd4将数据从管道中读出来。</code></p><p>也就是说管道是独立于任何进程的，并且充当了两个进程用于数据通信的载体，只要两个进程能够得到同一个管道的入口和出口（读端和写端的文件描述符），那么他们之间就可以通过管道进行数据的交互。</p><hr><h2 id="2-2-匿名管道"><a href="#2-2-匿名管道" class="headerlink" title="2.2 匿名管道"></a>2.2 匿名管道</h2><h3 id="2-2-1-创建匿名管道"><a href="#2-2-1-创建匿名管道" class="headerlink" title="2.2.1 创建匿名管道"></a>2.2.1 创建匿名管道</h3><p>匿名管道是管道的一种，既然是匿名也就是说这个管道没有名字，但其本质不变，就是位于内核中的一块内存，匿名管道拥有上面介绍的管道的所有特性<br>额外我们需知,匿名管道只能实现有血缘关系的进程间通信,如：父子进程，兄弟进程，爷孙进程，叔侄进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建匿名函数的函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个匿名的管道, 得到两个可用的文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：传出参数，需要传递一个整形数组的地址，数组大小为 2，也就是说最终会传出两个元素<ul><li><code>pipefd[0]: 对应管道读端的文件描述符，通过它可以将数据从管道中读出</code></li><li><code>pipefd[1]: 对应管道写端的文件描述符，通过它可以将数据写入到管道中</code></li></ul></li><li>返回值：成功返回 0，失败返回 -1</li></ul><hr><h3 id="2-2-2-进程间通信"><a href="#2-2-2-进程间通信" class="headerlink" title="2.2.2 进程间通信"></a>2.2.2 进程间通信</h3><p>使用匿名管道只能够实现有血缘关系的进程间通信，要求写一段程序完成下边的功能：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">需求描述:</span><br><span class="line">   在父进程中创建一个子进程, 父子进程分别执行不同的操作:</span><br><span class="line">     - 子进程: 执行一个shell命令 <span class="string">&quot;ps aux&quot;</span>, 将命令的结果传递给父进程</span><br><span class="line">     - 父进程: 将子进程命令的结果输出到终端</span><br></pre></td></tr></table></figure><p>需求分析:</p><ul><li>子进程中执行shell命令相当于启动一个磁盘程序，因此需要使用 execl()&#x2F;execlp()函数<ul><li>execlp(“ps”, “ps”, “aux”, NULL)</li></ul></li><li>子进程中执行完shell命令直接就可以在终端输出结果，如果将这些信息传递给父进程呢？<ul><li>数据传递需要使用管道，子进程需要将数据写入到管道中</li><li>将默认输出到终端的数据写入到管道就需要进行输出的重定向，需要使用 <code>dup2()</code> 做这件事情<ul><li><code>dup2(fd[1], STDOUT_FILENO);</code></li></ul></li></ul></li><li>父进程需要读管道，将从管道中读出的数据打印到终端</li><li>父进程最后需要释放子进程资源，防止出现僵尸进程</li></ul><p>在使用管道进行进程间通信的注意事项：<code>必须要保证数据在管道中的单向流动</code>。<br>这句话怎么理解呢，通过下面的图来分析一下：</p><blockquote><p>第一步: 在父进程中创建了匿名管道，得到了两个分配的文件描述符，fd3操作管道的读端，fd4操作管道的写端。</p></blockquote><p><img src="/img/9.11.png" alt="在这里插入图片描述"></p><blockquote><p>第二步：父进程创建子进程，父进程的文件描述符被拷贝，在子进程的文件描述符表中也得到了两个被分配的可以使用的文件描述符，通过fd3读管道，通过fd4写管道。通过下图可以看到管道中数据的流动不是单向的，有以下这么几种情况：</p><p>父进程通过fd4将数据写入管道，然后父进程再通过fd3将数据从管道中读出<br>父进程通过fd4将数据写入管道，然后子进程再通过fd3将数据从管道中读出<br>子进程通过fd4将数据写入管道，然后子进程再通过fd3将数据从管道中读出<br>子进程通过fd4将数据写入管道，然后父进程再通过fd3将数据从管道中读出<br>前边说到过，管道行为默认是阻塞的，假设子进程通过写端将数据写入管道，父进程的读端将数据读出，这样子进程的读端就读不到数据，导致子进程阻塞在读管道的操作上，这样就会给程序的执行造成一些不必要的影响。<br>如果我们本来也没有打算让进程读或者写管道，那么就可以将进程操作的读端或者写端关闭。</p></blockquote><p><img src="/img/9.12.png" alt="在这里插入图片描述"></p><blockquote><p>第三步：为了避免两个进程都读管道，但是可能其中某个进程由于读不到数据而阻塞的情况，我们可以关闭进程中用不到的那一端的文件描述符，这样数据就只能单向的从一端流向另外一端了，如下图，我们关闭了父进程的写端，关闭了子进程的读端：</p></blockquote><p><img src="/img/9.13.png" alt="在这里插入图片描述"></p><p>根据上面的分析，最终可以写出下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管道的数据是单向流动的:</span></span><br><span class="line"><span class="comment">// 操作管道的是两个进程, 进程A读管道, 需要关闭管道的写端, 进程B写管道, 需要关闭管道的读端</span></span><br><span class="line"><span class="comment">// 如果不做上述的操作, 会对程序的结果造成一些影响, 对管道的操作无法结束</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建匿名管道, 得到两个文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 创建子进程 -&gt; 能够操作管道的文件描述符被复制到子进程中</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 3. 在子进程中执行 execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL);</span></span><br><span class="line">        <span class="comment">// 在子进程中完成输出的重定向, 原来输出到终端现在要写管道</span></span><br><span class="line">        <span class="comment">// 进程打印数据默认输出到终端, 终端对应的文件描述符: stdout_fileno</span></span><br><span class="line">        <span class="comment">// 标准输出 重定向到 管道的写端</span></span><br><span class="line">        dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 父进程读管道</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 关闭管道的写端</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 5. 父进程打印读到的数据信息</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">        <span class="comment">// 读管道</span></span><br><span class="line">        <span class="comment">// 如果管道中没有数据, read会阻塞</span></span><br><span class="line">        <span class="comment">// 有数据之后, read解除阻塞, 直接读数据</span></span><br><span class="line">        <span class="comment">// 需要循环读数据, 管道是有容量的, 写满之后就不写了</span></span><br><span class="line">        <span class="comment">// 数据被读走之后, 继续写管道, 那么就需要再继续读数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="type">int</span> len = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 管道的写端关闭了, 如果管道中没有数据, 管道读端不会阻塞</span></span><br><span class="line">                <span class="comment">// 没数据直接返回0, 如果有数据, 将数据读出, 数据读完之后返回0</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s, len = %d\n&quot;</span>, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回收子进程资源</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-3-有名管道"><a href="#2-3-有名管道" class="headerlink" title="2.3 有名管道"></a>2.3 有名管道</h2><h3 id="2-3-1-创建有名管道"><a href="#2-3-1-创建有名管道" class="headerlink" title="2.3.1 创建有名管道"></a>2.3.1 创建有名管道</h3><p>有名管道拥有管道的所有特性，之所以称为有名是因管道在磁盘上有实体文件, 文件类型为<code>p</code> ，<code>有名管道文件大小永为0，因有名管道是将数据存储到内存的缓冲区中，打开这个磁盘上的管道文件就可以得到操作有名管道的文件描述符，通过文件描述符读写管道存储在内核中的数据。</code></p><p>有名管道也可称为 <code>fifo (first in first out)</code>，有名管道既可进行有血缘关系的进程间通信，也可进行没有血缘关系的进程间通信。<br>创建有名管道的方式有两种，一种是通过命令，一种是通过函数。</p><ul><li>通过命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkfifo</span> 有名管道的名字</span><br></pre></td></tr></table></figure><ul><li>通过函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="comment">// int open(const char *pathname, int flags, mode_t mode);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>pathname: 要创建的有名管道的名字</li><li>mode: 文件的操作权限, 和open()的第三个参数一个作用，最终权限: <code>(mode &amp; ~umask)</code></li></ul></li><li>返回值：创建成功返回 0，失败返回 -1</li></ul><hr><h3 id="2-3-2-进程间通信"><a href="#2-3-2-进程间通信" class="headerlink" title="2.3.2 进程间通信"></a>2.3.2 进程间通信</h3><p>不管有血缘关系还是没血缘关系，使用有名管道实现进程间通信的方式是相同的<br>就是在两个进程中分别以读、写的方式打开磁盘上的管道文件<br>得到用于读管道、写管道的文件描述符，就可调用对应的read()、write()函数进行读写操作了。</p><blockquote><p>有名管道操作需要通过 open() 操作得到读写管道的文件描述符，如果只是读端打开了或者只是写端打开了，进程会阻塞在这里不会向下执行<br>直到在另一个进程中将管道的对端打开，当前进程的阻塞也就解除了。<br>所以当发现进程阻塞在了open()函数上不要感到惊讶。·</p></blockquote><ul><li>写管道的进程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 创建有名管道文件 </span><br><span class="line">mkfifo()</span><br><span class="line"><span class="number">2.</span> 打开有名管道文件, 打开方式是 o_wronly</span><br><span class="line"><span class="type">int</span> wfd = open(<span class="string">&quot;xx&quot;</span>, O_WRONLY);</span><br><span class="line"><span class="number">3.</span> 调用write函数写文件 ==&gt; 数据被写入管道中</span><br><span class="line">write(wfd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line"><span class="number">4.</span> 写完之后关闭文件描述符</span><br><span class="line">close(wfd);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建有名管道文件</span></span><br><span class="line">    <span class="type">int</span> ret = mkfifo(<span class="string">&quot;./testfifo&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;管道文件创建成功...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 打开管道文件</span></span><br><span class="line">    <span class="comment">// 因为要写管道, 所有打开方式, 应该指定为 O_WRONLY</span></span><br><span class="line">    <span class="comment">// 如果先打开写端, 读端还没有打开, open函数会阻塞, 当读端也打开之后, open解除阻塞</span></span><br><span class="line">    <span class="type">int</span> wfd = open(<span class="string">&quot;./testfifo&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(wfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;以只写的方式打开文件成功...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 循环写管道</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, fifo, 我在写管道...%d\n&quot;</span>, i);</span><br><span class="line">        write(wfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        i++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(wfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>读管道的进程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 这两个进程需要操作相同的管道文件</span><br><span class="line"><span class="number">2.</span> 打开有名管道文件, 打开方式是 o_rdonly</span><br><span class="line"><span class="type">int</span> rfd = open(<span class="string">&quot;xx&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="number">3.</span> 调用read函数读文件 ==&gt; 读管道中的数据</span><br><span class="line"><span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">read(rfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="number">4.</span> 读完之后关闭文件描述符</span><br><span class="line">close(rfd);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开管道文件</span></span><br><span class="line">    <span class="comment">// 因为要read管道, so打开方式, 应该指定为 O_RDONLY</span></span><br><span class="line">    <span class="comment">// 如果只打开了读端, 写端还没有打开, open阻塞, 当写端被打开, 阻塞就解除了</span></span><br><span class="line">    <span class="type">int</span> rfd = open(<span class="string">&quot;./testfifo&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(rfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;以只读的方式打开文件成功...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 循环读管道</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">// 读是阻塞的, 如果管道中没有数据, read自动阻塞</span></span><br><span class="line">        <span class="comment">// 有数据解除阻塞, 继续读数据</span></span><br><span class="line">        <span class="type">int</span> len = read(rfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;读出的数据: %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 写端关闭了, read解除阻塞返回0</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;管道的写端已经关闭, 拜拜...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(rfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-4-管道的读写行为"><a href="#2-4-管道的读写行为" class="headerlink" title="2.4 管道的读写行为"></a>2.4 管道的读写行为</h2><p>关于管道不管是有名的还是匿名，在读写时，它们表现出的行为是一致的<br>下面是对其读写行为的总结:</p><ul><li>读管道，需要根据写端的状态进行分析：<ul><li>写端没有关闭 (操作管道写端的文件描述符没有被关闭)<ul><li>如果管道中没有数据 &#x3D;&#x3D;&gt; 读阻塞, 如果管道中被写入了数据, 阻塞解除</li><li>如果管道中有数据 &#x3D;&#x3D;&gt; 不阻塞，管道中的数据被读完了, 再继续读管道还会阻塞</li></ul></li><li>写端已经关闭了 (没有可用的文件描述符可以写管道了)<ul><li>管道中没有数据 &#x3D;&#x3D;&gt; 读端解除阻塞, read函数返回0</li><li>管道中有数据 &#x3D;&#x3D;&gt; read先将数据读出, 数据读完之后返回0, 不会阻塞了</li></ul></li></ul></li><li>写管道，需要根据读端的状态进行分析：<ul><li>读端没有关闭<ul><li>如果管道有存储的空间, 一直写数据</li><li>如果管道写满了, 写操作就阻塞, 当读端将管道数据读走了, 解除阻塞继续写</li></ul></li><li>读端关闭了，管道破裂(异常), 进程直接退出</li></ul></li></ul><blockquote><p>管道的两端默认是阻塞的，如何将管道设置为非阻塞呢？<br>管道的读写两端的非阻塞操作是相同的，下面的代码中将匿名的读端设置为了非阻塞：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过fcntl 修改就可以, 一般情况下不建议修改</span></span><br><span class="line"><span class="comment">// 管道操作对应两个文件描述符, 分别是管道的读端 和 写端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取读端的文件描述符的flag属性</span></span><br><span class="line"><span class="type">int</span> flag = fcntl(fd[<span class="number">0</span>], F_GETFL);</span><br><span class="line"><span class="comment">// 2. 添加非阻塞属性到 flag中</span></span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line"><span class="comment">// 3. 将新的flag属性设置给读端的文件描述符</span></span><br><span class="line">fcntl(fd[<span class="number">0</span>], F_SETFL, flag);</span><br><span class="line"><span class="comment">// 4. 非阻塞读管道</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br></pre></td></tr></table></figure><hr><h1 id="3-内存映射-mmap"><a href="#3-内存映射-mmap" class="headerlink" title="3. 内存映射(mmap)"></a>3. 内存映射(mmap)</h1><h2 id="3-1-创建内存映射区"><a href="#3-1-创建内存映射区" class="headerlink" title="3.1 创建内存映射区"></a>3.1 创建内存映射区</h2><p>想要实现进程间通信，可通过函数创建一块内存映射区<br>和管道不同的是管道对应的内存空间在<code>内核</code>中，而内存映射区对应的内存空间在进程的<code>用户区</code>（用于加载动态库的那个区域）<br>也就是说<code>进程间通信使用的内存映射区不是一块，而是在每个进程内部都有一块。</code></p><p>由于每个进程的地址空间是独立的，各个进程之间也不能直接访问对方的内存映射区，要通信的进程需将各自的内存映射区和同一个磁盘文件进行映射，这样进程之间就可以通过磁盘文件这个唯一的桥梁完成数据的交互了。<br><img src="/img/9.14.png" alt="在这里插入图片描述"></p><p>如上图所示：<br><code>磁盘文件数据可完全加载到进程的内存映射区也可部分加载到进程的内存映射区，当进程A中的内存映射区数据被修改了，数据会被自动同步到磁盘文件，同时和磁盘文件建立映射关系的其他进程内存映射区中的数据也会和磁盘文件进行数据的实时同步，这个同步机制保障了各进程间的数据共享。</code></p><p>使用内存映射区既可以进程有血缘关系的进程间通信也可以进程没有血缘关系的进程间通信。<br>创建内存映射区的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建内存映射区</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li><p>addr: 从动态库加载区的什么位置开始创建内存映射区，一般定为NULL, 委托内核分配</p></li><li><p>length: 创建的内存映射区的大小(byte)，实际上这个大小是按4k的整数倍去分配的</p></li><li><p>prot: 对内存映射区的操作权限</p><ul><li>PROT_READ: 读内存映射区</li><li>PROT_WRITE: 写内存映射区</li><li>如果要对映射区有读写权限: PROT_READ | PROT_WRITE</li></ul></li><li><p>flags:</p><ul><li>MAP_SHARED: 多个进程可以共享数据，进行映射区数据同步</li><li>MAP_PRIVATE: 映射区数据是私有的，不能同步给其他进程</li></ul></li><li><p>fd: 文件描述符, 对应一个打开的磁盘文件，内存映射区通过这个文件描述符和磁盘文件建立关联</p></li><li><p>offset: 磁盘文件的偏移量，文件从偏移到的位置开始进行数据映射<br>  使用这个参数需要注意两个问题：</p><ul><li>偏移量必须是4k的整数倍, 写0代表不偏移</li><li>这个参数必须大于 0</li></ul></li></ul></li><li>返回值:<ul><li>成功: 返回一个内存映射区的起始地址</li><li>失败: <code>MAP_FAILED</code>(that is, (void *) -1)</li></ul></li></ul><blockquote><p>mmap() 函数的参数较多，在使用该函数创建用于进程间通信的内存映射区的时候，各参数的指定有一些注意事项</p><ol><li>第一个参数 addr 指定为 <code>NULL</code> 即可</li><li>第二个参数 length 必须要 &gt; 0</li><li>第三个参数 prot，进程间通信需要对内存映射区有读写权限，因此需要指定为：<br>PROT_READ | PROT_WRITE</li><li>第四个参数 flags，如果要进行进程间通信, 需要指定 MAP_SHARED</li><li>第五个参数 fd，打开的文件必须大于0，进程间通信需要文件操作权限和映射区操作权限相同<ul><li>内存映射区创建成功之后, 关闭这个文件描述符不会影响进程间通信</li></ul></li><li>第六个参数 offset，不偏移指定为0，如果偏移必须是4k的整数倍</li></ol></blockquote><p>内存映射区使用完之后也需要释放，释放函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>addr: mmap()的返回值, 创建的内存映射区的起始地址</li><li>length: 和mmap()第二个参数相同即可</li></ul></li><li>返回值：函数调用成功返回 0，失败返回 -1</li></ul><hr><h2 id="3-2-进程间通信"><a href="#3-2-进程间通信" class="headerlink" title="3.2 进程间通信"></a>3.2 进程间通信</h2><p>操作内存映射区和操作管道是不一样的，<br>内存映射区是直接对内存地址进行操作,管道是通过文件描述符读写队列中的数据<br>管道的读写是阻塞的，内存映射区的读写是非阻塞的。</p><h3 id="3-2-1-有血缘关系"><a href="#3-2-1-有血缘关系" class="headerlink" title="3.2.1 有血缘关系"></a>3.2.1 有血缘关系</h3><p>由于创建子进程会发生虚拟地址空间的复制，那么在父进程中创建的内存映射区也会被复制到子进程中，这样在子进程里边就可以直接使用这块内存映射区了，所以对于有血缘关系的进程，进行进程间通信是非常简单的，处理代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  先创建内存映射区, 得到一个起始地址, 假设使用ptr指针保存这个地址</span><br><span class="line"><span class="number">2.</span>  通过fork()创建子进程-&gt;子进程中也就有一个内存映射区, 子进程中也有一个ptr指针指向这个地址</span><br><span class="line"><span class="number">3.</span>  父进程往自己的内存映射区写数据, 数据同步到了磁盘文件中</span><br><span class="line">磁盘文件数据又同步到子进程的映射区中</span><br><span class="line">子进程从自己的映射区往外读数据, 这个数据就是父进程写的</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开一个磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">// 2. 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span>* ptr = mmap(<span class="literal">NULL</span>, <span class="number">4000</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">                     MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程, 写数据</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* pt = <span class="string">&quot;我你爹, 你我儿?&quot;</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(ptr, pt, <span class="built_in">strlen</span>(pt)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程, 读数据</span></span><br><span class="line">        usleep(<span class="number">1</span>);<span class="comment">// 内存映射区不阻塞, 为了让子进程读出数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从映射区读出的数据: %s\n&quot;</span>, (<span class="type">char</span>*)ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存映射区</span></span><br><span class="line">    munmap(ptr, <span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-2-没有血缘关系"><a href="#3-2-2-没有血缘关系" class="headerlink" title="3.2.2 没有血缘关系"></a>3.2.2 没有血缘关系</h3><p>对于没有血缘关系的进程间通信，需要在每个进程中分别创建内存映射区，但是这些进程的内存映射区必须要关联相同的磁盘文件，这样才能实现进程间的数据同步。</p><blockquote><p>进程A的测试代码:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开一个磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">// 2. 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span>* ptr = mmap(<span class="literal">NULL</span>, <span class="number">4000</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">                     MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pt = <span class="string">&quot;我你爹, 你我儿?&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, pt, <span class="built_in">strlen</span>(pt)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存映射区</span></span><br><span class="line">    munmap(ptr, <span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>进程B的测试代码:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开一个磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">// 2. 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span>* ptr = mmap(<span class="literal">NULL</span>, <span class="number">4000</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">                     MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读内存映射区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从映射区读出的数据: %s\n&quot;</span>, (<span class="type">char</span>*)ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存映射区</span></span><br><span class="line">    munmap(ptr, <span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-3-拷贝文件"><a href="#3-3-拷贝文件" class="headerlink" title="3.3 拷贝文件"></a>3.3 拷贝文件</h2><p>用内存映射区除了可实现进程间通信，也可进行文件的拷贝，用这种方式拷贝文件可减少工作量，我们只需负责创建内存映射区和打开磁盘文件，关于文件中的数据读写就无需关心了。</p><blockquote><p>使用内存映射区拷贝文件思路：</p><ol><li>打开被拷贝文件，得到文件描述符 fd1，并计算出这个文件的大小 size</li><li>创建内存映射区A并且和被拷贝文件关联，也就是和fd1关联起来，得到映射区地址 ptrA</li><li>创建新文件，得到文件描述符fd2，用于存储被拷贝的数据，并且将这个文件大小拓展为 size</li><li>创建内存映射区B并且和新创建的文件关联，也就是和fd2关联起来，得到映射区地址 ptrB</li><li>进程地址空间之间的数据拷贝，memcpy（ptrB， ptrA，size），数据自动同步到新建文件中 </li><li>关闭内存映射区</li></ol></blockquote><p>文件拷贝示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开一个操盘文件english.txt得到文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">// 计算文件大小</span></span><br><span class="line">    <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建内存映射区和english.txt进行关联, 得到映射区起始地址</span></span><br><span class="line">    <span class="type">void</span>* ptrA = mmap(<span class="literal">NULL</span>, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptrA == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建一个新文件, 存储拷贝的数据</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;./copy.txt&quot;</span>, O_RDWR|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="comment">// 拓展这个新文件</span></span><br><span class="line">    ftruncate(fd1, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 创建一个映射区和新文件进行关联, 得到映射区的起始地址second</span></span><br><span class="line">    <span class="type">void</span>* ptrB = mmap(<span class="literal">NULL</span>, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd1, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptrB == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap----&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 使用memcpy拷贝映射区数据</span></span><br><span class="line">    <span class="comment">// 这两个指针指向两块内存, 都是内存映射区</span></span><br><span class="line">    <span class="comment">// 指针指向有效的内存, 拷贝的是内存中的数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptrB, ptrA, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 释放内存映射区</span></span><br><span class="line">    munmap(ptrA, size);</span><br><span class="line">    munmap(ptrB, size);</span><br><span class="line">    close(fd);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="4-共享内存"><a href="#4-共享内存" class="headerlink" title="4. 共享内存"></a>4. 共享内存</h1><p>共享内存不同于内存映射区，它不属于任何进程，并且不受进程生命周期的影响。<br>通过调用Linux提供的系统函数就可得到这块共享内存。<br>使用前需让进程和共享内存进行关联，得到共享内存的起始地址之后就可直接进行读写操作了，进程也可以和这块共享内存解除关联, 解除关联之后就不能操作这块共享内存了。<br><code>在所有进程间通信的方式中共享内存的效率是最高的。</code></p><blockquote><p>共享内存操作默认不阻塞，<code>如果多个进程同时读写共享内存，可能出现数据混乱</code>，共享内存需要借助其他机制来保证进程间的数据同步，比如：信号量.<br>共享内存内部没有提供这种机制。</p></blockquote><h2 id="4-1-创建-打开共享内存"><a href="#4-1-创建-打开共享内存" class="headerlink" title="4.1 创建&#x2F;打开共享内存"></a>4.1 创建&#x2F;打开共享内存</h2><h3 id="4-1-1-shmget"><a href="#4-1-1-shmget" class="headerlink" title="4.1.1 shmget"></a>4.1.1 shmget</h3><p>如共享内存不存在就需先创建出来，如已存在就需先打开这块共享内存。<br>不管是创建还是打开共享内存使用的函数是同一个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>key: 类型 key_t 是个整形数, 通过这个key可以创建或者打开一块共享内存，该参数的值一定要大于0</li><li>size: 创建共享内存的时候, 指定共享内存的大小，如果是打开一块存在的共享内存, size是没有意义的</li><li>shmflg：创建共享内存的时候指定的属性<ul><li>IPC_CREAT: 创建新的共享内存，如果创建共享内存, 需要指定对共享内存的操作权限，比如：IPC_CREAT | 0664</li><li>IPC_EXCL: 检测共享内存是否已经存在了，必须和 IPC_CREAT一起使用</li></ul></li></ul></li><li>返回值：共享内存创建或者打开成功返回标识共享内存的唯一的ID，失败返回-1</li></ul><p>函数使用举例:</p><blockquote><p>场景1：创建一块大小为4k的共享内存</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0664</span>);</span><br></pre></td></tr></table></figure><blockquote><p>场景2：创建一块大小为4k的共享内存, 并且检测是否存在</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果共享内存已经存在, 共享内存创建失败, 返回-1, 可以perror() 打印错误信息</span></span><br><span class="line">shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0664</span>|IPC_EXCL);</span><br></pre></td></tr></table></figure><blockquote><p>场景3：打开一块已经存在的共享内存</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数参数虽然指定了大小和IPC_CREAT, 但是都不起作用</span></span><br><span class="line"><span class="comment">// 因为共享内存已经存在, 只能打开, 参数4096也没有意义</span></span><br><span class="line">shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0664</span>);</span><br><span class="line">shmget(<span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>场景4：打开一块共享内存, 如果不存在就创建</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0664</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="4-1-2-ftok"><a href="#4-1-2-ftok" class="headerlink" title="4.1.2 ftok"></a>4.1.2 ftok</h3><p>shmget() 函数的第一个参数是一个大于0的正整数，如果不想自己指定可以通过 <code>ftok()</code>函数直接生成这个key值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ftok函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将两个参数作为种子, 生成一个 key_t 类型的数值</span></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数:</p><ul><li><p>pathname: 当前操作系统中一个存在的路径</p></li><li><p>proj_id: 这个参数只用到了int中的一个字节<br>  传参的时候要将其作为 char 进行操作，取值范围: 1-255</p></li></ul></li><li><p>返回值：函数调用成功返回一个可用于创建、打开共享内存的key值，调用失败返回-1</p></li></ul><p>使用举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据路径生成一个key_t</span></span><br><span class="line"><span class="type">key_t</span> key = ftok(<span class="string">&quot;/home/robin&quot;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建或打开共享内存</span></span><br><span class="line">shmget(key, <span class="number">4096</span>, IPC_CREATE|<span class="number">0664</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="4-2-关联和解除关联"><a href="#4-2-关联和解除关联" class="headerlink" title="4.2 关联和解除关联"></a>4.2 关联和解除关联</h2><h3 id="4-2-1-shmat"><a href="#4-2-1-shmat" class="headerlink" title="4.2.1 shmat"></a>4.2.1 shmat</h3><p>创建&#x2F;打开共享内存之后还必须和共享内存进行关联，这样才能得到共享内存的起始地址，通过得到的内存地址进行数据的读写操作<br>关联函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>shmid: 要操作的共享内存的ID, 是 shmget() 函数的返回值</li><li>shmaddr: 共享内存的起始地址, 用户不知道, 需要让内核指定, 写NULL</li><li>shmflg: 和共享内存关联的对共享内存的操作权限<ul><li>SHM_RDONLY: 读权限, 只能读共享内存中的数据</li><li>0: 读写权限，可以读写共享内存数据</li></ul></li></ul></li><li>返回值：关联成功，返回值共享内存的起始地址，关联失败返回 (void *) -1</li></ul><hr><h2 id="4-2-2-shmdt"><a href="#4-2-2-shmdt" class="headerlink" title="4.2.2 shmdt"></a>4.2.2 shmdt</h2><p>当进程不需要再操作共享内存，可以让进程和共享内存解除关联<br>另外如果没有执行该操作，进程退出之后，结束的进程和共享内存的关联也就自动解除了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：shmat() 函数的返回值, 共享内存的起始地址</li><li>返回值：关联解除成功返回0，失败返回-1</li></ul><hr><h2 id="4-3-删除共享内存"><a href="#4-3-删除共享内存" class="headerlink" title="4.3 删除共享内存"></a>4.3 删除共享内存</h2><h3 id="4-3-1-shmctl"><a href="#4-3-1-shmctl" class="headerlink" title="4.3.1 shmctl"></a>4.3.1 shmctl</h3><p><code>shmctl()</code> 函数是一个多功能函数,可设置、获取共享内存状态也可将共享内存标记为删除状态。<br><code>当共享内存被标记为删除状态之后，并不会马上被删除，直到所有的进程全部和共享内存解除关联，共享内存才会被删除。</code><br>因为通过shmctl()函数只是标记删除共享内存，所以在程序中多次调用该操作也没关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享内存控制函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数 struct shmid_ds 结构体原型          </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>    <span class="comment">/* Ownership and permissions */</span></span><br><span class="line"><span class="type">size_t</span>          shm_segsz;   <span class="comment">/* Size of segment (bytes) */</span></span><br><span class="line"><span class="type">time_t</span>          shm_atime;   <span class="comment">/* Last attach time */</span></span><br><span class="line"><span class="type">time_t</span>          shm_dtime;   <span class="comment">/* Last detach time */</span></span><br><span class="line"><span class="type">time_t</span>          shm_ctime;   <span class="comment">/* Last change time */</span></span><br><span class="line"><span class="type">pid_t</span>           shm_cpid;    <span class="comment">/* PID of creator */</span></span><br><span class="line"><span class="type">pid_t</span>           shm_lpid;    <span class="comment">/* PID of last shmat(2)/shmdt(2) */</span></span><br><span class="line">    <span class="comment">// 引用计数, 多少个进程和共享内存进行了关联</span></span><br><span class="line"><span class="type">shmatt_t</span>        shm_nattch;  <span class="comment">/* 记录了有多少个进程和当前共享内存进行了管联 */</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>shmid: 要操作的共享内存的ID, 是 shmget() 函数的返回值</li><li>cmd: 要做的操作<ul><li>IPC_STAT: 得到当前共享内存的状态</li><li>IPC_SET: 设置共享内存的状态</li><li>IPC_RMID: 标记共享内存要被删除了</li></ul></li><li>buf:<ul><li>cmd&#x3D;&#x3D;IPC_STAT, 作为传出参数, 会得到共享内存的相关属性信息</li><li>cmd&#x3D;&#x3D;IPC_SET, 作为传入参, 将用户的自定义属性设置到共享内存中</li><li>cmd&#x3D;&#x3D;IPC_RMID, buf就没意义了, 这时候buf指定为NULL即可</li></ul></li></ul></li><li>返回值：函数调用成功返回值大于等于0，调用失败返回-1</li></ul><hr><h3 id="4-3-2-相关shell命令"><a href="#4-3-2-相关shell命令" class="headerlink" title="4.3.2 相关shell命令"></a>4.3.2 相关shell命令</h3><p>使用<code>ipcs</code> 添加参数<code>-m</code>可以查看系统中共享内存的详细信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ipcs -m</span><br><span class="line"></span><br><span class="line">------------ 共享内存段 --------------</span><br><span class="line">key        shmid      拥有者  权限     字节     nattch     状态      </span><br><span class="line">0x00000000 425984     oracle     600        524288     2          目标       </span><br><span class="line">0x00000000 327681     oracle     600        524288     2          目标       </span><br><span class="line">0x00000000 458754     oracle     600        524288     2          目标 </span><br></pre></td></tr></table></figure><p>使用 <code>ipcrm</code> 命令可以标记删除某块共享内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key == shmget的第一个参数</span></span><br><span class="line">$ ipcrm -M shmkey  </span><br><span class="line"></span><br><span class="line"><span class="comment"># id == shmget的返回值</span></span><br><span class="line">$ ipcrm -m shmid</span><br></pre></td></tr></table></figure><hr><h3 id="4-3-3-共享内存状态"><a href="#4-3-3-共享内存状态" class="headerlink" title="4.3.3 共享内存状态"></a>4.3.3 共享内存状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 struct shmid_ds 结构体原型          </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>    <span class="comment">/* Ownership and permissions */</span></span><br><span class="line"><span class="type">size_t</span>          shm_segsz;   <span class="comment">/* Size of segment (bytes) */</span></span><br><span class="line"><span class="type">time_t</span>          shm_atime;   <span class="comment">/* Last attach time */</span></span><br><span class="line"><span class="type">time_t</span>          shm_dtime;   <span class="comment">/* Last detach time */</span></span><br><span class="line"><span class="type">time_t</span>          shm_ctime;   <span class="comment">/* Last change time */</span></span><br><span class="line"><span class="type">pid_t</span>           shm_cpid;    <span class="comment">/* PID of creator */</span></span><br><span class="line"><span class="type">pid_t</span>           shm_lpid;    <span class="comment">/* PID of last shmat(2)/shmdt(2) */</span></span><br><span class="line">    <span class="comment">// 引用计数, 多少个进程和共享内存进行了关联</span></span><br><span class="line"><span class="type">shmatt_t</span>        shm_nattch;  <span class="comment">/* 记录了有多少个进程和当前共享内存进行了管联 */</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过<code>shmctl()</code>我们可得知，共享内存的信息是存储到一个叫做<code>struct shmid_ds</code>的结构体中，其中有一个非常重要的成员叫做<code>shm_nattch</code>，在这个成员变量里边记录着当前共享内存关联的进程的个数，一般将其称为引用计数。<br>当共享内存被标记为删除状态，并且这个引用计数变为0之后共享内存才会被真正的被删除掉。</p><p>当共享内存被标记为删除状态之后，共享内存的状态也会发生变化，共享内存内部维护的key从一个正整数变为0，其属性从公共的变为私有。这里的私有指只有已经关联成功的进程才允许继续访问共享内存，不再允许新的进程和这块共享内存进行关联了。<br>下图演示了共享内存的状态变化：</p><p><img src="/img/9.15.png" alt="在这里插入图片描述"></p><hr><h2 id="4-4-进程间通信"><a href="#4-4-进程间通信" class="headerlink" title="4.4 进程间通信"></a>4.4 进程间通信</h2><p>使用共享内存实现进程间通信的操作流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 调用linux的系统API创建一块共享内存</span><br><span class="line">    - 这块内存不属于任何进程, 默认进程不能对其进行操作</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 准备好进程A, 和进程B, 这两个进程需要和创建的共享内存进行关联</span><br><span class="line">    - 关联操作: 调用linux的 api</span><br><span class="line">    - 关联成功之后, 得到了这块共享内存的起始地址</span><br><span class="line">        </span><br><span class="line"><span class="number">3.</span> 在进程A或者进程B中对共享内存进行读写操作</span><br><span class="line">    - 读内存: <span class="built_in">printf</span>() 等;</span><br><span class="line">- 写内存: <span class="built_in">memcpy</span>() 等;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 通信完成, 可以让进程A和B和共享内存解除关联</span><br><span class="line">    - 解除成功, 进程A和B不能再操作共享内存了</span><br><span class="line">    - 共享内存不受进程生命周期的影响的</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span> 共享内存不在使用之后, 将其删除</span><br><span class="line">    - 调用linux的api函数, 删除之后这块内存被内核回收了</span><br></pre></td></tr></table></figure><blockquote><p>写共享内存的进程代码:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建共享内存, 大小为4k</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">1000</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(shmid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 当前进程和共享内存关联</span></span><br><span class="line">    <span class="type">void</span>* ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == (<span class="type">void</span> *) <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 写共享内存</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p = <span class="string">&quot;hello 共享内存&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, p, <span class="built_in">strlen</span>(p)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞程序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续, 删除共享内存\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;共享内存已删除...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>读共享内存的进程代码:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建共享内存, 大小为4k</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">1000</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(shmid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 当前进程和共享内存关联</span></span><br><span class="line">    <span class="type">void</span>* ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == (<span class="type">void</span> *) <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 读共享内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;共享内存数据: %s\n&quot;</span>, (<span class="type">char</span>*)ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞程序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续, 删除共享内存\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;共享内存已经被删除...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-5-shm和mmap的区别"><a href="#4-5-shm和mmap的区别" class="headerlink" title="4.5 shm和mmap的区别"></a>4.5 shm和mmap的区别</h2><p><code>共享内存</code>和<code>内存映射区</code>都可以实现进程间通信，下面来分析一下二者的区别：</p><ul><li><p>实现进程间通信的方式</p><ul><li>shm: 多个进程只需要一块共享内存就够了，共享内存不属于进程，需要和进程关联才能使用</li><li>内存映射区: 位于每个进程的虚拟地址空间中, 并且需要关联同一个磁盘文件才能实现进程间数据通信</li></ul></li><li><p>效率:</p><ul><li>shm: 直接对内存操作，效率高</li><li>内存映射区: 需要内存和文件之间的数据同步，效率低</li></ul></li><li><p>生命周期</p><ul><li>shm：进程退出对共享内存没有影响，调用相关函数&#x2F;命令&#x2F; 关机才能删除共享内存</li><li>内存映射区：进程退出, 内存映射区也就没有了</li></ul></li><li><p>数据的完整性 -&gt; 突发状态下数据能不能被保存下来（比如: 突然断电）</p><ul><li>shm：数据存储在物理内存中, 断电之后系统关闭, 内存数据也就丢失了</li><li>内存映射区：可以完整的保存数据, 内存映射区数据会同步到磁盘文件</li></ul></li></ul><hr><h1 id="5-信号"><a href="#5-信号" class="headerlink" title="5. 信号"></a>5. 信号</h1><h2 id="5-1-信号概述"><a href="#5-1-信号概述" class="headerlink" title="5.1 信号概述"></a>5.1 信号概述</h2><p>Linux中的信号是一种消息处理机制, 它本质上是一个整数，不同的信号对应不同的值<br>由于信号的结构简单所以天生不能携带很大的信息量，但信号在系统中优先级非常高。</p><p>在Linux中的很多常规操作中都会有相关的信号产生，先从我们最熟悉的场景说起：</p><ul><li><code>通过键盘操作产生了信号</code>：用户按下Ctrl-C，这个键盘输入产生一个硬件中断，使用这个快捷键会产生信号, 这个信号会杀死对应的某个进程</li><li><code>通过shell命令产生了信号</code>：通过kill命令终止某一个进程，<code>kill -9 进程PID</code></li><li><code>通过函数调用产生了信号</code>：如果CPU当前正在执行这个进程的代码调用，比如函数 <code>sleep()</code>，进程收到相关的信号，被迫挂起</li><li><code>通过对硬件进行非法访问产生了信号</code>：正在运行的程序访问了非法内存，发生段错误，进程退出。</li></ul><p>信号也可以实现进程间通信，但是信号能传递的数据量很少，不满足大部分需求，另外信号的优先级很高，并且它对应的处理动作是回调完成的，它会打乱程序原有的处理流程，影响到最终的处理结果。<br>因此非常不建议使用信号进行进程间通信。</p><hr><h3 id="5-1-1-信号编号"><a href="#5-1-1-信号编号" class="headerlink" title="5.1.1 信号编号"></a>5.1.1 信号编号</h3><p>通过 <code>kill -l</code> 命令可以察看系统定义的信号列表:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行shell命令查看信号</span></span><br><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p>下表中详细阐述了信号产生的时机和对应的默认处理动作:</p><table><thead><tr><th>编号</th><th>信号</th><th>对应事件</th><th>默认动作</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>用户退出shell时，由该shell启动的所有进程将收到这个信号</td><td>终止进程</td></tr><tr><td>2</td><td>SIGINT</td><td>当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号</td><td>终止进程</td></tr><tr><td>3</td><td>SIGQUIT</td><td>用户按下&lt;ctrl+&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号</td><td>终止进程</td></tr><tr><td>4</td><td>SIGILL</td><td>CPU检测到某进程执行了非法指令</td><td>终止进程并产生core文件</td></tr><tr><td>5</td><td>SIGTRAP</td><td>该信号由断点指令或其他 trap指令产生</td><td>终止进程并产生core文件</td></tr><tr><td>6</td><td>SIGABRT</td><td>调用abort函数时产生该信号</td><td>终止进程并产生core文件</td></tr><tr><td>7</td><td>SIGBUS</td><td>非法访问内存地址，包括内存对齐出错</td><td>终止进程并产生core文件</td></tr><tr><td>8</td><td>SIGFPE</td><td>在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误</td><td>终止进程并产生core文件</td></tr><tr><td>9</td><td>SIGKILL</td><td>无条件终止进程。本信号不能被忽略，处理和阻塞</td><td>终止进程，可以杀死任何进程</td></tr><tr><td>10</td><td>SIGUSE1</td><td>用户定义的信号。即程序员可以在程序中定义并使用该信号</td><td>终止进程</td></tr><tr><td>11</td><td>SIGSEGV</td><td>指示进程进行了无效内存访问(段错误)</td><td>终止进程并产生core文件</td></tr><tr><td>12</td><td>SIGUSR2</td><td>另外一个用户自定义信号，程序员可以在程序中定义并使用该信号</td><td>终止进程</td></tr><tr><td>13</td><td>SIGPIPE</td><td>Broken pipe向一个没有读端的管道写数据</td><td>终止进程</td></tr><tr><td>14</td><td>SIGALRM</td><td>定时器超时，超时的时间由系统调用alarm设置</td><td>终止进程</td></tr><tr><td>15</td><td>SIGTERM</td><td>程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来示程序正常退出。执行shell命令Kill时，缺省产生这个信号</td><td>终止进程</td></tr><tr><td>16</td><td>SIGSTKFLT</td><td>Linux早期版本出现的信号，现仍保留向后兼容</td><td>终止进程</td></tr><tr><td>17</td><td>SIGCHLD</td><td>子进程结束时，父进程会收到这个信号</td><td>忽略这个信号</td></tr><tr><td>18</td><td>SIGCONT</td><td>如果进程已停止，则使其继续运行</td><td>继续&#x2F;忽略</td></tr><tr><td>19</td><td>SIGSTOP</td><td>停止进程的执行。信号不能被忽略，处理和阻塞</td><td>为终止进程</td></tr><tr><td>20</td><td>SIGTSTP</td><td>停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号</td><td>暂停进程</td></tr><tr><td>21</td><td>SIGTTIN</td><td>后台进程读终端控制台</td><td>暂停进程</td></tr><tr><td>22</td><td>SIGTTOU</td><td>该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生</td><td>暂停进程</td></tr><tr><td>23</td><td>SIGURG</td><td>套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络</td><td></td></tr><tr><td>24</td><td>SIGXCPU</td><td>进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程</td><td>终止进程</td></tr><tr><td>25</td><td>SIGXFSZ</td><td>超过文件的最大长度设置</td><td>终止进程</td></tr><tr><td>26</td><td>SIGVTALRM</td><td>虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间</td><td>终止进程</td></tr><tr><td>27</td><td>SGIPROF</td><td>类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间</td><td>终止进程</td></tr><tr><td>28</td><td>SIGWINCH</td><td>窗口变化大小时发出</td><td>忽略该信号</td></tr><tr><td>29</td><td>SIGIO</td><td>此信号向进程指示发出了一个异步IO事件</td><td>忽略该信号</td></tr><tr><td>30</td><td>SIGPWR</td><td>关机</td><td>终止进程</td></tr><tr><td>31</td><td>SIGSYS</td><td>无效的系统调用</td><td>终止进程并产生core文件</td></tr><tr><td>34~64</td><td>SIGRTMIN ~ SIGRTMAX</td><td>LINUX的实时信号，它们没有固定的含义（可以由用户自定义）</td><td>终止进程</td></tr></tbody></table><hr><h3 id="5-1-2-查看信号信息"><a href="#5-1-2-查看信号信息" class="headerlink" title="5.1.2 查看信号信息"></a>5.1.2 查看信号信息</h3><p>通过Linux提供的 man 文档可以查询所有信号的详细信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看man文档的信号描述</span></span><br><span class="line">$ man 7 signal</span><br></pre></td></tr></table></figure><p>在信号描述中介绍了对产生的信号的五种默认处理动作，分别是：</p><ol><li><code>Term</code>：信号将进程终止</li><li><code>Ign</code>：信号产生之后默认被忽略了</li><li><code>Core</code>：信号将进程终止, 并且生成一个core文件(一般用于gdb调试)</li><li><code>Stop</code>：信号会暂停进程的运行</li><li><code>Cont</code>：信号会让暂停的进程继续运行</li></ol><blockquote><p>关于对信号的介绍有一句非常重要的描述:<br>The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.<br>9号信号和19号信号不能被 捕捉, 阻塞, 和 忽略<br>9号信号: 无条件杀死进程<br>19号信号: 无条件暂停进程</p></blockquote><p>有些信号在不同的平台对应的值是不一样的，对应我们使用PC机来说，需要看中间一列的值：</p><p><img src="/img/9.16.png" alt="在这里插入图片描述"></p><hr><h3 id="5-1-3-信号的状态"><a href="#5-1-3-信号的状态" class="headerlink" title="5.1.3 信号的状态"></a>5.1.3 信号的状态</h3><p>Linux中的信号有三种状态，分别为：产生，未决，递达。</p><ol><li><code>产生</code>：键盘输入, 函数调用, 执行shell命令, 对硬件进行非法访问都会产生信号</li><li><code>未决</code>：信号产生了, 但是这个信号还没有被处理掉, 这个期间信号的状态称之为未决状态</li><li><code>递达</code>：信号被处理了(被某个进程处理掉)</li></ol><p><img src="/img/9.17.png" alt="在这里插入图片描述"></p><hr><h2 id="5-2-信号相关函数"><a href="#5-2-信号相关函数" class="headerlink" title="5.2 信号相关函数"></a>5.2 信号相关函数</h2><p>Linux中能够产生信号的函数有很多，下面介绍几个常用函数：</p><h3 id="5-2-1-kill-raise-abort"><a href="#5-2-1-kill-raise-abort" class="headerlink" title="5.2.1 kill&#x2F;raise&#x2F;abort"></a>5.2.1 kill&#x2F;raise&#x2F;abort</h3><p>这三个函数的功能比较类似，可以发送相关的信号给到对应的进程。</p><ul><li>kill 发送指定的信号到指定的进程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 给某一个进程发送一个信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>pid: 进程ID（man 文档里边写的比较详细）</li><li>sig: 要发送的信号</li></ul></li></ul><p>函数使用举例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己杀死自己</span></span><br><span class="line">kill(getpid(), <span class="number">9</span>);</span><br><span class="line"><span class="comment">// 子进程杀死自己的父进程</span></span><br><span class="line">kill(getppid(), <span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li>raise：给当前进程发送指定的信号</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">// 给自己发送某一个信号</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;<span class="comment">// 参数就是要给当前进程发送的信号</span></span><br></pre></td></tr></table></figure><ul><li>abort：给当前进程发送一个固定信号 (SIGABRT)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">// 这是一个中断函数, 调用这个函数, 发送一个固定信号 (SIGABRT), 杀死当前进程</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="5-2-2-定时器"><a href="#5-2-2-定时器" class="headerlink" title="5.2.2 定时器"></a>5.2.2 定时器</h3><h4 id="5-2-2-1-alarm"><a href="#5-2-2-1-alarm" class="headerlink" title="5.2.2.1 alarm"></a>5.2.2.1 alarm</h4><p>alarm() 函数只能进行单次定时，定时完成发射出一个信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数: 倒计时seconds秒, 倒计时完成发送一个信号 SIGALRM , 当前进程会收到这个信号，这个信号默认的处理动作是中断当前进程</li><li>返回值: 大于0表示倒计时还剩多少秒，返回值为0表示倒计时完成, 信号被发出</li></ul><blockquote><p>使用这个定时器函数, 检测一下当前计算机1s钟之内能数多少个数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 设置一个定时器, 定时1s</span></span><br><span class="line">    alarm(<span class="number">1</span>);<span class="comment">// 1s之后会发出一个信号, 这个信号将中断当前进程</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述程序的时候, 计算一下时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接通过终端输出</span></span><br><span class="line">$ time ./a.out</span><br><span class="line">real    0m1.013s<span class="comment"># 实际数数用的总时间</span></span><br><span class="line">user    0m0.060s<span class="comment"># 用户区代码使用的时间</span></span><br><span class="line">sys     0m0.324s<span class="comment"># 内核区使用的时间</span></span><br><span class="line"></span><br><span class="line">real = user + sys + 消耗的时间(频率的从用户区到内核区进程切换)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不直接写终端, 将数据重定向到磁盘文件中</span></span><br><span class="line">$ time ./a.out &gt; a.txt</span><br><span class="line">Alarm clock</span><br><span class="line"></span><br><span class="line">real    0m1.002s    <span class="comment"># 用户实际数数的时间变长了</span></span><br><span class="line">user    0m0.740s</span><br><span class="line">sys     0m0.236s</span><br></pre></td></tr></table></figure><blockquote><p>文件IO操作需要进行用户区到内核区的切换，处理方式不同，二者之间切换的频率也不同。<br>也就是说对文件IO操作进行优化是可以提供程序的执行效率的。</p></blockquote><hr><h4 id="5-2-2-2-setitimer"><a href="#5-2-2-2-setitimer" class="headerlink" title="5.2.2.2 setitimer"></a>5.2.2.2 setitimer</h4><p><code>setitimer ()</code> 函数可以进行周期性定时，每触发一次定时器就会发射出一个信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可以实现周期性定时, 每个一段固定的时间, 发出一个特定的定时器信号</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span> <span class="comment">/* 时间间隔 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>    <span class="comment">/* 第一次触发定时器的时长 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 举例: luffy有一个闹钟, 并且使用这个闹钟定时:</span></span><br><span class="line"><span class="comment">// 早晨7点中起床, 第一次闹钟响起时可能起不来, 之后每隔5分钟再响一次</span></span><br><span class="line"><span class="comment">//  - it_value: 当前设置闹钟的时间点 到 明天早晨7点 对应的总秒数</span></span><br><span class="line"><span class="comment">//  - it_interval: 闹钟第一次响过之后, 每隔5分钟响一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个结构体表示的是一个时间段: tv_sec + tv_usec</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span>      tv_sec;         <span class="comment">/* 秒 */</span></span><br><span class="line"><span class="type">suseconds_t</span> tv_usec;        <span class="comment">/* 微妙 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_value, </span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> itimerval *old_value)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>which: 定时器使用什么样的计时法则, 不同的计时法则发出的信号不同<ul><li><code>ITIMER_REAL</code>: 自然计时法, 最常用, 发出的信号为SIGALRM, 一般使用这个宏值，自然计时法时间 &#x3D; 用户区 + 内核 + 消耗的时间(从进程的用户区到内核区切换使用的总时间)</li><li><code>ITIMER_VIRTUAL</code>: 只计算程序在用户区运行使用的时间，发射的信号为 SIGVTALRM</li><li><code>ITIMER_PROF</code>: 只计算内核运行使用的时间, 发出的信号为SIGPROF</li></ul></li><li>new_value: 给定时器设置的定时信息, 传入参数</li><li>old_value: 上一次给定时器设置的定时信息, 传出参数，如果不需要这个信息, 指定为NULL</li></ul></li></ul><hr><h2 id="5-3-信号集"><a href="#5-3-信号集" class="headerlink" title="5.3 信号集"></a>5.3 信号集</h2><h3 id="5-3-1-阻塞-未决信号集"><a href="#5-3-1-阻塞-未决信号集" class="headerlink" title="5.3.1 阻塞&#x2F;未决信号集"></a>5.3.1 阻塞&#x2F;未决信号集</h3><p>在PCB中有两个非常重要的信号集。一个称之为“阻塞信号集”，另一个称之为“未决信号集”。<br>这两个信号集 体现在内核中就是两张表。<br>但是<code>操作系统不允许我们直接对这两个信号集进行任何操作，而是需要自定义另外一个集合，借助信号集操作函数来对PCB中的这两个信号集进行修改。</code></p><ul><li><p>信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。</p></li><li><p>信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。</p></li></ul><p><code>信号的阻塞就是让系统暂时保留信号留待以后发送。</code><br>由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了 防止信号打断某些敏感的操作。<br><img src="/img/9.18.png" alt="在这里插入图片描述"></p><p>阻塞信号集和未决信号集在内核中的结构是相同的<br>它们都是一个整形数组(被封装过的), 一共 128 字节 （int [32] &#x3D;&#x3D; 1024 bit），1024个标志位，其中前31个标志位，每一个都对应一个Linux中的标准信号，通过标志位的值来标记当前信号在信号集中的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上图对信号集在内核中存储的状态的描述</span></span><br><span class="line"><span class="comment"># 前31个信号: 1-31 , 对应 1024个标志位的前31个标志位</span></span><br><span class="line">信号标志位(从低地址位 到 高地址位)</span><br><span class="line">   1      -&gt;  0</span><br><span class="line">  2             1</span><br><span class="line">  3             2</span><br><span class="line">  4             3</span><br><span class="line"> 31            30</span><br></pre></td></tr></table></figure><ul><li>在阻塞信号集中，描述这个信号有没有被阻塞<ul><li>默认情况下没有信号是被阻塞的, 因此信号对应的标志位的值为 0</li><li>如果某个信号被设置为了阻塞状态, 这个信号对应的标志位 被设置为 1</li></ul></li><li>在未决信号集中, 描述信号是否处于未决状态<ul><li>如果这个信号被阻塞了, 不能处理, 这个信号对应的标志位被设置为1</li><li>如果这个信号的阻塞被解除了, 未决信号集中的这个信号马上就被处理了, 这个信号对应的标志位值变为0</li><li>如果这个信号没有阻塞, 信号产生之后直接被处理, 因此不会在未决信号集中做任何记录</li></ul></li></ul><hr><h3 id="5-3-2-信号集函数"><a href="#5-3-2-信号集函数" class="headerlink" title="5.3.2 信号集函数"></a>5.3.2 信号集函数</h3><p>因为用户是不能直接操作内核中的阻塞信号集和未决信号集的，必须要调用系统函数<br>阻塞信号集可通过系统函数进行读写操作，未决信号集只能对其进行读操作。</p><p>先来看一下读&#x2F;写阻塞信号集的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 使用这个函数修改内核中的阻塞信号集</span></span><br><span class="line"><span class="comment">// sigset_t 被封装之后得到的数据类型, 原型:int[32], 里边一共有1024给标志位, 每一个信号对应一个标志位</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>how:<ul><li><code>SIG_BLOCK</code>: 将参数 set 集合中的数据追加到阻塞信号集中</li><li><code>SIG_UNBLOCK</code>: 将参数 set 集合中的信号在阻塞信号集中解除阻塞</li><li><code>SIG_SETMASK</code>: 使用参 set 结合中的数据覆盖内核的阻塞信号集数据</li></ul></li><li><code>oldset</code>: 通过这个参数将设置之前的阻塞信号集数据传出，如果不需要可以指定为NULL</li></ul></li><li>返回值：函数调用成功返回0，调用失败返回-1</li></ul><p>sigprocmask() 函数有一个 sigset_t 类型的参数，对这种类型的数据进行初始化<br>需要调用一些相关的操作函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 如果在程序中读写 sigset_t 类型的变量</span></span><br><span class="line"><span class="comment">// 阻塞信号集和未决信号集都存储在 sigset_t 类型的变量中, 这个变量对应一块内存</span></span><br><span class="line"><span class="comment">// 阻塞信号集和未决信号集, 对应的内存中有1024bit = 128字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将set集合中所有的标志位设置为0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将set集合中所有的标志位设置为1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将set集合中某一个信号(signum)对应的标志位设置为1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">// 将set集合中某一个信号(signum)对应的标志位设置为0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">// 判断某个信号在集合中对应的标志位到底是0还是1, 如果是0返回0, 如果是1返回1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br></pre></td></tr></table></figure><p><img src="/img/9.19.png" alt="在这里插入图片描述"></p><p>未决信号集不需要我们修改, 如果设置了某个信号阻塞, 当这个信号产生之后, 内核会将这个信号的未决状态记录到未决信号集中，当阻塞的信号被解除阻塞, 未决信号集中的信号随之被处理, 内核再次修改未决信号集将该信号的状态修改为递达状态（标志位置0）。<br>因此，写未决信号集的动作都是内核做的，这是一个读未决信号集的操作函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 这个函数的参数是传出参数, 传出的内核未决信号集的拷贝</span></span><br><span class="line"><span class="comment">// 读一下这个集合就指定哪个信号是未决状态</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure><p>下面举一个简单的例子，演示一下信号集操作函数的使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">需求: </span><br><span class="line">在阻塞信号集中设置某些信号阻塞, 通过一些操作产生这些信号,</span><br><span class="line">然后读未决信号集, 最后再解除这些信号的阻塞</span><br><span class="line">假设阻塞这些信号: </span><br><span class="line">  - 2号信号: SIGINT: ctrl+c</span><br><span class="line">  - 3号信号: SIGQUIT: ctrl+\</span><br><span class="line">  - 9号信号: SIGKILL: 通过shell命令给进程发送这个信号 <span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化信号集</span></span><br><span class="line">    <span class="type">sigset_t</span> myset;</span><br><span class="line">    sigemptyset(&amp;myset);</span><br><span class="line">    <span class="comment">// 设置阻塞的信号</span></span><br><span class="line">    sigaddset(&amp;myset, SIGINT);  <span class="comment">// 2</span></span><br><span class="line">    sigaddset(&amp;myset, SIGQUIT); <span class="comment">// 3</span></span><br><span class="line">    sigaddset(&amp;myset, SIGKILL); <span class="comment">// 9 测试不能被阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将初始化的信号集中的数据设置给内核</span></span><br><span class="line">    <span class="type">sigset_t</span> old;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;myset, &amp;old);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 让进程一直运行, 在当前进程中产生对应的信号</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 4. 读内核的未决信号集</span></span><br><span class="line">        <span class="type">sigset_t</span> curset;</span><br><span class="line">        sigpending(&amp;curset);</span><br><span class="line">        <span class="comment">// 遍历这个信号集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ret = sigismember(&amp;curset, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 解除阻塞, 重新设置阻塞信号集</span></span><br><span class="line">            <span class="comment">//sigprocmask(SIG_UNBLOCK, &amp;myset, NULL);</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;old, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结论：程序中对 9 号信号的阻塞是无效的，因为它无法被阻塞。</p></blockquote><p>一张图总结这些信号集操作函数之间的关系:<br><img src="/img/9.20.png" alt="在这里插入图片描述"></p><hr><h2 id="5-4-信号捕捉"><a href="#5-4-信号捕捉" class="headerlink" title="5.4 信号捕捉"></a>5.4 信号捕捉</h2><p>Linux中的每个信号产生后都会有对应的默认处理行为，如果想要忽略这个信号或修改某些信号的默认行为就需要在程序中捕捉该信号。<br>程序中进行信号捕捉可看做一个注册的动作，提前告诉应用程序信号产生后做什么处理，当进程中对应的信号产生了，这个处理动作也就被调用了。</p><h3 id="5-4-1-signal"><a href="#5-4-1-signal" class="headerlink" title="5.4.1 signal"></a>5.4.1 signal</h3><p>使用 signal() 函数可以捕捉进程中产生的信号，并且修改捕捉到的函数的行为，这个信号的自定义处理动作是一个回调函数，内核通过 signal() 得到这个回调函数的地址，在信号产生之后该函数会被内核调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 在程序中什么时候产生信号, 程序猿是不知道的, 因此不能在信号产生之后再去处理</span></span><br><span class="line"><span class="comment">// 在信号产生之前, 提供一个注册函数, 用来捕捉信号</span></span><br><span class="line"><span class="comment">//  - 假设在将来这个信号产生了, 就委托内核进行捕捉, 这个信号的默认动作就不能被执行</span></span><br><span class="line"><span class="comment">//  - 执行什么样的处理动作 ==&gt; 在signal函数中指定的处理动作</span></span><br><span class="line"><span class="comment">//  - 如果这个信号不产生, 回调函数永远不会被调用</span></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;   </span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>signum: 需要捕捉的信号</li><li>handler: 信号捕捉到之后的处理动作, 这是一个函数指针, 函数原型</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure><p>这个回调函数是需要我们写的, 若我们不调用, 由内核调用，<br>内核调用回调函数的时候, 会给它传递一个实参，这个实参的值就是捕捉的那个信号值。</p><p>下面的测试程序中使用 signal() 函数来捕捉定时器产生的信号 SIGALRM：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器信号的处理动作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">doing</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前捕捉到的信号是: %d\n&quot;</span>, arg);</span><br><span class="line">    <span class="comment">// 打印当前的时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注册要捕捉哪一个信号, 执行什么样的处理动作</span></span><br><span class="line">    signal(SIGALRM, doing);</span><br><span class="line">    <span class="comment">// 1. 调用定时器函数设置定时器函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">newact</span>;</span></span><br><span class="line">    <span class="comment">// 3s之后发出第一个定时器信号, 之后每隔1s发出一个定时器信号</span></span><br><span class="line">    newact.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    newact.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    newact.it_interval.tv_sec = <span class="number">1</span>;</span><br><span class="line">    newact.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这个函数也不是阻塞函数, 函数调用成功, 倒计时开始</span></span><br><span class="line">    <span class="comment">// 倒计时过程中程序是继续运行的</span></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;newact, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写一个业务处理, 阻止当前进程自己结束, 让当前进程被发出的信号杀死</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-4-2-sigaction"><a href="#5-4-2-sigaction" class="headerlink" title="5.4.2 sigaction"></a>5.4.2 sigaction</h3><p>sigaction() 函数和 signal() 函数的功能是一样的，用于捕捉进程中产生的信号，并将用户自定义的信号行为函数（回调函数）注册给内核，内核在信号产生之后调用这个处理动作。<br>sigaction() 可以看做是 signal() 函数是加强版，函数参数更多更复杂，函数功能也更强一些。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>signum: 要捕捉的信号</li><li>act: 捕捉到信号之后的处理动作</li><li>oldact: 上一次调用该函数进行信号捕捉设置的信号处理动作, 该参数一般指定为NULL</li></ul></li><li>返回值：函数调用成功返回0，失败返回-1</li></ul><p>该函数的参数是一个结构体类型，结构体原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line"><span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);    <span class="comment">// 指向一个函数(回调函数)</span></span><br><span class="line"><span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line"><span class="type">sigset_t</span>   sa_mask;             <span class="comment">// 初始化为空即可, 处理函数执行期间不屏蔽任何信号</span></span><br><span class="line"><span class="type">int</span>        sa_flags;        <span class="comment">// 0</span></span><br><span class="line"><span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);  <span class="comment">//不用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体成员介绍：</p><ul><li><p>sa_handler: 函数指针，指向的函数就是捕捉到的信号的处理动作</p></li><li><p>sa_sigaction: 函数指针，指向的函数就是捕捉到的信号的处理动作</p></li><li><p>sa_mask: <code>在信号处理函数执行期间, 临时屏蔽某些信号</code>, 将要屏蔽的信号设置到集合中即可</p><ul><li>当前处理函数执行完毕, 临时屏蔽自动解除</li><li>假设在这个集合中不屏蔽任何信号, 默认也会屏蔽一个（捕捉的信号是谁, 就临时屏蔽谁）</li></ul></li><li><p>sa_flags：使用哪个函数指针指向的函数处理捕捉到的信号</p><ul><li><code>0</code>：使用 <code>sa_handler</code> (一般情况下使用这个)</li><li><code>SA_SIGINFO</code>：使用 sa_sigaction (使用信号传递数据&#x3D;&#x3D;进程间通信)</li></ul></li><li><p>sa_restorer: 被废弃的成员</p></li></ul><p>示例代码，通过sigaction()捕捉阻塞信号集中解除阻塞的信号，如果捕捉多个信号，可以给不同的信号添加不同的处理动作，代码中的处理动作只有一个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号的处理动作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">callback</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前捕捉的信号: %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化信号集</span></span><br><span class="line">    <span class="type">sigset_t</span> myset;</span><br><span class="line">    sigemptyset(&amp;myset);</span><br><span class="line">    <span class="comment">// 设置阻塞的信号</span></span><br><span class="line">    sigaddset(&amp;myset, SIGINT);  <span class="comment">// 2</span></span><br><span class="line">    sigaddset(&amp;myset, SIGQUIT); <span class="comment">// 3</span></span><br><span class="line">    sigaddset(&amp;myset, SIGKILL); <span class="comment">// 9 测试不能被阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当阻塞的信号被解除阻塞, 该信号就可以被捕捉到了</span></span><br><span class="line">    <span class="comment">// 如果信号被捕捉到之后, 马上就被处理掉了 --&gt; 递达状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = callback;</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 和sigint的处理动作相同</span></span><br><span class="line">    sigaction(SIGQUIT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGKILL, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将初始化的信号集中的数据设置给内核</span></span><br><span class="line">    <span class="type">sigset_t</span> old;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;myset, &amp;old);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 让进程一直运行, 在当前进程中产生对应的信号</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 4. 读内核的未决信号集</span></span><br><span class="line">        <span class="type">sigset_t</span> curset;</span><br><span class="line">        sigpending(&amp;curset);</span><br><span class="line">        <span class="comment">// 遍历这个信号集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ret = sigismember(&amp;curset, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 解除阻塞, 重新设置阻塞信号集</span></span><br><span class="line">            <span class="comment">//sigprocmask(SIG_UNBLOCK, &amp;myset, NULL);</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;old, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结论：程序中对 9 号信号的捕捉是无效的，因为它无法被捕捉。</p></blockquote><hr><h2 id="5-5-SIGCHLD-信号"><a href="#5-5-SIGCHLD-信号" class="headerlink" title="5.5 SIGCHLD 信号"></a>5.5 SIGCHLD 信号</h2><p>当子进程退出、暂停、从暂停回复运行的时候，在子进程中会产生一个SIGCHLD信号，并将其发送给父进程，但是父进程收到这个信号后默认忽略。<br>我们可以在父进程中对这个信号加以利用，基于这个信号来回收子进程的资源，因此需要在父进程中捕捉子进程发送过来的这个信号。</p><p>下面是基于信号回收子进程资源的示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收子进程处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">recycle</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到的信号是: %d\n&quot;</span>, num);</span><br><span class="line">    <span class="comment">// 子进程的资源回收, 非阻塞</span></span><br><span class="line">    <span class="comment">// SIGCHLD信号17号信号, 1-31号信号不支持排队</span></span><br><span class="line">    <span class="comment">// 如果这些信号同时产生多个, 最终处理的时候只处理一次</span></span><br><span class="line">    <span class="comment">// 假设多个子进程同时退出, 父进程同时收到了多个sigchld信号</span></span><br><span class="line">    <span class="comment">// 父进程只会处理一次这个信号, 因此当前函数被调用了一次, waitpid被调用一次</span></span><br><span class="line">    <span class="comment">// 相当于只回收了一个子进程, 但是是同时死了多个子进程, 因此就出现了僵尸进程</span></span><br><span class="line">    <span class="comment">// 解决方案: 循环回收即可</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是阻塞回收, 就回不到另外一个处理逻辑上去了</span></span><br><span class="line">        <span class="type">pid_t</span> pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child died, pid = %d\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 没有死亡的子进程, 直接退出当前循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;所有子进程都回收完毕了, 拜拜...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置sigchld信号阻塞</span></span><br><span class="line">    <span class="type">sigset_t</span> myset;</span><br><span class="line">    sigemptyset(&amp;myset);</span><br><span class="line">    sigaddset(&amp;myset, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;myset, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环创建多个子进程 - 20</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 注册信号捕捉, 捕捉sigchld</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_flags  =<span class="number">0</span>;</span><br><span class="line">        act.sa_handler = recycle;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        <span class="comment">// 注册信号捕捉, 委托内核处理将来产生的信号</span></span><br><span class="line">        <span class="comment">// 当信号产生之后, 当前进程优先处理信号, 之前的处理动作会暂停</span></span><br><span class="line">        <span class="comment">// 信号处理完毕之后, 回到原来的暂停的位置继续运行</span></span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解除sigcld信号的阻塞</span></span><br><span class="line">        <span class="comment">// 信号被阻塞之后,就捕捉不到了, 解除阻塞之后才能捕捉到这个信号</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;myset, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父进程执行其他业务逻辑就可以了</span></span><br><span class="line">        <span class="comment">// 默认父进程执行这个while循环, 但是信号产生了, 这个执行逻辑或强迫暂停</span></span><br><span class="line">        <span class="comment">// 父进程去处理信号的处理函数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="6-守护进程"><a href="#6-守护进程" class="headerlink" title="6. 守护进程"></a>6. 守护进程</h1><p>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。</p><h2 id="6-1-进程组"><a href="#6-1-进程组" class="headerlink" title="6.1 进程组"></a>6.1 进程组</h2><p>多个进程的集合就是进程组, 这个组中必须有一个组长, 组长就是进程组中的第一个进程，组长以外的都是普通的成员，每个进程组都有一个唯一的组ID，进程组的ID和组长的PID是一样的。</p><p>进程组中的成员是可以转移的，如果当前进程组中的成员被转移到了其他的组，或者进制中的所有进程都退出了，那么这个进程组也就不存在了。<br>如果进程组中组长死了, 但是当前进程组中有其他进程，这个进程组还是继续存在的。<br>下面介绍几个常用的进程组函数：</p><blockquote><p>得到当前进程所在的进程组的组ID</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>获取指定的进程所在的进程组的组ID，参数 pid 就是指定的进程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>将某个进程移动到其他进程组中或者创建新的进程组</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>pid: 某个进程的进程ID</li><li>pgid: 某个进程组的组ID<ul><li>如果pgid对应的进程组存在，pid对应的进程会移动到这个组中, pid !&#x3D; pgid</li><li>如果pgid对应的进程组不存在，会创建一个新的进程组, 因此要求 pid &#x3D;&#x3D; pgid, 当前进程就是组长了</li></ul></li></ul></li><li>返回值：函数调用成功返回0，失败返回-1</li></ul><hr><h2 id="6-2-会话"><a href="#6-2-会话" class="headerlink" title="6.2 会话"></a>6.2 会话</h2><p>会话(session)是由一个或多个进程组组成的，一个会话可以对应一个控制终端, 也可以没有。<br>一个普通的进程可以调用 <code>setsid()</code> 函数使自己成为新 session 的领头进程（会长），并且这个 session 领头进程还会被放入到一个新的进程组中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某个进程所属的会话ID</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将某个进程变成会话 =&gt;&gt; 得到一个守护进程</span></span><br><span class="line"><span class="comment">// 使用哪个进程调用这个函数, 这个进程就会变成一个会话</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>使用这个函数的注意事项:</p><ol><li>调用这个函数的进程不能是组长进程, 如果是,该函数调用失败，如何保证这个函数能调用成功呢?<br>先fork()创建子进程, 终止父进程,</li><li>让子进程调用这个函数 如果调用这个函数的进程不是进程组长, 会话创建成功<br>这个进程会变成当前会话中的第一个进程，同时也会变成新的进程组的组长<br>该函数调用成功之后, 当前进程就脱离了控制终端，因此不会阻塞终端</li></ol></blockquote><hr><h2 id="6-3-创建守护进程"><a href="#6-3-创建守护进程" class="headerlink" title="6.3 创建守护进程"></a>6.3 创建守护进程</h2><p>如果要创建一个守护进程，标准步骤如下，部分操作可以根据实际需求进行取舍：</p><ol><li><p>创建子进程, 让父进程退出</p><ul><li>因为父进程有可能是组长进程，不符合条件，也没有什么利用价值，退出即可</li><li>子进程没有任何职务, 目的是让子进程最终变成一个会话, 最终就会得到守护进程</li></ul></li><li><p>通过子进程创建新的会话，调用函数 setsid()，脱离控制终端, 变成守护进程</p></li><li><p>改变当前进程的工作目录 (可选项)</p><ul><li>某些文件系统可以被卸载, 比如: U盘, 移动硬盘<br> 进程如果在这些目录中运行，运行期间这些设备被卸载了，运行的进程也就不能正常工作了。</li><li>修改当前进程的工作目录需要调用函数 <code>chdir()</code></li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>重新设置文件的掩码 (可选项,)<ul><li>掩码: umask, 在创建新文件的时候需要和这个掩码进行运算, 去掉文件的某些权限</li><li>设置掩码需要使用函数 <code>umask()</code></li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mode_t</span> <span class="title function_">umask</span><span class="params">(<span class="type">mode_t</span> mask)</span>;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>关闭&#x2F;重定向文件描述符 (建议做)</p><ul><li><p>启动一个进程, 文件描述符表中默认有三个被打开了, 对应的都是当前的终端文件</p></li><li><p>因为进程通过调用 setsid() 已经脱离了当前终端, 因此关联的文件描述符也就没用了, 可以关闭.如下第一代码部分</p></li><li><p>重定向文件描述符(和关闭二选一): 改变文件描述符关联的默认文件, 让他们指向一个特殊的文件<code>/dev/null</code>，只要把数据扔到这个特殊的设备文件中, 数据被被销毁了</p></li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">close(STDIN_FILENO);</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">close(STDERR_FILENO);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line"><span class="comment">// 重定向之后, 这三个文件描述符就和当前终端没有任何关系了</span></span><br><span class="line">dup2(fd, STDIN_FILENO);</span><br><span class="line">dup2(fd, STDOUT_FILENO);</span><br><span class="line">dup2(fd, STDERR_FILENO);</span><br></pre></td></tr></table></figure><ol start="6"><li>根据实际需求在守护进程中执行某些特定的操作</li></ol><hr><h2 id="6-4-守护进程的应用"><a href="#6-4-守护进程的应用" class="headerlink" title="6.4 守护进程的应用"></a>6.4 守护进程的应用</h2><p>写一个守护进程, 每隔2s获取一次系统时间, 并将得到的时间写入到磁盘文件中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号的处理动作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">writeFile</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 得到系统时间</span></span><br><span class="line">    <span class="type">time_t</span> seconds = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 时间转换, 总秒数 -&gt; 可以识别的时间字符串</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">loc</span> =</span> localtime(&amp;seconds);</span><br><span class="line">    <span class="comment">// sprintf();</span></span><br><span class="line">    <span class="type">char</span>* curtime = asctime(loc); <span class="comment">// 自带换行</span></span><br><span class="line">    <span class="comment">// 打开一个文件, 如果文件不存在, 就创建, 文件需要有追加属性</span></span><br><span class="line">    <span class="comment">// ./对应的是哪个目录? /home/robin</span></span><br><span class="line">    <span class="comment">// 0664 &amp; ~022</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./time+++++++.log&quot;</span>, O_WRONLY|O_CREAT|O_APPEND, <span class="number">0664</span>);</span><br><span class="line">    write(fd, curtime, <span class="built_in">strlen</span>(curtime));</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建子进程, 杀死父进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// kill(getpid(), 9); raise(9); abort();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 子进程, 将其变成会话, 脱离当前终端</span></span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 修改进程的工作目录, 修改到一个不能被修改和删除的目录中 /home/robin</span></span><br><span class="line">    chdir(<span class="string">&quot;/home/robin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 设置掩码, 在进程中创建文件的时候这个掩码就起作用了</span></span><br><span class="line">    umask(<span class="number">022</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 重定向和终端关联的文件描述符 -&gt; /dev/null</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    dup2(fd, STDIN_FILENO);</span><br><span class="line">    dup2(fd, STDOUT_FILENO);</span><br><span class="line">    dup2(fd, STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 委托内核捕捉并处理将来发生的信号-SIGALRM(14)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = writeFile;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 设置定时器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">val</span>;</span></span><br><span class="line">    val.it_value.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    val.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    setitimer(ITIMER_REAL, &amp;val, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件IO</title>
      <link href="/2023/10/22/%E6%96%87%E4%BB%B6IO/"/>
      <url>/2023/10/22/%E6%96%87%E4%BB%B6IO/</url>
      
        <content type="html"><![CDATA[<h1 id="1-文件描述符"><a href="#1-文件描述符" class="headerlink" title="1. 文件描述符"></a>1. 文件描述符</h1><h2 id="1-1-虚拟地址空间"><a href="#1-1-虚拟地址空间" class="headerlink" title="1.1 虚拟地址空间"></a>1.1 虚拟地址空间</h2><p>虚拟地址空间是一个非常抽象的概念，先根据字面意思进行解释：</p><blockquote><p>它可以用来加载程序数据（数据可能被加载到物理内存上，空间不够就加载到虚拟内存中）<br> 它对应着一段连续的内存地址，起始位置为 0。<br>之所以说虚拟是因为这个起始的0地址是被虚拟出来的， 不是物理内存的0地址。</p></blockquote><p>虚拟地址空间的大小也由操作系统决定，32位的操作系统虚拟地址空间的大小为 2^32^ 字节，也就是4G，64位的操作系统虚拟地址空间大小为2^64^ 字节，也就是16777216T。</p><p><code>当我们运行磁盘上一个可执行程序, 就会得到一个进程，内核会给每一个运行的进程创建一块属于自己的虚拟地址空间，并将应用程序数据装载到虚拟地址空间对应的地址上。</code></p><p>进程在运行过程中，程序内部所有的指令都是通过CPU处理完成的，CPU只进行数据运算并不具备数据存储的能力，其处理的数据都加载自物理内存<br>那么进程中的数据是如何进出入到物理内存中的呢？<br>其实是通过CPU中的内存管理单元MMU（Memory Management Unit）从进程的虚拟地址空间中映射过去的。</p><p><img src="/img/8.26.png" alt="在这里插入图片描述"></p><hr><h3 id="1-1-1-存在的意义"><a href="#1-1-1-存在的意义" class="headerlink" title="1.1.1 存在的意义"></a>1.1.1 存在的意义</h3><p>为什么操作系统不直接将数据加载到物理内存中而是将数据加载到虚拟地址空间中，在通过CPU的MMU映射到物理内存中呢？</p><p>看一下如果直接将数据加载到物理内存会发生什么事情：</p><p><img src="/img/8.27.png" alt="在这里插入图片描述"></p><blockquote><p>假设计算机的物理内存大小为1G, 进程A需要100M内存因此直接在物理内存上从0地址开始分配100M, 进程B启动需要250M内存,因此继续在物理内存上为其分配250M内存<br>并且进程A和进程B占用的内存是连续的。之后再启动其他进程继续按照这种方法进行物理内存的分配…</p></blockquote><p>使用这种方式分配内存会有如下几个问题：</p><ol><li><code>每个进程的地址不隔离，有安全风险。</code></li></ol><p>由于程序都是直接访问物理内存，所以恶意程序可以通过内存寻址随意修改别的进程对应的内存数据，以达到破坏的目的。虽然有些时候是非恶意的，但是有些存在 bug 的程序可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。</p><ol start="2"><li><code>内存效率低。</code></li></ol><p>如果直接使用物理内存的话，一个进程对应的内存块就是作为一个整体操作的<br>如果出现物理内存不够用的时候，我们一般的办法是将不常用的进程拷贝到磁盘的交换分区（虚拟内存）中，以便腾出内存，因此就需要将整个进程一起拷走，如果数据量大，在内存和磁盘之间拷贝时间就会很长，效率低下。</p><ol start="3"><li><code>进程中数据的地址不确定，每次都会发生变化。</code></li></ol><p>由于物理内存的使用情况一直在动态的变化，我们无法确定内存现在使用到哪里了，如果直接将程序数据加载到物理内存，内存中每次存储数据的起始地址都是不一样的，这样数据的加载都需要使用相对地址，加载效率低（静态库是使用绝对地址加载的）。</p><blockquote><p>有了虚拟地址空间之后就可以完美的解决上边提到的所有问题了，虚拟地址空间就是一个中间层，相当于在程序和物理内存之间设置了一个屏障，将二者隔离开来。<br>程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上。这样，只要操作系统处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果。</p></blockquote><hr><h3 id="1-1-2-分区"><a href="#1-1-2-分区" class="headerlink" title="1.1.2 分区"></a>1.1.2 分区</h3><p>从操作系统层级上看，虚拟地址空间主要分为两个部分<code>内核区</code>和<code>用户区</code>。</p><ul><li><strong>内核区</strong>：<ul><li>内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。</li><li>内核总是驻留在内存中，是操作系统的一部分。</li><li>系统中所有进程对应的虚拟地址空间的内核区都会映射到同一块物理内存上（系统内核只有一个）。</li></ul></li><li><strong>用户区</strong>：存储用户程序运行中用到的各种数据。</li></ul><p>先看进程对应的虚拟地址空间的各个分区，再来详细介绍用户区的组成（以32位系统的虚拟地址空间为例）。<br><img src="/img/8.28.png" alt="在这里插入图片描述"></p><p><em>每个进程的虚拟地址空间都是从0地址开始的，我们在程序中打印的变量地址也其在虚拟地址空间中的地址，程序是无法直接访问物理内存的。</em></p><p>虚拟地址空间中用户区地址范围是 0~3G，里边分为多个区块：</p><ul><li><code>保留区</code>: 位于虚拟地址空间的最底部，未赋予物理地址。任何对它的引用都是非法的，程序中的空指针（NULL）指向的就是这块内存地址。</li><li><code>.text段</code>: 代码段也称正文段或文本段，通常用于存放程序的执行代码(即CPU执行的机器指令)，代码段一般情况下是只读的，这是对执行代码的一种保护机制。</li><li><code>.data段</code>: 数据段通常用于存放程序中已初始化且初值不为0的全局变量和静态变量。数据段属于静态内存分配(静态存储区)，可读可写。</li><li><code>.bss段</code>: 未初始化以及初始为0的全局变量和静态变量，操作系统会将这些未初始化变量初始化为0</li><li><code>堆(heap)</code>：用于存放进程运行时动态分配的内存。<ul><li>堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。</li><li>堆向高地址扩展(即“向上生长”)，是不连续的内存区域。<br>  这是由于系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历。</li></ul></li><li><code>内存映射区(mmap)</code>：作为内存映射区加载磁盘文件，或者加载程序运作过程中需要调用的动态库。</li><li><code>栈(stack)</code>: 存储函数内部声明的非静态局部变量，函数参数，函数返回地址等信息，栈内存由编译器自动分配释放。栈和堆相反地址“向下生长”，分配的内存是连续的。</li><li><code>命令行参数</code>：存储进程执行的时候传递给<code>main()</code>函数的参数，argc，argv[]</li><li><code>环境变量</code>: 存储和进程相关的环境变量, 比如: 工作路径, 进程所有者等信息</li></ul><hr><h2 id="1-2-文件描述符"><a href="#1-2-文件描述符" class="headerlink" title="1.2  文件描述符"></a>1.2  文件描述符</h2><h3 id="1-2-1-文件描述符"><a href="#1-2-1-文件描述符" class="headerlink" title="1.2.1 文件描述符"></a>1.2.1 文件描述符</h3><p>在Linux操作系统中的一切都被抽象为文件,那么一个打开的文件是如何与应用程序进行对应呢？<br>解决方案是使用<code>文件描述符（file descriptor，简称fd）</code>，当在进程中打开一个现有文件或者创建一个新文件时，内核向该进程返回一个文件描述符，用于对应这个打开&#x2F;新建的文件。<br>这些文件描述符都存储在内核为每个进程维护的一个文件描述符表中。</p><p>在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><blockquote><p>在Linux系统中一切皆文件，系统中一切都被抽象成了文件。对这些文件的读写都需要通过文件描述符来完成。<br>标准C库的文件IO函数使用的文件指针<code>FILE*</code>在Linux中也需要通过文件描述符的辅助才能完成读写操作。<code>FILE</code>其实是一个结构体，其内部有一个成员就是文件描述符（下面结构体的第25行）。</p></blockquote><p>FILE结构体在Linux头文件中的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux c FILE结构体定义： /usr/include/libio.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> _fileno;<span class="comment">// 文件描述符</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"> </span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在文件: /usr/include/stdio.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> <span class="title">FILE</span>;</span></span><br></pre></td></tr></table></figure><hr><h3 id="1-2-2-文件描述符表"><a href="#1-2-2-文件描述符表" class="headerlink" title="1.2.2 文件描述符表"></a>1.2.2 文件描述符表</h3><p>前面讲到启动一个进程就会得到一个对应的虚拟地址空间，这个虚拟地址空间分为两大部分，在内核区有专门用于进程管理的模块。Linux的进程控制块<code>PCB（process control block）</code>本质是一个叫做<code>task_struct</code>的结构体，里边包括管理进程所需的各种信息，其中有一个结构体叫做<code>file</code> ，我们将它叫做文件描述符表，里边有一个整形索引表,用于存储文件描述符。</p><p>内核为每一个进程维护了一个文件描述符表，索引表中的值都是从0开始的，所以在不同的进程中你会看到相同的文件描述符，但是它们指向的不一定是同一个磁盘文件。<br><img src="/img/8.29.png" alt="在这里插入图片描述"></p><blockquote><p>Linux中用户操作的每个终端都被视作一个设备文件, 当前操作的终端文件可以使用 &#x2F;dev&#x2F;tty表示。</p></blockquote><ul><li><code>打开的最大文件数</code></li></ul><p>每一个进程对应的文件描述符表能够存储的打开的文件数是有限制的, 默认为1024个，这个默认值是可以修改的，支持打开的最大文件数据取决于操作系统的硬件配置。</p><ul><li><code>默认分配的文件描述符</code><br>当一个进程被启动之后，内核PCB的文件描述符表中就已经分配了三个文件描述符，这三个文件描述符对应的都是当前启动这个进程的终端文件（Linux中一切皆文件，终端就是一个设备文件，在 &#x2F;dev 目录中）<ul><li><code>STDIN_FILENO</code>：标准输入，可以通过这个文件描述符将数据输入到终端文件中，宏值为0。</li><li><code>STDOUT_FILENO</code>：标准输出，可以通过这个文件描述符将数据通过终端输出出来，宏值为1。</li><li><code>STDERR_FILENO</code>：标准错误，可以通过这个文件描述符将错误信息通过终端输出出来，宏值为2。</li></ul></li></ul><p>这三个默认分配的文件描述符是可以通过<code>close()</code>函数关闭掉，但是关闭之后当前进程也就不能和当前终端进行输入或者输出的信息交互了。</p><ul><li><code>给新打开的文件分配文件描述符</code><ul><li>因为进程启动之后，文件描述符表中的0,1,2就被分配出去了，因此<code>从3开始分配</code></li><li>在进程中每打开一个文件，就会给这个文件分配一个新的文件描述符，比如：<ul><li>通过<code>open()</code>函数打开 <code>/hello.txt</code>，文件描述符 3 被分配给了这个文件，保持这个打开状态，再次通过<code>open()</code>函数打开 <code>/hello.txt</code>，文件描述符 4 被分配给了这个文件，也就是说一个进程中不同的文件描述符打开的磁盘文件可能是同一个。</li><li>通过<code>open()</code>函数打开 <code>/hello.txt</code> ，文件描述符 3 被分配给了这个文件，将打开的文件关闭，此时文件描述符3就被释放了。再次通过<code>open()</code>函数打开 <code>/hello.txt</code>，文件描述符 3 被分配给了这个文件，也就是说打开的新文件会关联文件描述符表中最小的没有被占用的文件描述符。</li></ul></li></ul></li></ul><p>总结:</p><ol><li>每个进程对应的文件描述符表默认支持打开的最大文件数为 1024，可以修改</li><li>每个进程的文件描述符表中都已经默认分配了三个文件描述符，对应的都是当前终端文件（&#x2F;dev&#x2F;tty）</li><li>每打开新的文件，内核会从进程的文件描述符表中找到一个空闲的没有别占用的文件描述符与其进行关联</li><li>文件描述符表中不同的文件描述符可以对应同一个磁盘文件</li><li>每个进程文件描述符表中的文件描述符值是唯一的，不会重复</li></ol><hr><h1 id="2-Linux系统文件IO"><a href="#2-Linux系统文件IO" class="headerlink" title="2. Linux系统文件IO"></a>2. Linux系统文件IO</h1><p>每个系统都有自己的专属函数，我们习惯称其为系统函数。<br><code>系统函数并不是内核函数</code>，因为内核函数是不允许用户使用的，系统函数就充当了二者之间的桥梁，这样用户就可以间接的完成某些内核操作了。</p><p>在前面介绍了文件描述符，在Linux系统中必须要使用系统提供的IO函数才能基于这些文件描述符完成对相关文件的读写操作。这些Linux系统IO函数和标准C库的IO函数使用方法类似，函数名称也类似</p><hr><h2 id="2-1-open-close"><a href="#2-1-open-close" class="headerlink" title="2.1 open&#x2F;close"></a>2.1 open&#x2F;close</h2><h3 id="2-1-1-函数原型"><a href="#2-1-1-函数原型" class="headerlink" title="2.1.1 函数原型"></a>2.1.1 函数原型</h3><blockquote><p>通过open函数我们即可打开一个磁盘文件，如果磁盘文件不存在还可以创建一个新的的文件</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">open是一个系统函数, 只能在linux系统中使用, windows不支持</span></span><br><span class="line"><span class="comment">fopen 是标准c库函数, 一般都可以跨平台使用, 可以这样理解:</span></span><br><span class="line"><span class="comment">- 在linux中 fopen底层封装了Linux的系统API open</span></span><br><span class="line"><span class="comment">- 在window中, fopen底层封装的是 window 的 api</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 打开一个已经存在的磁盘文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">// 打开磁盘文件, 如果文件不存在, 就会自动创建</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>参数介绍:</p><ul><li><p>pathname: 被打开的文件的文件名</p></li><li><p>flags: 使用什么方式打开指定的文件，这个参数对应一些宏值，需要根据实际需求指定</p><ul><li><code>必须要指定的属性</code>, 以下三个属性不能同时使用, 只能任选其一<ul><li><code>O_RDONLY</code>: 以只读方式打开文件</li><li><code>O_WRONLY</code>: 以只写方式打开文件</li><li><code>O_RDWR</code>: 以读写方式打开文件</li></ul></li><li><code>可选属性</code>, 和上边的属性一起使用<ul><li><code>O_APPEND</code>: 新数据追加到文件尾部, 不会覆盖文件的原来内容</li><li><code>O_CREAT</code>: 如果文件不存在, 创建该文件, 如果文件存在什么也不做</li><li><code>O_EXCL</code>: 检测文件是否存在, 必须要和 <code>O_CREAT</code> 一起使用, 不能单独使用: <code>O_CREAT</code> | <code>O_EXCL</code><ul><li>检测到文件不存在, 创建新文件</li><li>检测到文件已经存在, 创建失败, 函数直接返回-1（如果不添加这个属性，不会返回-1）</li></ul></li></ul></li></ul></li><li><p>mode: 在创建新文件的时候才需要指定这个参数的值，用于指定新文件的权限，这是一个八进制的整数</p><ul><li>这个参数的最大值为：0777</li><li>创建的新文件对应的最终实际权限, 计算公式: <code>(mode &amp; ~umask)</code><ul><li>umask 掩码可以通过 umask 命令查看</li></ul></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">umask</span></span><br><span class="line">0002</span><br></pre></td></tr></table></figure><p>假设 mode 参数的值为 0777, 通过计算得到的文件权限为 0775</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># umask(文件掩码):  002(八进制)  = 000000010 (二进制)  </span></span><br><span class="line"><span class="comment"># ~umask(掩码取反): ~000000010 (二进制) = 111111101 (二进制)  </span></span><br><span class="line"><span class="comment"># 参数mode指定的权限为: 0777(八进制) = 111111111(二进制)</span></span><br><span class="line"><span class="comment"># 计算公式: mode &amp; ~umask</span></span><br><span class="line">             111111111</span><br><span class="line">       &amp;     111111101</span><br><span class="line">            ------------------</span><br><span class="line">             111111101    二进制</span><br><span class="line">            ------------------</span><br><span class="line">             mod=0775     八进制  </span><br></pre></td></tr></table></figure><ul><li>返回值:<ul><li>成功: 返回内核分配的文件描述符, 这个值被记录在内核的文件描述符表中，这是一个大于0的整数</li><li>失败: -1</li></ul></li></ul><hr><h3 id="2-1-2-close函数原型"><a href="#2-1-2-close函数原型" class="headerlink" title="2.1.2 close函数原型"></a>2.1.2 close函数原型</h3><blockquote><p>通过open函数可以让内核给文件分配一个文件描述符, 如果需要释放这个文件描述符就需要关闭文件。对应的这个系统函数叫做 close</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><ul><li>函数参数: fd 是文件描述符, 是open() 函数的返回值</li><li>函数返回值: 函数调用成功返回值 0, 调用失败返回 -1</li></ul><hr><h3 id="2-1-3-打开已存在文件"><a href="#2-1-3-打开已存在文件" class="headerlink" title="2.1.3 打开已存在文件"></a>2.1.3 打开已存在文件</h3><blockquote><p>我们可以使用<code>open()</code>函数打开一个本地已经存在的文件, 假设我们想要读写这个文件, 操作代码如下:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;abc.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd: %d\n&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc open.c </span><br><span class="line">$ ./a.out </span><br><span class="line">fd: 3<span class="comment"># 打开的文件对应的文件描述符值为 3</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-1-4-创建新文件"><a href="#2-1-4-创建新文件" class="headerlink" title="2.1.4 创建新文件"></a>2.1.4 创建新文件</h3><blockquote><p>如果要创建一个新的文件，还是使用 <code>open</code> 函数，只不过需要添加 <code>O_CREAT</code> 属性, 并且给新文件指定操作权限。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建新文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./new.txt&quot;</span>, O_CREAT|O_RDWR, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建新文件成功, fd: %d\n&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc open1.c </span><br><span class="line">$ ./a.out </span><br><span class="line">创建新文件成功, fd: 3</span><br></pre></td></tr></table></figure><p>假设在创建新文件的时候, 给 open 指定第三个参数指定新文件的操作权限, 文件也是会被创建出来的, 只不过新的文件的权限可能会有点奇怪, 这个权限会随机分配而且还会出现一些特殊的权限位, 如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ $ ll new.txt </span><br><span class="line">-r-x--s--T 1 robin robin 0 Jan 30 16:17 new.txt*   <span class="comment"># T 就是一个特殊权限</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-1-5-文件状态判断"><a href="#2-1-5-文件状态判断" class="headerlink" title="2.1.5 文件状态判断"></a>2.1.5 文件状态判断</h3><blockquote><p>在创建新文件的时候我们还可以通过 <code>O_EXCL</code>进行文件的检测, 具体处理方式如下:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建新文件之前, 先检测是否存在</span></span><br><span class="line">    <span class="comment">// 文件存在创建失败, 返回-1, 文件不存在创建成功, 返回分配的文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./new.txt&quot;</span>, O_CREAT|O_EXCL|O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建文件失败, 已经存在了, fd: %d\n&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建新文件成功, fd: %d\n&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行程序:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc open1.c </span><br><span class="line">$ ./a.out </span><br><span class="line">创建文件失败, 已经存在了, fd: -1</span><br></pre></td></tr></table></figure><hr><h2 id="2-2-read-write"><a href="#2-2-read-write" class="headerlink" title="2.2 read&#x2F;write"></a>2.2 read&#x2F;write</h2><h3 id="2-2-1-read"><a href="#2-2-1-read" class="headerlink" title="2.2.1 read"></a>2.2.1 read</h3><blockquote><p>read 函数用于读取文件内部数据，在通过 open 打开文件的时候需要指定读权限</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li><code>fd</code>: 文件描述符, open() 函数的返回值, 通过这个参数定位打开的磁盘文件</li><li><code>buf</code>: 是一个传出参数, 指向一块有效的内存, 用于存储从文件中读出的数据<ul><li><code>传出参数</code>: 类似于返回值, 将变量地址传递给函数, 函数调用完毕, 地址中就有数据了</li></ul></li><li><code>count</code>: buf指针指向的内存的大小, 指定可以存储的最大字节数</li></ul></li><li>返回值:<ul><li>大于0: 从文件中读出的字节数，读文件成功</li><li>等于0: 代表文件读完了，读文件成功</li><li>-1: 读文件失败了</li></ul></li></ul><hr><h3 id="2-2-2-write"><a href="#2-2-2-write" class="headerlink" title="2.2.2 write"></a>2.2.2 write</h3><blockquote><p>write 函数用于将数据写入到文件内部，在通过 open 打开文件的时候需要指定写权限</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li><code>fd</code>: 文件描述符, open() 函数的返回值, 通过这个参数定位打开的磁盘文件</li><li><code>buf</code>: 指向一块有效的内存地址, 里边有要写入到磁盘文件中的数据</li><li><code>count</code>: 要往磁盘文件中写入的字节数, 一般情况下是buf字符串的长度, <code>strlen(buf)</code></li></ul></li><li>返回值:<ul><li>大于0: 成功写入到磁盘文件中的字节数</li><li>-1: 写文件失败了</li></ul></li></ul><hr><h3 id="2-2-3-文件拷贝"><a href="#2-2-3-文件拷贝" class="headerlink" title="2.2.3 文件拷贝"></a>2.2.3 文件拷贝</h3><blockquote><p>假设有一个比较大的磁盘文件, 打开这个文件得到文件描述符<code>fd1</code>，然后在创建一个新的磁盘文件得到文件描述符<code>fd2</code>, 在程序中通过 <code>fd1</code>将文件内容读出，并通过<code>fd2</code>将读出的数据写入到新文件中。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件的拷贝</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开存在的文件english.txt, 读这个文件</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;./english.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open-readfile&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 打开不存在的文件, 将其创建出来, 将从english.txt读出的内容写入这个文件中</span></span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;copy.txt&quot;</span>, O_WRONLY|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd2 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open-writefile&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 循环读文件, 循环写文件</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>( (len = read(fd1, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将读到的数据写入到另一个文件中</span></span><br><span class="line">        write(fd2, buf, len); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 关闭文件</span></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-3-lseek"><a href="#2-3-lseek" class="headerlink" title="2.3 lseek"></a>2.3 lseek</h2><blockquote><p>系统函数 lseek 的功能是比较强大的, 我们既可以通过这个函数移动文件指针, 也可以通过这个函数进行文件的拓展。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>fd: 文件描述符, open() 函数的返回值, 通过这个参数定位打开的磁盘文件</li><li>offset: 偏移量，需要和第三个参数配合使用</li><li>whence: 通过这个参数指定函数实现什么样的功能<ul><li>SEEK_SET: 从文件头部开始偏移 offset 个字节</li><li>SEEK_CUR: 从当前文件指针的位置向后偏移offset个字节</li><li>SEEK_END: 从文件尾部向后偏移offset个字节</li></ul></li></ul></li><li>返回值:<ul><li>成功: 文件指针从头部开始计算总的偏移量</li><li>失败: -1</li></ul></li></ul><hr><h3 id="2-3-1-移动文件指针"><a href="#2-3-1-移动文件指针" class="headerlink" title="2.3.1 移动文件指针"></a>2.3.1 移动文件指针</h3><blockquote><p>通过对 lseek 函数第三个参数的设置, 经常使用该函数实现如下几个功能</p></blockquote><ul><li>文件指针移动到文件头部</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br></pre></td></tr></table></figure><ul><li>得到当前文件指针的位置</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd, <span class="number">0</span>, SEEK_CUR); </span><br></pre></td></tr></table></figure><ul><li>得到文件总大小</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd, <span class="number">0</span>, SEEK_END);</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-2-文件拓展"><a href="#2-3-2-文件拓展" class="headerlink" title="2.3.2 文件拓展"></a>2.3.2 文件拓展</h3><p>假设使用一个下载软件进行一个大文件下载，但是磁盘很紧张，如果不能马上将文件下载到本地，磁盘空间就可能被其他文件占用了，导致下载软件下载的文件无处存放。那么这个文件怎么解决呢？</p><p>我们可以在开始下载的时候先进行文件拓展，将一些字符写入到目标文件中，让拓展的文件和即将被下载的文件一样大，这样磁盘空间就被成功抢到手，软件就可以下载对应的文件了。</p><p>使用 lseek 函数进行文件拓展必须要满足一下条件：</p><blockquote><p>文件指针必须要偏移到文件尾部之后， 多出来的就需要被填充的部分。<br>文件拓展之后，必须要使用 write()函数进行一次写操作（写什么都可以，没有字节数要求）。</p></blockquote><p>文件拓展举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lseek.c</span></span><br><span class="line"><span class="comment">// 拓展文件大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件拓展, 一共增加了 1001 个字节</span></span><br><span class="line">    lseek(fd, <span class="number">1000</span>, SEEK_END);</span><br><span class="line">    write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看执行执行的效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译程序 </span></span><br><span class="line">$ gcc lseek.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目录文件信息</span></span><br><span class="line">$ ll</span><br><span class="line">-rwxrwxr-x 1 robin robin 8808 May  6  2019 a.out*</span><br><span class="line">-rwxrwxr-x 1 robin robin 1013 May  6  2019 hello.txt*</span><br><span class="line">-rw-rw-r-- 1 robin robin  299 May  6  2019 lseek.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行程序, 拓展文件</span></span><br><span class="line">$ ./a.out </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在查看目录文件信息</span></span><br><span class="line">$ ll</span><br><span class="line">-rwxrwxr-x 1 robin robin 8808 May  6  2019 a.out*</span><br><span class="line">-rwxrwxr-x 1 robin robin 2014 Jan 30 17:39 hello.txt*   <span class="comment"># 大小从 1013 -&gt; 2014, 拓展了1001字节</span></span><br><span class="line">-rw-rw-r-- 1 robin robin  299 May  6  2019 lseek.c</span><br></pre></td></tr></table></figure><hr><h2 id="2-4-truncate-ftruncate"><a href="#2-4-truncate-ftruncate" class="headerlink" title="2.4 truncate&#x2F;ftruncate"></a>2.4 truncate&#x2F;ftruncate</h2><blockquote><p>truncate&#x2F;ftruncate 这两个函数的功能是一样的，可以对文件进行拓展也可以截断文件。<br>使用这两个函数拓展文件比使用lseek要简单</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">// 拓展文件或截断文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>path: 要拓展&#x2F;截断的文件的文件名</li><li>fd: 文件描述符, open() 得到的</li><li>length: 文件的最终大小<ul><li>文件原来size &gt; length，文件被截断, 尾部多余的部分被删除, 文件最终长度为length</li><li>文件原来size &lt; length，文件被拓展, 文件最终长度为length</li></ul></li></ul></li><li>返回值: 成功返回0; 失败返回值-1</li></ul><blockquote><p>truncate() 和 ftruncate() 两个函数的区别在于一个使用文件名一个使用文件描述符操作文件, 功能相同。<br>不管是使用这两个函数还是使用 lseek() 函数拓展文件，文件尾部填充的字符都是 0。</p></blockquote><hr><h2 id="2-5-perror"><a href="#2-5-perror" class="headerlink" title="2.5 perror"></a>2.5 perror</h2><blockquote><p>在查看Linux系统函数的时候, 我们可以发现一个规律:<br>大部分系统函数的返回值都是整形，并且通过这个返回值来描述系统函数的状态（调用是否成功了）<br>在man文档中关于系统函数的返回值大部分时候都是这样描述的：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">       On  success,  zero is returned.  On error, -1 is returned, and errno is <span class="built_in">set</span></span><br><span class="line">       appropriately.</span><br><span class="line">       </span><br><span class="line">       如果成功，则返回0。出现错误时，返回-1，并给errno设置一个适当的值。</span><br></pre></td></tr></table></figure><blockquote><p><code>errno</code>是一个全局变量，只要调用的Linux系统函数有异常（返回-1)错误对应的错误号就会被设置给这个全局变量。<br>这个错误号存储在系统的两个头文件中：<br><code> /usr/include/asm-generic/errno-base.h</code><br><code>/usr/include/asm-generic/errno.h</code></p></blockquote><p>得到错误号，去查询对应的头文件是非常不方便的，我们可以通过 perror 函数将错误号对应的描述信息打印出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数, 自己指定这个字符串的值就可以, 指定什么就会原样输出, 除此之外还会输出错误号对应的描述信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure><p>举例: 使用 perrno 打印错误信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR|O_EXCL|O_CREAT, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc open.c</span><br><span class="line">$ ./a.out </span><br><span class="line">open: File exists<span class="comment"># 通过 perror 输出的错误信息</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-6-错误号"><a href="#2-6-错误号" class="headerlink" title="2.6 错误号"></a>2.6 错误号</h2><p>为了方便查询, 特将全局变量 errno 和错误信息描述的对照关系贴出:</p><h3 id="2-6-1-Part1"><a href="#2-6-1-Part1" class="headerlink" title="2.6.1 Part1"></a>2.6.1 Part1</h3><p>信息来自头文件: &#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno-base.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EPERM            1      <span class="comment">/* Operation not permitted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOENT           2      <span class="comment">/* No such file or directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESRCH            3      <span class="comment">/* No such process */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EINTR            4      <span class="comment">/* Interrupted system call */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EIO              5      <span class="comment">/* I/O error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENXIO            6      <span class="comment">/* No such device or address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E2BIG            7      <span class="comment">/* Argument list too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOEXEC          8      <span class="comment">/* Exec format error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADF            9      <span class="comment">/* Bad file number */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECHILD          10      <span class="comment">/* No child processes */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EAGAIN          11      <span class="comment">/* Try again */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOMEM          12      <span class="comment">/* Out of memory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EACCES          13      <span class="comment">/* Permission denied */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFAULT          14      <span class="comment">/* Bad address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTBLK         15      <span class="comment">/* Block device required */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBUSY           16      <span class="comment">/* Device or resource busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEXIST          17      <span class="comment">/* File exists */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXDEV           18      <span class="comment">/* Cross-device link */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENODEV          19      <span class="comment">/* No such device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTDIR         20      <span class="comment">/* Not a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EISDIR          21      <span class="comment">/* Is a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EINVAL          22      <span class="comment">/* Invalid argument */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENFILE          23      <span class="comment">/* File table overflow */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMFILE          24      <span class="comment">/* Too many open files */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTTY          25      <span class="comment">/* Not a typewriter */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETXTBSY         26      <span class="comment">/* Text file busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFBIG           27      <span class="comment">/* File too large */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSPC          28      <span class="comment">/* No space left on device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESPIPE          29      <span class="comment">/* Illegal seek */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EROFS           30      <span class="comment">/* Read-only file system */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMLINK          31      <span class="comment">/* Too many links */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPIPE           32      <span class="comment">/* Broken pipe */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDOM            33      <span class="comment">/* Math argument out of domain of func */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERANGE          34      <span class="comment">/* Math result not representable */</span></span></span><br></pre></td></tr></table></figure><hr><h3 id="2-6-2-Part2"><a href="#2-6-2-Part2" class="headerlink" title="2.6.2 Part2"></a>2.6.2 Part2</h3><p>信息来自头文件: &#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EDEADLK         35      <span class="comment">/* Resource deadlock would occur */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENAMETOOLONG    36      <span class="comment">/* File name too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOLCK          37      <span class="comment">/* No record locks available */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This error code is special: arch syscall entry code will return</span></span><br><span class="line"><span class="comment"> * -ENOSYS if users try to call a syscall that doesn&#x27;t exist.  To keep</span></span><br><span class="line"><span class="comment"> * failures of syscalls that really do exist distinguishable from</span></span><br><span class="line"><span class="comment"> * failures due to attempts to use a nonexistent syscall, syscall</span></span><br><span class="line"><span class="comment"> * implementations should refrain from returning -ENOSYS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSYS          38      <span class="comment">/* Invalid system call number */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTEMPTY       39      <span class="comment">/* Directory not empty */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELOOP           40      <span class="comment">/* Too many symbolic links encountered */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EWOULDBLOCK     EAGAIN  <span class="comment">/* Operation would block */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOMSG          42      <span class="comment">/* No message of desired type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EIDRM           43      <span class="comment">/* Identifier removed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECHRNG          44      <span class="comment">/* Channel number out of range */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL2NSYNC        45      <span class="comment">/* Level 2 not synchronized */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL3HLT          46      <span class="comment">/* Level 3 halted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL3RST          47      <span class="comment">/* Level 3 reset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELNRNG          48      <span class="comment">/* Link number out of range */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EUNATCH         49      <span class="comment">/* Protocol driver not attached */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOCSI          50      <span class="comment">/* No CSI structure available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL2HLT          51      <span class="comment">/* Level 2 halted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADE           52      <span class="comment">/* Invalid exchange */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADR           53      <span class="comment">/* Invalid request descriptor */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXFULL          54      <span class="comment">/* Exchange full */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOANO          55      <span class="comment">/* No anode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADRQC         56      <span class="comment">/* Invalid request code */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADSLT         57      <span class="comment">/* Invalid slot */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDEADLOCK       EDEADLK</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBFONT          59      <span class="comment">/* Bad font file format */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSTR          60      <span class="comment">/* Device not a stream */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENODATA         61      <span class="comment">/* No data available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETIME           62      <span class="comment">/* Timer expired */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSR           63      <span class="comment">/* Out of streams resources */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENONET          64      <span class="comment">/* Machine is not on the network */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOPKG          65      <span class="comment">/* Package not installed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EREMOTE         66      <span class="comment">/* Object is remote */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOLINK         67      <span class="comment">/* Link has been severed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EADV            68      <span class="comment">/* Advertise error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESRMNT          69      <span class="comment">/* Srmount error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECOMM           70      <span class="comment">/* Communication error on send */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROTO          71      <span class="comment">/* Protocol error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMULTIHOP       72      <span class="comment">/* Multihop attempted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDOTDOT         73      <span class="comment">/* RFS specific error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADMSG         74      <span class="comment">/* Not a data message */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOVERFLOW       75      <span class="comment">/* Value too large for defined data type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTUNIQ        76      <span class="comment">/* Name not unique on network */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADFD          77      <span class="comment">/* File descriptor in bad state */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EREMCHG         78      <span class="comment">/* Remote address changed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBACC         79      <span class="comment">/* Can not access a needed shared library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBBAD         80      <span class="comment">/* Accessing a corrupted shared library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBSCN         81      <span class="comment">/* .lib section in a.out corrupted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBMAX         82      <span class="comment">/* Attempting to link in too many shared libraries */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBEXEC        83      <span class="comment">/* Cannot exec a shared library directly */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EILSEQ          84      <span class="comment">/* Illegal byte sequence */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERESTART        85      <span class="comment">/* Interrupted system call should be restarted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESTRPIPE        86      <span class="comment">/* Streams pipe error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EUSERS          87      <span class="comment">/* Too many users */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTSOCK        88      <span class="comment">/* Socket operation on non-socket */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDESTADDRREQ    89      <span class="comment">/* Destination address required */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMSGSIZE        90      <span class="comment">/* Message too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROTOTYPE      91      <span class="comment">/* Protocol wrong type for socket */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOPROTOOPT     92      <span class="comment">/* Protocol not available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROTONOSUPPORT 93      <span class="comment">/* Protocol not supported */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESOCKTNOSUPPORT 94      <span class="comment">/* Socket type not supported */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOPNOTSUPP      95      <span class="comment">/* Operation not supported on transport endpoint */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPFNOSUPPORT    96      <span class="comment">/* Protocol family not supported */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EAFNOSUPPORT    97      <span class="comment">/* Address family not supported by protocol */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EADDRINUSE      98      <span class="comment">/* Address already in use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EADDRNOTAVAIL   99      <span class="comment">/* Cannot assign requested address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENETDOWN        100     <span class="comment">/* Network is down */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENETUNREACH     101     <span class="comment">/* Network is unreachable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENETRESET       102     <span class="comment">/* Network dropped connection because of reset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECONNABORTED    103     <span class="comment">/* Software caused connection abort */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECONNRESET      104     <span class="comment">/* Connection reset by peer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOBUFS         105     <span class="comment">/* No buffer space available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EISCONN         106     <span class="comment">/* Transport endpoint is already connected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTCONN        107     <span class="comment">/* Transport endpoint is not connected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESHUTDOWN       108     <span class="comment">/* Cannot send after transport endpoint shutdown */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETOOMANYREFS    109     <span class="comment">/* Too many references: cannot splice */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETIMEDOUT       110     <span class="comment">/* Connection timed out */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECONNREFUSED    111     <span class="comment">/* Connection refused */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EHOSTDOWN       112     <span class="comment">/* Host is down */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EHOSTUNREACH    113     <span class="comment">/* No route to host */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EALREADY        114     <span class="comment">/* Operation already in progress */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EINPROGRESS     115     <span class="comment">/* Operation now in progress */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESTALE          116     <span class="comment">/* Stale file handle */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EUCLEAN         117     <span class="comment">/* Structure needs cleaning */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTNAM         118     <span class="comment">/* Not a XENIX named type file */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENAVAIL         119     <span class="comment">/* No XENIX semaphores available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EISNAM          120     <span class="comment">/* Is a named type file */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EREMOTEIO       121     <span class="comment">/* Remote I/O error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDQUOT          122     <span class="comment">/* Quota exceeded */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOMEDIUM       123     <span class="comment">/* No medium found */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMEDIUMTYPE     124     <span class="comment">/* Wrong medium type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECANCELED       125     <span class="comment">/* Operation Canceled */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOKEY          126     <span class="comment">/* Required key not available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EKEYEXPIRED     127     <span class="comment">/* Key has expired */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EKEYREVOKED     128     <span class="comment">/* Key has been revoked */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EKEYREJECTED    129     <span class="comment">/* Key was rejected by service */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* for robust mutexes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOWNERDEAD      130     <span class="comment">/* Owner died */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTRECOVERABLE 131     <span class="comment">/* State not recoverable */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERFKILL         132     <span class="comment">/* Operation not possible due to RF-kill */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EHWPOISON       133     <span class="comment">/* Memory page has hardware error */</span></span></span><br></pre></td></tr></table></figure><hr><h1 id="3-文件的属性信息"><a href="#3-文件的属性信息" class="headerlink" title="3. 文件的属性信息"></a>3. 文件的属性信息</h1><p>众所周知，Linux是一个基于文件的操作系统，因此作为文件本身也就有很多属性，如果想要查看某一个文件的属性有两种方式：<code>命令</code>和<code>函数</code>。<br>虽然有两种方式但是它们对应的名字是相同的，叫做<code>stat</code>。另外使用<code>file</code>命令也可以查看文件的一些属性信息。</p><h2 id="3-1-file-命令"><a href="#3-1-file-命令" class="headerlink" title="3.1 file 命令"></a>3.1 file 命令</h2><blockquote><p>该命令用来识别文件类型，也可用来辨别一些文件的编码格式。它是通过查看文件的<code>头部信息</code>来获取文件类型，而不是像Windows通过扩展名来确定文件类型的。</p></blockquote><p>命令语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数在命令中的位置没有限制</span></span><br><span class="line">$ file 文件名 [参数] </span><br></pre></td></tr></table></figure><p>file 命令的参数是可选项, 可以不加, 常用的参数如下表:</p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>-b</td><td>只显示文件类型和文件编码, 不显示文件名</td></tr><tr><td>-i</td><td>显示文件的 MIME 类型</td></tr><tr><td>-F</td><td>设置输出字符串的分隔符</td></tr><tr><td>-L</td><td>查看软连接文件自身文件属性</td></tr></tbody></table><hr><h3 id="3-1-1-查看文件类型和编码格式"><a href="#3-1-1-查看文件类型和编码格式" class="headerlink" title="3.1.1 查看文件类型和编码格式"></a>3.1.1 查看文件类型和编码格式</h3><p>使用不带任何选项的 file 命令，即可查看指定文件的类型和文件编码信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空文件</span></span><br><span class="line">$ file 11.txt </span><br><span class="line">11.txt: empty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件, 编码格式为: ASCII</span></span><br><span class="line">$ file b.cpp</span><br><span class="line">b.cpp: C <span class="built_in">source</span>, ASCII text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件, 编码格式为: UTF-8 </span></span><br><span class="line">robin@OS:~$ file test.cpp </span><br><span class="line">test.cpp: C <span class="built_in">source</span>, UTF-8 Unicode (with BOM) text, with CRLF line terminators</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可执行程序, Linux中的可执行程序为 ELF 格式</span></span><br><span class="line">robin@OS:~$ file a.out </span><br><span class="line">a.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=5317ae9fba592bf583c4f680d8cc48a8b58c96a5, not stripped</span><br></pre></td></tr></table></figure><hr><h3 id="3-1-2-只显示文件格式以及编码"><a href="#3-1-2-只显示文件格式以及编码" class="headerlink" title="3.1.2 只显示文件格式以及编码"></a>3.1.2 只显示文件格式以及编码</h3><p>使用<code>-b</code>参数，可以使 file 命令的输出不出现文件名，只显示文件格式以及编码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空文件</span></span><br><span class="line">$ file 11.txt -b</span><br><span class="line">empty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件, 编码格式为: ASCII</span></span><br><span class="line">$ file b.cpp -b</span><br><span class="line">C <span class="built_in">source</span>, ASCII text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件, 编码格式为: UTF-8 </span></span><br><span class="line">robin@OS:~$ file test.cpp  -b</span><br><span class="line">C <span class="built_in">source</span>, UTF-8 Unicode (with BOM) text, with CRLF line terminators</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可执行程序, Linux中的可执行程序为 ELF 格式</span></span><br><span class="line">robin@OS:~$ file a.out  -b</span><br><span class="line">ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=5317ae9fba592bf583c4f680d8cc48a8b58c96a5, not stripped</span><br></pre></td></tr></table></figure><hr><h3 id="3-1-3-显示文件的-MIME-类型"><a href="#3-1-3-显示文件的-MIME-类型" class="headerlink" title="3.1.3 显示文件的 MIME 类型"></a>3.1.3 显示文件的 MIME 类型</h3><p>给file命令添加<code>-i</code>参数，可以输出文件对应的 MIME 类型的字符串。</p><blockquote><p><code>MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型</code>。<br>是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，<code>浏览器会自动使用指定应用程序来打开</code>。<br>多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># charset 为该文件的字符编码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件, MIME类型: text/x-c, 字符编码: utf-8</span></span><br><span class="line">$ file occi.cpp -i</span><br><span class="line">occi.cpp: text/x-c; charset=utf-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩文件, MIME类型: application/gzip, 字符编码: binary</span></span><br><span class="line">$ file fcgi.tar.gz -i</span><br><span class="line">fcgi.tar.gz: application/gzip; charset=binary</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文本文件, MIME类型: text/plain, 字符编码: utf-8</span></span><br><span class="line">$ file english.txt -i</span><br><span class="line">english.txt: text/plain; charset=utf-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># html文件, MIME类型: text/html, 字符编码: us-ascii</span></span><br><span class="line">$ file demo.html -i</span><br><span class="line">demo.html: text/html; charset=us-ascii</span><br></pre></td></tr></table></figure><hr><h3 id="3-1-4-设置输出分隔符"><a href="#3-1-4-设置输出分隔符" class="headerlink" title="3.1.4 设置输出分隔符"></a>3.1.4 设置输出分隔符</h3><p>在 file 命令中，文件名和后边的属性信息默认使用冒号（:）分隔，我们可以通过 <code>-F</code> 参数修改分隔符<br>分隔符可以是单字符也可以是一个字符串，如果分隔符是字符串需要将这个参数值写到引号中（单&#x2F;双引号都可以）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认格式输出</span></span><br><span class="line">$ file english.txt </span><br><span class="line">english.txt: UTF-8 Unicode text, with very long lines, with CRLF line terminators</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改分隔符为字符串 “==&gt;&quot;</span></span><br><span class="line">$ file english.txt -F <span class="string">&quot;==&gt;&quot;</span></span><br><span class="line">english.txt==&gt; UTF-8 Unicode text, with very long lines, with CRLF line terminators</span><br><span class="line"></span><br><span class="line">$ file english.txt -F <span class="string">&#x27;==&gt;&#x27;</span></span><br><span class="line">english.txt==&gt; UTF-8 Unicode text, with very long lines, with CRLF line terminators</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改分隔符为单字符 &#x27;=&#x27;</span></span><br><span class="line">$ file english.txt -F = </span><br><span class="line">english.txt= UTF-8 Unicode text, with very long lines, with CRLF line terminators</span><br></pre></td></tr></table></figure><hr><h3 id="3-1-5-查看软连接文件"><a href="#3-1-5-查看软连接文件" class="headerlink" title="3.1.5 查看软连接文件"></a>3.1.5 查看软连接文件</h3><blockquote><p>软连接文件是一个特殊格式的文件, 查看这种格式的文件可以得到两种结果: 第一种是软连接文件本身的属性信息,另一种是链接文件指向的那个文件的属性信息。<br>直接通过 <code>file</code> 查看文件属性得到的是链接文件指向的文件的信息<br>如果添加参数 <code>-L</code>得到的链接文件自身的属性信息。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 ls 查看链接文件属性信息</span></span><br><span class="line">$ ll link.lnk </span><br><span class="line">lrwxrwxrwx 1 root root 24 Jan 25 17:27 link.lnk -&gt; /root/luffy/onepiece.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用file直接查看链接文件信息: 得到的是链接文件指向的那个文件的名字</span></span><br><span class="line">$ file link.lnk </span><br><span class="line">link.lnk: symbolic <span class="built_in">link</span> to `/root/luffy/onepiece.txt<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 使用 file 查看链接文件自身属性信息, 添加参数 -L</span></span><br><span class="line"><span class="string">$ file link.lnk -L</span></span><br><span class="line"><span class="string">link.lnk: UTF-8 Unicode text</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-2-stat-命令"><a href="#3-2-stat-命令" class="headerlink" title="3.2 stat 命令"></a>3.2 stat 命令</h2><p>stat命令显示文件或目录的详细属性信息包括文件系统状态，比ls命令输出的信息更详细。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法格式</span></span><br><span class="line"><span class="comment"># 参数在命令中的位置没有限制</span></span><br><span class="line">$ <span class="built_in">stat</span> [参数] 文件或者目录名</span><br></pre></td></tr></table></figure><p>关于这个命令的可选参数如下表:</p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>-f</td><td>不显示文件本身的信息，显示文件所在文件系统的信息</td></tr><tr><td>-L</td><td>查看软链接文件关联的文件的属性信息</td></tr><tr><td>-c</td><td>查看文件某个单个的属性信息</td></tr><tr><td>-t</td><td>简洁模式，只显示摘要信息，不显示属性描述</td></tr></tbody></table><hr><h3 id="3-2-1-显示所有属性"><a href="#3-2-1-显示所有属性" class="headerlink" title="3.2.1 显示所有属性"></a>3.2.1 显示所有属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">stat</span> english.txt </span><br><span class="line">  File: <span class="string">&#x27;english.txt&#x27;</span></span><br><span class="line">  Size: 129567          Blocks: 256        IO Block: 4096   regular file</span><br><span class="line">Device: 801h/2049d      Inode: 526273      Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: ( 1001/   robin)   Gid: ( 1001/   robin)</span><br><span class="line">Access: 2021-01-31 00:00:36.791490304 +0800</span><br><span class="line">Modify: 2021-01-31 00:00:36.791490304 +0800</span><br><span class="line">Change: 2021-01-31 00:00:36.791490304 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><p>在输出的信息中我们可以看到很多属性,</p><ul><li><code>File</code>: 文件名</li><li><code>Size</code>: 文件大小, 单位是字节</li><li><code>Blocks</code>: 文件使用的数据块总数</li><li><code>IO Block</code>：IO块大小</li><li><code>regular file</code>：文件的实际类型，文件类型不同，该关键字也会变化</li><li><code>Device</code>：设备编号</li><li><code>Inode</code>：Inode号，操作系统用inode编号来识别不同的文件，找到文件数据所在的block，读出数据。</li><li><code>Links</code>：硬链接计数</li><li><code>Access</code>：文件所有者+所属组用户+其他人对文件的访问权限</li><li><code>Uid</code>： 文件所有者名字和所有者ID</li><li><code>Gid</code>：文件所有数组名字已经组ID</li><li><code>Access Time</code>：表示文件的访问时间。当文件内容被访问时，这个时间被更新</li><li><code>Modify Time</code>：表示文件内容的修改时间，当文件的数据内容被修改时，这个时间被更新</li><li><code>Change Time</code>：表示文件的状态时间，当文件的状态被修改时，这个时间被更新，例如：文件的硬链接链接数，大小，权限，Blocks数等。</li><li><code>Birth</code>: 文件生成的日期</li></ul><hr><h3 id="3-2-2-只显示系统信息"><a href="#3-2-2-只显示系统信息" class="headerlink" title="3.2.2 只显示系统信息"></a>3.2.2 只显示系统信息</h3><p>给 stat 命令添加 <code>-f</code>参数将只显示文件在文件系统中的相关属性信息, 文件自身属性不显示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">stat</span> luffy/ -f</span><br><span class="line">  File: <span class="string">&quot;luffy/&quot;</span></span><br><span class="line">    ID: 47d795d8889d00d3 Namelen: 255     Type: ext2/ext3</span><br><span class="line">Block size: 4096       Fundamental block size: 4096</span><br><span class="line">Blocks: Total: 10288179   Free: 8991208    Available: 8546752</span><br><span class="line">Inodes: Total: 2621440    Free: 2515927</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-3-软连接文件"><a href="#3-2-3-软连接文件" class="headerlink" title="3.2.3 软连接文件"></a>3.2.3 软连接文件</h3><p>使用 stat 查看软链接类型的文件, 默认显示的是这个软链接文件的属性信息, 添加参数 <code>-L</code> 就可以查看这个软连接文件关联的文件的属性信息了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看软件文件属性 -&gt; 使用 ls -l</span></span><br><span class="line"><span class="built_in">ls</span> -l link.lnk </span><br><span class="line">lrwxrwxrwx 1 root root 24 Jan 25 17:27 link.lnk -&gt; /root/luffy/onepiece.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 stat 查看软连接文件属性信息</span></span><br><span class="line">$ <span class="built_in">stat</span> link.lnk </span><br><span class="line">  File: ‘link.lnk’ -&gt; ‘/root/luffy/onepiece.txt’</span><br><span class="line">  Size: 24              Blocks: 0          IO Block: 4096   symbolic <span class="built_in">link</span></span><br><span class="line">Device: fd01h/64769d    Inode: 393832      Links: 1</span><br><span class="line">Access: (0777/lrwxrwxrwx)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2021-01-30 23:46:29.922760178 +0800</span><br><span class="line">Modify: 2021-01-25 17:27:12.057386837 +0800</span><br><span class="line">Change: 2021-01-25 17:27:12.057386837 +0800</span><br><span class="line"> Birth: -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 stat 查看软连接文件关联的文件的属性信息</span></span><br><span class="line">$ <span class="built_in">stat</span> link.lnk -L</span><br><span class="line">  File: ‘link.lnk’</span><br><span class="line">  Size: 3700              Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 660353      Links: 2</span><br><span class="line">Access: (0444/-r--r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2021-01-30 23:46:53.696723182 +0800</span><br><span class="line">Modify: 2021-01-25 17:54:47.000000000 +0800</span><br><span class="line">Change: 2021-01-26 11:57:00.587658977 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-4-简洁输出"><a href="#3-2-4-简洁输出" class="headerlink" title="3.2.4 简洁输出"></a>3.2.4 简洁输出</h3><p>使用 stat 进行简洁信息输出的可读性不是太好, 所有的属性描述都别忽略了, 如果只想得到属性值, 可以给该命令添加<code>-t</code>参数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">stat</span> luffy/ -t</span><br><span class="line">luffy/ 4096 8 41fd 1001 1001 801 662325 8 0 0 1611659086 1580893020 1580893020 0 4096</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-5-单个属性输出"><a href="#3-2-5-单个属性输出" class="headerlink" title="3.2.5 单个属性输出"></a>3.2.5 单个属性输出</h3><p>如果每次只想通过 stat 命令得到某一个文件属性, 可以给名添加 <code>-c</code> 参数。<br>不同的文件属性分别对应一些定义好的特殊符号，想得到哪个属性值，将其指定到参数 <code>-c</code> 后边即可。</p><p>属性对应的字符如下表：</p><table><thead><tr><th>格式化字符</th><th>功能</th></tr></thead><tbody><tr><td>%a</td><td>文件的八进制访问权限（#和0是输出标准）</td></tr><tr><td>%A</td><td>人类可读形式的文件访问权限（rwx）</td></tr><tr><td>%b</td><td>已分配的块数量</td></tr><tr><td>%B</td><td>报告的每个块的大小(以字节为单位)</td></tr><tr><td>%C</td><td>SELinux 安全上下文字符串</td></tr><tr><td>%d</td><td>设备编号 （十进制）</td></tr><tr><td>%D</td><td>设备编号 （十六进制）</td></tr><tr><td>%F</td><td>文件类型</td></tr><tr><td>%g</td><td>文件所属组组ID</td></tr><tr><td>%G</td><td>文件所属组名字</td></tr><tr><td>%h</td><td>用连接计数</td></tr><tr><td>%i</td><td>inode编号</td></tr><tr><td>%m</td><td>挂载点</td></tr><tr><td>%n</td><td>文件名</td></tr><tr><td>%N</td><td>用引号括起来的文件名，并且会显示软连接文件引用的文件路径</td></tr><tr><td>%o</td><td>最佳I&#x2F;O传输大小提示</td></tr><tr><td>%s</td><td>文件总大小, 单位为字节</td></tr><tr><td>%t</td><td>十六进制的主要设备类型，用于字符&#x2F;块设备特殊文件</td></tr><tr><td>%T</td><td>十六进制的次要设备类型，用于字符&#x2F;块设备特殊文件</td></tr><tr><td>%u</td><td>文件所有者ID</td></tr><tr><td>%U</td><td>文件所有者名字</td></tr><tr><td>%w</td><td>文件生成的日期 ，人类可识别的时间字符串 – 获取不到信息不显示</td></tr><tr><td>%W</td><td>文件生成的日期 ，自纪元以来的秒数 （参考 %X ）– 获取不到信息不显示</td></tr><tr><td>%x</td><td>最后访问文件的时间, 人类可识别的时间字符串</td></tr><tr><td>%X</td><td>最后访问文件的时间, 自纪元以来的秒数（从1970.1.1开始到最后一次文件访问的总秒数）</td></tr><tr><td>%y</td><td>最后修改文件内容的时间, 人类可识别的时间字符串</td></tr><tr><td>%Y</td><td>最后修改文件内容的时间, 自纪元以来的秒数（参考 %X ）</td></tr><tr><td>%z</td><td>最后修改文件状态的时间, 人类可识别的时间字符串</td></tr><tr><td>%Z</td><td>最后修改文件状态的时间, 自纪元以来的秒数（参考 %X ）</td></tr></tbody></table><p>仔细阅读上表可以知道：文件的每一个属性都有一个或者多个与之对应的格式化字符，这样就可以精确定位所需要的属性信息了，举几个例子作为参考：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">stat</span> occi.cpp -c %a</span><br><span class="line">644</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">stat</span> occi.cpp -c %A           </span><br><span class="line">-rw-r--r--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 ls -l 验证权限</span></span><br><span class="line">$ ll occi.cpp </span><br><span class="line">-rw-r--r-- 1 robin robin 1406 Jan 31 00:00 occi.cpp<span class="comment"># 0664</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">stat</span> link.lnk -c %N</span><br><span class="line"><span class="string">&#x27;link.lnk&#x27;</span> -&gt; <span class="string">&#x27;/home/robin/english.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">stat</span> link.lnk -c %y</span><br><span class="line">2021-01-31 10:48:52.317846411 +0800</span><br></pre></td></tr></table></figure><hr><h2 id="3-3-stat-lstat-函数"><a href="#3-3-stat-lstat-函数" class="headerlink" title="3.3 stat&#x2F;lstat 函数"></a>3.3 stat&#x2F;lstat 函数</h2><p><code>stat</code>&#x2F;<code>lstat</code> 函数的功能和 stat 命令的功能是一样的, 只不过是应用场景不同。<br>这两个函数的区别在于处理软链接文件的方式上</p><ul><li><code>lstat()</code>: 得到的是软连接文件本身的属性信息</li><li><code>stat()</code>: 得到的是软链接文件关联的文件的属性信息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>pathname: 文件名, 要获取这个文件的属性信息</li><li>buf: 传出参数, 文件的信息被写入到了这块内存中</li></ul></li><li>返回值: 函数调用成功返回 0，调用失败返回 -1</li></ul><p>这个函数的第二个参数是一个结构体类型, 这个结构体相对复杂, 通过这个结构体可以存储得到的文件的所有属性信息, 结构体原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>          st_dev;        <span class="comment">// 文件的设备编号</span></span><br><span class="line">    <span class="type">ino_t</span>           st_ino;        <span class="comment">// inode节点</span></span><br><span class="line">    <span class="type">mode_t</span>      st_mode;      <span class="comment">// 文件的类型和存取的权限, 16位整形数  -&gt; 常用</span></span><br><span class="line">    <span class="type">nlink_t</span>        st_nlink;     <span class="comment">// 连到该文件的硬连接数目，刚建立的文件值为1</span></span><br><span class="line">    <span class="type">uid_t</span>           st_uid;       <span class="comment">// 用户ID</span></span><br><span class="line">    <span class="type">gid_t</span>           st_gid;       <span class="comment">// 组ID</span></span><br><span class="line">    <span class="type">dev_t</span>          st_rdev;      <span class="comment">// (设备类型)若此文件为设备文件，则为其设备编号</span></span><br><span class="line">    <span class="type">off_t</span>            st_size;      <span class="comment">// 文件字节数(文件大小)   --&gt; 常用</span></span><br><span class="line">    <span class="type">blksize_t</span>     st_blksize;   <span class="comment">// 块大小(文件系统的I/O 缓冲区大小)</span></span><br><span class="line">    <span class="type">blkcnt_t</span>      st_blocks;    <span class="comment">// block的块数</span></span><br><span class="line">    <span class="type">time_t</span>         st_atime;     <span class="comment">// 最后一次访问时间</span></span><br><span class="line">    <span class="type">time_t</span>         st_mtime;     <span class="comment">// 最后一次修改时间(文件内容)</span></span><br><span class="line">    <span class="type">time_t</span>         st_ctime;     <span class="comment">// 最后一次改变时间(指属性)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="3-3-1-获取文件大小"><a href="#3-3-1-获取文件大小" class="headerlink" title="3.3.1 获取文件大小"></a>3.3.1 获取文件大小</h3><p>下面调用 <code>stat()</code> 函数, 以代码的方式演示一下如何得到某个文件的大小:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 定义结构体, 存储文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">myst</span>;</span></span><br><span class="line">    <span class="comment">// 2. 获取文件属性 english.txt</span></span><br><span class="line">    <span class="type">int</span> ret = stat(<span class="string">&quot;./english.txt&quot;</span>, &amp;myst);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件大小: %d\n&quot;</span>, (<span class="type">int</span>)myst.st_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-3-2-获取文件类型"><a href="#3-3-2-获取文件类型" class="headerlink" title="3.3.2 获取文件类型"></a>3.3.2 获取文件类型</h3><p>文件的类型信息存储在 <code>struct stat</code> 结构体的<code>st_mode</code>成员中, 它是一个 <code>mode_t</code> 类型, 本质上是一个16位的整数。<br>Linux API中为我们提供了相关的宏函数，通过对应的宏函数可以直接判断出文件是不是某种类型，这些信息都可以通过 man 文档（<code>man 2 stat</code>）查询到。</p><p>相关的宏函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型是存储在结构体的这个成员中: mode_t  st_mode;  </span></span><br><span class="line"><span class="comment">// 这些宏函数中的  m 对应的就是结构体成员  st_mode</span></span><br><span class="line"><span class="comment">// 宏函数返回值: 是对应的类型返回-&gt; 1, 不是对应类型返回0</span></span><br><span class="line"></span><br><span class="line">S_ISREG(m)  is it a regular file?  </span><br><span class="line">- 普通文件</span><br><span class="line">S_ISDIR(m)  directory?</span><br><span class="line">- 目录</span><br><span class="line">S_ISCHR(m)  character device?</span><br><span class="line">- 字符设备</span><br><span class="line">S_ISBLK(m)  block device?</span><br><span class="line">- 块设备</span><br><span class="line">S_ISFIFO(m) FIFO (named pipe)?</span><br><span class="line">- 管道</span><br><span class="line">S_ISLNK(m)  symbolic link?  (Not in POSIX<span class="number">.1</span><span class="number">-1996.</span>)</span><br><span class="line">- 软连接</span><br><span class="line">S_ISSOCK(m) socket?  (Not in POSIX<span class="number">.1</span><span class="number">-1996.</span>)</span><br><span class="line">    - 本地套接字文件</span><br></pre></td></tr></table></figure><p>在程序中通过宏函数判断文件类型, 实例代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 定义结构体, 存储文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">myst</span>;</span></span><br><span class="line">    <span class="comment">// 2. 获取文件属性 english.txt</span></span><br><span class="line">    <span class="type">int</span> ret = stat(<span class="string">&quot;./hello&quot;</span>, &amp;myst);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断文件类型</span></span><br><span class="line">    <span class="keyword">if</span>(S_ISREG(myst.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这个文件是一个普通文件...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(myst.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这个文件是一个目录...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S_ISLNK(myst.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这个文件是一个软连接文件...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-3-2-获取文件权限"><a href="#3-3-2-获取文件权限" class="headerlink" title="3.3.2 获取文件权限"></a>3.3.2 获取文件权限</h3><p>用户对文件的操作权限也存储在 <code>struct stat</code> 结构体的<code>st_mode</code>成员中, 在这个16位的整数中不同用户的权限存储位置如下图<br>如果想知道有没有相关权限可以通过按位与(&amp;)操作将这个标志位值取出判断即可。</p><p><img src="/img/8.30.png" alt="在这里插入图片描述"></p><p>Linux 中为我们提供了用于不同用户不同权限判定使用的宏，具体信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">关于变量 st_mode: </span><br><span class="line">- st_mode -- 16位整数</span><br><span class="line">○ 0-2 bit -- 其他人权限</span><br><span class="line">- S_IROTH    00004  读权限   100</span><br><span class="line">- S_IWOTH    00002  写权限   010</span><br><span class="line">- S_IXOTH    00001  执行权限  001</span><br><span class="line">- S_IRWXO    00007  掩码, 过滤 st_mode中除其他人权限以外的信息</span><br><span class="line">○ 3-5 bit -- 所属组权限</span><br><span class="line">- S_IRGRP    00040  读权限</span><br><span class="line">- S_IWGRP    00020  写权限</span><br><span class="line">- S_IXGRP    00010  执行权限</span><br><span class="line">- S_IRWXG    00070  掩码, 过滤 st_mode中除所属组权限以外的信息</span><br><span class="line">○ 6-8 bit -- 文件所有者权限</span><br><span class="line">- S_IRUSR    00400    读权限</span><br><span class="line">- S_IWUSR    00200    写权限</span><br><span class="line">- S_IXUSR    00100    执行权限</span><br><span class="line">- S_IRWXU    00700    掩码, 过滤 st_mode中除文件所有者权限以外的信息</span><br><span class="line">○ 12-15 bit -- 文件类型</span><br><span class="line">- S_IFSOCK   0140000 套接字</span><br><span class="line">- S_IFLNK    0120000 符号链接（软链接）</span><br><span class="line">- S_IFREG    0100000 普通文件</span><br><span class="line">- S_IFBLK    0060000 块设备</span><br><span class="line">- S_IFDIR    0040000 目录</span><br><span class="line">- S_IFCHR    0020000 字符设备</span><br><span class="line">- S_IFIFO    0010000 管道</span><br><span class="line">- S_IFMT     0170000 掩码,过滤 st_mode中除文件类型以外的信息</span><br><span class="line"></span><br><span class="line"><span class="comment">############### 按位与操作举例 ###############</span></span><br><span class="line">    1111 1111 1111 1011   <span class="comment"># st_mode</span></span><br><span class="line">    0000 0000 0000 0100   <span class="comment"># S_IROTH</span></span><br><span class="line">&amp;</span><br><span class="line">----------------------------------------</span><br><span class="line">    0000 0000 0000 0000   <span class="comment"># 没有任何权限</span></span><br></pre></td></tr></table></figure><p>通过仔细阅读上边提供的宏信息, 我们可以知道处理使用它们得到用户对文件的操作权限, 还可以用于判断文件的类型（判断文件类型的第二种方式），具体操作方式可以参考如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 定义结构体, 存储文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">myst</span>;</span></span><br><span class="line">    <span class="comment">// 2. 获取文件属性 english.txt</span></span><br><span class="line">    <span class="type">int</span> ret = stat(<span class="string">&quot;./hello&quot;</span>, &amp;myst);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件大小: %d\n&quot;</span>, (<span class="type">int</span>)myst.st_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断文件类型</span></span><br><span class="line">    <span class="keyword">if</span>(S_ISREG(myst.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这个文件是一个普通文件...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(myst.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这个文件是一个目录...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S_ISLNK(myst.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这个文件是一个软连接文件...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所有者对文件的操作权限</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件所有者对文件的操作权限: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(myst.st_mode &amp; S_IRUSR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(myst.st_mode &amp; S_IWUSR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(myst.st_mode &amp; S_IXUSR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-4-练习"><a href="#3-4-练习" class="headerlink" title="3.4 练习"></a>3.4 练习</h2><p>掌握了如何通过 stat &#x2F; lstat 函数获取文件相关属性之后,<br>我们就可以使用这两个函数来模拟执行命令 ls -l 的效果，具体代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out filename\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = stat(argv[<span class="number">1</span>], &amp;st);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储文件类型和访问权限</span></span><br><span class="line">    <span class="type">char</span> perms[<span class="number">11</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 判断文件类型</span></span><br><span class="line">    <span class="keyword">switch</span>(st.st_mode &amp; S_IFMT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> S_IFLNK:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFDIR:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFREG:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFCHR:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFSOCK:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFIFO:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断文件的访问权限</span></span><br><span class="line">    <span class="comment">// 文件所有者</span></span><br><span class="line">    perms[<span class="number">1</span>] = (st.st_mode &amp; S_IRUSR) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">2</span>] = (st.st_mode &amp; S_IWUSR) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">3</span>] = (st.st_mode &amp; S_IXUSR) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="comment">// 文件所属组</span></span><br><span class="line">    perms[<span class="number">4</span>] = (st.st_mode &amp; S_IRGRP) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">5</span>] = (st.st_mode &amp; S_IWGRP) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">6</span>] = (st.st_mode &amp; S_IXGRP) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="comment">// 其他人</span></span><br><span class="line">    perms[<span class="number">7</span>] = (st.st_mode &amp; S_IROTH) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">8</span>] = (st.st_mode &amp; S_IWOTH) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">9</span>] = (st.st_mode &amp; S_IXOTH) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 硬链接计数</span></span><br><span class="line">    <span class="type">int</span> linkNum = st.st_nlink;</span><br><span class="line">    <span class="comment">// 文件所有者</span></span><br><span class="line">    <span class="type">char</span>* fileUser = getpwuid(st.st_uid)-&gt;pw_name;</span><br><span class="line">    <span class="comment">// 文件所属组</span></span><br><span class="line">    <span class="type">char</span>* fileGrp = getgrgid(st.st_gid)-&gt;gr_name;</span><br><span class="line">    <span class="comment">// 文件大小</span></span><br><span class="line">    <span class="type">int</span> fileSize = (<span class="type">int</span>)st.st_size;</span><br><span class="line">    <span class="comment">// 修改时间</span></span><br><span class="line">    <span class="type">char</span>* time = ctime(&amp;st.st_mtime);</span><br><span class="line">    <span class="type">char</span> mtime[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strncpy</span>(mtime, time, <span class="built_in">strlen</span>(time)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s  %d  %s  %s  %d  %s  %s&quot;</span>, </span><br><span class="line">            perms, linkNum, fileUser, fileGrp, fileSize, mtime, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="4-文件描述符复制和重定向"><a href="#4-文件描述符复制和重定向" class="headerlink" title="4. 文件描述符复制和重定向"></a>4. 文件描述符复制和重定向</h1><p>在Linux中只要调用<code>open()</code>函数就可以给被操作的文件分配一个文件描述符<br>除了使用这种方式Linux系统还提供了一些其他的 API 用于文件描述符的分配<br>相关函数有三个：<code>dup</code>, <code>dup2</code>, <code>fcntl</code>。</p><h2 id="4-1-dup"><a href="#4-1-dup" class="headerlink" title="4.1 dup"></a>4.1 dup</h2><h3 id="4-1-1-函数详解"><a href="#4-1-1-函数详解" class="headerlink" title="4.1.1 函数详解"></a>4.1.1 函数详解</h3><p>dup函数的作用是复制文件描述符，这样就有多个文件描述符可以指向同一个文件了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数： oldfd 是要被复制的文件描述符</p></li><li><p>返回值：函数调用成功返回被复制出的文件描述符，调用失败返回 -1</p></li></ul><p>下图展示了 dup()函数具体行为, 这样不管使用 fd1还是使用fd2都可以对磁盘文件A进行操作了。<br><img src="/img/8.31.png" alt="在这里插入图片描述"></p><blockquote><p>被复制出的新文件描述符是独立于旧的文件描述符的，二者没有连带关系。也就是说当旧的文件描述符被关闭了，复制出的新文件描述符还是可以继续使用的。</p></blockquote><hr><h3 id="4-1-2-示例代码"><a href="#4-1-2-示例代码" class="headerlink" title="4.1.2 示例代码"></a>4.1.2 示例代码</h3><p>下面的代码中演示了通过<code>dup()</code>函数进行文件描述符复制<br>并验证了复制之后两个新、旧文件描述符是独立的，二者没有连带关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个新的磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./mytest.txt&quot;</span>, O_RDWR|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d\n&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pt = <span class="string">&quot;你好, 世界......&quot;</span>;</span><br><span class="line">    <span class="comment">// 写成功之后, 文件指针在文件尾部</span></span><br><span class="line">    write(fd, pt, <span class="built_in">strlen</span>(pt));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制这个文件描述符 fd</span></span><br><span class="line">    <span class="type">int</span> newfd = dup(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;newfd: %d\n&quot;</span>, newfd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭旧的文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用新的文件描述符继续写文件</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ppt = <span class="string">&quot;((((((((((((((((你要相信光！！！))))))))))))))))&quot;</span>;</span><br><span class="line">    write(newfd, ppt, <span class="built_in">strlen</span>(ppt));</span><br><span class="line">    close(newfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-2-dup2"><a href="#4-2-dup2" class="headerlink" title="4.2 dup2"></a>4.2 dup2</h2><h3 id="4-2-1-函数详解"><a href="#4-2-1-函数详解" class="headerlink" title="4.2.1 函数详解"></a>4.2.1 函数详解</h3><p>dup2() 函数是 dup() 函数的加强版，基于dup2() 既可以进行文件描述符的复制, 也可以进行文件描述符的重定向。<br>文件描述符重定向就是改变已经分配的文件描述符关联的磁盘文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 1. 文件描述符的复制, 和dup是一样的</span></span><br><span class="line"><span class="comment">// 2. 能够重定向文件描述符</span></span><br><span class="line"><span class="comment">// - 重定向: 改变文件描述符和文件的关联关系, 和新的文件建立关联关系, 和原来的文件断开关联关系</span></span><br><span class="line"><span class="comment">//1. 首先通过open()打开文件 a.txt , 得到文件描述符 fd</span></span><br><span class="line"><span class="comment">//2. 然后通过open()打开文件 b.txt , 得到文件描述符 fd1</span></span><br><span class="line"><span class="comment">//3. 将fd1从定向 到fd上:</span></span><br><span class="line"><span class="comment">//fd1和b.txt这磁盘文件断开关联, 关联到a.txt上, 以后fd和fd1都对用同一个磁盘文件 a.txt</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数: oldfd和&#96;&#96;newfd&#96; 都是文件描述符</li><li>返回值: 函数调用成功返回新的文件描述符, 调用失败返回 -1</li></ul><p>关于这个函数的两个参数虽然都是文件描述符，但是在使用过程中又对应了不同的场景，具体如下：</p><ul><li><p>场景1:<br>假设参数 <code>oldfd</code> 对应磁盘文件 <code>a.txt</code>, <code>newfd</code>对应磁盘文件<code>b.txt</code>。<br>在这种情况下调用dup2函数, 是给<code>newfd做了重定向</code>，newfd 和文件 b.txt <code>断开关联, 相当于关闭了这个文件, 同时 newfd 指向了磁盘上的a.txt文件</code>，最终 oldfd 和 newfd 都指向了磁盘文件 a.txt。<br><img src="/img/8.32.png" alt="在这里插入图片描述"></p></li><li><p>场景2:<br>假设参数 oldfd 对应磁盘文件 a.txt, newfd不对应任何的磁盘文件（newfd 必须是一个大于等于0的整数）。<br>在这种情况下调用dup2函数, 在这种情况下会进行文件描述符的<code>复制</code>，newfd 指向了磁盘上的a.txt文件，最终 oldfd 和 newfd 都指向了磁盘文件 a.txt。<br><img src="/img/8.33.png" alt="在这里插入图片描述"></p></li><li><p>场景3:<br>假设参数 oldfd 和newfd两个文件描述符对应的是同一个磁盘文件 a.txt,<br>在这种情况下调用dup2函数, 什么也不会发生。<br><img src="/img/8.34.png" alt="在这里插入图片描述"></p></li></ul><hr><h3 id="4-2-2-示例代码"><a href="#4-2-2-示例代码" class="headerlink" title="4.2.2 示例代码"></a>4.2.2 示例代码</h3><blockquote><p>给dup2() 的第二个参数指定一个空闲的没被占用的文件描述符就可以进行文件描述符的复制了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用dup2 复制文件描述符</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个新的磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./111.txt&quot;</span>, O_RDWR|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d\n&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pt = <span class="string">&quot;你好, 世界......&quot;</span>;</span><br><span class="line">    <span class="comment">// 写成功之后, 文件指针在文件尾部</span></span><br><span class="line">    write(fd, pt, <span class="built_in">strlen</span>(pt));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. fd1没有对应任何的磁盘文件, fd1 必须要 &gt;=0</span></span><br><span class="line">    <span class="type">int</span> fd1 = <span class="number">1023</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fd -&gt; 111.txt</span></span><br><span class="line">    <span class="comment">// 文件描述符复制, fd1指向fd对应的文件 111.txt</span></span><br><span class="line">    dup2(fd, fd1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭旧的文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用fd1写文件</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ppt = <span class="string">&quot;(((((((((((((((你要相信光！！！)))))))))))))))))&quot;</span>;</span><br><span class="line">    write(fd1, ppt, <span class="built_in">strlen</span>(ppt));</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将两个有效的文件描述符分别传递给 dup2()函数，就可以实现文件描述符的重定向了。<br>将第二个参数的文件描述符重定向到参数1文件描述符指向的文件上。 </p></blockquote><p>如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用dup2 文件描述符重定向</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个新的磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./111.txt&quot;</span>, O_RDWR|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d\n&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pt = <span class="string">&quot;你好, 世界......&quot;</span>;</span><br><span class="line">    <span class="comment">// 写成功之后, 文件指针在文件尾部</span></span><br><span class="line">    write(fd, pt, <span class="built_in">strlen</span>(pt));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建第二个磁盘文件 222.txt</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;./222.txt&quot;</span>, O_RDWR|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open1&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fd -&gt; 111.txt, fd1-&gt;222.txt</span></span><br><span class="line">    <span class="comment">// 从定向, 将fd1指向fd对应的文件 111.txt</span></span><br><span class="line">    dup2(fd, fd1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭旧的文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用fd1写文件</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ppt = <span class="string">&quot;(((((((((((((((你要相信光！！！)))))))))))))))&quot;</span>;</span><br><span class="line">    write(fd1, ppt, <span class="built_in">strlen</span>(ppt));</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-3-fcntl"><a href="#4-3-fcntl" class="headerlink" title="4.3  fcntl"></a>4.3  fcntl</h2><h3 id="4-3-1-函数详解"><a href="#4-3-1-函数详解" class="headerlink" title="4.3.1 函数详解"></a>4.3.1 函数详解</h3><p>fcntl() 是一个变参函数, 并且是多功能函数<br>在这里只介绍如何通过这个函数实现<code>文件描述符的复制</code>和<code>获取/设置已打开的文件属性</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span><span class="comment">// 主要的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>fd: 要操作的文件描述符</li><li>cmd: 通过该参数控制函数要实现什么功能</li></ul></li><li>返回值：函数调用失败返回 -1，调用成功，返回正确的值：<ul><li>参数 cmd &#x3D; F_DUPFD：返回新的被分配的文件描述符</li><li>参数 cmd &#x3D; F_GETFL：返回文件的flag属性信息</li></ul></li></ul><p>fcntl() 函数的 cmd 可使用的参数列表:</p><table><thead><tr><th>参数 cmd 的取值</th><th>功能描述</th></tr></thead><tbody><tr><td>F_DUPFD</td><td>复制一个已经存在的文件描述符</td></tr><tr><td>F_GETFL</td><td>获取文件的状态标志</td></tr><tr><td>F_SETFL</td><td>设置文件的状态标志</td></tr></tbody></table><p>文件的状态标志指的是在使用 open() 函数打开文件的时候指定的 flags 属性, 也就是第二个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>下表中列出了一些常用的文件状态标志：</p><table><thead><tr><th>文件状态标志</th><th>说明</th></tr></thead><tbody><tr><td>O_RDONLY</td><td>只读打开</td></tr><tr><td>O_WRONLY</td><td>只写打开</td></tr><tr><td>O_RDWR</td><td>读、写打开</td></tr><tr><td>O_APPEND</td><td>追加写</td></tr><tr><td>O_NONBLOCK</td><td>非阻塞模式</td></tr><tr><td>O_SYNC</td><td>等待写完成（数据和属性）</td></tr><tr><td>O_ASYNC</td><td>异步I&#x2F;O</td></tr><tr><td>O_RSYNC</td><td>同步读和写</td></tr></tbody></table><hr><h3 id="4-3-2-复制文件描述符"><a href="#4-3-2-复制文件描述符" class="headerlink" title="4.3.2 复制文件描述符"></a>4.3.2 复制文件描述符</h3><p>使用 fcntl() 函数进行文件描述符复制, 第二个参数 <code>cmd</code> 需要指定为 <code>F_DUPFD</code>（这是个变参函数其他参数不需要指定）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> newfd = fcntl(fd, F_DUPFD);</span><br></pre></td></tr></table></figure><p>使用 fcntl() 复制文件描述符, 函数返回值为新分配的文件描述符，示例代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个新的磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./mytest.txt&quot;</span>, O_RDWR|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d\n&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pt = <span class="string">&quot;你好, 世界......&quot;</span>;</span><br><span class="line">    <span class="comment">// 写成功之后, 文件指针在文件尾部</span></span><br><span class="line">    write(fd, pt, <span class="built_in">strlen</span>(pt));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制这个文件描述符 fd</span></span><br><span class="line">    <span class="type">int</span> newfd = fcntl(fd, F_DUPFD);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;newfd: %d\n&quot;</span>, newfd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭旧的文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用新的文件描述符继续写文件</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ppt = <span class="string">&quot;((((((((((((((((((((((骚年，你要相信光！！！))))))))))))))))))))))&quot;</span>;</span><br><span class="line">    write(newfd, ppt, <span class="built_in">strlen</span>(ppt));</span><br><span class="line">    close(newfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-3-3-设置文件状态标志"><a href="#4-3-3-设置文件状态标志" class="headerlink" title="4.3.3 设置文件状态标志"></a>4.3.3 设置文件状态标志</h3><p>通过 <code>open()</code>函数打开文件之后, 文件的flag属性就已经被确定下来了<br>如果想在打开状态下修改这些属性，可以使用 <code>fcntl()</code>函数实现<br><code>注意</code>: 不是所有的flag 属性都能被动态修改, 只能修改如下状态标志: <code>O_APPEND</code>, <code>O_NONBLOCK</code>, <code>O_SYNC</code>, <code>O_ASYNC</code>, <code>O_RSYNC</code>等。</p><p>得到已打开的文件的状态标志，需要将 cmd 设置为 F_GETFL，得到的信息在函数的返回值中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag = fcntl(fd, F_GETFL);</span><br></pre></td></tr></table></figure><p>设置已打开的文件的状态标志，需要将 cmd 设置为 F_SETFL，新的flag需要通过第三个参数传递给 fcntl() 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到文件的flag属性</span></span><br><span class="line"><span class="type">int</span> flag = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="comment">// 添加新的flag 标志</span></span><br><span class="line">flag = flag | O_APPEND;</span><br><span class="line"><span class="comment">// 将更新后的falg设置给文件</span></span><br><span class="line">fcntl(fd, F_SETFL, flag);</span><br></pre></td></tr></table></figure><blockquote><p>举例： 通过<code>fcntl()</code>函数获取&#x2F;设置已打开的文件属性，先来描述一下场景：<br>如果要往当前文件中写数据, 打开一个新文件, 文件的写指针在文件头部，数据默认也是写到文件开头，如果不想将数据写到文件头部,可以给文件追加一个O_APPEND属性。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写实例程序, 给文件描述符追加 O_APPEND</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开一个已经存在的磁盘文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./111.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d\n&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不想将数据写到文件头部, 可以给文件描述符追加一个O_APPEND属性</span></span><br><span class="line">    <span class="comment">// 通过fcntl获取文件描述符的 flag属性</span></span><br><span class="line">    <span class="type">int</span> flag = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="comment">// 给得到的flag追加 O_APPEND属性</span></span><br><span class="line">    flag = flag | O_APPEND; <span class="comment">// flag |= O_APPEND;</span></span><br><span class="line">    <span class="comment">// 重新将flag属性设置给文件描述符</span></span><br><span class="line">    fcntl(fd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用fd写文件, 添加的数据应该写到文件尾部</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ppp = <span class="string">&quot;((((((((((((((你要相信光！！！)))))))))))))))&quot;</span>;</span><br><span class="line">    write(fd, ppp, <span class="built_in">strlen</span>(ppp));</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="5-目录遍历"><a href="#5-目录遍历" class="headerlink" title="5. 目录遍历"></a>5. 目录遍历</h1><p>Linux的目录是一个树状结构，了解数据结构的都明白，遍历一棵树最简单的方式是递归。<br>掌握递归的使用方法，遍历树状目录也不难。</p><p>Linux给我们提供了相关的目录遍历的函数，分别为：<code>opendir()</code>, <code>readdir()</code>, <code>closedir()</code>。<br>目录的操作方式和标准C库提供的文件操作步骤是类似的。</p><h2 id="5-1-目录三剑客"><a href="#5-1-目录三剑客" class="headerlink" title="5.1 目录三剑客"></a>5.1 目录三剑客</h2><h3 id="5-1-1-opendir"><a href="#5-1-1-opendir" class="headerlink" title="5.1.1 opendir"></a>5.1.1 opendir</h3><p>在目录操作之前必须要先通过 <code>opendir()</code> 函数打开这个目录</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="comment">// 打开目录</span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数: name -&gt; 要打开的目录的名字</li><li>返回值: DIR*, 结构体类型指针。打开成功返回目录的实例，打开失败返回 NULL</li></ul><hr><h3 id="5-1-2-readdir"><a href="#5-1-2-readdir" class="headerlink" title="5.1.2 readdir"></a>5.1.2 readdir</h3><p>目录打开之后，就可以通过 <code>readdir()</code> 函数遍历目录中的文件信息了。<br>每调用一次这个函数就可以得到目录中的一个文件信息<br>当目录中的文件信息被全部遍历完毕会得到一个空对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">// 读目录</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：dirp -&gt; opendir() 函数的返回值</li><li>返回值：函数调用成功，返回读到的文件的信息,<br>目录文件被读完了或者函数调用失败返回 NULL</li></ul><p>函数返回值 <code>struct dirent</code> 结构体原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    <span class="type">ino_t</span>          d_ino;       <span class="comment">/* 文件对应的inode编号, 定位文件存储在磁盘的那个数据块上 */</span></span><br><span class="line">    <span class="type">off_t</span>          d_off;       <span class="comment">/* 文件在当前目录中的偏移量 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> d_reclen;    <span class="comment">/* 文件名字的实际长度 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  d_type;      <span class="comment">/* 文件的类型, linux中有7中文件类型 */</span></span><br><span class="line">    <span class="type">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* 文件的名字 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于结构体中的文件类型<code>d_type</code>，可使用的宏值如下：</p><ul><li><code>DT_BLK</code>：块设备文件</li><li><code>DT_CHR</code>：字符设备文件</li><li><code>DT_DIR</code>：目录文件</li><li><code>DT_FIFO</code> ：管道文件</li><li><code>DT_LNK</code>：软连接文件</li><li><code>DT_REG</code>：普通文件</li><li><code>DT_SOCK</code>：本地套接字文件</li><li><code>DT_UNKNOWN</code>：无法识别的文件类型</li></ul><p>那么，如何通过 readdir() 函数遍历某一个目录中的文件呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开目录</span></span><br><span class="line">DIR* dir = opendir(<span class="string">&quot;/home/test&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">ptr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 遍历目录</span></span><br><span class="line"><span class="keyword">while</span>( (ptr=readdir(dir)) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-1-3-closedir"><a href="#5-1-3-closedir" class="headerlink" title="5.1.3 closedir"></a>5.1.3 closedir</h3><p>目录操作完毕之后, 需要通过 <code>closedir()</code>关闭通过<code>opendir()</code>得到的实例，释放资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">// 关闭目录, 参数是 opendir() 的返回值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：dirp-&gt; opendir() 函数的返回值</li><li>返回值: 目录关闭成功返回0, 失败返回 -1</li></ul><hr><h2 id="5-2-遍历目录"><a href="#5-2-遍历目录" class="headerlink" title="5.2 遍历目录"></a>5.2 遍历目录</h2><h3 id="5-2-1-遍历单层目录"><a href="#5-2-1-遍历单层目录" class="headerlink" title="5.2.1 遍历单层目录"></a>5.2.1 遍历单层目录</h3><p>如果只遍历单层目录是不需要递归的，按照上边介绍的函数的使用方法，依次继续调用即可。<br>假设我们需要得到某个指定目录下 mp3 格式文件的个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filenum.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开目录</span></span><br><span class="line">    DIR* dir = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 遍历当前目录中的文件</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">ptr</span> =</span> readdir(dir);</span><br><span class="line">        <span class="keyword">if</span>(ptr == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;目录读完了...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读到了一个文件</span></span><br><span class="line">        <span class="comment">// 判断文件类型</span></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_REG)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span>* p = <span class="built_in">strstr</span>(ptr-&gt;d_name, <span class="string">&quot;.mp3&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(p != <span class="literal">NULL</span> &amp;&amp; *(p+<span class="number">4</span>) == <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//+4 判断是否真的是后缀</span></span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;file %d: %s\n&quot;</span>, count, ptr-&gt;d_name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s目录中mp3文件的个数: %d\n&quot;</span>, argv[<span class="number">1</span>], count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭目录</span></span><br><span class="line">    closedir(dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译名执行程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ gcc filenum.c</span><br><span class="line"><span class="comment"># 读当前目录中mp3文件个数</span></span><br><span class="line">$ ./a.out .</span><br><span class="line">file 1: 1.mp3</span><br><span class="line">目录读完了...</span><br><span class="line">.目录中mp3文件的个数: 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读 ./sub 目录中mp3文件个数</span></span><br><span class="line">$ ./a.out ./sub/</span><br><span class="line">file 1: 3.mp3</span><br><span class="line">file 2: 1.mp3</span><br><span class="line">file 3: 5.mp3</span><br><span class="line">file 4: 4.mp3</span><br><span class="line">file 5: 2.mp3</span><br><span class="line">目录读完了...</span><br><span class="line">./sub/目录中mp3文件的个数: 5</span><br></pre></td></tr></table></figure><hr><h3 id="5-2-2-遍历多层目录"><a href="#5-2-2-遍历多层目录" class="headerlink" title="5.2.2 遍历多层目录"></a>5.2.2 遍历多层目录</h3><p>Linux 的目录是树状结构，遍历每层目录的方式是一样的，也就是说最简单的遍历方式是递归。<br>程序的重点就是确定递归结束的条件：遍历的文件如果不是目录类型就结束递归。</p><p>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filenum.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getMp3Num</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 打开目录</span></span><br><span class="line">    DIR* dir = opendir(path);</span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 遍历当前目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">ptr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((ptr = readdir(dir)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是目录 . .. 跳过不处理</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(ptr-&gt;d_name, <span class="string">&quot;.&quot;</span>)==<span class="number">0</span> ||</span><br><span class="line">           <span class="built_in">strcmp</span>(ptr-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 假设读到的当前文件是目录</span></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_DIR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 目录</span></span><br><span class="line">            <span class="type">char</span> newPath[<span class="number">1024</span>];</span><br><span class="line">            <span class="built_in">sprintf</span>(newPath, <span class="string">&quot;%s/%s&quot;</span>, path, ptr-&gt;d_name);</span><br><span class="line">            <span class="comment">// 读当前目录的子目录</span></span><br><span class="line">            count += getMp3Num(newPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ptr-&gt;d_type == DT_REG)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 普通文件</span></span><br><span class="line">            <span class="type">char</span>* p = <span class="built_in">strstr</span>(ptr-&gt;d_name, <span class="string">&quot;.mp3&quot;</span>);</span><br><span class="line">            <span class="comment">// 判断文件后缀是不是 .mp3</span></span><br><span class="line">            <span class="keyword">if</span>(p != <span class="literal">NULL</span> &amp;&amp; *(p+<span class="number">4</span>) == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s/%s\n&quot;</span>, path, ptr-&gt;d_name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ./a.out path</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out path\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = getMp3Num(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s 目录中mp3文件个数: %d\n&quot;</span>, argv[<span class="number">1</span>], num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ gcc filenum.c</span><br><span class="line"><span class="comment"># 查看 abc 目录中mp3 文件个数</span></span><br><span class="line">$ ./a.out abc</span><br><span class="line">abc/sub/3.mp3</span><br><span class="line">abc/sub/1.mp3</span><br><span class="line">abc/sub/5.mp3</span><br><span class="line">abc/sub/4.mp3</span><br><span class="line">abc/sub/2.mp3</span><br><span class="line">abc/sub/music/test2.mp3</span><br><span class="line">abc/sub/music/test3.mp3</span><br><span class="line">abc/sub/music/test1.mp3</span><br><span class="line">abc/hello.mp3</span><br><span class="line">abc 目录中mp3文件个数: 9</span><br></pre></td></tr></table></figure><hr><h2 id="5-3-scandir函数"><a href="#5-3-scandir函数" class="headerlink" title="5.3 scandir函数"></a>5.3 scandir函数</h2><p>也可使用<code>scandir()</code>函数进行目录的遍历（只遍历指定目录，不进入到子目录中进行递归遍历）<br>它的参数并不简单，涉及到三级指针和回调函数的使用。</p><p>&#x2F;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ 函数原型</span><br><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">scandir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dirp, <span class="keyword">struct</span> dirent ***namelist,</span></span><br><span class="line"><span class="params">              <span class="type">int</span> (*filter)(<span class="type">const</span> <span class="keyword">struct</span> dirent *),</span></span><br><span class="line"><span class="params">              <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="keyword">struct</span> dirent **, <span class="type">const</span> <span class="keyword">struct</span> dirent **))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">alphasort</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dirent **a, <span class="type">const</span> <span class="keyword">struct</span> dirent **b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">versionsort</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dirent **a, <span class="type">const</span> <span class="keyword">struct</span> dirent **b)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>dirp: 需要遍历的目录的名字</li><li>namelist: 三级指针, 传出参数, 需要在指向的地址中存储遍历目录得到的所有文件的信息<ul><li><code>在函数内部会给这个指针指向的地址分配内存，要注意在程序中释放内存</code></li></ul></li><li>filter: 函数指针, 指针指向的函数就是回调函数, 需要在自定义函数中指定如果过滤目录中的文件<ul><li>如果不对目录中的文件进行过滤, 该函数指针指定为NULL即可</li><li>如果自己指定过滤函数, 满足条件要返回1, 否则返回 0</li></ul></li><li>compar: 函数指针, 对过滤得到的文件进行排序, 可以使用提供的两种排序方式:<ul><li>alphasort: 根据文件名进行排序</li><li>versionsort: 根据版本进行排序</li></ul></li></ul></li><li>返回值: 函数执行成功返回找到的匹配成功的文件的个数，如果失败返回-1。</li></ul><hr><h3 id="5-3-1-文件过滤"><a href="#5-3-1-文件过滤" class="headerlink" title="5.3.1 文件过滤"></a>5.3.1 文件过滤</h3><p><code>scandir()</code> 可以让使用者自定义文件的过滤方式, 然后将过滤函数的地址传递给 <code>scandir()</code> 的第三个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 过滤函数的原型</span></span><br><span class="line"><span class="comment">// 函数的参数就是遍历的目录中的子文件对应的结构体</span></span><br><span class="line"><span class="type">int</span> (*filter)(<span class="type">const</span> <span class="keyword">struct</span> dirent *);</span><br></pre></td></tr></table></figure><blockquote><p>基于这个函数指针定义的函数就可以称之为回调函数,<br>这个函数不是由我们调用, 而是通过 <code>scandir()</code> 调用，因此这个函数的实参也是由 <code>scandir()</code> 函数提供的，作为回调函数的编写人员，只需搞清这个参数的含义是什么，然后在函数体中直接使用即可。</p></blockquote><p>假设判断目录中某一个文件是否为Mp3格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isMp3</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dirent *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr-&gt;d_type == DT_REG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* p = <span class="built_in">strstr</span>(ptr-&gt;d_name, <span class="string">&quot;.mp3&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">NULL</span> &amp;&amp; *(p+<span class="number">4</span>) == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-3-2-遍历目录"><a href="#5-3-2-遍历目录" class="headerlink" title="5.3.2 遍历目录"></a>5.3.2 遍历目录</h3><p>了解了 <code>scandir()</code> 函数的使用后,<br>写一个程序, 搜索指定目录下的 mp3格式文件个数和文件名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件过滤函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isMp3</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dirent *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr-&gt;d_type == DT_REG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* p = <span class="built_in">strstr</span>(ptr-&gt;d_name, <span class="string">&quot;.mp3&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">NULL</span> &amp;&amp; *(p+<span class="number">4</span>) == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out path\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> **<span class="title">namelist</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> num = scandir(argv[<span class="number">1</span>], &amp;namelist, isMp3, alphasort);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file %d: %s\n&quot;</span>, i, namelist[i]-&gt;d_name);</span><br><span class="line">        <span class="built_in">free</span>(namelist[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(namelist);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再解析一下 scandir() 的第二个参数，传递的是一个二级指针的地址:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> **<span class="title">namelist</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> num = scandir(argv[<span class="number">1</span>], &amp;namelist, isMp3, alphasort);</span><br></pre></td></tr></table></figure><p>那么在这个 <code>namelist</code> 中存储的什么类型的数据呢？<br>也就是 <code>struct dirent **namelist</code> 指向的什么类型的数据?</p><p>答案: 指向的是一个指针数组 <code>struct dirent *namelist[]</code></p><ul><li>数组元素的个数就是遍历的目录中的文件个数</li><li>数组的每个元素都是指针类型: <code>struct dirent *</code><br>指针指向的地址是由 <code>scandir()</code> 函数分配的, 因此在使用完毕之后需要释放内存</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程同步异步和原子变量</title>
      <link href="/2023/10/22/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/"/>
      <url>/2023/10/22/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-线程的使用"><a href="#1-线程的使用" class="headerlink" title="1.线程的使用"></a>1.线程的使用</h1><blockquote><p>C++11中增加了线程以及线程相关的类，支持了并发编程，提高了编写的多线程程序的可移植性<br>C++11中提供的线程类叫做<code>std::thread</code>，基于这个类创建一个新的线程非常的简单，只需要提供线程函数或者函数对象即可，并且可以同时指定线程函数的参数。<br>以下了解以下常用API</p></blockquote><h2 id="1-1-函数构造"><a href="#1-1-函数构造" class="headerlink" title="1.1 函数构造"></a>1.1 函数构造</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">thread</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">thread</span>(thread&amp;&amp; other) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Function, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span><span class="params">( Function&amp;&amp; f, Args&amp;&amp;... args )</span></span>;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="built_in">thread</span>( <span class="type">const</span> thread&amp; ) = <span class="keyword">delete</span>;。</span><br></pre></td></tr></table></figure><ul><li><p>构造函数①：默认构造函数，构造一个线程对象，在这个线程中不执行任何处理动作</p></li><li><p>构造函数②：移动构造函数，将 other 的线程所有权转移给新的thread 对象。<br>之后 other 不再表示执行线程。</p></li><li><p>构造函数③：创建线程对象，并在该线程中执行函数f中的业务逻辑，args是要传递给函数f的参数</p><ul><li><p>任务函数f的可选类型有很多，具体如下：</p><ul><li>普通函数，类成员函数，匿名函数，仿函数（这些都是可调用对象类型）</li><li>可以是可调用对象包装器类型，也可是使用绑定器绑定之后得到的类型（仿函数）</li></ul></li></ul></li><li><p>构造函数④：使用&#x3D;delete显示删除拷贝构造, 不允许线程对象之间的拷贝</p></li></ul><hr><h2 id="1-2-公共成员函数"><a href="#1-2-公共成员函数" class="headerlink" title="1.2 公共成员函数"></a>1.2 公共成员函数</h2><h3 id="1-2-1-get-id"><a href="#1-2-1-get-id" class="headerlink" title="1.2.1 get_id()"></a>1.2.1 get_id()</h3><blockquote><p>应用程序启动之后默认只有一个线程，这个线程一般称之为<code>主线程或父线程</code>，通过线程类创建出的线程一般称之为<code>子线程</code>，每个被创建出的线程实例都对应一个线程ID，这个ID是唯一的，可以通过这个ID来区分和识别各个已经存在的线程实例，这个获取线程ID的函数叫做<code>get_id()</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line">std::<span class="function">thread::id <span class="title">get_id</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> num, string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;num: &quot;</span> </span><br><span class="line">             &lt;&lt; num &lt;&lt; <span class="string">&quot;, str: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程的线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func, <span class="number">520</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t 的线程ID: &quot;</span> &lt;&lt; t.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t1的线程ID: &quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>thread t(func, 520, “i love you”);</p><ul><li>线程类的构造函数③是一个<code>变参函数</code>，因此无需担心线程任务函数的参数个数问题</li><li>任务函数func()一般返回值为void，因为子线程在调用这个函数的时候<code>不会处理其返回值</code></li></ul></li><li><p>thread t1(func1);</p><ul><li>子线程对象t1中的任务函数func1()，没有参数，因此在线程构造函数中就无需指定了</li></ul></li><li><p>通过线程对象调用<code>get_id()</code>就可以知道这个子线程的线程ID:<code>t.get_id()</code>,<code>t1.get_id()</code></p></li></ul><blockquote><p>但在上面的示例程序中有bug<br>有可能子线程中的任务还没有执行完毕，主线程就结束了,最后也得不到我们想要的结果。</p></blockquote><p>当启动了一个线程（创建了一个thread对象）之后，在这个线程结束的时候（std::terminate()），我们如何去回收线程所使用的资源呢？thread库给我们两种选择：</p><ul><li><code>加入式（join()）</code></li><li><code>分离式（detach()）</code></li></ul><p>我们必须要在线程对象销毁之前在二者之间作出选择，否则程序运行期间会有bug产生。</p><hr><h3 id="1-2-2-join"><a href="#1-2-2-join" class="headerlink" title="1.2.2 join()"></a>1.2.2 join()</h3><blockquote><p>join()字面意思是连接一个线程，意味着主动地等待线程的终止（线程阻塞）。<br>在某个线程中通过子线程对象调用join()函数，调用这个函数的线程被阻塞<br>子线程对象中的任务函数会继续执行，当任务执行完毕之后join()会清理当前子线程中的相关资源然后返回，同时，调用该函数的线程解除阻塞继续向下执行。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>解决后如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程的线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func, <span class="number">520</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t 的线程ID: &quot;</span> &lt;&lt; t.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t1的线程ID: &quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为了更好的理解join()的使用，再举一个例子，场景如下：<br>程序中一共有三个线程，其中两个子线程负责分段处理函数，完毕之后，由主线程对这个文件进行下一步处理</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(download1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(download2)</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞主线程，等待所有子线程任务执行完毕再继续向下执行</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-2-3-detach"><a href="#2-2-3-detach" class="headerlink" title="2.2.3 detach()"></a>2.2.3 detach()</h3><blockquote><p><code>detach()</code>函数的作用是进行线程分离，分离主线程和创建出的子线程。<br>在线程分离之后，主线程退出也会一并销毁创建出的所有子线程<br>在主线程退出之前，它可以脱离主线程继续独立的运行<br>任务执行完毕之后，这个子线程会自动释放自己占用的系统资源。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>线程分离函数没有参数也没有返回值，只需要在线程成功之后，通过线程对象调用该函数即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程的线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func, <span class="number">520</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t 的线程ID: &quot;</span> &lt;&lt; t.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t1的线程ID: &quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="comment">// 让主线程休眠, 等待子线程执行完毕</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>注意</code>：detach()不会阻塞线程<br>子线程和主线程分离之后，<code>主线程就不能再对这个子线程做任何控制</code><br>比如：通过join()阻塞主线程等待子线程中的任务执行完毕，或调用get_id()获取子线程的线程ID。</p><hr><h3 id="2-2-5-joinable"><a href="#2-2-5-joinable" class="headerlink" title="2.2.5 joinable()"></a>2.2.5 joinable()</h3><p><code>joinable()</code>函数用于判断主线程和子线程是否处理关联（连接）状态</p><ul><li>返回值为<code>true</code>：主线程和子线程之间有关联（连接）关系</li><li>返回值为<code>false</code>：主线程和子线程之间没有关联（连接）关系</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread t;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before starting, joinable: &quot;</span> &lt;&lt; t.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t = <span class="built_in">thread</span>(foo);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after starting, joinable: &quot;</span> &lt;&lt; t.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after joining, joinable: &quot;</span> &lt;&lt; t.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(foo)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after starting, joinable: &quot;</span> &lt;&lt; t1.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after detaching, joinable: &quot;</span> &lt;&lt; t1.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">before starting, joinable: <span class="number">0</span></span><br><span class="line">after starting, joinable: <span class="number">1</span></span><br><span class="line">after joining, joinable: <span class="number">0</span></span><br><span class="line">after starting, joinable: <span class="number">1</span></span><br><span class="line">after detaching, joinable: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>给予结果我们可以得到如下结论</p><ul><li>在创建的子线程对象的时候，如果没有指定任务函数，那么子线程不会启动，主线程和这个子线程也不会进行连接</li><li>在创建的子线程对象的时候，如果指定了任务函数，子线程启动并执行任务，主线程和这个子线程自动连接成功</li><li>子线程调用了detach()函数之后，父子线程分离，同时二者的连接断开，调用joinable()返回false</li><li>在子线程调用了join()函数，子线程中的任务函数继续执行，直到任务处理完毕<br>这时join()会清理（回收）当前子线程的相关资源，所以这个子线程和主线程的连接也就断开了，因此，调用join()之后再调用joinable()会返回false。</li></ul><hr><h3 id="2-2-6-operator"><a href="#2-2-6-operator" class="headerlink" title="2.2.6 operator&#x3D;"></a>2.2.6 operator&#x3D;</h3><blockquote><p>线程中的资源是不能被复制的，因此通过&#x3D;操作符进行赋值操作最终并不会得到两个完全相同的对象。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// move (1)</span></span><br><span class="line">thread&amp; <span class="keyword">operator</span>= (thread&amp;&amp; other) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// copy [deleted] (2)</span></span><br><span class="line">thread&amp; <span class="keyword">operator</span>= (<span class="type">const</span> other&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><p>通过以上&#x3D;操作符的重载声明可以得知：</p><ul><li>如果other是一个右值，会进行资源所有权的转移</li><li>如果other不是右值，禁止拷贝，该函数被显示删除（&#x3D;delete），不可用</li></ul><hr><h2 id="1-3-静态函数"><a href="#1-3-静态函数" class="headerlink" title="1.3 静态函数"></a>1.3 静态函数</h2><blockquote><p>thread线程类还提供了一个静态方法，用于获取当前计算机的CPU核心数<br> 根据这个结果可以在程序中创建出数量相等的线程<br><code>每个线程独占一个CPU核心，这些线程就不用分时复用CPU时间片，此时程序的并发效率是最高的。</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="title">hardware_concurrency</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;CPU number: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-4-call-once"><a href="#1-4-call-once" class="headerlink" title="1.4 call_once"></a>1.4 call_once</h2><blockquote><p>在某些特定情况下，某些函数只能在多线程环境下调用一次，比如：要初始化某个对象，而这个对象只能被初始化一次<br>可以使用<code>std::call_once()</code>来保证函数在多线程环境下只能被调用一次。使用call_once()的时候，需要一个<code>once_flag</code>作为call_once()的传入参数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="comment">// 定义于头文件 &lt;mutex&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Callable, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_once</span><span class="params">( std::once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>flag</code>：once_flag类型的对象，要保证这个对象能够被多个线程同时访问到</li><li><code>f</code>：回调函数，可以传递一个有名函数地址，也可以指定一个匿名函数</li><li><code>args</code>：作为实参传递给回调函数</li></ul><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">once_flag g_flag;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_once</span><span class="params">(<span class="type">int</span> a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">(<span class="type">int</span> age, string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">call_once</span>(g_flag, do_once, <span class="number">19</span>, <span class="string">&quot;luffy&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;do_something() function num = &quot;</span> &lt;&lt; num++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(do_something, <span class="number">20</span>, <span class="string">&quot;ace&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(do_something, <span class="number">20</span>, <span class="string">&quot;sabo&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(do_something, <span class="number">19</span>, <span class="string">&quot;luffy&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name: luffy, age: <span class="number">19</span></span><br><span class="line"><span class="built_in">do_something</span>() function num = <span class="number">1</span></span><br><span class="line"><span class="built_in">do_something</span>() function num = <span class="number">2</span></span><br><span class="line"><span class="built_in">do_something</span>() function num = <span class="number">3</span></span><br></pre></td></tr></table></figure><hr><h1 id="2-this-thread-命名空间"><a href="#2-this-thread-命名空间" class="headerlink" title="2. this_thread 命名空间"></a>2. this_thread 命名空间</h1><blockquote><p>在C++11中不仅添加了线程类，还添加了一个关于线程的命名空间<code>std::this_thread</code><br>在这个命名空间中提供了四个公共的成员函数</p></blockquote><h2 id="2-1-get-id"><a href="#2-1-get-id" class="headerlink" title="2.1 get_id()"></a>2.1 get_id()</h2><blockquote><p>所说曾相识,但还是有所不同<br>调用命名空间std::this_thread中的get_id()方法可以得到当前线程的线程ID</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="function">thread::id <span class="title">get_id</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-2-sleep-for"><a href="#2-2-sleep-for" class="headerlink" title="2.2 sleep_for()"></a>2.2 sleep_for()</h2><blockquote><p>线程被创建后有这五种状态：创建态，就绪态，运行态，阻塞态(挂起态)，退出态(终止态)<br>关于状态之间的转换和进程是一样的</p></blockquote><p>线程和进程的执行有很多相似之处，在计算机中启动的多个线程都需要占用CPU资源<br>但是CPU的个数是有限的并且每个CPU在同一时间点不能同时处理多个任务。<br>为了实现并发处理，多个线程都是分时复用CPU时间片，快速的交替处理各个线程中的任务。<br>因此多个线程之间需要争抢CPU时间片，抢到了就执行，抢不到则无法执行<br>因为默认所有的线程优先级都相同，内核也会从中调度，不会出现某个线程永远抢不到CPU时间片的情况。</p><p>命名空间<code>this_thread</code>中提供了一个休眠函数<code>sleep_for()</code><br>调用这个函数的线程会马上从<code>运行态变成阻塞态</code>并在这种状态下<code>休眠</code>一定的时长<br>因为阻塞态的线程已经让出了CPU资源，代码也不会被执行，所以线程休眠过程中对CPU来说没有任何负担。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sleep_for</span> <span class="params">(<span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time)</span></span>;</span><br></pre></td></tr></table></figure><p>参数需要指定一个休眠时长，是一个时间段</p><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在func()函数的for循环中使用了<code>this_thread::sleep_for(chrono::seconds(1));</code>之后，每循环一次程序都会阻塞1秒钟，也就是说每隔1秒才会进行一次输出。<br><code>注意</code>：程序休眠完成之后，会从阻塞态重新变成就绪态，就绪态的线程需要再次争抢CPU时间片，抢到之后才会变成运行态，这时候程序才会继续向下运行。</p><hr><h2 id="2-3-sleep-until"><a href="#2-3-sleep-until" class="headerlink" title="2.3 sleep_until()"></a>2.3 sleep_until()</h2><blockquote><p>命名空间<code>this_thread</code>中提供了另一个休眠函数<code>sleep_until()</code>，和<code>sleep_for()</code>不同的是它的参数类型不一样<br><code>sleep_until()</code>：指定线程阻塞到某一个指定的时间点<code>time_point</code>类型，之后解除阻塞<br><code>sleep_for()</code>：指定线程阻塞一定的时间长度<code>duration</code> 类型，之后解除阻塞</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sleep_until</span> <span class="params">(<span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)</span></span>;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取当前系统时间点</span></span><br><span class="line">        <span class="keyword">auto</span> now = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="comment">// 时间间隔为2s</span></span><br><span class="line">        <span class="function">chrono::seconds <span class="title">sec</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 当前时间点之后休眠两秒</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_until</span>(now + sec);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sleep_until()</code>和<code>sleep_for()</code>函数的功能是一样的<br>只不过前者是基于时间点去阻塞线程<br>后者是基于时间段去阻塞线程</p><hr><h2 id="2-4-yield"><a href="#2-4-yield" class="headerlink" title="2.4  yield()"></a>2.4  yield()</h2><blockquote><p>命名空间<code>this_thread</code>中提供了一个非常绅士的函数<code>yield()</code><br>在线程中调用这个函数后，处于运行态的线程会主动让出自己已经抢到的CPU时间片，最终变为<code>就绪态</code><br>这样其它的线程就有更大的概率能够抢到CPU时间片了。<br><code>注意</code>:线程调用了yield()之后,这个线程会马上参与到下一轮CPU的抢夺中</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yield</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的程序中，执行func()中的for循环会占用大量的时间<br>极端情况下，如果当前线程占用CPU资源不释放就会导致其他线程中的任务无法被处理，或者该线程每次都能抢到CPU时间片，导致其他线程中的任务没有机会被执行。<br>解决方案就是每执行一次循环，让该线程主动放弃CPU资源，重新和其他线程再次抢夺CPU时间片，如果其他线程抢到了CPU时间片就可以执行相应的任务了。</p><p>结论：<code>std::this_thread::yield()</code> 的目的是避免一个线程长时间占用CPU资源，从而导致多线程处理性能下降</p><hr><h1 id="3-线程同步之互斥锁"><a href="#3-线程同步之互斥锁" class="headerlink" title="3. 线程同步之互斥锁"></a>3. 线程同步之互斥锁</h1><p>进行多线程编程，如果多个线程需要对同一块内存进行操作，比如：<code>同时读</code>、<code>同时写</code>、<code>同时读写</code>对于后两种情况来说，如果不做任何的人为干涉就会出现各种各样的错误数据。<br>这是因为线程在运行的时候需要先得到CPU时间片，时间片用完之后需要放弃已获得的CPU资源，就这样线程频繁地在就绪态和运行态之间切换，更复杂一点还可以在就绪态、运行态、挂起态之间切换，这样就会导致线程的执行顺序并不是有序的，而是随机的混乱的</p><p>解决多线程数据混乱的方案就是进行线程同步，最常用的就是互斥锁，在C++11中一共提供了四种互斥锁：</p><ul><li><code>std::mutex</code>：独占的互斥锁，不能递归使用</li><li><code>std::timed_mutex</code>：带超时的独占互斥锁，不能递归使用</li><li><code>std::recursive_mutex</code>：递归互斥锁，不带超时功能</li><li><code>std::recursive_timed_mutex</code>：带超时的递归互斥锁</li></ul><p>互斥锁在有些资料中也被称之为<code>互斥量</code>，二者是一个东西。</p><h2 id="3-1-std-mutex"><a href="#3-1-std-mutex" class="headerlink" title="3.1 std:mutex"></a>3.1 std:mutex</h2><p>不论是在C还是C++中，进行线程同步的处理流程基本上是一致的，C++的mutex类提供了相关的API函数：</p><h3 id="3-1-1-成员函数"><a href="#3-1-1-成员函数" class="headerlink" title="3.1.1 成员函数"></a>3.1.1 成员函数</h3><p><code>lock()</code>函数用于给临界区加锁，并且只能有一个线程获得锁的所有权，它有阻塞线程的作用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>独占互斥锁对象有两种状态：锁定和未锁定。<br>如果互斥锁是打开的，调用lock()函数的线程会得到互斥锁的所有权，并将其上锁，其它线程再调用该函数的时候由于得不到互斥锁的所有权，就会被lock()函数阻塞。<br>当拥有互斥锁所有权的线程将互斥锁解锁，此时被lock()阻塞的线程解除阻塞，抢到互斥锁所有权的线程加锁并继续运行，没抢到互斥锁所有权的线程继续阻塞。</p><p>除了使用<code>lock()</code>还可以使用<code>try_lock()</code>获取互斥锁的所有权并对互斥锁加锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>二者的区别在于try_lock()不会阻塞线程，lock()会阻塞线程：</p><ul><li>如果互斥锁是未锁定状态，得到了互斥锁所有权并加锁成功，函数返回true</li><li>如果互斥锁是锁定状态，无法得到互斥锁所有权加锁失败，函数返回false</li></ul><p>当互斥锁被锁定之后可以通过<code>unlock()</code>进行解锁，但是需要注意的是<code>只有拥有互斥锁所有权的线程也就是对互斥锁上锁的线程才能将其解锁</code>，其它线程是没有权限做这件事情的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>使用互斥锁进行线程同步的大致思路主要分为以下几步：</p><ol><li>找到多个线程操作的共享资源(全局变量、堆内存、类成员变量等),也可以称之为临界资源</li><li>找到和共享资源有关的上下文代码，也就是临界区（下图中的黄色代码部分）</li><li>在临界区的上边调用互斥锁类的<code>lock()</code>方法</li><li>在临界区的下边调用互斥锁的<code>unlock()</code>方法</li></ol><p>线程同步的目的是让多线程按照顺序依次执行临界区代码，这样做线程对共享资源的访问就从并行访问变为了线性访问，访问<code>效率降低</code>，但是保证了数据的正确性。</p><p><img src="/img/8.24.png" alt="在这里插入图片描述"></p><hr><h3 id="3-1-2-线程同步"><a href="#3-1-2-线程同步" class="headerlink" title="3.1.2 线程同步"></a>3.1.2 线程同步</h3><p>让两个线程共同操作一个全局变量，二者交替数数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_num = <span class="number">0</span>;  <span class="comment">// 为 g_num_mutex 所保护</span></span><br><span class="line">mutex g_num_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slow_increment</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        g_num_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        </span><br><span class="line">        ++g_num;</span><br><span class="line">        cout &lt;&lt; id &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; g_num &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        g_num_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(slow_increment, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(slow_increment, <span class="number">1</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例程序中，两个子线程执行的任务的一样的（可以不一样，不同的任务中也可以对共享资源进行读写操作），在任务函数中把与全局变量相关的代码加了锁，两个线程只能顺序访问这部分代码（如果不进行线程同步打印出的数据是混乱且无序的）。</p><p><code>注意</code>:</p><ol><li>在所有线程的任务函数执行完毕之前，互斥锁对象是不能被析构的，一定要在程序中保证这个对象的可用性。</li><li>互斥锁的个数和共享资源的个数相等，也就是说每一个共享资源都应该对应一个互斥锁对象。互斥锁对象的个数和线程的个数没有关系。</li></ol><hr><h2 id="3-2-std-lock-guard"><a href="#3-2-std-lock-guard" class="headerlink" title="3.2 std::lock_guard"></a>3.2 std::lock_guard</h2><blockquote><p>lock_guard是C++11新增的一个模板类，使用这个类，可以<code>简化互斥锁lock()和unlock()</code>的写法，同时也<code>更安全</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义和常用的构造函数原型</span></span><br><span class="line"><span class="comment">// 类的定义，定义于头文件 &lt;mutex&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Mutex</span> &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_guard</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">lock_guard</span><span class="params">( mutex_type&amp; m )</span></span>;</span><br></pre></td></tr></table></figure><p><code>lock_guard</code>在使用上面的构造函数构造对象时，会自动锁定互斥量<br>而在退出作用域后进行析构时就会自动解锁，从而保证了互斥量的正确操作，避免忘记unlock()操作而导致线程死锁。<br><code>lock_guard</code>使用了RAII技术，就是在类构造函数中分配资源，在析构函数中释放资源，保证资源出了作用域就释放。</p><p>使用lock_guard对上面的例子进行修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slow_increment</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用哨兵锁管理互斥锁</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(g_num_mutex)</span></span>;</span><br><span class="line">        ++g_num;</span><br><span class="line">        cout &lt;&lt; id &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; g_num &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过修改发现代码被精简了，而且不用担心因为忘记解锁而造成程序的死锁<br><code>弊端</code>:在上面的示例程序中整个for循环的体都被当做了临界区，多个线程是线性的执行临界区代码的，因此临界区越大程序效率越低</p><hr><h2 id="3-3-std-recursive-mutex"><a href="#3-3-std-recursive-mutex" class="headerlink" title="3.3 std::recursive_mutex"></a>3.3 std::recursive_mutex</h2><blockquote><p>递归互斥锁<code>std::recursive_mutex</code>允许同一线程多次获得互斥锁，可以用来解决同一线程需要多次获取互斥量时死锁的问题</p></blockquote><p>使用独占非递归互斥量会发生<code>死锁</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Calculate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Calculate</span>() : <span class="built_in">m_i</span>(<span class="number">6</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_i *= x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">div</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_i /= x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">both</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="built_in">mul</span>(x);</span><br><span class="line">        <span class="built_in">div</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calculate cal;</span><br><span class="line">    cal.<span class="built_in">both</span>(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序中执行了<code>cal.both(6, 3);</code>调用之后，程序就会发生死锁<br>在<code>both()</code>中已经对互斥锁加锁了，继续调用<code>mult()</code>函数，已经得到互斥锁所有权的线程再次获取这个互斥锁的所有权就会造成死锁（在C++中程序会异常退出，使用C库函数会导致这个互斥锁永远无法被解锁，最终阻塞所有的线程）。<br>要解决这个死锁的问题，一个简单的办法就是使用递归互斥锁<code>std::recursive_mutex</code>，它允许一个线程多次获得互斥锁的所有权。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Calculate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Calculate</span>() : <span class="built_in">m_i</span>(<span class="number">6</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;recursive_mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_i *= x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">div</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;recursive_mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_i /= x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">both</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;recursive_mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="built_in">mul</span>(x);</span><br><span class="line">        <span class="built_in">div</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    recursive_mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calculate cal;</span><br><span class="line">    cal.<span class="built_in">both</span>(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;cal.m_i = &quot;</span> &lt;&lt; cal.m_i &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然递归互斥锁可以解决同一个互斥锁频繁获取互斥锁资源的问题，但是还是建议<code>少用</code></p><ol><li>使用递归互斥锁的场景往往都是可以简化的，使用递归互斥锁很容易放纵复杂逻辑的产生，从而导致bug的产生</li><li>递归互斥锁比非递归互斥锁效率要低一些。</li><li>递归互斥锁虽然允许同一个线程多次获得同一个互斥锁的所有权，但最大次数并未具体说明，一旦超过一定的次数，就会抛出std::system错误。</li></ol><hr><h2 id="3-4-std-timed-mutex"><a href="#3-4-std-timed-mutex" class="headerlink" title="3.4 std::timed_mutex"></a>3.4 std::timed_mutex</h2><blockquote><p><code>std::timed_mutex</code>是超时独占互斥锁，主要是在获取互斥锁资源时增加了超时等待功能，因为不知道获取锁资源需要等待多长时间，为了保证不一直等待下去，设置了一个超时时长，超时后线程就可以解除阻塞去做其他事情了。</p></blockquote><p><code>std::timed_mutex</code>比<code>std::_mutex</code>多了两个成员函数：<code>try_lock_for()</code> <code>try_lock_until()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::timed_mutex比std::_mutex多出的两个成员函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">try_lock_for</span> <span class="params">(<span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">try_lock_until</span> <span class="params">(<span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>try_lock_for</code>函数是当线程获取不到互斥锁资源时，让线程阻塞一定的时间长度</li><li><code>try_lock_until</code>函数是当线程获取不到互斥锁资源时，让线程阻塞到某一个指定的时间点</li><li>关于两个函数的返回值<br>当得到互斥锁的所有权之后，函数会马上解除阻塞，返回true<br>如果阻塞的时长用完或者到达指定的时间点之后，函数也会解除阻塞，返回false</li></ul><p>演示std::timed_mutex的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">timed_mutex g_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">chrono::seconds <span class="title">timeout</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过阻塞一定的时长来争取得到互斥锁所有权</span></span><br><span class="line">        <span class="keyword">if</span> (g_mutex.<span class="built_in">try_lock_for</span>(timeout))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;当前线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() </span><br><span class="line">                &lt;&lt; <span class="string">&quot;, 得到互斥锁所有权...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 模拟处理任务用了一定的时长</span></span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">10</span>));</span><br><span class="line">            <span class="comment">// 互斥锁解锁</span></span><br><span class="line">            g_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;当前线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() </span><br><span class="line">                &lt;&lt; <span class="string">&quot;, 没有得到互斥锁所有权...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 模拟处理其他任务用了一定的时长</span></span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(work)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(work)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码输出的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">当前线程ID: <span class="number">125776</span>, 得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 没有得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 没有得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 没有得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 没有得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 没有得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 没有得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 没有得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 没有得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 没有得到互斥锁所有权...</span><br><span class="line">当前线程ID: <span class="number">112324</span>, 得到互斥锁所有权...</span><br></pre></td></tr></table></figure><p>在上面的例子中，通过一个while循环不停的去获取超时互斥锁的所有权，如果得不到就阻塞1秒钟，1秒之后如果还是得不到阻塞50毫秒，然后再次继续尝试，直到获得互斥锁的所有权，跳出循环体。</p><p>递归超时互斥锁<code>std::recursive_timed_mutex</code>的使用方式和<code>std::timed_mutex</code>是一样的<br>只不过它可以允许一个线程多次获得互斥锁所有权<br>而<code>std::timed_mutex</code>只允许线程获取一次互斥锁所有权。<br>递归超时互斥锁<code>std::recursive_timed_mutex</code>也拥有和&#96;std::recursive_mutex&#96;&#96;一样的弊端</p><hr><h1 id="4-线程同步之条件变量"><a href="#4-线程同步之条件变量" class="headerlink" title="4.线程同步之条件变量"></a>4.线程同步之条件变量</h1><blockquote><p>条件变量是C++11提供的另外一种用于等待的同步机制，它能阻塞一个或多个线程，直到收到另外一个线程发出的通知或者超时时，才会唤醒当前阻塞的线程。<br>条件变量需要和互斥量配合起来使用</p></blockquote><p>C++11提供了两种条件变量：</p><ul><li><code>condition_variable</code>：需要配合<code>std::unique_lock&lt;std::mutex&gt;</code>进行<code>wait</code>操作，也就是阻塞线程的操作。</li><li><code>condition_variable_any</code>：可以和任意带有<code>lock()</code>、<code>unlock()</code>语义的mutex搭配使用，也就是说有四种：<ol><li><code>std::mutex</code>：独占的非递归互斥锁</li><li><code>std::timed_mutex</code>：带超时的独占非递归互斥锁</li><li><code>std::recursive_mutex</code>：不带超时功能的递归互斥锁</li><li><code>std::recursive_timed_mutex</code>：带超时的递归互斥锁</li></ol></li></ul><p>条件变量通常用于生产者和消费者模型，大致使用过程如下：</p><ol><li>拥有条件变量的线程获取互斥量</li><li>循环检查某个条件，如果条件不满足阻塞当前线程，否则线程继续向下执行<ul><li>产品的数量达到上限，生产者阻塞，否则生产者一直生产</li><li>产品的数量为零，消费者阻塞，否则消费者一直消费</li></ul></li><li>条件满足之后，可以调用<code>notify_one()</code>或<code>notify_all()</code>唤醒一个或所有被阻塞的线程<ul><li>由消费者唤醒被阻塞的生产者，生产者解除阻塞继续生产</li><li>由生产者唤醒被阻塞的消费者，消费者解除阻塞继续消费</li></ul></li></ol><hr><h2 id="4-1-condition-variable"><a href="#4-1-condition-variable" class="headerlink" title="4.1 condition_variable"></a>4.1 condition_variable</h2><h3 id="4-1-1-成员函数"><a href="#4-1-1-成员函数" class="headerlink" title="4.1.1 成员函数"></a>4.1.1 成员函数</h3><blockquote><p>condition_variable的成员函数主要分为两部分：线程等待(阻塞)函数和线程通知(唤醒)函数<br>这些函数被定义于头文件<code>&lt;condition_variable&gt;</code></p></blockquote><ul><li>等待函数</li></ul><p>调用<code>wait()</code>函数的线程会被阻塞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck)</span></span>;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>函数①：调用该函数的线程直接被阻塞</p></li><li><p>函数②：该函数的第二个参数是一个判断条件，是一个返回值为布尔类型的函数</p><ul><li>该参数可以传递一个有名函数的地址，也可以直接指定一个匿名函数</li><li>表达式返回<code>false</code>当前线程被阻塞</li><li>表达式返回<code>true</code>当前线程不会被阻塞，继续向下执行</li></ul></li><li><p>独占的互斥锁对象不能直接传递给<code>wait()</code>函数，需要通过模板类<code>unique_lock</code>进行二次处理，通过得到的对象仍然可以对独占的互斥锁对象做如下操作，使用起来更灵活。</p></li></ul><table><thead><tr><th>公共成员函数</th><th>说明</th></tr></thead><tbody><tr><td>lock</td><td>锁定关联的互斥锁</td></tr><tr><td>try_lock</td><td>尝试锁定关联的互斥锁，若无法锁定，函数直接返回</td></tr><tr><td>try_lock_for</td><td>试图锁定关联的可定时锁定互斥锁，若互斥锁在给定时长中仍不能被锁定，函数返回</td></tr><tr><td>try_lock_until</td><td>试图锁定关联的可定时锁定互斥锁，若互斥锁在给定的时间点后仍不能被锁定，函数返回</td></tr><tr><td>unlock</td><td>将互斥锁解锁</td></tr></tbody></table><ul><li>如果线程被该函数阻塞，这个线程会释放占有的互斥锁的所有权<br>当阻塞解除之后这个线程会重新得到互斥锁的所有权，继续向下执行（这个过程是在函数内部完成的,其目的是为了避免线程的死锁）。</li></ul><hr><blockquote><p><code>wait_for()</code>函数和<code>wait()</code>的功能是一样的，只不过多了一个阻塞时长<br>假设阻塞的线程没有被其他线程唤醒，当阻塞时长用完之后，线程就会自动解除阻塞，继续向下执行。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>&gt;</span><br><span class="line"><span class="function">cv_status <span class="title">wait_for</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_for</span><span class="params">(unique_lock&lt;mutex&gt;&amp; lck,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><hr><blockquote><p><code>wait_until()</code>函数和<code>wait_for()</code>的功能是一样的，它是指定让线程阻塞到某一个时间点，假设阻塞的线程没有被其他线程唤醒，当到达指定的时间点之后，线程就会自动解除阻塞，继续向下执行。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line"><span class="function">cv_status <span class="title">wait_until</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_until</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>通知函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_one</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_all</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><pre><code>notify_one()：唤醒一个被当前条件变量阻塞的线程notify_all()：唤醒全部被当前条件变量阻塞的线程</code></pre><hr><hr><h3 id="4-1-2-生产者和消费者模型"><a href="#4-1-2-生产者和消费者模型" class="headerlink" title="4.1.2 生产者和消费者模型"></a>4.1.2 生产者和消费者模型</h3><blockquote><p>我们可以使用条件变量来实现一个同步队列，这个队列作为生产者线程和消费者线程的共享资源</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SyncQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SyncQueue</span>(<span class="type">int</span> maxSize) : <span class="built_in">m_maxSize</span>(maxSize) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="comment">// 判断任务队列是不是已经满了</span></span><br><span class="line">        <span class="keyword">while</span> (m_queue.<span class="built_in">size</span>() == m_maxSize)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;任务队列已满, 请耐心等待...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 阻塞线程</span></span><br><span class="line">            m_notFull.<span class="built_in">wait</span>(locker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将任务放入到任务队列中</span></span><br><span class="line">        m_queue.<span class="built_in">push_back</span>(x);</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; 被生产&quot;</span> &lt;&lt; endl; </span><br><span class="line">        <span class="comment">// 通知消费者去消费</span></span><br><span class="line">        m_notEmpty.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">take</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (m_queue.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;任务队列已空，请耐心等待。。。&quot;</span> &lt;&lt; endl;</span><br><span class="line">            m_notEmpty.<span class="built_in">wait</span>(locker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从任务队列中取出任务(消费)</span></span><br><span class="line">        <span class="type">int</span> x = m_queue.<span class="built_in">front</span>();</span><br><span class="line">        m_queue.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="comment">// 通知生产者去生产</span></span><br><span class="line">        m_notFull.<span class="built_in">notify_one</span>();</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; 被消费&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>() == m_maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; m_queue;     <span class="comment">// 存储队列数据</span></span><br><span class="line">    mutex m_mutex;         <span class="comment">// 互斥锁</span></span><br><span class="line">    condition_variable m_notEmpty;   <span class="comment">// 不为空的条件变量</span></span><br><span class="line">    condition_variable m_notFull;    <span class="comment">// 没有满的条件变量</span></span><br><span class="line">    <span class="type">int</span> m_maxSize;         <span class="comment">// 任务队列的最大任务个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SyncQueue <span class="title">taskQ</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> produce = <span class="built_in">bind</span>(&amp;SyncQueue::put, &amp;taskQ, placeholders::_1);</span><br><span class="line">    <span class="keyword">auto</span> consume = <span class="built_in">bind</span>(&amp;SyncQueue::take, &amp;taskQ);</span><br><span class="line">    thread t1[<span class="number">3</span>];</span><br><span class="line">    thread t2[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t1[i] = <span class="built_in">thread</span>(produce, i+<span class="number">100</span>);</span><br><span class="line">        t2[i] = <span class="built_in">thread</span>(consume);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t1[i].<span class="built_in">join</span>();</span><br><span class="line">        t2[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件变量<code>condition_variable</code>类的<code>wait()</code>还有一个重载的方法<br>可以接受一个条件，这个条件也可以是一个返回值为布尔类型的函数，条件变量会先检查判断这个条件是否满足<br>如满足条（布尔值为true），则当前线程重新获得互斥锁的所有权，结束阻塞，继续向下执行；<br>如不满足（布尔值为false），当前线程会释放互斥锁（解锁）同时被阻塞，等待被唤醒。</p><blockquote><p>上面示例程序中的put()、take()函数可以做如下修改：</p></blockquote><ul><li>put()函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 根据条件阻塞线程</span></span><br><span class="line">    m_notFull.<span class="built_in">wait</span>(locker, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>() != m_maxSize;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 将任务放入到任务队列中</span></span><br><span class="line">    m_queue.<span class="built_in">push_back</span>(x);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; 被生产&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 通知消费者去消费</span></span><br><span class="line">    m_notEmpty.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>take()函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">take</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    m_notEmpty.<span class="built_in">wait</span>(locker, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">        <span class="keyword">return</span> !m_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 从任务队列中取出任务(消费)</span></span><br><span class="line">    <span class="type">int</span> x = m_queue.<span class="built_in">front</span>();</span><br><span class="line">    m_queue.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="comment">// 通知生产者去生产</span></span><br><span class="line">    m_notFull.<span class="built_in">notify_one</span>();</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; 被消费&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后可以发现，程序变得更加精简了，而且执行效率更高了，因为在这两个函数中的while循环被删掉了，但是最终的效果是一样的，推荐使用这种方式的wait()进行线程的阻塞。</p><hr><h2 id="4-2-condition-variable-any"><a href="#4-2-condition-variable-any" class="headerlink" title="4.2 condition_variable_any"></a>4.2 condition_variable_any</h2><h3 id="4-2-1-成员函数"><a href="#4-2-1-成员函数" class="headerlink" title="4.2.1 成员函数"></a>4.2.1 成员函数</h3><blockquote><p>condition_variable_any的成员函数也是分为两部分：线程等待（阻塞）函数 和线程通知（唤醒）函数，这些函数被定义于头文件 <code>&lt;condition_variable&gt;</code></p></blockquote><ul><li>等待函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>&gt; <span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(Lock&amp; lck)</span></span>;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(Lock&amp; lck, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>函数①：调用该函数的线程直接被阻塞</li><li>函数②：该函数的第二个参数是一个判断条件，是一个返回值为布尔类型的函数<ul><li>该参数可以传递一个有名函数的地址，也可以直接指定一个匿名函数</li><li>表达式返回false当前线程被阻塞，表达式返回true当前线程不会被阻塞，继续向下执行</li></ul></li><li>可以直接传递给wait()函数的互斥锁类型有四种，分别是：<br>std::mutex、std::timed_mutex、std::recursive_mutex、std::recursive_timed_mutex</li><li>如果线程被该函数阻塞，这个线程会释放占有的互斥锁的所有权，当阻塞解除之后这个线程会重新得到互斥锁的所有权，继续向下执行（这个过程是在函数内部完成的，了解这个过程即可，其目的是为了避免线程的死锁）。</li></ul><blockquote><p>wait_for()函数和wait()的功能是一样的，只不过多了一个阻塞时长，假设阻塞的线程没有被其他线程唤醒，当阻塞时长用完之后，线程就会自动解除阻塞，继续向下执行。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>, <span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>&gt;</span><br><span class="line"><span class="function">cv_status <span class="title">wait_for</span> <span class="params">(Lock&amp; lck, <span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>, <span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_for</span> <span class="params">(Lock&amp; lck, <span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>wait_until()函数和wait_for()的功能是一样的，它是指定让线程阻塞到某一个时间点，假设阻塞的线程没有被其他线程唤醒，当到达指定的时间点之后，线程就会自动解除阻塞，继续向下执行。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>, <span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line"><span class="function">cv_status <span class="title">wait_until</span> <span class="params">(Lock&amp; lck, <span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>, <span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_until</span> <span class="params">(Lock&amp; lck, </span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time, </span></span></span><br><span class="line"><span class="params"><span class="function">                 Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>通知函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_one</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_all</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><pre><code>notify_one()：唤醒一个被当前条件变量阻塞的线程notify_all()：唤醒全部被当前条件变量阻塞的线程</code></pre><hr><h3 id="4-2-2-生产者和消费者模型"><a href="#4-2-2-生产者和消费者模型" class="headerlink" title="4.2.2 生产者和消费者模型"></a>4.2.2 生产者和消费者模型</h3><blockquote><p>使用条件变量condition_variable_any同样可以实现上面的生产者和消费者的例子<br>代码只有个别细节上有所不同：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SyncQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SyncQueue</span>(<span class="type">int</span> maxSize) : <span class="built_in">m_maxSize</span>(maxSize) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="comment">// 根据条件阻塞线程</span></span><br><span class="line">        m_notFull.<span class="built_in">wait</span>(m_mutex, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">return</span> m_queue.<span class="built_in">size</span>() != m_maxSize;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 将任务放入到任务队列中</span></span><br><span class="line">        m_queue.<span class="built_in">push_back</span>(x);</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; 被生产&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 通知消费者去消费</span></span><br><span class="line">        m_notEmpty.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">take</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_notEmpty.<span class="built_in">wait</span>(m_mutex, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">return</span> !m_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 从任务队列中取出任务(消费)</span></span><br><span class="line">        <span class="type">int</span> x = m_queue.<span class="built_in">front</span>();</span><br><span class="line">        m_queue.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="comment">// 通知生产者去生产</span></span><br><span class="line">        m_notFull.<span class="built_in">notify_one</span>();</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; 被消费&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>() == m_maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; m_queue;     <span class="comment">// 存储队列数据</span></span><br><span class="line">    mutex m_mutex;         <span class="comment">// 互斥锁</span></span><br><span class="line">    condition_variable_any m_notEmpty;   <span class="comment">// 不为空的条件变量</span></span><br><span class="line">    condition_variable_any m_notFull;    <span class="comment">// 没有满的条件变量</span></span><br><span class="line">    <span class="type">int</span> m_maxSize;         <span class="comment">// 任务队列的最大任务个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SyncQueue <span class="title">taskQ</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> produce = <span class="built_in">bind</span>(&amp;SyncQueue::put, &amp;taskQ, placeholders::_1);</span><br><span class="line">    <span class="keyword">auto</span> consume = <span class="built_in">bind</span>(&amp;SyncQueue::take, &amp;taskQ);</span><br><span class="line">    thread t1[<span class="number">3</span>];</span><br><span class="line">    thread t2[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t1[i] = <span class="built_in">thread</span>(produce, i + <span class="number">100</span>);</span><br><span class="line">        t2[i] = <span class="built_in">thread</span>(consume);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t1[i].<span class="built_in">join</span>();</span><br><span class="line">        t2[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：以上介绍的两种条件变量各自有各自的特点</p><p><code>condition_variable</code> 配合 <code>unique_lock</code> 使用更灵活，可以在在任何时候自由地释放互斥锁<br><code>condition_variable_any</code> 如果和<code>lock_guard</code> 一起使用必须要等到其生命周期结束才能将互斥锁释放。<br><code>condition_variable_any</code> 可以和多种互斥锁配合使用，应用场景也更广<br> <code>condition_variable</code> 只能和独占的非递归互斥锁（mutex）配合使用，有一定的局限性。</p><hr><h1 id="5-原子变量"><a href="#5-原子变量" class="headerlink" title="5. 原子变量"></a>5. 原子变量</h1><p>C++11提供了一个原子类型<code>std::atomic&lt;T&gt;</code>，通过这个原子类型管理的内部变量就可以称之为原子变量，我们可以给原子类型指定<code>bool、char、int、long、指针等类型</code>作为模板参数（<code>不支持浮点类型和复合类型</code>）。</p><p>原子指的是一系列不可被CPU上下文交换的机器指令，这些指令组合在一起就形成了原子操作。在多核CPU下，当某个CPU核心开始运行原子操作时，会先暂停其它CPU内核对内存的操作，以保证原子操作不会被其它CPU内核所干扰。</p><p>由于原子操作是通过指令提供的支持，因此它的性能相比锁和消息传递会好很多。<br>相比较于锁而言，原子类型不需要开发者处理加锁和释放锁的问题，同时支持修改，读取等操作，还具备较高的并发性能，几乎所有的语言都支持原子类型。</p><p>可以看出原子类型是无锁类型，但是无锁不代表无需等待，因为原子类型内部使用了<code>CAS</code>循环，当大量的冲突发生时，该等待还是得等待,但是总归<code>比锁要好</code>。</p><p>C++11内置了整形的原子变量，这样就可以更方便的使用原子变量了。在多线程操作中，使用原子变量之后就不需要再使用互斥量来保护该变量了，用起来更简洁。<br>因为对原子变量进行的操作只能是一个原子操作（atomic operation），<code>原子操作指的是不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何上下文切换。</code><br>多线程同时访问共享资源造成数据混乱的原因就是因为CPU的上下文切换导致的，使用原子变量解决了这个问题，因此互斥锁的使用也就不再需要了。</p><blockquote><p><code>CAS</code>全称是<code>Compare and swap</code><br>它通过一条指令读取指定的内存地址，然后判断其中的值是否等于给定的前置值<br>如果相等，则将其修改为新的值</p></blockquote><hr><h2 id="5-1-atomic-类成员"><a href="#5-1-atomic-类成员" class="headerlink" title="5.1 atomic 类成员"></a>5.1 atomic 类成员</h2><p>类定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义于头文件 &lt;atomic&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">atomic</span>;</span><br></pre></td></tr></table></figure><p>通过定义可得知：<code>在使用这个模板类的时候，一定要指定模板类型。</code></p><hr><h3 id="5-1-1-构造函数"><a href="#5-1-1-构造函数" class="headerlink" title="5.1.1 构造函数"></a>5.1.1 构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">atomic</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">atomic</span><span class="params">(T desired)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">atomic</span>(<span class="type">const</span> atomic&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><ul><li>构造函数①：默认无参构造函数。</li><li>构造函数②：使用 desired 初始化原子变量的值。</li><li>构造函数③：使用&#x3D;delete显示删除拷贝构造函数, <code>不允许进行对象之间的拷贝</code></li></ul><hr><h3 id="5-1-2-公共成员函数"><a href="#5-1-2-公共成员函数" class="headerlink" title="5.1.2 公共成员函数"></a>5.1.2 公共成员函数</h3><blockquote><p>原子类型在类内部重载了&#x3D;操作符，并且不允许在类的外部使用 &#x3D; 进行对象的拷贝。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">operator</span>=( T desired ) <span class="keyword">noexcept</span>;</span><br><span class="line">T <span class="keyword">operator</span>=( T desired ) <span class="keyword">volatile</span> <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">atomic&amp; <span class="keyword">operator</span>=( <span class="type">const</span> atomic&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">atomic&amp; <span class="keyword">operator</span>=( <span class="type">const</span> atomic&amp; ) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><hr><blockquote><p>以 <code>desired</code> 替换当前值。按照 <code>order</code> 的值影响内存。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span><span class="params">( T desired, std::memory_order order = std::memory_order_seq_cst )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span><span class="params">( T desired, std::memory_order order = std::memory_order_seq_cst )</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><ul><li>desired：存储到原子变量中的值</li><li>order：强制的内存顺序</li></ul><hr><blockquote><p>原子地加载并返回原子变量的当前值。按照 order 的值影响内存。直接访问原子对象也可以得到原子变量的当前值。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">load</span><span class="params">(std::memory_order order = std::memory_order_seq_cst)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">T <span class="title">load</span><span class="params">(std::memory_order order = std::memory_order_seq_cst)</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="5-1-3-特化成员函数"><a href="#5-1-3-特化成员函数" class="headerlink" title="5.1.3 特化成员函数"></a>5.1.3 特化成员函数</h3><ul><li>复合赋值运算符重载，主要包含以下形式：</li></ul><p>当模板类型T为整数：</p><table><thead><tr><th>操作符重载</th><th>描述</th></tr></thead><tbody><tr><td>T operator+&#x3D; (T val) volatile noexcept;</td><td>原子地执行加法并赋值，返回新的值 (volatile版本)</td></tr><tr><td>T operator+&#x3D; (T val) noexcept;</td><td>原子地执行加法并赋值，返回新的值</td></tr><tr><td>T operator-&#x3D; (T val) volatile noexcept;</td><td>原子地执行减法并赋值，返回新的值 (volatile版本)</td></tr><tr><td>T operator-&#x3D; (T val) noexcept;</td><td>原子地执行减法并赋值，返回新的值</td></tr><tr><td>T operator&amp;&#x3D; (T val) volatile noexcept;</td><td>原子地执行按位与操作并赋值，返回新的值 (volatile版本)</td></tr><tr><td>T operator&amp;&#x3D; (T val) noexcept;</td><td>原子地执行按位与操作并赋值，返回新的值</td></tr><tr><td>T operator</td><td>&#x3D; (T val) volatile noexcept;</td></tr><tr><td>T operator</td><td>&#x3D; (T val) noexcept;</td></tr><tr><td>T operator^&#x3D; (T val) volatile noexcept;</td><td>原子地执行按位异或操作并赋值，返回新的值 (volatile版本)</td></tr><tr><td>T operator^&#x3D; (T val) noexcept;</td><td>原子地执行按位异或操作并赋值，返回新的值</td></tr></tbody></table><p>当模板类型T为指针：</p><table><thead><tr><th>操作符重载</th><th>描述</th></tr></thead><tbody><tr><td>T operator+&#x3D; (ptrdiff_t val) volatile noexcept;</td><td>原子地执行指针加法并赋值，返回新的指针 (volatile版本)</td></tr><tr><td>T operator+&#x3D; (ptrdiff_t val) noexcept;</td><td>原子地执行指针加法并赋值，返回新的指针</td></tr><tr><td>T operator-&#x3D; (ptrdiff_t val) volatile noexcept;</td><td>原子地执行指针减法并赋值，返回新的指针 (volatile版本)</td></tr><tr><td>T operator-&#x3D; (ptrdiff_t val) noexcept;</td><td>原子地执行指针减法并赋值，返回新的指针</td></tr></tbody></table><ul><li>以上各个 operator 都会有对应的 fetch_* 操作，详细见下表：</li></ul><table><thead><tr><th>操作符</th><th>操作符重载函数</th><th>等级的成员函数</th><th>整形</th><th>指针</th><th>其他</th></tr></thead><tbody><tr><td>+</td><td>atomic::operator+&#x3D;</td><td>atomic::fetch_add</td><td>是</td><td>是</td><td>否</td></tr><tr><td>-</td><td>atomic::operator-&#x3D;</td><td>atomic::fetch_sub</td><td>是</td><td>是</td><td>否</td></tr><tr><td>&amp;</td><td>atomic::operator&amp;&#x3D;</td><td>atomic::fetch_and</td><td>是</td><td>否</td><td>否</td></tr><tr><td>|</td><td>atomic::operator|&#x3D;</td><td>atomic::fetch_or</td><td>是</td><td>否</td><td>否</td></tr><tr><td>^</td><td>atomic::operator^&#x3D;</td><td>atomic::fetch_xor</td><td>是</td><td>否</td><td>否</td></tr></tbody></table><hr><h3 id="5-1-4-内存顺序约束"><a href="#5-1-4-内存顺序约束" class="headerlink" title="5.1.4 内存顺序约束"></a>5.1.4 内存顺序约束</h3><blockquote><p>通过上面的 API 函数我们可以看出，在调用 atomic类提供的 API 函数的时候，需要指定原子顺序<br>在C++11给我们提供的 API中使用枚举用作执行原子操作的函数的实参，以指定如何同步不同线程上的其他操作。</p></blockquote><p>定义如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">memory_order</span> &#123;</span><br><span class="line">    memory_order_relaxed,   <span class="comment">// relaxed</span></span><br><span class="line">    memory_order_consume,   <span class="comment">// consume</span></span><br><span class="line">    memory_order_acquire,   <span class="comment">// acquire</span></span><br><span class="line">    memory_order_release,   <span class="comment">// release</span></span><br><span class="line">    memory_order_acq_rel,   <span class="comment">// acquire/release</span></span><br><span class="line">    memory_order_seq_cst    <span class="comment">// sequentially consistent</span></span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure><ul><li><code>memory_order_relaxed</code>,这是最宽松的规则，它对编译器和CPU不做任何限制，可以乱序</li><li><code>memory_order_release</code> <strong>释放</strong>，设定内存屏障(Memory barrier)，保证它之前的操作永远在它之前，但是它后面的操作可能被重排到它前面</li><li><code>memory_order_acquire</code> <strong>获取</strong>, 设定内存屏障，保证在它之后的访问永远在它之后，但是它之前的操作却有可能被重排到它后面，往往和<code>Release</code>在不同线程中联合使用</li><li><code>memory_order_consume</code>：改进版的<code>memory_order_acquire</code> ，开销更小</li><li><code>memory_order_acq_rel</code>，它是<code>Acquire</code> 和 <code>Release</code> 的结合，同时拥有它们俩提供的保证。比如你要对一个 atomic 自增 1，同时希望该操作之前和之后的读取或写入操作不会被重新排序</li><li><code>memory_order_seq_cst</code> 顺序一致性， <code>memory_order_seq_cst</code> 就像是<code>memory_order_acq_rel</code>的加强版，它不管原子操作是属于读取还是写入的操作<br>只要某个线程有用到<code>memory_order_seq_cst</code> 的原子操作，线程中该<code>memory_order_seq_cst</code> 操作前的数据操作绝对不会被重新排在该<code>memory_order_seq_cst</code> 操作之后，且该<code>memory_order_seq_cst</code> 操作后的数据操作也绝对不会被重新排在<code>memory_order_seq_cst</code> 操作前。</li></ul><h3 id="5-1-5-C-20新增成员"><a href="#5-1-5-C-20新增成员" class="headerlink" title="5.1.5 C++20新增成员"></a>5.1.5 C++20新增成员</h3><blockquote><p>在C++20版本中添加了新的功能函数，可以通过原子类型来阻塞线程，和条件变量中的等待&#x2F;通知函数是一样的。</p></blockquote><table><thead><tr><th>公共成员函数</th><th>说明</th></tr></thead><tbody><tr><td>wait (C++20)</td><td>阻塞线程直至被提醒且原子值更改</td></tr><tr><td>notify_one (C++20)</td><td>通知（唤醒）至少一个在原子对象上阻塞的线程</td></tr><tr><td>notify_all (C++20)</td><td>通知（唤醒）所有在原子对象上阻塞的线程</td></tr></tbody></table><p><strong>类型别名</strong></p><table><thead><tr><th>别名</th><th>原始类型定义</th></tr></thead><tbody><tr><td>atomic_bool (C++11)</td><td>std::atomic&lt;bool&gt;</td></tr><tr><td>atomic_char (C++11)</td><td>std::atomic&lt;char&gt;</td></tr><tr><td>atomic_schar (C++11)</td><td>std::atomic&lt;signed char&gt;</td></tr><tr><td>atomic_uchar (C++11)</td><td>std::atomic&lt;unsigned char&gt;</td></tr><tr><td>atomic_short (C++11)</td><td>std::atomic&lt;short&gt;</td></tr><tr><td>atomic_ushort (C++11)</td><td>std::atomic&lt;unsigned short&gt;</td></tr><tr><td>atomic_int (C++11)</td><td>std::atomic&lt;int&gt;</td></tr><tr><td>atomic_uint (C++11)</td><td>std::atomic&lt;unsigned int&gt;</td></tr><tr><td>atomic_long (C++11)</td><td>std::atomic&lt;long&gt;</td></tr><tr><td>atomic_ulong (C++11)</td><td>std::atomic&lt;unsigned long&gt;</td></tr><tr><td>atomic_llong (C++11)</td><td>std::atomic&lt;long long&gt;</td></tr><tr><td>atomic_ullong (C++11)</td><td>std::atomic&lt;unsigned long long&gt;</td></tr><tr><td>atomic_char8_t (C++20)</td><td>std::atomic&lt;char8_t&gt;</td></tr><tr><td>atomic_char16_t (C++11)</td><td>std::atomic&lt;char16_t&gt;</td></tr><tr><td>atomic_char32_t (C++11)</td><td>std::atomic&lt;char32_t&gt;</td></tr><tr><td>atomic_wchar_t (C++11)</td><td>std::atomic&lt;wchar_t&gt;</td></tr><tr><td>atomic_int8_t (C++11)</td><td>std::atomic&lt;std::int8_t&gt;</td></tr><tr><td>atomic_uint8_t (C++11)</td><td>std::atomic&lt;std::uint8_t&gt;</td></tr><tr><td>atomic_int16_t (C++11)</td><td>std::atomic&lt;std::int16_t&gt;</td></tr><tr><td>atomic_uint16_t (C++11)</td><td>std::atomic&lt;std::uint16_t&gt;</td></tr><tr><td>atomic_int32_t (C++11)</td><td>std::atomic&lt;std::int32_t&gt;</td></tr><tr><td>atomic_uint32_t (C++11)</td><td>std::atomic&lt;std::uint32_t&gt;</td></tr><tr><td>atomic_int64_t (C++11)</td><td>std::atomic&lt;std::int64_t&gt;</td></tr><tr><td>atomic_uint64_t (C++11)</td><td>std::atomic&lt;std::uint64_t&gt;</td></tr><tr><td>atomic_int_least8_t (C++11)</td><td>std::atomic&lt;std::int_least8_t&gt;</td></tr><tr><td>atomic_uint_least8_t (C++11)</td><td>std::atomic&lt;std::uint_least8_t&gt;</td></tr><tr><td>atomic_int_least16_t (C++11)</td><td>std::atomic&lt;std::int_least16_t&gt;</td></tr><tr><td>atomic_uint_least16_t (C++11)</td><td>std::atomic&lt;std::uint_least16_t&gt;</td></tr><tr><td>atomic_int_least32_t (C++11)</td><td>std::atomic&lt;std::int_least32_t&gt;</td></tr><tr><td>atomic_uint_least32_t (C++11)</td><td>std::atomic&lt;std::uint_least32_t&gt;</td></tr><tr><td>atomic_int_least64_t (C++11)</td><td>std::atomic&lt;std::int_least64_t&gt;</td></tr><tr><td>atomic_uint_least64_t (C++11)</td><td>std::atomic&lt;std::uint_least64_t&gt;</td></tr><tr><td>atomic_int_fast8_t (C++11)</td><td>std::atomic&lt;std::int_fast8_t&gt;</td></tr><tr><td>atomic_uint_fast8_t (C++11)</td><td>std::atomic&lt;std::uint_fast8_t&gt;</td></tr><tr><td>atomic_int_fast16_t (C++11)</td><td>std::atomic&lt;std::int_fast16_t&gt;</td></tr><tr><td>atomic_uint_fast16_t (C++11)</td><td>std::atomic&lt;std::uint_fast16_t&gt;</td></tr><tr><td>atomic_int_fast32_t (C++11)</td><td>std::atomic&lt;std::int_fast32_t&gt;</td></tr><tr><td>atomic_uint_fast32_t (C++11)</td><td>std::atomic&lt;std::uint_fast32_t&gt;</td></tr><tr><td>atomic_int_fast64_t (C++11)</td><td>std::atomic&lt;std::int_fast64_t&gt;</td></tr><tr><td>atomic_uint_fast64_t (C++11)</td><td>std::atomic&lt;std::uint_fast64_t&gt;</td></tr><tr><td>atomic_intptr_t (C++11)</td><td>std::atomic&lt;std::intptr_t&gt;</td></tr><tr><td>atomic_uintptr_t (C++11)</td><td>std::atomic&lt;std::uintptr_t&gt;</td></tr><tr><td>atomic_size_t (C++11)</td><td>std::atomic&lt;std::size_t&gt;</td></tr><tr><td>atomic_ptrdiff_t (C++11)</td><td>std::atomic&lt;std::ptrdiff_t&gt;</td></tr><tr><td>atomic_intmax_t (C++11)</td><td>std::atomic&lt;std::intmax_t&gt;</td></tr><tr><td>atomic_uintmax_t (C++11)</td><td>std::atomic&lt;std::uintmax_t&gt;</td></tr></tbody></table><hr><h2 id="5-2-原子变量的使用"><a href="#5-2-原子变量的使用" class="headerlink" title="5.2 原子变量的使用"></a>5.2 原子变量的使用</h2><blockquote><p>假设我们要制作一个多线程交替数数的计数器，我们使用互斥锁和原子变量的方式分别进行实现，对比一下二者的差异：</p></blockquote><h3 id="5-2-1-互斥锁版本"><a href="#5-2-1-互斥锁版本" class="headerlink" title="5.2.1 互斥锁版本"></a>5.2.1 互斥锁版本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            m_value++;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;increment number: &quot;</span> &lt;&lt; m_value </span><br><span class="line">                &lt;&lt; <span class="string">&quot;, theadID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            m_value--;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;decrement number: &quot;</span> &lt;&lt; m_value </span><br><span class="line">                &lt;&lt; <span class="string">&quot;, theadID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_value = <span class="number">0</span>;</span><br><span class="line">    mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Counter c;</span><br><span class="line">    <span class="keyword">auto</span> increment = <span class="built_in">bind</span>(&amp;Counter::increment, &amp;c);</span><br><span class="line">    <span class="keyword">auto</span> decrement = <span class="built_in">bind</span>(&amp;Counter::decrement, &amp;c);</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(decrement)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-2-原子变量版本"><a href="#5-2-2-原子变量版本" class="headerlink" title="5.2.2 原子变量版本"></a>5.2.2 原子变量版本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_value++;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;increment number: &quot;</span> &lt;&lt; m_value</span><br><span class="line">                &lt;&lt; <span class="string">&quot;, theadID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_value--;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;decrement number: &quot;</span> &lt;&lt; m_value</span><br><span class="line">                &lt;&lt; <span class="string">&quot;, theadID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// atomic&lt;int&gt; == atomic_int</span></span><br><span class="line">    atomic_int m_value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Counter c;</span><br><span class="line">    <span class="keyword">auto</span> increment = <span class="built_in">bind</span>(&amp;Counter::increment, &amp;c);</span><br><span class="line">    <span class="keyword">auto</span> decrement = <span class="built_in">bind</span>(&amp;Counter::decrement, &amp;c);</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(decrement)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码的对比可以看出，使用了原子变量之后，就不需要再定义互斥量了，在使用上更加简便，并且这两种方式都能保证在多线程操作过程中数据的正确性，不会出现数据的混乱。</p><p>原子类型<code>atomic&lt;T&gt;</code> 可以封装原始数据最终得到一个原子变量对象，操作原子对象能够得到和操作原始数据一样的效果，当然也可以通过<code>store()</code>和<code>load()</code>来读写原子对象内部的原始数据。</p><hr><h1 id="6-多线程异步操作"><a href="#6-多线程异步操作" class="headerlink" title="6. 多线程异步操作"></a>6. 多线程异步操作</h1><h2 id="6-1-std-future"><a href="#6-1-std-future" class="headerlink" title="6.1 std:future"></a>6.1 std:future</h2><blockquote><p>C++11中增加的线程类，使得我们能够非常方便的创建和使用线程<br>但有时会有些不方便，比如需要获取线程返回的结果，就不能通过join()得到结果，只能通过一些额外手段获得，比如：定义一个全局变量，在子线程中赋值，在主线程中读这个变量的值，整个过程比较繁琐。</p></blockquote><p>C++提供的线程库中提供了一些类用于访问异步操作的结果。</p><p>那么，什么叫做异步呢？<br><img src="/img/8.25.png" alt="在这里插入图片描述"></p><p>我们去星巴克买咖啡，因为都是现磨的，所以需要等待，但是我们付完账后不会站在柜台前死等，而是去找个座位坐下来玩玩手机打发一下时间，当店员把咖啡磨好之后，就会通知我们过去取，这就叫做异步。</p><ul><li>顾客（主线程）发起一个任务（子线程磨咖啡），磨咖啡的过程中顾客去做别的事情了，有两条时间线（异步）</li><li>顾客（主线程）发起一个任务（子线程磨咖啡），磨咖啡的过程中顾客没去做别的事情而是死等，这时就只有一条时间线（同步），此时效率相对较低。</li></ul><p>因此多线程程序中的任务大都是异步的，主线程和子线程分别执行不同的任务，如果想要在主线中得到某个子线程任务函数返回的结果可以使用C++11提供的<code>std:future</code>类，这个类需要和其他类或函数搭配使用</p><p>先来介绍一下这个类的API函数：</p><p><strong>类的定义</strong></p><p>通过类的定义可以得知，<code>future</code>是一个模板类，也就是这个类可以存储任意指定类型的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义于头文件 &lt;future&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt; <span class="keyword">class</span> <span class="title class_">future</span>;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt; <span class="keyword">class</span> <span class="title class_">future</span>&lt;T&amp;&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;          <span class="keyword">class</span> <span class="title class_">future</span>&lt;<span class="type">void</span>&gt;;</span><br></pre></td></tr></table></figure><p><strong>构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">future</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">future</span>( future&amp;&amp; other ) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">future</span>( <span class="type">const</span> future&amp; other ) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><ul><li>构造函数①：默认无参构造函数</li><li>构造函数②：移动构造函数，转移资源的所有权</li><li>构造函数③：使用&#x3D;delete显示删除拷贝构造函数, 不允许进行对象之间的拷贝</li></ul><p><strong>常用成员函数（public)</strong></p><blockquote><p>一般情况下使用<code>=</code>进行赋值操作就进行对象的拷贝，但是future对象<code>不可用复制</code><br>因此会根据实际情况进行处理：</p></blockquote><ul><li>如果other是右值，那么转移资源的所有权</li><li>如果other是非右值，不允许进行对象之间的拷贝（该函数被显示删除禁止使用）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">future&amp; <span class="keyword">operator</span>=( future&amp;&amp; other ) <span class="keyword">noexcept</span>;</span><br><span class="line">future&amp; <span class="keyword">operator</span>=( <span class="type">const</span> future&amp; other ) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><hr><blockquote><p>取出<code>future</code>对象内部保存的数据，其中<code>void get()</code>是为<code>future&lt;void&gt;</code>准备的<br>此时对象内部类型就是<code>void</code>，该函数是一个阻塞函数，当子线程的数据就绪后解除阻塞就能得到传出的数值了。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">T&amp; <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><blockquote><p>因为<code>future</code>对象内部存储的是异步线程任务执行完毕后的结果，是在调用之后的将来得到的，因此可以通过调用<code>wait()</code>方法，阻塞当前线程，等待这个子线程的任务执行完毕，任务执行完毕当前线程的阻塞也就解除了。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><code>wait()</code>方法就会死等，直到子线程任务执行完毕将返回值写入到<code>future</code>对象中<br><code>wait_for()</code>只会让线程阻塞一定的时长，但是这样并不能保证对应的那个子线程中的任务已经执行完毕了。<br><code>wait_until()</code>和<code>wait_for()</code>函数功能是差不多<br>前者是阻塞到某一指定的时间点，后者是阻塞一定的时长。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Rep, <span class="keyword">class</span> Period &gt;</span></span><br><span class="line"><span class="function">std::future_status <span class="title">wait_for</span><span class="params">( <span class="type">const</span> std::chrono::duration&lt;Rep,Period&gt;&amp; timeout_duration )</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Clock, <span class="keyword">class</span> Duration &gt;</span></span><br><span class="line"><span class="function">std::future_status <span class="title">wait_until</span><span class="params">( <span class="type">const</span> std::chrono::time_point&lt;Clock,Duration&gt;&amp; timeout_time )</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>当<code>wait_until()</code>和<code>wait_for()</code>函数返回之后，并不能确定子线程当前的状态，因此我们需要判断函数的返回值，这样就能知道子线程当前的状态了：</p><table><thead><tr><th>常量</th><th>解释</th></tr></thead><tbody><tr><td>future_status::deferred</td><td>子线程中的任务函仍未启动</td></tr><tr><td>future_status::ready</td><td>子线程中的任务已经执行完毕，结果已就绪</td></tr><tr><td>future_status::timeout</td><td>子线程中的任务正在执行中，指定等待时长已用完</td></tr></tbody></table><hr><h2 id="6-2-std-promise"><a href="#6-2-std-promise" class="headerlink" title="6.2 std::promise"></a>6.2 std::promise</h2><blockquote><p><code>std::promise</code>是一个协助线程赋值的类，它能够将数据和future对象绑定起来，为获取线程函数中的某个值提供便利。</p></blockquote><h3 id="6-2-1-类成员函数"><a href="#6-2-1-类成员函数" class="headerlink" title="6.2.1 类成员函数"></a>6.2.1 类成员函数</h3><p><strong>类定义</strong></p><p>通过<code>std::promise</code>类的定义可以得知，这也是一个模板类，我们要在线程中传递什么类型的数据，模板参数就指定为什么类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义于头文件 &lt;future&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">R</span> &gt; <span class="keyword">class</span> <span class="title class_">promise</span>;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">R</span> &gt; <span class="keyword">class</span> <span class="title class_">promise</span>&lt;R&amp;&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;          <span class="keyword">class</span> <span class="title class_">promise</span>&lt;<span class="type">void</span>&gt;;</span><br></pre></td></tr></table></figure><p><strong>构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ①</span></span><br><span class="line"><span class="built_in">promise</span>();</span><br><span class="line"><span class="comment">// ②</span></span><br><span class="line"><span class="built_in">promise</span>( promise&amp;&amp; other ) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// ③</span></span><br><span class="line"><span class="built_in">promise</span>( <span class="type">const</span> promise&amp; other ) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><ul><li>构造函数①：默认构造函数，得到一个空对象</li><li>构造函数②：移动构造函数</li><li>构造函数③：使用&#x3D;delete显示删除拷贝构造函数, 不允许进行对象之间的拷贝</li></ul><p><strong>公共成员函数</strong></p><blockquote><p>在<code>std::promise</code>类内部管理着一个<code>future</code>类对象，调用<code>get_future()</code>就可以得到这个<code>future</code>对象了</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function">std::future&lt;T&gt; <span class="title">get_future</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>存储要传出的 <code>value</code> 值，并立即让状态就绪，这样数据被传出其它线程就可以得到这个数据了。重载的第四个函数是为<code>promise&lt;void&gt;</code>类型的对象准备的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">( <span class="type">const</span> R&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">( R&amp;&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">( R&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>存储要传出的 <code>value</code> 值，但是不立即令状态就绪。在当前线程退出时，子线程资源被销毁，再令状态就绪。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value_at_thread_exit</span><span class="params">( <span class="type">const</span> R&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value_at_thread_exit</span><span class="params">( R&amp;&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value_at_thread_exit</span><span class="params">( R&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value_at_thread_exit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="6-2-2-promise的使用"><a href="#6-2-2-promise的使用" class="headerlink" title="6.2.2 promise的使用"></a>6.2.2 promise的使用</h3><p>通过promise传递数据的过程一共分为5步：</p><ol><li>在主线程中创建std::promise对象</li><li>将这个std::promise对象通过引用的方式传递给子线程的任务函数</li><li>在子线程任务函数中给std::promise对象赋值</li><li>在主线程中通过std::promise对象取出绑定的future实例对象</li><li>通过得到的future对象取出子线程任务函数中返回的值。</li></ol><p><strong>子线程任务函数执行期间，让状态就绪</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    promise&lt;<span class="type">int</span>&gt; pr;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">([](promise&lt;<span class="type">int</span>&gt; &amp;p) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        p.set_value(<span class="number">100</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">        this_thread::sleep_for(chrono::seconds(<span class="number">3</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;睡醒了....&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;, ref(pr))</span></span>;</span><br><span class="line"></span><br><span class="line">    future&lt;<span class="type">int</span>&gt; f = pr.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="type">int</span> value = f.<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例程序输出的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value: <span class="number">100</span></span><br><span class="line">睡醒了....</span><br></pre></td></tr></table></figure><p>示例程序的中子线程的任务函数指定的是一个匿名函数，在这个匿名的任务函数执行期间通过<code>p.set_value(100);</code>传出了数据并且激活了状态<br>数据就绪后，外部主线程中的<code>int value = f.get();</code>解除阻塞，并将得到的数据打印出来，5秒钟之后子线程休眠结束，匿名的任务函数执行完毕。</p><p><strong>子线程任务函数执行结束，让状态就绪</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    promise&lt;<span class="type">int</span>&gt; pr;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">([](promise&lt;<span class="type">int</span>&gt; &amp;p) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        p.set_value_at_thread_exit(<span class="number">100</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">        this_thread::sleep_for(chrono::seconds(<span class="number">3</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;睡醒了....&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;, ref(pr))</span></span>;</span><br><span class="line"></span><br><span class="line">    future&lt;<span class="type">int</span>&gt; f = pr.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="type">int</span> value = f.<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例程序输出的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">睡醒了....</span><br><span class="line">value: <span class="number">100</span></span><br></pre></td></tr></table></figure><p>在示例程序中，子线程的这个匿名的任务函数中通过<code>p.set_value_at_thread_exit(100);</code>在执行完毕并退出之后才会传出数据并激活状态<br>数据就绪后，外部主线程中的<code>int value = f.get();</code>解除阻塞，并将得到的数据打印出来，因此子线程在休眠5秒钟之后主线程中才能得到传出的数据。</p><p><code>注意</code>:在外部主线程中创建的<code>promise</code>对象必须要通过引用的方式传递到子线程的任务函数中，在实例化子线程对象的时候，如果任务函数的参数是引用类型，那么实参一定要放到<code>std::ref()</code>函数中，表示要传递这个实参的引用到任务函数中。</p><hr><h2 id="6-3-std-packaged-task"><a href="#6-3-std-packaged-task" class="headerlink" title="6.3. std::packaged_task"></a>6.3. std::packaged_task</h2><blockquote><p><code>std::packaged_task</code>类包装了一个可调用对象包装器类对象（可调用对象包装器包装的是可调用对象，可调用对象都可以作为函数来使用），恶补一下可调用对象和可调用对象包装器</p></blockquote><p>这个类可以将内部包装的函数和<code>future</code>类绑定到一起,以便进行后续的异步调用,和<code>std::promise</code>有点类似<br><code>std::promise</code>内部保存一个共享状态的值，而<code>std::packaged_task</code>保存的是一个函数。</p><hr><h3 id="6-3-1-类成员函数"><a href="#6-3-1-类成员函数" class="headerlink" title="6.3.1 类成员函数"></a>6.3.1 类成员函数</h3><p><strong>类的定义</strong></p><p>通过类的定义可以看到这也是一个模板类，模板类型和要在线程中传出的数据类型是一致的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义于头文件 &lt;future&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> &gt; <span class="keyword">class</span> <span class="title class_">packaged_task</span>;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span> ...Args &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">packaged_task</span>&lt;<span class="built_in">R</span>(Args...)&gt;;</span><br></pre></td></tr></table></figure><p><strong>构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ①</span></span><br><span class="line"><span class="built_in">packaged_task</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// ②</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">packaged_task</span><span class="params">( F&amp;&amp; f )</span></span>;</span><br><span class="line"><span class="comment">// ③</span></span><br><span class="line"><span class="built_in">packaged_task</span>( <span class="type">const</span> packaged_task&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="comment">// ④</span></span><br><span class="line"><span class="built_in">packaged_task</span>( packaged_task&amp;&amp; rhs ) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><ul><li>构造函数①：无参构造，构造一个无任务的空对象</li><li>构造函数②：通过一个可调用对象，构造一个任务对象</li><li>构造函数③：显示删除，不允许通过拷贝构造函数进行对象的拷贝</li><li>构造函数④：移动构造函数</li></ul><p><strong>常用公共成员函数</strong></p><p>通过调用任务对象内部的<code>get_future()</code>方法就可以得到一个<code>future</code>对象，基于这个对象就可以得到传出的数据了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function">std::future&lt;R&gt; <span class="title">get_future</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="6-3-2-packaged-task的使用"><a href="#6-3-2-packaged-task的使用" class="headerlink" title="6.3.2 packaged_task的使用"></a>6.3.2 packaged_task的使用</h3><blockquote><p><code>packaged_task</code>其实就是对子线程要执行的任务函数进行了包装，和可调用对象包装器的使用方法相同，包装完毕之后直接将包装得到的任务对象传递给线程对象就可以了。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">([](<span class="type">int</span> x) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">return</span> x += <span class="number">100</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(ref(task), <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    future&lt;<span class="type">int</span>&gt; f = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="type">int</span> value = f.<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例代码中，通过<code>packaged_task</code>类包装了一个匿名函数作为子线程的任务函数，最终的得到的这个任务对象需要通过引用的方式传递到子线程内部，这样才能在主线程的最后通过任务对象得到<code>future</code>对象，再通过这个<code>future</code>对象取出子线程通过返回值传递出的数据。</p><hr><h2 id="6-4-std-async"><a href="#6-4-std-async" class="headerlink" title="6.4 std::async"></a>6.4 std::async</h2><blockquote><p><code>std::async</code>函数比前面提到的<code>std::promise</code>和<code>packaged_task</code>更高级一些<br>因为通过这函数可以直接启动一个子线程并在这个子线程中执行对应的任务函数，异步任务执行完成返回的结果也是存储到一个<code>future</code>对象中<br>当需要获取异步任务的结果时，只需要调用<code>future</code>类的<code>get()</code>方法即可<br>如果不关注异步任务的结果，只是简单地等待任务完成的话，可以调用<code>future</code>类的<code>wait()</code>或者<code>wait_for()</code>方法。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">// 定义于头文件 &lt;future&gt;</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">std::future&lt;std::<span class="type">result_of_t</span>&lt;std::<span class="built_in">decay_t</span>&lt;Function&gt;(std::<span class="type">decay_t</span>&lt;Args&gt;...)&gt;&gt;</span><br><span class="line">    <span class="built_in">async</span>( Function&amp;&amp; f, Args&amp;&amp;... args );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args &gt;</span><br><span class="line">std::future&lt;std::<span class="type">result_of_t</span>&lt;std::<span class="built_in">decay_t</span>&lt;Function&gt;(std::<span class="type">decay_t</span>&lt;Args&gt;...)&gt;&gt;</span><br><span class="line">    <span class="built_in">async</span>( std::launch policy, Function&amp;&amp; f, Args&amp;&amp;... args );</span><br></pre></td></tr></table></figure><p>可以看到这是一个模板函数，在C++11中这个函数有两种调用方式：</p><ul><li><p>函数①：直接调用传递到函数体内部的可调用对象，返回一个<code>future</code>对象</p></li><li><p>函数②：通过指定的策略调用传递到函数内部的可调用对象，返回一个<code>future</code>对象<br>函数参数:</p></li><li><p><code>f</code>：可调用对象，这个对象在子线程中被作为任务函数使用</p></li><li><p><code>Args</code>：传递给 f 的参数（实参）</p></li><li><p><code>policy</code>：可调用对象·f的执行策略</p></li></ul><table><thead><tr><th>策略</th><th>说明</th></tr></thead><tbody><tr><td>std::launch::async</td><td>调用async函数时创建新的线程执行任务函数</td></tr><tr><td>std::launch::deferred</td><td>调用async函数时不执行任务函数，直到调用了future的get()或者wait()时才执行任务（这种方式不会创建新的线程）</td></tr></tbody></table><p>关于std::async()函数的使用，对应的示例代码如下：</p><h3 id="6-4-1-方式1"><a href="#6-4-1-方式1" class="headerlink" title="6.4.1 方式1"></a>6.4.1 方式1</h3><p><strong>调用async()函数直接创建线程执行任务</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 调用函数直接创建线程执行任务</span></span><br><span class="line">    future&lt;<span class="type">int</span>&gt; f = <span class="built_in">async</span>([](<span class="type">int</span> x) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">return</span> x += <span class="number">100</span>;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    future_status status;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        status = f.<span class="built_in">wait_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (status == future_status::deferred)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;线程还没有执行...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            f.<span class="built_in">wait</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (status == future_status::ready)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;子线程返回值: &quot;</span> &lt;&lt; f.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (status == future_status::timeout)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;任务还未执行完毕, 继续等待...&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (status != future_status::ready);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例程序输出的结果为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">主线程ID: <span class="number">8904</span></span><br><span class="line">子线程ID: <span class="number">25036</span></span><br><span class="line">任务还未执行完毕, 继续等待...</span><br><span class="line">任务还未执行完毕, 继续等待...</span><br><span class="line">任务还未执行完毕, 继续等待...</span><br><span class="line">任务还未执行完毕, 继续等待...</span><br><span class="line">任务还未执行完毕, 继续等待...</span><br><span class="line">子线程返回值: <span class="number">200</span></span><br></pre></td></tr></table></figure><p>调用<code>async()</code>函数时不指定策略就是直接创建线程并执行任务,示例代码的主线程中做了如下操作<br><code>status = f.wait_for(chrono::seconds(1));</code><br>其实直接调用<code>f.get()</code>就能得到子线程的返回值。<br>为了演示&#96;wait_for()&#96;&#96;的使用，所以写的复杂了些。</p><hr><h3 id="6-4-2-方式2"><a href="#6-4-2-方式2" class="headerlink" title="6.4.2 方式2"></a>6.4.2 方式2</h3><p><strong>调用async()函数不创建线程执行任务</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 调用函数直接创建线程执行任务</span></span><br><span class="line">    future&lt;<span class="type">int</span>&gt; f = <span class="built_in">async</span>(launch::deferred, [](<span class="type">int</span> x) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> x += <span class="number">100</span>;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    cout &lt;&lt; f.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例程序输出的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主线程ID: <span class="number">24760</span></span><br><span class="line">主线程开始休眠<span class="number">5</span>秒...</span><br><span class="line">子线程ID: <span class="number">24760</span></span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure><p>由于指定了<code>launch::deferred</code> 策略，因此调用<code>async()</code>函数并不会创建新的线程执行任务<br>当使用<code>future</code>类对象调用了<code>get()</code>或者<code>wait()</code>方法后才开始执行任务（此处一定要注意调用<code>wait_for()</code>函数是不行的）。</p><p>通过测试程序输出的结果可以看到，两次输出的线程ID是相同的，任务函数是在主线程中被延迟（主线程休眠了5秒）调用了。</p><p>最终总结：</p><ol><li>使用<code>async()</code>函数，是多线程操作中最简单的一种方式，不需要自己创建线程对象，并且可以得到子线程函数的返回值。</li><li>使用<code>std::promise</code>类，在子线程中可以传出返回值也可以传出其他数据，并且可选择在什么时机将数据从子线程中传递出来，使用起来更灵活。</li><li>使用<code>std::packaged_task</code>类，可将子线程的任务函数进行包装，并可得到子线程返回值。</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++线程 </tag>
            
            <tag> 原子变量 </tag>
            
            <tag> 线程同步 </tag>
            
            <tag> 线程异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2023/10/22/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2023/10/22/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-线程池原理"><a href="#1-线程池原理" class="headerlink" title="1. 线程池原理"></a>1. 线程池原理</h1><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便<br>但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>那么有没有一种办法使得线程可以复用:<br>执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？</p><p>线程池是一种多线程处理形式，处理过程中将任务添加到队列<br>在创建线程后<code>自动启动</code>这些任务。线程池线程都是后台线程。<br>每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。<br>如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。<br>如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。<br>超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p><p>在各个编程语言的语种中都有线程池的概念，并且很多语言中直接提供了线程池，作为程序猿直接使用就可以了，下面给大家介绍一下线程池的实现原理：</p><ul><li><p>线程池的组成主要分为3个部分，这三部分配合工作就可以得到一个完整的线程池：</p><ol><li><code>任务队列，存储需要处理的任务，由工作的线程来处理这些任务</code><ul><li>通过线程池提供的API函数，将一个待处理的任务添加到任务队列，或者从任务队列中删除</li><li>已处理的任务会被从任务队列中删除</li><li>线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程</li></ul></li><li><code>工作的线程（任务队列任务的消费者） ，N个</code><ul><li>线程池中维护了一定数量的工作线程, 他们的作用是是不停的读任务队列, 从里边取出任务并处理</li><li>工作的线程相当于是任务队列的消费者角色，</li><li>如果任务队列为空, 工作的线程将会被阻塞 (使用条件变量&#x2F;信号量阻塞)</li><li>如果阻塞之后有了新的任务, 由生产者将阻塞解除, 工作线程开始工作</li></ul></li><li><code>管理者线程（不处理任务队列中的任务），1个</code><ul><li>它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测<ul><li>当任务过多的时候, 可以适当的创建一些新的工作线程</li><li>当任务过少的时候, 可以适当的销毁一些工作的线程</li></ul></li></ul></li></ol></li></ul><p><img src="/img/8.22.png" alt="在这里插入图片描述"></p><hr><h1 id="2-C实现线程池"><a href="#2-C实现线程池" class="headerlink" title="2. C实现线程池"></a>2. C实现线程池</h1><h2 id="2-1-头文件"><a href="#2-1-头文件" class="headerlink" title="2.1 头文件"></a>2.1 头文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">void</span> (*function)(<span class="type">void</span>* args);</span><br><span class="line"><span class="type">void</span>* args;</span><br><span class="line">&#125;Task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//任务队列</span></span><br><span class="line">Task* task_queue;</span><br><span class="line"><span class="type">int</span> queue_capacity;<span class="comment">//容量</span></span><br><span class="line"><span class="type">int</span> queue_size;<span class="comment">//当前任务个数</span></span><br><span class="line"><span class="type">int</span> queue_front;<span class="comment">//队头-&gt;消费用</span></span><br><span class="line"><span class="type">int</span> queue_tail;<span class="comment">//队尾-&gt;生产用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> managerID;<span class="comment">//管理者线程ID(1个)</span></span><br><span class="line"><span class="type">pthread_t</span>* threadID;<span class="comment">//工作的线程ID(多个,用指针)</span></span><br><span class="line"><span class="type">int</span> min_num;<span class="comment">//最小的线程数量</span></span><br><span class="line"><span class="type">int</span> max_num;<span class="comment">//最大的线程数量</span></span><br><span class="line"><span class="type">int</span> busy_num;<span class="comment">//在忙的线程数量</span></span><br><span class="line"><span class="type">int</span> live_num;<span class="comment">//存活的线程数量</span></span><br><span class="line"><span class="type">int</span> exit_num;<span class="comment">//将要销毁的线程数量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_pool;<span class="comment">//线程池的锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_busy_num;<span class="comment">//busy_num的锁</span></span><br><span class="line"><span class="type">pthread_cond_t</span> producer_wait_consumer;<span class="comment">//生产者等待消费者</span></span><br><span class="line"><span class="type">pthread_cond_t</span> consumer_wait_producer;<span class="comment">//消费者等待生产者</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> shutdown;<span class="comment">//是否销毁线程池,销毁为1,否则为0</span></span><br><span class="line">&#125;ThreadPool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程池并且初始化</span></span><br><span class="line">ThreadPool* <span class="title function_">Thread_Pool_Create</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, <span class="type">int</span> queuesize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁线程池</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Thread_Pool_Destroy</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给线程池添加任务(相当于生产者)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread_Pool_Add</span><span class="params">(ThreadPool* pool, <span class="type">void</span>(*function)(<span class="type">void</span>*), <span class="type">void</span>* args)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线程池中工作的线程个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_Busy_Num</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线程池中存活的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_Live_Num</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为被封装的函数</span></span><br><span class="line"><span class="comment">//工作的线程(消费者线程)任务函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">Worker</span><span class="params">(<span class="type">void</span>* args)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理者线程任务函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">Manager</span><span class="params">(<span class="type">void</span>* args)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单个线程的退出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread_Exit</span><span class="params">(ThreadPool* pool)</span>;</span><br></pre></td></tr></table></figure><h2 id="2-2-源文件的定义"><a href="#2-2-源文件的定义" class="headerlink" title="2.2 源文件的定义"></a>2.2 源文件的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">ThreadPool* <span class="title function_">Thread_Pool_Create</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, <span class="type">int</span> queuesize)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//开线程池</span></span><br><span class="line">ThreadPool* pool = (ThreadPool*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadPool));</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pool == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc threadpool fail\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开线程ID</span></span><br><span class="line">pool-&gt;threadID = (<span class="type">pthread_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;threadID == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc threadID fail\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始线程ID都初始化为0</span></span><br><span class="line"><span class="built_in">memset</span>(pool-&gt;threadID, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">pool-&gt;max_num = max;</span><br><span class="line">pool-&gt;min_num = min;</span><br><span class="line">pool-&gt;busy_num = <span class="number">0</span>;</span><br><span class="line">pool-&gt;live_num = min;</span><br><span class="line">pool-&gt;exit_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化锁和条件变量</span></span><br><span class="line"><span class="keyword">if</span> (pthread_mutex_init(&amp;pool-&gt;mutex_pool, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">pthread_mutex_init(&amp;pool-&gt;mutex_busy_num, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">pthread_cond_init(&amp;pool-&gt;producer_wait_consumer, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">pthread_cond_init(&amp;pool-&gt;consumer_wait_producer, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mutex or cond init fail\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化任务队列</span></span><br><span class="line">pool-&gt;task_queue = (Task*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Task) * queuesize);</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;task_queue == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc task_queue fail...\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pool-&gt;queue_capacity = queuesize;</span><br><span class="line">pool-&gt;queue_size = <span class="number">0</span>;</span><br><span class="line">pool-&gt;queue_front = <span class="number">0</span>;</span><br><span class="line">pool-&gt;queue_tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">pool-&gt;shutdown = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程</span></span><br><span class="line">pthread_create(&amp;pool-&gt;managerID, <span class="literal">NULL</span>, Manager, pool);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; min; ++i)</span><br><span class="line">&#123;</span><br><span class="line">pthread_create(&amp;pool-&gt;threadID[i], <span class="literal">NULL</span>, Worker, pool);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pool; <span class="comment">//到这里说明成功,返回创建出来的线程池</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳到这里说明失败了,释放资源</span></span><br><span class="line"><span class="keyword">if</span> (pool &amp;&amp; pool-&gt;threadID)</span><br><span class="line"><span class="built_in">free</span>(pool-&gt;threadID);</span><br><span class="line"><span class="keyword">if</span> (pool)</span><br><span class="line"><span class="built_in">free</span>(pool);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Thread_Pool_Destroy</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果线程池本就不存在</span></span><br><span class="line"><span class="keyword">if</span> (pool == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">pool-&gt;shutdown = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//阻塞并回收管理者线程</span></span><br><span class="line">pthread_join(pool-&gt;managerID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒阻塞的消费者进程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;live_num; ++i)</span><br><span class="line">pthread_cond_signal(&amp;pool-&gt;consumer_wait_producer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放堆内存</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;task_queue)</span><br><span class="line"><span class="built_in">free</span>(pool-&gt;task_queue);</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;threadID)</span><br><span class="line"><span class="built_in">free</span>(pool-&gt;threadID);</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁锁和条件变量</span></span><br><span class="line">pthread_mutex_destroy(&amp;pool-&gt;mutex_pool);</span><br><span class="line">pthread_mutex_destroy(&amp;pool-&gt;mutex_busy_num);</span><br><span class="line">pthread_cond_destroy(&amp;pool-&gt;consumer_wait_producer);</span><br><span class="line">pthread_cond_destroy(&amp;pool-&gt;producer_wait_consumer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁线程池</span></span><br><span class="line"><span class="built_in">free</span>(pool);</span><br><span class="line">pool = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread_Pool_Add</span><span class="params">(ThreadPool* pool, <span class="type">void</span>(*function)(<span class="type">void</span>*), <span class="type">void</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="comment">//如果任务队列满了</span></span><br><span class="line"><span class="keyword">while</span> (pool-&gt;queue_size == pool-&gt;queue_capacity &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//生产者阻塞,等待消费者进程</span></span><br><span class="line">pthread_cond_wait(&amp;pool-&gt;producer_wait_consumer, &amp;pool-&gt;mutex_pool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果线程池要关闭</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;shutdown)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加任务</span></span><br><span class="line"><span class="comment">//队尾添加任务,队尾向后移动,队列任务数加一</span></span><br><span class="line">pool-&gt;task_queue[pool-&gt;queue_tail].function = function;</span><br><span class="line">pool-&gt;task_queue[pool-&gt;queue_tail].args = args;</span><br><span class="line">pool-&gt;queue_tail = (pool-&gt;queue_tail + <span class="number">1</span>) % pool-&gt;queue_capacity;</span><br><span class="line">pool-&gt;queue_size++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提醒消费者消费</span></span><br><span class="line">pthread_cond_signal(&amp;pool-&gt;consumer_wait_producer);</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_pool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_Busy_Num</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_busy_num);</span><br><span class="line"><span class="type">int</span> busynum = pool-&gt;busy_num;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_busy_num);</span><br><span class="line"><span class="keyword">return</span> busynum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_Live_Num</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="type">int</span> livenum = pool-&gt;live_num;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="keyword">return</span> livenum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">Worker</span><span class="params">(<span class="type">void</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line">ThreadPool* pool = (ThreadPool*)args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果当前任务队列为空</span></span><br><span class="line"><span class="keyword">while</span> (pool-&gt;queue_size == <span class="number">0</span> &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//阻塞消费者线程</span></span><br><span class="line">pthread_cond_wait(&amp;pool-&gt;consumer_wait_producer,&amp;pool-&gt;mutex_pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要销毁线程</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;exit_num &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pool-&gt;exit_num--;</span><br><span class="line"><span class="comment">//同时如果存活线程大于最小值</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;live_num &gt; pool-&gt;min_num)</span><br><span class="line">&#123;</span><br><span class="line">pool-&gt;live_num--;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_pool);</span><br><span class="line">Thread_Exit(pool);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果线程池要关闭</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;shutdown)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_pool);</span><br><span class="line">Thread_Exit(pool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从任务队列取出任务</span></span><br><span class="line">Task task;</span><br><span class="line">task.function = pool-&gt;task_queue[pool-&gt;queue_front].function;</span><br><span class="line">task.args = pool-&gt;task_queue[pool-&gt;queue_front].args;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队头向后移动以下次取任务</span></span><br><span class="line">pool-&gt;queue_front = (pool-&gt;queue_front + <span class="number">1</span>) % pool-&gt;queue_capacity;</span><br><span class="line">pool-&gt;queue_size--;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁提醒生产者</span></span><br><span class="line">pthread_cond_signal(&amp;pool-&gt;producer_wait_consumer);</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印,busynum++</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread %ld start working...\n&quot;</span>, pthread_self());</span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_busy_num);</span><br><span class="line">pool-&gt;busy_num++;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_busy_num);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行函数,完成任务,销毁任务队列中这个数据(函数)</span></span><br><span class="line">task.function(task.args);</span><br><span class="line"><span class="built_in">free</span>(task.args);</span><br><span class="line">task.args = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印,busynum--</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread %ld end working\n&quot;</span>, pthread_self());</span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_busy_num);</span><br><span class="line">pool-&gt;busy_num--;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_busy_num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;shutdown)</span><br><span class="line">Thread_Exit(pool);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">Manager</span><span class="params">(<span class="type">void</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line">ThreadPool* pool = (ThreadPool*)args;</span><br><span class="line"><span class="keyword">while</span> (!pool-&gt;shutdown)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//每隔三秒检查一次</span></span><br><span class="line">sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出线程池中任务的数量和当前的线程数量</span></span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="type">int</span> queue_size = pool-&gt;queue_size;</span><br><span class="line"><span class="type">int</span> live_num = pool-&gt;live_num;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出忙的线程数量</span></span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_busy_num);</span><br><span class="line"><span class="type">int</span> busy_num = pool-&gt;busy_num;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_busy_num);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加线程</span></span><br><span class="line"><span class="comment">//任务个数&gt;存活线程个数 &amp;&amp; 存活线程个数&lt;最大线程数(消费者太少了,任务队列消化太慢</span></span><br><span class="line"><span class="keyword">if</span> (queue_size &gt; live_num &amp;&amp; live_num &lt; pool-&gt;max_num)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;max_num &amp;&amp;</span><br><span class="line"> counter &lt; NUMBER &amp;&amp; </span><br><span class="line">pool-&gt;live_num &lt; pool-&gt;max_num; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;threadID[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_create(&amp;pool-&gt;threadID[i], <span class="literal">NULL</span>, Worker, pool);</span><br><span class="line">counter++;</span><br><span class="line">pool-&gt;live_num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_pool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁线程</span></span><br><span class="line"><span class="comment">//忙的线程*2 &lt; 存活的线程数 &amp;&amp; 存活的线程&gt;最小线程数</span></span><br><span class="line"><span class="keyword">if</span> (busy_num * <span class="number">2</span> &lt; live_num &amp;&amp; live_num &gt; pool-&gt;min_num)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex_pool);</span><br><span class="line">pool-&gt;exit_num = NUMBER;</span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex_pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">//让工作的线程自杀</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMBER; ++i)</span><br><span class="line">&#123;</span><br><span class="line">pthread_cond_signal(&amp;pool-&gt;consumer_wait_producer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread_Exit</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pthread_t</span> tid = pthread_self();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;max_num; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;threadID[i] == tid)</span><br><span class="line">&#123;</span><br><span class="line">pool-&gt;threadID[i] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread %ld exiting...\n&quot;</span>, tid);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-测试部分"><a href="#2-3-测试部分" class="headerlink" title="2.3 测试部分"></a>2.3 测试部分</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Task_Test</span><span class="params">(<span class="type">void</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num = *(<span class="type">int</span>*)args;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread %ld is working,number = %d\n&quot;</span>, pthread_self(), num);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">ThreadPool* pool = Thread_Pool_Create(<span class="number">3</span>, <span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>* num = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*num = i + <span class="number">100</span>;</span><br><span class="line">Thread_Pool_Add(pool, Task_Test, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">Thread_Pool_Destroy(pool);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="3-C-实现线程池"><a href="#3-C-实现线程池" class="headerlink" title="3. C++实现线程池"></a>3. C++实现线程池</h1><h2 id="3-1-头文件"><a href="#3-1-头文件" class="headerlink" title="3.1 头文件"></a>3.1 头文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> callback = <span class="built_in">void</span>(*)(<span class="type">void</span>*);</span><br><span class="line"><span class="comment">//任务的结构体</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Task</span>()</span><br><span class="line">&#123;</span><br><span class="line">function = <span class="literal">nullptr</span>;</span><br><span class="line">args = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Task</span>(callback fun, <span class="type">void</span>* args)</span><br><span class="line">&#123;</span><br><span class="line">function = fun;</span><br><span class="line"><span class="keyword">this</span> -&gt; args = (T*)args;</span><br><span class="line">&#125;</span><br><span class="line">callback function;</span><br><span class="line">T* args;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务队列</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_mutex_init</span>(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddTask</span><span class="params">(Task&lt;T&gt; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">queue.<span class="built_in">push</span>(task);</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddTask</span><span class="params">(callback fun, <span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"><span class="function">Task&lt;T&gt; <span class="title">task</span><span class="params">(fun,args)</span></span>; </span><br><span class="line">queue.<span class="built_in">push</span>(task);</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出一个任务</span></span><br><span class="line"><span class="function">Task&lt;T&gt; <span class="title">TakeTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Task&lt;T&gt; task;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">if</span> (queue.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">task = queue.<span class="built_in">front</span>();</span><br><span class="line">queue.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前队列中的任务个数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetTaskNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> queue.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex; <span class="comment">//互斥锁</span></span><br><span class="line">std::queue&lt;Task&lt;T&gt;&gt; queue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ThreadPool</span>(<span class="type">int</span> min , <span class="type">int</span> max)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//实例化任务队列</span></span><br><span class="line">taskqueue = <span class="keyword">new</span> TaskQueue&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化线程池</span></span><br><span class="line">min_num = min;</span><br><span class="line">max_num = max;</span><br><span class="line">busy_num = <span class="number">0</span>;</span><br><span class="line">live_num = min;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据线程最大上限,给线程数组分配内存</span></span><br><span class="line">threadID = <span class="keyword">new</span> <span class="type">pthread_t</span>[max];</span><br><span class="line"><span class="keyword">if</span> (threadID == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;new threadID fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化线程ID</span></span><br><span class="line"><span class="built_in">memset</span>(threadID, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化互斥锁和条件变量</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;mutex_pool, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line"><span class="built_in">pthread_cond_init</span>(&amp;notempty, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mutex or cond init fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; min; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;threadID[i], <span class="literal">NULL</span>, Work, <span class="keyword">this</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;create thread ID :&quot;</span> &lt;&lt; <span class="built_in">to_string</span>(threadID[i]) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;managerID, <span class="literal">NULL</span>, Manage, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">shutdown = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//销毁管理者进程</span></span><br><span class="line"><span class="built_in">pthread_join</span>(managerID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒消费者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; live_num; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_cond_signal</span>(&amp;notempty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (taskqueue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> taskqueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (threadID)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] threadID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_pool);</span><br><span class="line"><span class="built_in">pthread_cond_destroy</span>(&amp;notempty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add_Task</span><span class="params">(Task&lt;T&gt; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (shutdown)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加任务,不需加锁,队列中有</span></span><br><span class="line">taskqueue-&gt;<span class="built_in">AddTask</span>(task);</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒消费者</span></span><br><span class="line"><span class="built_in">pthread_cond_signal</span>(&amp;notempty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取忙线程个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get_Busy_Num</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> busynum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex_pool);</span><br><span class="line">busynum = busy_num;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_pool);</span><br><span class="line"><span class="keyword">return</span> busynum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取存活线程个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get_Live_Num</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> livenum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex_pool); </span><br><span class="line">livenum = live_num; </span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_pool); </span><br><span class="line"><span class="keyword">return</span> livenum; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//工作的线程任务函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">Work</span><span class="params">(<span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ThreadPool* pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//访问任务队列加锁</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="comment">//判断任务队列是否为空,空了就堵塞</span></span><br><span class="line"><span class="keyword">while</span> (pool-&gt;taskqueue-&gt;<span class="built_in">GetTaskNum</span>() == <span class="number">0</span> &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;thread :&quot;</span> &lt;&lt; <span class="built_in">to_string</span>(<span class="built_in">pthread_self</span>()) &lt;&lt; <span class="string">&quot; waiting...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">pthread_cond_wait</span>(&amp;pool-&gt;notempty, &amp;pool-&gt;mutex_pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解除后 判断是否要销毁进程</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;exit_num &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pool-&gt;exit_num--;</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;live_num &gt; pool-&gt;min_num)</span><br><span class="line">&#123;</span><br><span class="line">pool-&gt;live_num--;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line">pool-&gt;<span class="built_in">Thread_Exit</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断线程池是否要关闭了</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;shutdown)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line">pool-&gt;<span class="built_in">Thread_Exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从任务队列取出任务</span></span><br><span class="line">Task&lt;T&gt; task = pool-&gt;taskqueue-&gt;<span class="built_in">TakeTask</span>();</span><br><span class="line">pool-&gt;busy_num++;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;thread :&quot;</span> &lt;&lt; <span class="built_in">to_string</span>(<span class="built_in">pthread_self</span>()) &lt;&lt; <span class="string">&quot; start working...&quot;</span> &lt;&lt; endl;</span><br><span class="line">task.<span class="built_in">function</span>(task.args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> task.args;</span><br><span class="line">task.args = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务结束</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;thread :&quot;</span> &lt;&lt; <span class="built_in">to_string</span>(<span class="built_in">pthread_self</span>()) &lt;&lt; <span class="string">&quot; end working...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line">pool-&gt;busy_num--;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理者线程任务函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">Manage</span><span class="params">(<span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ThreadPool* pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(args);</span><br><span class="line"><span class="keyword">while</span> (!pool-&gt;shutdown)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//5秒检测一次</span></span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="type">int</span> livenum = pool-&gt;live_num;</span><br><span class="line"><span class="type">int</span> busynum = pool-&gt;busy_num;</span><br><span class="line"><span class="type">int</span> queuesize = pool-&gt;taskqueue-&gt;<span class="built_in">GetTaskNum</span>();</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUMBER = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="keyword">if</span> (queuesize &gt; livenum &amp;&amp; livenum &lt; pool-&gt;max_num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;max_num &amp;&amp; </span><br><span class="line">num &lt; NUMBER &amp;&amp; </span><br><span class="line">pool-&gt;live_num &lt; pool-&gt;max_num ; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;threadID[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;pool-&gt;threadID[i], <span class="literal">NULL</span>, Work, pool);</span><br><span class="line">num++;</span><br><span class="line">pool-&gt;live_num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="keyword">if</span> (busynum * <span class="number">2</span> &lt; livenum &amp;&amp; livenum &gt; pool-&gt;min_num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line">pool-&gt;exit_num = NUMBER;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutex_pool);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMBER; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;notempty);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread_Exit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">pthread_t</span> tid = <span class="built_in">pthread_self</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max_num; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (threadID[i] == tid)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;thread :&quot;</span> &lt;&lt; <span class="built_in">to_string</span>(<span class="built_in">pthread_self</span>()) &lt;&lt; <span class="string">&quot;exiting&quot;</span> &lt;&lt; endl;</span><br><span class="line">threadID[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_pool;</span><br><span class="line"><span class="type">pthread_cond_t</span> notempty;</span><br><span class="line"><span class="type">pthread_t</span>* threadID;</span><br><span class="line"><span class="type">pthread_t</span> managerID;</span><br><span class="line">TaskQueue&lt;T&gt;* taskqueue;</span><br><span class="line"><span class="type">int</span> min_num;</span><br><span class="line"><span class="type">int</span> max_num;</span><br><span class="line"><span class="type">int</span> busy_num;</span><br><span class="line"><span class="type">int</span> live_num;</span><br><span class="line"><span class="type">int</span> exit_num;</span><br><span class="line"><span class="type">bool</span> shutdown = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-2-测试部分"><a href="#3-2-测试部分" class="headerlink" title="3.2  测试部分"></a>3.2  测试部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ThreadPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task_Test</span><span class="params">(<span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> num = *(<span class="type">int</span>*)args;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;thread :&quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; is working &quot;</span> &lt;&lt; <span class="string">&quot;number =&quot;</span> &lt;&lt; num &lt;&lt;endl;</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line"><span class="function">ThreadPool&lt;<span class="type">int</span>&gt; <span class="title">pool</span><span class="params">(<span class="number">3</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>* num = <span class="keyword">new</span> <span class="built_in">int</span>(i+<span class="number">100</span>);</span><br><span class="line">pool.<span class="built_in">Add_Task</span>(<span class="built_in">Task</span>&lt;<span class="type">int</span>&gt;(Task_Test,num));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">40</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><blockquote><p>以上只是基于C修改出对应于C++的代码</p></blockquote><p>并且以上代码存在一个问题<br>输出的结果有时会因为线程原因出现混乱<br>可以通过加锁来解决,但锁的数量超过1就容易导致死锁问题,所以暂且搁置</p><hr><h1 id="4-C-11实现线程池"><a href="#4-C-11实现线程池" class="headerlink" title="4. C++11实现线程池"></a>4. C++11实现线程池</h1><p>并非原创,摘于<a href="https://www.cnblogs.com/lzpong/p/6397997.html">此处</a></p><h2 id="4-1-头文件"><a href="#4-1-头文件" class="headerlink" title="4.1 头文件"></a>4.1 头文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_MAX_NUM 16</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> _initsize;</span><br><span class="line"><span class="keyword">using</span> Task = function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">vector&lt;thread&gt; _pool;</span><br><span class="line">queue&lt;Task&gt; _tasks;</span><br><span class="line">mutex _lock;</span><br><span class="line">mutex _lockGrow;</span><br><span class="line">condition_variable _task_cv;</span><br><span class="line">atomic&lt;<span class="type">bool</span>&gt; _run&#123;<span class="literal">true</span>&#125;;</span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; _spa_trd_num&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">threadpool</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> size = <span class="number">4</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_initsize = size;</span><br><span class="line"><span class="built_in">Add_Thread</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> ~<span class="built_in">threadpool</span>()</span><br><span class="line">&#123;</span><br><span class="line">_run = <span class="literal">false</span>;</span><br><span class="line">_task_cv.<span class="built_in">notify_all</span>();</span><br><span class="line"><span class="keyword">for</span> (thread&amp; thread : _pool)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (thread.<span class="built_in">joinable</span>())</span><br><span class="line">thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F,<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">commit</span><span class="params">(F&amp;&amp; f, Args&amp;&amp; ...args)</span> -&gt; future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span> &gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!_run)</span><br><span class="line"><span class="keyword">throw</span> runtime_error&#123;<span class="string">&quot;commit auto stop&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">using</span> RetType = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...));</span><br><span class="line"><span class="keyword">auto</span> task = make_shared&lt;packaged_task&lt;<span class="built_in">RetType</span>()&gt;&gt;(<span class="built_in">bind</span>(forward&lt;F&gt;(f), forward&lt;Args&gt;(args)...));</span><br><span class="line">future&lt;RetType&gt; future = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">&#123;</span><br><span class="line">lock_guard&lt;mutex&gt; lock&#123;_lock&#125;;</span><br><span class="line">_tasks.<span class="built_in">emplace</span>([task]() &#123;(*task)(); &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (_spa_trd_num &lt; <span class="number">1</span> &amp;&amp; _pool.<span class="built_in">size</span>() &lt; THREADPOOL_MAX_NUM)</span><br><span class="line"><span class="built_in">Add_Thread</span>(<span class="number">1</span>);</span><br><span class="line">_task_cv.<span class="built_in">notify_one</span>();</span><br><span class="line"><span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">commit2</span><span class="params">(F&amp;&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!_run)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#123;</span><br><span class="line">lock_guard&lt;mutex&gt; lock&#123;_lock&#125;;</span><br><span class="line">_tasks.<span class="built_in">emplace</span>(forward&lt;F&gt;(f));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (_spa_trd_num &lt; <span class="number">1</span> &amp;&amp; _pool.<span class="built_in">size</span>() &lt; THREADPOOL_MAX_NUM)</span><br><span class="line"><span class="built_in">Add_Thread</span>(<span class="number">1</span>);</span><br><span class="line">_task_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">idlCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _spa_trd_num; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">thrCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _pool.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add_Thread</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!_run)</span><br><span class="line"><span class="keyword">throw</span> runtime_error&#123;<span class="string">&quot;Add_Thread stop&quot;</span>&#125;;</span><br><span class="line">unique_lock&lt;mutex&gt; lockgrow&#123;_lockGrow&#125;;</span><br><span class="line"><span class="keyword">for</span> (; _pool.<span class="built_in">size</span>() &lt; THREADPOOL_MAX_NUM &amp;&amp; size &gt; <span class="number">0</span>; --size)</span><br><span class="line">&#123;</span><br><span class="line">_pool.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">Task task;</span><br><span class="line">&#123;</span><br><span class="line">unique_lock&lt;mutex&gt; lock&#123;_lock&#125;;</span><br><span class="line">_task_cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> !_run || !_tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"><span class="keyword">if</span> (!_run &amp;&amp; _tasks.<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">_spa_trd_num--;</span><br><span class="line">task = <span class="built_in">move</span>(_tasks.<span class="built_in">front</span>());</span><br><span class="line">_tasks.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">task</span>();</span><br><span class="line"><span class="keyword">if</span> (_spa_trd_num &gt; <span class="number">0</span> &amp;&amp; _pool.<span class="built_in">size</span>() &gt; _initsize)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#123;</span><br><span class="line">unique_lock&lt;mutex&gt; lock&#123;_lock&#125;;</span><br><span class="line">_spa_trd_num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#123;</span><br><span class="line">unique_lock&lt;mutex&gt; lock&#123;_lock&#125;;</span><br><span class="line">_spa_trd_num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>要使用pthread依赖库</p></blockquote><hr><h2 id="4-2-测试部分"><a href="#4-2-测试部分" class="headerlink" title="4.2 测试部分"></a>4.2 测试部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ThreadPool.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> slp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun1  %ld\n&quot;</span>, std::this_thread::<span class="built_in">get_id</span>());</span><br><span class="line">    <span class="keyword">if</span> (slp &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fun1 sleep %ld  =========  %ld\n&quot;</span>, slp, std::this_thread::<span class="built_in">get_id</span>());</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(slp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">gfun</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;gfun  %ld\n&quot;</span>, n, std::this_thread::<span class="built_in">get_id</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Afun</span><span class="params">(<span class="type">int</span> n = <span class="number">0</span>)</span> <span class="comment">//函数必须是 static 的才能直接使用线程池</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot;Afun  &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">Bfun</span><span class="params">(<span class="type">int</span> n, std::string str, <span class="type">char</span> c)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot;Bfun   &quot;</span> &lt;&lt; str.<span class="built_in">c_str</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; (<span class="type">int</span>)c &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">try</span> </span>&#123;</span><br><span class="line">    std::threadpool executor&#123; <span class="number">50</span> &#125;;</span><br><span class="line">    std::future&lt;<span class="type">void</span>&gt; ff = executor.<span class="built_in">commit</span>(fun1, <span class="number">0</span>);</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fg = executor.<span class="built_in">commit</span>(gfun&#123;&#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//std::future&lt;int&gt; gg = executor.commit(A::Afun, 9999); //IDE提示错误,但可以编译运行</span></span><br><span class="line">    std::future&lt;std::string&gt; gh = executor.<span class="built_in">commit</span>(A::Bfun, <span class="number">9998</span>, <span class="string">&quot;mult args&quot;</span>, <span class="number">123</span>);</span><br><span class="line">    std::future&lt;std::string&gt; fh = executor.<span class="built_in">commit</span>([]()-&gt;std::string &#123; std::cout &lt;&lt; <span class="string">&quot;hello, fh !  &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl; <span class="keyword">return</span> <span class="string">&quot;hello,fh ret !\n&quot;</span>; &#125;);</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    std::cout &lt;&lt; fg.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; fh.<span class="built_in">get</span>().<span class="built_in">c_str</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; =======  fun1,55 ========= &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">    executor.<span class="built_in">commit</span>(fun1, <span class="number">55</span>).<span class="built_in">get</span>();    <span class="comment">//调用.get()获取返回值会等待线程执行完</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::threadpool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    std::vector&lt; std::future&lt;<span class="type">int</span>&gt; &gt; results;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        results.<span class="built_in">emplace_back</span>(</span><br><span class="line">            pool.<span class="built_in">commit</span>([i] &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;hello &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">                std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;world &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> i * i;</span><br><span class="line">                &#125;)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">15</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; result : results)</span><br><span class="line">        std::cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;some error &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果<br><img src="/img/8.23.png" alt="在这里插入图片描述"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小项目 </tag>
            
            <tag> C++线程 </tag>
            
            <tag> C线程 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程同步</title>
      <link href="/2023/10/22/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/2023/10/22/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-线程同步的概念"><a href="#1-线程同步的概念" class="headerlink" title="1. 线程同步的概念"></a>1. 线程同步的概念</h1><blockquote><p>假设有4个线程A、B、C、D，当前一个线程A对内存中的共享资源进行访问的时候，其他线程B, C, D都不可以对这块内存进行操作，直到线程A对这块内存访问完毕为止，B，C，D中的一个才能访问这块内存，剩余的两个需要继续阻塞等待，以此类推，直至所有的线程都对这块内存操作完毕。 线程对内存的这种访问方式就称之为线程同步<br>通过概念的介绍，我们可以了解到所谓的<code>同步并不是多个线程同时对内存进行访问，而是按照先后顺序依次进行的。</code></p></blockquote><hr><h2 id="1-1-为什么要同步"><a href="#1-1-为什么要同步" class="headerlink" title="1.1 为什么要同步"></a>1.1 为什么要同步</h2><blockquote><p>两个线程交替数数（每个线程数50个数，交替数到100）的例子：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 50</span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程处理函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcA_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread A, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcB_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread B, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        usleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个子线程</span></span><br><span class="line">    pthread_create(&amp;p1, <span class="literal">NULL</span>, funcA_num, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;p2, <span class="literal">NULL</span>, funcB_num, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，资源回收</span></span><br><span class="line">    pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行,结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out </span><br><span class="line">Thread B, <span class="built_in">id</span> = 140504473724672, number = 1</span><br><span class="line">Thread B, <span class="built_in">id</span> = 140504473724672, number = 2</span><br><span class="line">Thread A, <span class="built_in">id</span> = 140504482117376, number = 2</span><br><span class="line">Thread B, <span class="built_in">id</span> = 140504473724672, number = 3</span><br><span class="line">Thread A, <span class="built_in">id</span> = 140504482117376, number = 4</span><br><span class="line">Thread B, <span class="built_in">id</span> = 140504473724672, number = 5</span><br><span class="line">Thread A, <span class="built_in">id</span> = 140504482117376, number = 6</span><br><span class="line">Thread B, <span class="built_in">id</span> = 140504473724672, number = 7</span><br><span class="line">Thread B, <span class="built_in">id</span> = 140504473724672, number = 8</span><br><span class="line">Thread A, <span class="built_in">id</span> = 140504482117376, number = 7</span><br><span class="line">Thread B, <span class="built_in">id</span> = 140504473724672, number = 8</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">Thread A, <span class="built_in">id</span> = 140504482117376, number = 53</span><br><span class="line">Thread A, <span class="built_in">id</span> = 140504482117376, number = 54</span><br><span class="line">Thread A, <span class="built_in">id</span> = 140504482117376, number = 55</span><br><span class="line">Thread A, <span class="built_in">id</span> = 140504482117376, number = 56</span><br><span class="line">Thread A, <span class="built_in">id</span> = 140504482117376, number = 57</span><br><span class="line">Thread A, <span class="built_in">id</span> = 140504482117376, number = 58</span><br><span class="line">Thread A, <span class="built_in">id</span> = 140504482117376, number = 59</span><br><span class="line">Thread A, <span class="built_in">id</span> = 140504482117376, number = 60</span><br><span class="line">Thread A, <span class="built_in">id</span> = 140504482117376, number = 61</span><br></pre></td></tr></table></figure><p>通过对上面的测试，可以看出虽然每个线程内部循环了50次每次数一个数，但是最终没有到100，有些数字被重复数了多次，其原因就是没有对线程进行同步处理，造成了数据的混乱。</p><p>两个线程在数数的时候需要分时复用CPU时间片，测试程序中调用了<code>sleep()</code>导致线程的CPU时间片没用完就被迫挂起, 这样就能让CPU的上下文切换（保存当前状态, 下一次继续运行的时候需要加载保存的状态）更加频繁，更容易再现数据混乱的这个现象。</p><p><img src="/img/8.18.png" alt="在这里插入图片描述"></p><p>CPU对应寄存器、一级缓存、二级缓存、三级缓存是独占的，用于存储处理的数据和线程的状态信息，数据被CPU处理完成需要再次被写入到物理内存中，物理内存数据也可以通过文件IO操作写入到磁盘中。</p><p>在测试程序中两个线程共用全局变量number当线程变成运行态之后开始数，从物理内存加载数据，然后将数据放到CPU进行运算，最后将结果更新到物理内存中。如果数数的两个线程都可以顺利完成这个流程，那么得到的结果肯定是正确的。</p><p>如果线程A执行这个过程期间就失去了CPU时间片，线程A被挂起了最新的数据没能更新到物理内存。线程B变成运行态之后从物理内存读数据，它就没有拿到最新数据，只能基于旧的数据往后数，然后失去CPU时间片挂起。线程A得到CPU时间片变成运行态，第一件事儿就是将上次没更新到内存的数据更新到内存，但是这样会导致线程B已经更新到内存的数据被覆盖，活儿白干了，最终导致有些数据会被重复数很多次。</p><hr><h2 id="1-2-同步方式"><a href="#1-2-同步方式" class="headerlink" title="1.2 同步方式"></a>1.2 同步方式</h2><p>对于多个线程访问共享资源出现数据混乱的问题，需要进行线程同步。<br>常用的线程同步方式有四种：互斥锁、读写锁、条件变量、信号量。<br>所谓的共享资源就是多个线程共同访问的变量，这些变量通常为全局数据区变量或者堆区变量，这些变量对应的共享资源也被称之为<code>临界资源</code>。</p><p><img src="/img/8.19.png" alt="在这里插入图片描述"></p><p>找到临界资源之后，再找和临界资源相关的上下文代码，这样就得到了一个代码块，这个代码块可以称之为临界区。确定好临界区（<code>临界区越小越好</code>）之后，就可以进行线程同步了，线程同步的大致处理思路是这样的：</p><ul><li>在临界区代码的上边，添加加锁函数，对临界区加锁。<br>哪个线程调用这句代码，就会把这把锁锁上，其他线程就只能阻塞在锁上了。</li><li>在临界区代码的下边，添加解锁函数，对临界区解锁。<br>出临界区的线程会将锁定的那把锁打开，其他抢到锁的线程就可以进入到临界区了。</li><li>通过锁机制能保证临界区代码最多只能同时有一个线程访问,这样并行访问就变为串行访问了。</li></ul><hr><h1 id="2-互斥锁"><a href="#2-互斥锁" class="headerlink" title="2. 互斥锁"></a>2. 互斥锁</h1><h2 id="2-1-互斥锁函数"><a href="#2-1-互斥锁函数" class="headerlink" title="2.1 互斥锁函数"></a>2.1 互斥锁函数</h2><p>互斥锁是线程同步最常用的一种方式，通过互斥锁可以锁定一个代码块, 被锁定的代码块, 所有的线程只能顺序执行(不能并行处理)，这样多线程访问共享资源数据混乱的问题就可以被解决了<br>代价就是执行效率的降低，因为默认临界区多个线程是可以并行处理的，现在只能串行处理。</p><p>在Linux中互斥锁的类型为<code>pthread_mutex_t</code>，创建一个这种类型的变量就得到了一把互斥锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span>  mutex;</span><br></pre></td></tr></table></figure><p>在创建的锁对象中保存了当前这把锁的状态信息：锁定还是打开<br>如果是锁定状态就还记录了给这把锁加锁的线程信息（线程ID）。一个互斥锁变量只能被一个线程锁定，被锁定后其他线程再对互斥锁变量加锁就会被阻塞，直到这把互斥锁被解锁，被阻塞的线程才能被解除阻塞。<br>一般情况下，<code>每一个共享资源对应一个把互斥锁，锁的个数和线程的个数无关。</code></p><hr><p>Linux 提供的互斥锁操作函数如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="comment">// restrict: 是一个关键字, 用来修饰指针,</span></span><br><span class="line"><span class="comment">//只有这个关键字修饰的指针可以访问指向的内存地址, 其他指针(强制类型转换)是不行的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放互斥锁资源            </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数:<br>mutex: 互斥锁变量的地址<br>attr: 互斥锁的属性, 一般使用默认属性即可, 这个参数指定为NULL</p></li><li><p>返回值<br> 如果函数调用成功会返回0，调用失败会返回相应的错误号：</p></li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改互斥锁的状态, 将其设定为锁定状态, 这个状态被写入到参数 mutex 中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>这个函数被调用, 首先会判断参数 mutex 互斥锁中的状态是不是锁定状态:</p><ul><li>如果没有被锁定, 是打开的, 这个线程可以加锁成功, 这个锁中会记录是哪个线程加锁成功了</li><li>如果被锁定了, 其他线程加锁就失败了, 这些线程都会阻塞在这把锁上</li><li>当这把锁被解开之后, 阻塞在锁上的线程就解除阻塞了，并且这些线程是通过竞争的方式对这把锁加锁，没抢到锁的线程继续阻塞</li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试加锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数对互斥锁变量加锁还是有两种情况:</p><ul><li>如果这把锁没有被锁定是打开的，线程加锁成功</li><li>如果锁变量被锁住了，调用这个函数加锁的线程，不会被阻塞，加锁失败直接返回错误号</li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对互斥锁解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>不是所有的线程都可以对互斥锁解锁，哪个线程加的锁, 哪个线程才能解锁成功。</p><hr><hr><h2 id="2-2-互斥锁的使用"><a href="#2-2-互斥锁的使用" class="headerlink" title="2.2 互斥锁的使用"></a>2.2 互斥锁的使用</h2><p>将上面多线程交替数数的例子修改一下，使用互斥锁进行线程同步。<br>两个线程一共操作了同一个全局变量，因此需要添加一互斥锁，来控制这两个线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一把互斥锁</span></span><br><span class="line"><span class="comment">// 全局变量, 多个线程共享</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程处理函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcA_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果线程A加锁成功, 不阻塞</span></span><br><span class="line">        <span class="comment">// 如果B加锁成功, 线程A阻塞</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">        number = cur;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread A, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcB_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// a加锁成功, b线程访问这把锁的时候是锁定的</span></span><br><span class="line">        <span class="comment">// 线程B先阻塞, a线程解锁之后阻塞解除</span></span><br><span class="line">        <span class="comment">// 线程B加锁成功了</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        number = cur;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread B, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        usleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个子线程</span></span><br><span class="line">    pthread_create(&amp;p1, <span class="literal">NULL</span>, funcA_num, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;p2, <span class="literal">NULL</span>, funcB_num, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，资源回收</span></span><br><span class="line">    pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    <span class="comment">// 线程销毁之后, 再去释放互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3.死锁"></a>3.死锁</h1><p>当多个线程访问共享资源, 需要加锁, 如果锁使用不当, 就会造成死锁这种现象。<br>线程死锁造成的后果是：所有的线程都被阻塞，并且线程的阻塞是无法解开的（因为可以解锁的线程也被阻塞了）。</p><p>造成死锁的场景有如下几种：</p><ul><li>加锁之后没有解锁</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功, 当前循环完毕没有解锁, 在下一轮循环的时候自己被阻塞了</span></span><br><span class="line">        <span class="comment">// 其余的线程也被阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        <span class="comment">// 忘记解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功</span></span><br><span class="line">        <span class="comment">// 其余的线程被阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        <span class="keyword">if</span>(xxx)</span><br><span class="line">        &#123;</span><br><span class="line">        ...;</span><br><span class="line">            <span class="keyword">return</span> ;<span class="comment">// 函数退出, 没有解锁（解锁函数无法被执行了）</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重复加锁,造成死锁</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功</span></span><br><span class="line">        <span class="comment">// 其余的线程阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 锁被锁住了, A线程阻塞</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏的比较深的情况</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">funcA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功</span></span><br><span class="line">        <span class="comment">// 其余的线程阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">funcB</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功</span></span><br><span class="line">        <span class="comment">// 其余的线程阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        funcA();<span class="comment">// 重复加锁</span></span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在程序中有多个共享资源, 因此有很多把锁，随意加锁，导致相互被阻塞</li></ul><blockquote><p>场景描述:</p><ol><li>有两个共享资源:X, Y，X对应锁A, Y对应锁B<ul><li>线程A访问资源X, 加锁A</li><li>线程B访问资源Y, 加锁B</li></ul></li><li>线程A要访问资源Y, 线程B要访问资源X，因为资源X和Y已经被对应的锁锁住了，因此这个两个线程被阻塞<ul><li>线程A被锁B阻塞了, 无法打开A锁</li><li>线程B被锁A阻塞了, 无法打开B锁</li></ul></li></ol></blockquote><p><img src="/img/8.20.png" alt="在这里插入图片描述"></p><p>在使用多线程编程的时候，如何避免死锁呢？</p><ul><li><p>避免多次锁定, 多检查</p></li><li><p>对共享资源访问完毕之后, 一定要解锁，或者在加锁的使用 <code>trylock</code></p></li><li><p>如果程序中有多把锁, 可以控制对锁的访问顺序(顺序访问共享资源，但在有些情况下是做不到的)，另外也可以在对其他互斥锁做加锁操作之前，先释放当前线程拥有的互斥锁。</p></li><li><p>项目程序中可以引入一些专门用于死锁检测的模块</p></li></ul><hr><h1 id="4-读写锁"><a href="#4-读写锁" class="headerlink" title="4. 读写锁"></a>4. 读写锁</h1><h2 id="4-1-读写锁函数"><a href="#4-1-读写锁函数" class="headerlink" title="4.1 读写锁函数"></a>4.1 读写锁函数</h2><p>读写锁是互斥锁的升级版, 在做读操作的时候可以提高程序的执行效率<br>如果所有的线程都是做读操作, 那么读是并行的，但使用互斥锁，读操作是串行的。</p><p>读写锁是一把锁，锁的类型为<code>pthread_rwlock_t</code>，有了类型之后就可以创建一把互斥锁了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br></pre></td></tr></table></figure><p>之所以称其为读写锁，是因为这把锁既可以锁定读操作，也可以锁定写操作。<br>为了方便理解，可以大致认为在这把锁中记录了这些信息：</p><ul><li>锁的状态: 锁定&#x2F;打开</li><li>锁定的是什么操作: 读操作&#x2F;写操作，使用读写锁锁定了读操作，需要先解锁才能去锁定写操作，反之亦然。</li><li>哪个线程将这把锁锁上了</li></ul><p>读写锁的使用方式与互斥锁的使用方式是完全相同的：<br>找共享资源, 确定临界区，在临界区的开始位置加锁（读锁&#x2F;写锁），临界区的结束位置解锁。</p><p>因为通过一把读写锁可以锁定读或者写操作，下面介绍一下关于读写锁的特点：</p><ol><li>使用读写锁的<code>读锁</code>锁定了临界区，线程对临界区的访问是并行的，读锁是共享的。</li><li>使用读写锁的<code>写锁</code>锁定了临界区，线程对临界区的访问是串行的，写锁是独占的。</li><li>使用读写锁分别对两个临界区加了读锁和写锁，两个线程要同时访问者两个临界区，访问写锁临界区的线程继续运行，访问读锁临界区的线程阻塞，因为<code>写锁比读锁的优先级高</code>。</li></ol><blockquote><p>如果程序中所有的线程都对共享资源做写操作，使用读写锁没有优势，和互斥锁是一样的<br>如果程序中所有的线程都对共享资源有写有读操作，且对共享资源<code>读的操作越多，读写锁更有优势。</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放读写锁占用的系统资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul><li>返回值<br> 函数调用成功返回0，失败返回对应的错误号</li><li>参数<br> rwlock: 读写锁的地址，传出参数<br>attr: 读写锁属性，一般使用默认属性，指定为NULL</li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在程序中对读写锁加读锁, 锁定的是读操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>如果读写锁是打开的，那么加锁成功；<br>如果读写锁已经锁定了读操作，调用这个函数<code>依然可以加锁成功</code>，因为读锁是共享的；<br>如果读写锁已经锁定了写操作，调用这个函数的线程会被阻塞。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可以有效的避免死锁</span></span><br><span class="line"><span class="comment">// 如果加读锁失败, 不会阻塞当前线程, 直接返回错误号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>如果读写锁是打开的，那么加锁成功；<br>如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；<br>如果读写锁已经锁定了写操作，调用这个函数加锁失败，对应的线程不会被阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在程序中对读写锁加写锁, 锁定的是写操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>如果读写锁是打开的，那么加锁成功；<br>如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数的线程会被阻塞。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可以有效的避免死锁</span></span><br><span class="line"><span class="comment">// 如果加写锁失败, 不会阻塞当前线程, 直接返回错误号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>如果读写锁是打开的，那么加锁成功；<br>如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数加锁失败，但是线程不会阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解锁, 不管锁定了读还是写都可用解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="4-2-读写锁的使用"><a href="#4-2-读写锁的使用" class="headerlink" title="4.2 读写锁的使用"></a>4.2 读写锁的使用</h2><blockquote><p>8个线程操作同一个全局变量，3个线程不定时写同一全局资源，5个线程不定时读同一全局资源。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义读写锁</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写的线程的处理函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">writeNum</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur ++;</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++写操作完毕, number : %d, tid = %ld\n&quot;</span>, </span><br><span class="line">        number, pthread_self());</span><br><span class="line">        </span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        <span class="comment">// 添加sleep目的是要看到多个线程交替工作</span></span><br><span class="line">        usleep(rand() % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读线程的处理函数</span></span><br><span class="line"><span class="comment">// 多个线程可以如果处理动作相同, 可以使用相同的处理函数</span></span><br><span class="line"><span class="comment">// 每个线程中的栈资源是独享</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">readNum</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--全局变量number = %d, tid = %ld\n&quot;</span>, number, pthread_self());</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(rand() % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化读写锁</span></span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3个写线程, 5个读的线程</span></span><br><span class="line">    <span class="type">pthread_t</span> wtid[<span class="number">3</span>];</span><br><span class="line">    <span class="type">pthread_t</span> rtid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;wtid[i], <span class="literal">NULL</span>, writeNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;rtid[i], <span class="literal">NULL</span>, readNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(wtid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(rtid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁读写锁</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="5-条件变量"><a href="#5-条件变量" class="headerlink" title="5. 条件变量"></a>5. 条件变量</h1><h2 id="5-1-条件变量函数"><a href="#5-1-条件变量函数" class="headerlink" title="5.1 条件变量函数"></a>5.1 条件变量函数</h2><p>严格意义上来说，条件变量的主要作用不是处理线程同步, 而是进行线程的阻塞。<br>多线程程序中只使用条件变量无法实现线程的同步, 必须要配合互斥锁来使用。<br>虽然条件变量和互斥锁都能阻塞线程，但是二者的效果是不一样的，二者的区别如下：</p><ul><li>假设有A-Z 26个线程，这26个线程共同访问同一把互斥锁，如果线程A加锁成功，那么其余B-Z线程访问互斥锁都阻塞，所有的线程只能顺序访问临界区</li><li>条件变量只有在满足指定条件下才会阻塞线程，如果条件不满足，多个线程可以同时进入临界区，同时读写临界资源，这种情况下会出现共享资源中数据的混乱。</li></ul><p>一般情况下条件变量用于处理<code>生产者和消费者模型</code>，并且和互斥锁配合使用。条件变量类型对应的类型为<code>pthread_cond_t</code>，这样就可以定义一个条件变量类型的变量了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br></pre></td></tr></table></figure><p>被条件变量阻塞的线程的线程信息会被记录到这个变量中，以便在解除阻塞的时候使用。</p><p>条件变量操作函数函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">      <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 销毁释放资源        </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<br>cond: 条件变量的地址<br>attr: 条件变量属性, 一般使用默认属性, 指定为NULL</li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程阻塞函数, 哪个线程调用这个函数, 哪个线程就会被阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, </span></span><br><span class="line"><span class="params"><span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br></pre></td></tr></table></figure><p>该函数在阻塞线程的时候，需要一个互斥锁参数，这个互斥锁主要功能是进行线程同步，让线程顺序进入临界区，避免出现数共享资源的数据混乱。<br>该函数会对这个互斥锁做以下几件事情：</p><ol><li>在阻塞线程时候，如果线程已经对互斥锁mutex上锁，那么会将这把锁打开，这样做是为了避免死锁</li><li>当线程解除阻塞的时候，函数内部会帮助这个线程再次将这个mutex互斥锁锁上，继续向下访问临界区</li></ol><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示的时间是从1970.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span> tv_sec;      <span class="comment">// Seconds </span></span><br><span class="line"><span class="type">long</span>   tv_nsec;     <span class="comment">// Nanoseconds [0 .. 999999999]</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将线程阻塞一定的时间长度, 时间到达之后, 线程就解除阻塞了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">           <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, </span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br></pre></td></tr></table></figure><p>这个函数的前两个参数和pthread_cond_wait函数是一样的<br>第三个参数表示线程阻塞的时长<br>但是需要额外注意一点：struct timespec这个结构体中记录的时间是从1970.1.1到某个时间点的时间，总长度使用秒&#x2F;纳秒表示。因此赋值方式相对要麻烦一点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> mytime = time(<span class="literal">NULL</span>);<span class="comment">// 1970.1.1 0:0:0 到当前的总秒数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tmsp</span>;</span></span><br><span class="line">tmsp.tv_nsec = <span class="number">0</span>;</span><br><span class="line">tmsp.tv_sec = mytime + <span class="number">100</span>;<span class="comment">// 线程阻塞100s</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 至少有一个被解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><p>调用上面两个函数中的任一，都可以唤醒被<code>pthread_cond_wait</code>或者<code>pthread_cond_timedwait</code>阻塞的线程<br>区别在于pthread_cond_signal是唤醒至少一个被阻塞的线程（总个数不定），pthread_cond_broadcast是唤醒所有被阻塞的线程</p><hr><hr><h2 id="5-2-生产者消费者"><a href="#5-2-生产者消费者" class="headerlink" title="5.2 生产者消费者"></a>5.2 生产者消费者</h2><p>生产者和消费者模型的组成：</p><ol><li>生产者线程 -&gt; 若干个</li></ol><ul><li>生产商品或者任务放入到任务队列中</li><li>任务队列满了就阻塞, 不满的时候就工作</li><li>通过一个生产者的<code>条件变量</code>控制生产者线程阻塞和非阻塞</li></ul><ol start="2"><li>消费者线程 -&gt; 若干个</li></ol><ul><li>读任务队列, 将任务或者数据取出</li><li>任务队列中有数据就消费，没有数据就阻塞</li><li>通过一个消费者的<code>条件变量</code>控制消费者线程阻塞和非阻塞</li></ul><ol start="3"><li>队列 -&gt; 存储任务&#x2F;数据，对应一块内存，为了读写访问可以通过一个数据结构维护这块内存</li></ol><ul><li>可以是数组、链表，也可以使用stl容器：queue &#x2F; stack &#x2F; list &#x2F; vector</li></ul><p><img src="/img/8.21.png" alt="在这里插入图片描述"></p><p>场景描述：使用条件变量实现生产者和消费者模型<br>生产者有5个，往链表头部添加节点，消费者也有5个，删除链表头部的节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义条件变量, 控制消费者线程</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>,pnew&gt;number,</span><br><span class="line">        pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产了任务, 通知消费者消费</span></span><br><span class="line">        pthread_cond_broadcast(&amp;cond);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">//if(head == NULL)   // 这样写有bug</span></span><br><span class="line">        <span class="keyword">while</span>(head == <span class="literal">NULL</span>)  <span class="comment">//当没有东西消费时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 消费者线程需要阻塞</span></span><br><span class="line">            <span class="comment">// 线程加互斥锁成功, 但是线程阻塞在这行代码上, 锁没解开</span></span><br><span class="line">            <span class="comment">// 函数自动将线程拥有的锁解开</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">            <span class="comment">// 当消费者线程解除阻塞之后, 会自动将这把锁锁上</span></span><br><span class="line">            <span class="comment">// 这时当前这个线程又重新拥有了这把互斥锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode&gt;number,</span><br><span class="line">        pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);        </span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化条件变量</span></span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁条件变量</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么在第7行使用if 有bug:</p><ul><li>当链表为空, 一个消费者线程都会被函数 <code>pthread_cond_wait(&amp;cond, &amp;mutex);</code>阻塞</li><li>阻塞时会打开锁,这时其他的消费者进程可能会趁机进入然后也阻塞在这里</li><li>当生产者生产了1个节点, 调用 <code>pthread_cond_broadcast(&amp;cond);</code> 唤醒了所有阻塞的线程</li><li>有一个消费者线程通过 <code>pthread_cond_wait()</code>加锁, 其余没有加锁的线程继续阻塞</li><li>加锁成功的线程向下运行, 并成功删除一个节点, 然后解锁</li><li>没有加锁成功的线程解除阻塞继续抢这把锁, 另一个子线程加锁</li><li>但是这个线程删除链表节点的时候链表已经为空了, 后边访问这个空节点时就会出现段错误</li><li>需要循环对链表是否为空进行判断, 需要将if 该成 while</li></ul><hr><h1 id="6-信号量"><a href="#6-信号量" class="headerlink" title="6. 信号量"></a>6. 信号量</h1><h2 id="6-1-信号量函数"><a href="#6-1-信号量函数" class="headerlink" title="6.1 信号量函数"></a>6.1 信号量函数</h2><p>信号量用在多线程多任务同步，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。<br>信号量不一定是锁定某一个资源，而是流程上的概念，比如：有A，B两个线程，B线程要等A线程完成某一任务以后再进行自己下面的步骤，这个任务并不一定是锁定某一资源，还可以是进行一些计算或者数据处理之类。</p><p><code>信号量(信号灯)</code>与互斥锁和条件变量的主要不同在于”灯”的概念，灯亮资源可用，灯灭则不可用。信号量主要阻塞线程, 不能完全保证线程安全，如要保证线程安全, 需要信号量互斥锁一起使用。</p><p>信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或者消费者线程的运行。信号的类型为<code>sem_t</code>对应的头文件为<code>&lt;semaphore.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">// 初始化信号量/信号灯</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源释放, 线程销毁之后调用这个函数即可</span></span><br><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数            </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>sem：信号量变量地址</li><li>pshared：<ul><li>0：线程同步</li><li>非0：进程同步</li></ul></li></ul></li><li>value：初始化当前信号量拥有的资源数（&gt;&#x3D;0），如果资源数为0，线程就会被阻塞了。</li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>sem中的资源数&gt;0，线程不会阻塞，线程会占用sem中的一个资源，因此资源数-1，<br>sem中的资源数减为0时，资源被耗尽，因此线程也就被阻塞了。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>sem中的资源数&gt;0，线程不会阻塞，线程会占用sem中的一个资源，因此资源数-1<br>sem中的资源数减为0时，资源被耗尽，但是线程不会被阻塞，直接返回错误号，因此可以在程序中添加判断分支，用于处理获取资源失败之后的情况。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示的时间是从1970.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span> tv_sec;      <span class="comment">/* Seconds */</span></span><br><span class="line"><span class="type">long</span>   tv_nsec;     <span class="comment">/* Nanoseconds [0 .. 999999999] */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用该函数线程获取sem中的一个资源，当资源数为0时，线程阻塞</span></span><br><span class="line"><span class="comment">// 在阻塞abs_timeout对应的时长之后，解除阻塞。</span></span><br><span class="line"><span class="comment">// abs_timeout: 阻塞的时间长度, 单位是s, 是从1970.1.1开始计算的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br></pre></td></tr></table></figure><p>该函数的参数<code>abs_timeout</code>和<code>pthread_cond_timedwait</code>的最后一个参数是一样的<br>sem中的资源数&gt;0，线程不会阻塞，线程会占用sem中的一个资源，因此资源数-1<br>sem中的资源数减为0时，资源被耗尽，线程被阻塞，当阻塞指定的时长之后，线程解除阻塞。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用该函数给sem中的资源数+1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>调用该函数会将sem中的资源数+1<br>如果有线程在调用<code>sem_wait</code>、<code>sem_trywait</code>、<code>sem_timedwait</code>时因sem中的资源数为0被阻塞<br>这时这些线程会解除阻塞，获取到资源之后继续向下运行。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看信号量 sem 中的整形数的当前值, 这个值会被写入到sval指针对应的内存中</span></span><br><span class="line"><span class="comment">// sval是一个传出参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br></pre></td></tr></table></figure><p>查看sem中现在拥有的资源个数，通过第二个参数sval将数据传出<br>也就是说第二个参数的作用和返回值是一样的。</p><hr><hr><h2 id="6-2-生产者消费者"><a href="#6-2-生产者消费者" class="headerlink" title="6.2 生产者消费者"></a>6.2 生产者消费者</h2><p>由于生产者和消费者是两类线程，并且在还没有生成之前是不能进行消费的<br>在使用信号量处理这类问题的时候可以定义两个信号量，分别用于记录生产者和消费者线程拥有的总资源数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者线程 </span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量初始化</span></span><br><span class="line">sem_init(&amp;psem, <span class="number">0</span>, <span class="number">5</span>);    <span class="comment">// 5个生产者可以同时生产</span></span><br><span class="line">sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">// 消费者线程没有资源, 因此不能消费</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="comment">// 在生产之前, 从信号量中取出一个资源</span></span><br><span class="line">sem_wait(&amp;psem);</span><br><span class="line"><span class="comment">// 生产者商品代码, 有商品了, 放到任务队列</span></span><br><span class="line">...... </span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 通知消费者消费，给消费者信号量添加资源，让消费者解除阻塞</span></span><br><span class="line">sem_post(&amp;csem);</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="comment">// 消费者需要等待生产, 默认启动之后应该阻塞</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line"><span class="comment">// 开始消费</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 消费完成, 通过生产者生产，给生产者信号量添加资源</span></span><br><span class="line">sem_post(&amp;psem);</span><br></pre></td></tr></table></figure><p>初始化信号量的时候没有消费者分配资源，消费者线程由于没有资源自然就被阻塞了，等生产者生产出产品之后，再给消费者分配资源，这样二者就可以配合着完成生产和消费流程了。</p><hr><h2 id="6-3-信号量使用"><a href="#6-3-信号量使用" class="headerlink" title="6.3 信号量使用"></a>6.3 信号量使用</h2><blockquote><p>使用信号量实现生产者和消费者模型<br>生产者5个，往链表头部添加节点，消费者5个，删除链表头部的节点。</p></blockquote><hr><h3 id="6-3-1-总资源数为1"><a href="#6-3-1-总资源数为1" class="headerlink" title="6.3.1 总资源数为1"></a>6.3.1 总资源数为1</h3><p>如果生产者和消费者线程使用的信号量对应的总资源数为1<br>那么不管线程有多少个，可以工作的线程只有一个，其余线程由于拿不到资源，都被迫阻塞了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生产者拿一个信号灯</span></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>,pnew&gt;number,</span><br><span class="line">        pthread_self());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者消费, 给消费者加信号灯</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode&gt;number,</span><br><span class="line">        pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        <span class="comment">// 通知生产者生成, 给生产者加信号灯</span></span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="comment">// 生产者和消费者拥有的信号灯的总和为1</span></span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 生成者线程一共有1个信号灯</span></span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 消费者线程一共有0个信号灯</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;psem);</span><br><span class="line">    sem_destroy(&amp;csem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：如果生产者和消费者使用的信号量总资源数为1，那么不会出现生产者线程和消费者线程同时访问共享资源的情况，不管生产者和消费者线程有多少个，它们都是顺序执行的。</p><hr><h3 id="6-3-2-总资源数大于1"><a href="#6-3-2-总资源数大于1" class="headerlink" title="6.3.2 总资源数大于1"></a>6.3.2 总资源数大于1</h3><p>如果生产者和消费者线程使用的信号量对应的总资源数为大于1，这种场景下出现的情况就多了：</p><ul><li>多个生产者线程同时生产</li><li>多个消费者同时消费</li><li>生产者线程和消费者线程同时生产和消费</li></ul><p>以上不管哪一种情况都可能会出现多个线程访问共享资源的情况<br>如果想防止共享资源出现数据混乱，那么就需要使用互斥锁进行线程同步，处理代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生产者拿一个信号灯</span></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        <span class="comment">// 加锁, 这句代码放到 sem_wait()上边, 有可能会造成死锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>,pnew&gt;number,</span><br><span class="line">        pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者消费</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode&gt;number,</span><br><span class="line">        pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 通知生产者生成, 给生产者加信号灯</span></span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// 生成者线程一共有5个信号灯</span></span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 消费者线程一共有0个信号灯</span></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;psem);</span><br><span class="line">    sem_destroy(&amp;csem);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在写上述代码时有一个需要注意是事项<br>不管是消费者线程的处理函数还是生产者线程的处理函数内部有这么两行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br></pre></td></tr></table></figure><p>这两行代码的调用顺序是不能颠倒的，否则就有可能会造成死锁，下面来分析一种死锁的场景：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 生产者拿一个信号灯</span></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">......</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 通知消费者消费</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">......</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 通知生产者生成, 给生产者加信号灯</span></span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// 生成者线程一共有5个信号灯</span></span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 消费者线程一共有0个信号灯</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化状态下消费者线程没有任务信号量资源<br>假设某一个消费者线程先运行，调用<code>pthread_mutex_lock(&amp;mutex);</code>对互斥锁加锁成功<br>然后调用<code>sem_wait(&amp;csem);</code>由于没有资源，因此被阻塞了。<br>其余的消费者线程由于没有抢到互斥锁，因此被阻塞在互斥锁上。</p><p>对应生产者线程第一步操作也是调用<code>pthread_mutex_lock(&amp;mutex);</code><br>但是这时候互斥锁已经被消费者线程锁上了，所有生产者都被阻塞<br>到此为止，多余的线程都被阻塞了，程序产生了死锁。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程同步 </tag>
            
            <tag> C线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tips</title>
      <link href="/2023/10/22/thread-tips/"/>
      <url>/2023/10/22/thread-tips/</url>
      
        <content type="html"><![CDATA[<h1 id="1-线程介绍"><a href="#1-线程介绍" class="headerlink" title="1. 线程介绍"></a>1. 线程介绍</h1><p>线程是轻量级的进程（LWP：light weight process），在Linux环境下线程的本质仍是进程。<br>在计算机上运行的程序是一组指令及指令参数的组合，指令按照既定的逻辑控制计算机运行。<br>操作系统会以进程为单位，分配系统资源，可以这样理解<br>进程是<code>资源分配的最小单位，线程是操作系统调度执行的最小单位。</code></p><p>从概念上来说线程和进程的区别:</p><ul><li><p>进程有自己独立的地址空间, 多个线程共用同一个地址空间</p><ul><li>线程更节省系统资源, 效率不仅可以保持, 而且能更高</li><li>在一个地址空间中多个线程独享: 每个线程都有属于自己的栈区, 寄存器(内核中管理的)</li><li>在一个地址空间中多个线程共享: 代码段, 堆区, 全局数据区, 打开的文件(文件描述符表)</li></ul></li><li><p>线程是程序的最小执行单位, 进程是操作系统中最小的资源分配单位</p><ul><li>每个进程对应一个虚拟地址空间，一个进程只能抢一个CPU时间片</li><li>一个地址空间中可以划分出多个线程, 能在有效的资源基础上, 抢更多的CPU时间片</li></ul></li></ul><p><img src="/img/8.16.png" alt="在这里插入图片描述"></p><ul><li>CPU的调度和切换: 线程的上下文切换比进程要快的多<br>上下文切换：进程&#x2F;线程分时复用CPU时间片，在切换之前会将上一个任务的状态进行保存, 下次切换回这个任务的时候, 加载这个状态继续运行，<code>任务从保存到再次加载</code>这个过程就是一次上下文切换。</li><li>线程更加廉价, 启动速度更快, 退出也快, 对系统资源的冲击小。</li></ul><p><strong>在处理多任务程序的时候使用多线程比使用多进程要更有优势，但是线程并不是越多越好</strong></p><ol><li>文件IO操作：文件IO对CPU是使用率不高, 因此可以分时复用CPU时间片<br>线程的个数 &#x3D; 2 * CPU核心数 (效率最高)</li><li>处理复杂的算法(主要是CPU进行运算, 压力大)<br> 线程的个数 &#x3D; CPU的核心数 (效率最高)</li></ol><hr><h1 id="2-创建线程"><a href="#2-创建线程" class="headerlink" title="2. 创建线程"></a>2. 创建线程</h1><h2 id="2-1-线程函数"><a href="#2-1-线程函数" class="headerlink" title="2.1 线程函数"></a>2.1 线程函数</h2><blockquote><p>每一个线程都有一个唯一的线程ID，ID类型为<code>pthread_t</code><br>这个ID是一个无符号长整形(<code>unsigned long</code>)</p></blockquote><p>如果想要得到当前线程的线程ID，可以调用如下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">// 返回当前线程的线程ID</span></span><br></pre></td></tr></table></figure><p>在一个进程中调用线程创建函数，就可得到一个子线程<br>和进程不同，需要给每一个创建出的线程指定一个处理函数，否则这个线程无法工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                    <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), </span></span><br><span class="line"><span class="params">                    <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="comment">// Compile and link with -pthread</span></span><br><span class="line"><span class="comment">//线程库的名字叫pthread, 全名: libpthread.so libptread.a</span></span><br></pre></td></tr></table></figure><p>介绍一下pthread_create函数的</p><ul><li>参数<br><code>thread</code>: 传出参数,无符号长整形,线程创建成功, 会将线程ID写入到这个指针指向的内存中<br><code>attr</code>: 线程的属性, 一般情况下使用默认属性即可, 写NULL<br><code>start_routine</code>: 函数指针，创建出的子线程的处理动作，该函数在子线程中执行。<br><code>arg</code>: 作为实参传递到 start_routine 指针指向的函数内部</li><li>返回值：线程创建成功返回0，创建失败返回对应的错误号</li></ul><hr><h2 id="2-2-创建线程"><a href="#2-2-创建线程" class="headerlink" title="2.2 创建线程"></a>2.2 创建线程</h2><p><img src="/img/8.17.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">Work</span><span class="params">(<span class="type">void</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子线程id: %ld\n&quot;</span>,pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> ; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i : %d\n&quot;</span>,i);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.创建子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,Work,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功,线程id : %ld\n&quot;</span>,tid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.子线程不会执行下面的代码,由主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主线程id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> ; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i == %d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行休息,否则可能导致子线程未执行时,主线程已经结束,直接结束了进程</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>使用gcc编译时容易出现的错误</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc pthread_create.c </span><br></pre></td></tr></table></figure><p>错误原因是编译器链接不到线程库文件(动态库)，需在编译时通过参数指定出来<br>动态库名为 <code>libpthread.so</code>需要使用的参数为 <code>-l</code><br>据规则掐头去尾最终形态应该写成：<code>-lpthread</code>（参数和参数值中间可以有空格）。</p><p>所以正确的写法是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc pthread_create.c -lpthread</span><br></pre></td></tr></table></figure><blockquote><p>在打印的输出中为什么子线程处理函数没有执行呢（只看到了子线程的部分日志输出?<br>主线程一直在运行, 执行期间创建出了子线程，说明主线程有CPU时间片, 在这个时间片内将代码执行完毕了, 主线程就退出了。<br>子线程被创建出来之后需要抢cpu时间片, 抢不到就不能运行，如果主线程退出了, <code>虚拟地址空间就被释放了, 子线程一并销毁</code>。<br>但是如果某一个子线程退出了, 主线程仍在运行, 虚拟地址空间依旧存在。<br>结论：在没有人为干预的情况下，虚拟地址空间的生命周期和主线程是一样的，与子线程无关。<br>目前的解决方案: 让子线程执行完毕, 主线程再退出, 可以在主线程中添加挂起函数 <code>sleep();</code></p></blockquote><hr><h1 id="3-线程退出"><a href="#3-线程退出" class="headerlink" title="3. 线程退出"></a>3. 线程退出</h1><blockquote><p>在编写多线程程序的时候，如果想要让线程退出，但不导致虚拟地址空间的释放（针对于主线程）<br>我们就可以调用线程库中的线程退出函数，只要调用该函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，不管是在<code>子线程或者主线程中都可以使用</code>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<br> 线程退出时携带的数据，当前子线程的主线程会得到该数据。如果不需要使用，指定为NULL</li></ul><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);<span class="comment">// 直接退出子线程</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程调用退出函数退出, 地址空间不会被释放</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="4-线程回收"><a href="#4-线程回收" class="headerlink" title="4. 线程回收"></a>4. 线程回收</h1><h2 id="4-1-线程函数"><a href="#4-1-线程函数" class="headerlink" title="4.1 线程函数"></a>4.1 线程函数</h2><blockquote><p>线程和进程一样，子线程退出的时候其内核资源主要由主线程回收<br>线程库中提供的线程回收函叫做<code>pthread_join()</code><br>这个函数是一个阻塞函数<br>子线程在运行, 调用该函数就会阻塞<br>子线程退出, 函数解除阻塞进行资源的回收.<br>函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。<br>另外通过线程回收函数还可以获取到子线程退出时传递出来的数据，函数原型如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 这是一个阻塞函数, 子线程在运行这个函数就阻塞</span></span><br><span class="line"><span class="comment">// 子线程退出, 函数解除阻塞, 回收对应的子线程资源, 类似于回收进程使用的函数 wait()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>thread: 要被回收的子线程的线程ID</li><li>retval: 二级指针, 指向一级指针的地址, 是一个传出参数, 这个地址中存储了pthread_exit() 传递出的数据，如果不需要这个参数，可以指定为NULL</li></ul></li><li>返回值：线程回收成功返回0，回收失败返回错误号。</li></ul><hr><h2 id="4-2-回收子线程数据"><a href="#4-2-回收子线程数据" class="headerlink" title="4.2 回收子线程数据"></a>4.2 回收子线程数据</h2><blockquote><p>在子线程退出的时候可以使用<code>pthread_exit()</code>的参数将数据传出<br>在回收这个子线程的时候可以通过<code>phread_join()</code>的第二个参数来接收子线程传递出的数据。接收数据有很多种处理方式，列举几种：</p></blockquote><h3 id="4-2-1-使用子线程栈"><a href="#4-2-1-使用子线程栈" class="headerlink" title="4.2.1 使用子线程栈"></a>4.2.1 使用子线程栈</h3><blockquote><p>通过函数<code>pthread_exit(void *retval);</code>可以得知，子线程退出的时候，需要将数据记录到一块内存中，通过参数传出的是存储数据的内存的地址，而不是具体数据，因为参数是void*类型，所有这个万能指针可以指向任意类型的内存地址。先来看第一种方式，将子线程退出数据保存在子线程自己的栈区：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_join.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> <span class="title">p</span>;</span></span><br><span class="line">            p.age  =<span class="number">12</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            p.id = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 该函数的参数将这个地址传递给了主线程的pthread_join()</span></span><br><span class="line">            pthread_exit(&amp;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">// 代码执行不到这个位置就退出了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存</span></span><br><span class="line">    <span class="comment">// 这个内存地址就是pthread_exit() 参数指向的内存</span></span><br><span class="line">    pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span>* <span class="title">pp</span> =</span> (<span class="keyword">struct</span> Persion*)ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程返回数据: name: %s, age: %d, id: %d\n&quot;</span>, pp-&gt;name, pp-&gt;age, pp-&gt;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是当我们编译时打印出的信息并没有得到子线程的数据</p><blockquote><p>具体原因是这样的：<br>如果多个线程共用同一个虚拟地址空间，每个线程在栈区都有一块属于自己的内存，相当于栈区被这几个线程平分了，当线程退出，线程在栈区的内存也就被回收了，因此随着子线程的退出，写入到栈区的数据也就被释放了。</p></blockquote><hr><h3 id="4-2-2-使用全局变量"><a href="#4-2-2-使用全局变量" class="headerlink" title="4.2.2 使用全局变量"></a>4.2.2 使用全局变量</h3><blockquote><p>位于同一虚拟地址空间中的线程，虽然不能共享栈区数据，但可以共享全局<code>数据区和堆区</code>数据，因此在子线程退出的时候可以将传出数据存储到全局变量、静态变量或者堆内存中。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> <span class="title">p</span>;</span><span class="comment">// 定义全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用全局变量</span></span><br><span class="line">            p.age  =<span class="number">12</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            p.id = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 该函数的参数将这个地址传递给了主线程的pthread_join()</span></span><br><span class="line">            pthread_exit(&amp;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存</span></span><br><span class="line">    <span class="comment">// 这个内存地址就是pthread_exit() 参数指向的内存</span></span><br><span class="line">    pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span>* <span class="title">pp</span> =</span> (<span class="keyword">struct</span> Persion*)ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name: %s, age: %d, id: %d\n&quot;</span>, pp-&gt;name, pp-&gt;age, pp-&gt;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-2-3-使用主线程栈"><a href="#4-2-3-使用主线程栈" class="headerlink" title="4.2.3 使用主线程栈"></a>4.2.3 使用主线程栈</h3><blockquote><p>虽然每个线程都有属于自己的栈区空间，但是位于<code>同一个地址空间的多个线程是可以相互访问对方的栈空间上的数据的。</code><br>由于很多情况下还需要在主线程中回收子线程资源，所以主线程一般都是最后退出，基于这个原因在下面程序中将子线程返回的数据保存到了主线程的栈区内存中：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span>* <span class="title">p</span> =</span> (<span class="keyword">struct</span> Persion*)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用主线程的栈内存</span></span><br><span class="line">            p-&gt;age  =<span class="number">12</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p-&gt;name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            p-&gt;id = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 该函数的参数将这个地址传递给了主线程的pthread_join()</span></span><br><span class="line">            pthread_exit(p); <span class="comment">//p本来就是指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> <span class="title">p</span>;</span></span><br><span class="line">    <span class="comment">// 主线程的栈内存传递给子线程</span></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, &amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存</span></span><br><span class="line">    <span class="comment">// 这个内存地址就是pthread_exit() 参数指向的内存</span></span><br><span class="line">    pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name: %s, age: %d, id: %d\n&quot;</span>, p.name, p.age, p.id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的程序中，调用pthread_create()创建子线程，并将主线程中栈空间变量p的地址传递到了子线程中，在子线程中将要传递出的数据写入到了这块内存中。<br>也就是说在程序的main()函数中，通过指针变量ptr或者通过结构体变量p都可以读出子线程传出的数据。</p></blockquote><hr><h1 id="5-线程分离"><a href="#5-线程分离" class="headerlink" title="5. 线程分离"></a>5. 线程分离</h1><blockquote><p>在某些情况下，程序中的主线程有属于自己的业务处理流程，如果让主线程负责子线程的资源回收，调用pthread_join()只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。<br>在线程库函数中为我们提供了线程分离函数<code>pthread_detach()</code>，调用这个函数之后指定的子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了。<code>线程分离之后在主线程中使用pthread_join()就回收不到子线程资源了。</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数是子线程的线程ID, 主线程就可以和这个子线程分离了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置子线程和主线程分离</span></span><br><span class="line">    pthread_detach(tid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程自己退出即可</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="6-其他线程函数"><a href="#6-其他线程函数" class="headerlink" title="6. 其他线程函数"></a>6. 其他线程函数</h1><h2 id="6-1-线程取消"><a href="#6-1-线程取消" class="headerlink" title="6.1 线程取消"></a>6.1 线程取消</h2><blockquote><p>线程取消的意思就是在某些特定情况下在一个线程中杀死另一个线程。<br>使用这个函数杀死一个线程需要分两步：<br>在线程A中调用线程取消函数pthread_cancel，指定杀死线程B，这时候线程B是死不了的<br>在线程B中进程一次<code>系统调用</code>（从用户区切换到内核区），否则线程B可以一直运行。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：要杀死的线程的线程ID</li><li>返回值：函数调用成功返回0，调用失败返回非0错误号。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf函数会调用系统函数, 因此这是个间接的系统调用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; child i: %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 杀死子线程, 如果子线程中做系统调用, 子线程就结束了</span></span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程自己退出即可</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于系统调用有两种方式：</p><ul><li>直接调用Linux系统函数</li><li>调用标准C库函数，为了实现某些功能，在Linux平台下标准C库函数会调用相关的系统函数</li></ul><hr><h2 id="6-2-线程ID的比较"><a href="#6-2-线程ID的比较" class="headerlink" title="6.2 线程ID的比较"></a>6.2 线程ID的比较</h2><blockquote><p>在Linux中线程ID本质就是一个无符号长整形，因此可以直接使用比较操作符比较两个线程的ID，但是线程库是可以跨平台使用的，在某些平台上 pthread_t可能不是一个单纯的整形，这中情况下比较两个线程的ID必须要使用比较函数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：t1 和 t2 是要比较的线程的线程ID</li><li>返回值：如果两个线程ID相等返回非0值，如果不相等返回0</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GDB</title>
      <link href="/2023/10/22/GDB/"/>
      <url>/2023/10/22/GDB/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>gdb 是由 GNU 软件系统社区提供的调试器，同 gcc 配套 组成了一套完整的开发环境，可移植性好，支持非常多的体系结构并被移植到各种系统中（包括各种类 Unix 系统与 Windows 系统里的 MinGW 和 Cygwin<br>此外，除了 C ，gcc&#x2F;gdb 还支持包括 C++、Objective-C、Ada 和 Pascal 等语言后端的编译和调试。 gcc&#x2F;gdb 是 Linux 和许多类 Unix 系统中的标准开发环境，Linux 内核也是专门针对 gcc 进行编码的。</p></blockquote><p>GDB 是一套字符界面的程序集，可以使用命令 gdb 加载要调试的程序。</p><hr><h1 id="一、调试准备"><a href="#一、调试准备" class="headerlink" title="一、调试准备"></a>一、调试准备</h1><blockquote><p>项目程序如果是为调试而编译时， 必须要打开调试选项(<code>-g</code>)。<br>-g选项的作用是在可执行文件中加入源代码信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。<br>习惯上如果是c程序就使用gcc编译,  c++程序使用g++编译, 编译命令中添加上边提到的参数即可。<br>另外还有一些可选项，eg: 在尽量不影响程序行为的情况下关掉编译器的优化选项(<code>-O0</code>)，<code>-Wall</code>选项打开所有 warning，可以发现许多问题，避免一些不必要的 bug。</p></blockquote><p>假设有一个文件 args.c, 要对其进行gdb调试，编译的时候必须要添加参数 -g，加入了源代码信息的可执行文件比之前要大。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -g args.c -o app</span><br><span class="line"><span class="comment">#不加 -g 参数就无法进行gdb调试</span></span><br></pre></td></tr></table></figure><hr><h1 id="二、启动和退出gdb"><a href="#二、启动和退出gdb" class="headerlink" title="二、启动和退出gdb"></a>二、启动和退出gdb</h1><hr><h2 id="1-启动gdb"><a href="#1-启动gdb" class="headerlink" title="1.启动gdb"></a>1.启动gdb</h2><blockquote><p>gdb是一个用于应用程序调试的进程, 需要先将其打开, 一定要注意 gdb进程启动之后, 需要被调试的应用程序是没有执行的。<br>打开Linux终端，切换到要调试的可执行程序所在路径，执行如下命令就可以启动 gdb了。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb 可执行程序的名字</span><br></pre></td></tr></table></figure><hr><h2 id="2-命令行传参"><a href="#2-命令行传参" class="headerlink" title="2.命令行传参"></a>2.命令行传参</h2><blockquote><p>有些程序在启动时需传递命令行参数，如果要调试这类程序，<br>这些命令行参数必须要在应用程序启动之前通过调试程序的gdb进程传递进去。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.编译出可执行程序</span></span><br><span class="line">gcc args.c -o app -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.启动gdb进程, 指定需要gdb调试的应用程序名称</span></span><br><span class="line">gdb app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.在启动app之前设置命令行参数。</span></span><br><span class="line"><span class="comment">#gdb中设置参数的命令叫做set args ...，查看设置的命令行参数命令是 show args。 </span></span><br><span class="line"><span class="comment">#语法格式如下：</span></span><br><span class="line"><span class="comment"># 设置参数</span></span><br><span class="line"><span class="built_in">set</span> args 参数1 参数2 .... ...</span><br><span class="line"><span class="comment">#查看设置的命令行参数</span></span><br><span class="line">show args</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#非gdb调试命令行传参</span></span><br><span class="line"><span class="comment">#argv[0] == ./app， argv[1] == &quot;1&quot;  ...  argv[5] == &quot;5&quot;</span></span><br><span class="line">./app 1 2 3 4 5 <span class="comment">#将数据传送给main函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用 gdb 调试</span></span><br><span class="line"><span class="built_in">set</span> args 1 2 3 4 5</span><br><span class="line"><span class="comment">#查看设置的命令行参数</span></span><br><span class="line">show args</span><br></pre></td></tr></table></figure><hr><h2 id="3-gdb中启动程序"><a href="#3-gdb中启动程序" class="headerlink" title="3.gdb中启动程序"></a>3.gdb中启动程序</h2><blockquote><p>在gdb中启动要调试的应用程序有两种方式, 一种是使用<code>run</code>命令,<br>另一种是使用<code>start</code>命令启动。在整个 gdb 调试过程中, 启动应用程序的命令<code>只能使用一次</code>。</p></blockquote><ul><li>run: 可以缩写为 <code>r</code>, 如果程序中设置了断点会停在第一个断点的位置, 如果没设置断点, 程序就执行完了</li><li>start: 启动程序, 最终会阻塞在main函数的第一行，等待输入后续其它 gdb 指令<br> 如想让程序start后继续运行, 或在断点处继续运行，可使用 <code>continue</code>命令, 可以简写为 <code>c</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.</span></span><br><span class="line">r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.</span></span><br><span class="line">run  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.</span></span><br><span class="line">start</span><br><span class="line"><span class="built_in">continue</span></span><br><span class="line">c</span><br></pre></td></tr></table></figure><hr><h2 id="4-退出gdb"><a href="#4-退出gdb" class="headerlink" title="4.退出gdb"></a>4.退出gdb</h2><blockquote><p>退出gdb调试, 就是终止 gdb 进程, 需要使用 quit命令, 可以缩写为 q</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.</span></span><br><span class="line">quit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.</span></span><br><span class="line">q</span><br></pre></td></tr></table></figure><hr><h1 id="三、查看代码"><a href="#三、查看代码" class="headerlink" title="三、查看代码"></a>三、查看代码</h1><blockquote><p>因为gdb调试没有IDE那样的完善的可视化窗口界面，给调试的程序打断点又是调试之前必做的工作。<br>因此gdb提供了查看代码的命令，这样就可以定位要调试的代码行的位置了。<br>查看代码的命令叫做<code>list</code>可以缩写为 <code>l</code>, 通过这个命令我们可以查看项目中任意一个文件中的内容，并且还可以通过文件行号，函数名等方式查看。</p></blockquote><hr><h2 id="1-当前文件"><a href="#1-当前文件" class="headerlink" title="1.当前文件"></a>1.当前文件</h2><blockquote><p>一个项目中一般有很多源文件, 默认通过list查看到代码信息位于程序入口函数main对应的的文件中。<br>因此如果不进行文件切换, main函数所在的文件就是当前文件, 如果进行了文件切换, 切换到哪个文件哪个文件就是当前文件。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list==l</span></span><br><span class="line"><span class="comment"># 从第一行开始显示</span></span><br><span class="line">list </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列值这行号对应的上下文代码, 默认情况下只显示10行内容</span></span><br><span class="line">list 行号</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示这个函数的上下文内容, 默认显示10行</span></span><br><span class="line">list 函数名</span><br></pre></td></tr></table></figure><p>若想要向下继续查看可以按 <code>Enter</code> (再次执行上一次执行的gdb命令)</p><hr><h2 id="2-切换文件"><a href="#2-切换文件" class="headerlink" title="2.切换文件"></a>2.切换文件</h2><blockquote><p>在查看文件内容的时，需要进行文件切换<br>我们只需要在list命令后将要查看的文件名指定出来就可以了，切换命令执行完毕之后，这个文件就变成了当前文件。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到指定的文件，并列出这行号对应的上下文代码, 默认显示10行</span></span><br><span class="line">l 文件名:行号</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定的文件，并显示这个函数的上下文内容, 默认显示10行</span></span><br><span class="line">l 文件名:函数名</span><br></pre></td></tr></table></figure><hr><h2 id="3-设置显示行数"><a href="#3-设置显示行数" class="headerlink" title="3.设置显示行数"></a>3.设置显示行数</h2><blockquote><p>默认list只能一次查看10行代码, 如果想显示更多, 可通过<code>set listsize</code>设置<br> 同样如果想查看当前显示行数可通过 <code>show listsize</code>查看<br> 这里的listsize可以简写为 <code>list</code>。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#listsize == list</span></span><br><span class="line"><span class="built_in">set</span> listsize 行数</span><br><span class="line"></span><br><span class="line">show listsize</span><br></pre></td></tr></table></figure><hr><h1 id="四、断点操作"><a href="#四、断点操作" class="headerlink" title="四、断点操作"></a>四、断点操作</h1><blockquote><p>想要通过gdb调试某一行或者得到某个变量在运行状态下的实际值，就需要在在这一行设置断点<br>程序指定到断点的位置就会阻塞，我们就可通过gdb的调试命令得到我们想要的信息了。<br>设置断点的命令叫做<code>break</code>可以缩写为<code>b</code>。</p></blockquote><hr><h2 id="1-设置断点"><a href="#1-设置断点" class="headerlink" title="1.设置断点"></a>1.设置断点</h2><blockquote><p>断点的设置有两种方式<br><code>常规断点</code>，程序只要运行到这个位置就会被阻塞<br><code>条件断点</code>，只有指定的条件被满足了程序才会在断点处阻塞。<br>调试程序的断点可以设置到某个具体的行, 也可以设置到某个函数上</p></blockquote><ul><li>设置普通断点到当前文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b 行号</span><br><span class="line">b 函数名   <span class="comment">#停在函数的第一行</span></span><br></pre></td></tr></table></figure><ul><li><p>设置普通断点到非当前文件上</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b 文件名:行号</span><br><span class="line">b 文件名:函数名</span><br></pre></td></tr></table></figure></li><li><p>设置条件断点</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通常情况下, 在循环中条件断点用的比较多</span></span><br><span class="line">b 行数 <span class="keyword">if</span> 变量名==某个值</span><br></pre></td></tr></table></figure><hr><h2 id="2-查看断点"><a href="#2-查看断点" class="headerlink" title="2.查看断点"></a>2.查看断点</h2><blockquote><p>可以通过 <code>info break</code>命令查看设置的断点信息，其中info可以缩写为<code>i</code><br>即 <code>i b</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000400cb5 <span class="keyword">in</span> main() at test.cpp:12</span><br><span class="line">2       breakpoint     keep y   0x0000000000400cbd <span class="keyword">in</span> main() at test.cpp:13</span><br><span class="line">3       breakpoint     keep y   0x0000000000400cec <span class="keyword">in</span> main() at test.cpp:18</span><br><span class="line">4       breakpoint     keep n   0x00000000004009a5 <span class="keyword">in</span> insertionSort(int*, int) </span><br><span class="line">                                                   at insert.cpp:8</span><br><span class="line">5       breakpoint     keep y   0x0000000000400cdd <span class="keyword">in</span> main() at test.cpp:16</span><br><span class="line">6       breakpoint     keep y   0x00000000004009e5 <span class="keyword">in</span> insertionSort(int*, int) </span><br><span class="line">                                                   at insert.cpp:16</span><br></pre></td></tr></table></figure><ul><li><code>Num</code>: 断点的编号, 删除或设置断点状态时候需要使用</li><li><code>Enb</code>: 断点的状态, y表示断点可用, n表示断点不可用</li><li><code>What</code>: 描述断点被设置在了哪个文件的哪一行或者哪个函数上</li></ul><hr><h2 id="3-删除断点"><a href="#3-删除断点" class="headerlink" title="3.删除断点"></a>3.删除断点</h2><blockquote><p>如果确定设置的某个断点不再使用, 可将其删除<br> 删除命令是 <code>delete 断点编号</code>, 这个delete可以简写为<code>del</code>也可以再简写为<code>d</code>。<br>删除断点的方式有两种: 删除(一个或者多个)指定断点或者删除一个连续的断点区间，</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d 1          <span class="comment"># 删除第1个断点</span></span><br><span class="line">d 2 4 6      <span class="comment"># 删除第2,4,6个断点</span></span><br><span class="line">d 1-5 <span class="comment"># 删除第1至第5个断点</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-设置断点状态"><a href="#4-设置断点状态" class="headerlink" title="4.设置断点状态"></a>4.设置断点状态</h2><blockquote><p>如果某断点只是临时不需要，可将其设置为不可用状态<br>设置命令为<code>disable 断点编号</code>,可简写为<code>dis</code></p><p>当需要的时候再将其设置回可用状态<br>设置命令为 <code>enable 断点编号</code>,可简写为<code>ena</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dis 2 4<span class="comment"># 设置第2, 第4 个断点无效</span></span><br><span class="line">dis 5-8<span class="comment"># 设置 第5,6,7,8个 断点无效</span></span><br><span class="line">ena 2 4<span class="comment"># 设置第2, 第4个断点有效</span></span><br><span class="line">ena 5-7<span class="comment"># 设置第5,6,7个断点有效</span></span><br></pre></td></tr></table></figure><p>用法与 del 类似</p><hr><h1 id="五、调试命令"><a href="#五、调试命令" class="headerlink" title="五、调试命令"></a>五、调试命令</h1><hr><h2 id="1-继续运行gdb"><a href="#1-继续运行gdb" class="headerlink" title="1.继续运行gdb"></a>1.继续运行gdb</h2><blockquote><p>如果调试的程序被断点阻塞,又想程序继续执行<br>这时候就可以使用<code>continue</code>命令。程序会继续运行, 直到遇到下一个有效的断点。<br>continue可以缩写为 <code>c</code>。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">continue</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-手动打印信息"><a href="#2-手动打印信息" class="headerlink" title="2.手动打印信息"></a>2.手动打印信息</h2><blockquote><p>当程序被某个断点阻塞之后, 可通过一些命令打印变量的名字或者变量的类型<br>并且还可以跟踪打印某个变量的值。</p></blockquote><hr><h3 id="①打印变量的值"><a href="#①打印变量的值" class="headerlink" title="①打印变量的值"></a>①打印变量的值</h3><blockquote><p>在gdb调试的时候如果需要打印变量的值， 命令是 <code>print</code>, 可缩写为 <code>p</code>。<br>如果打印的变量是<code>整数</code>还可以指定输出的整数的格式, 格式化输出的整数对应的字符表如下：</p></blockquote><table><thead><tr><th>格式化字符(&#x2F;fmt)</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;x</td><td>以十六进制的形式打印出整数</td></tr><tr><td>&#x2F;d</td><td>以有符号、十进制的形式打印出整数</td></tr><tr><td>&#x2F;u</td><td>以无符号、十进制的形式打印出整数</td></tr><tr><td>&#x2F;o</td><td>以八进制的形式打印出整数</td></tr><tr><td>&#x2F;t</td><td>以二进制的形式打印出整数</td></tr><tr><td>&#x2F;f</td><td>以浮点数的形式打印变量或表达式的值</td></tr><tr><td>&#x2F;c</td><td>以字符形式打印变量或表达式的值</td></tr></tbody></table><p>p的语法格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p 变量名</span><br><span class="line"></span><br><span class="line">p/fmt 变量名</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10进制</span></span><br><span class="line">p i  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 16进制</span></span><br><span class="line">p/x i    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 8进制</span></span><br><span class="line">p/o i </span><br></pre></td></tr></table></figure><hr><h3 id="②打印变量类型"><a href="#②打印变量类型" class="headerlink" title="②打印变量类型"></a>②打印变量类型</h3><blockquote><p>使用命令<code>ptype</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptype 变量名</span><br></pre></td></tr></table></figure><hr><h2 id="3-自动打印信息"><a href="#3-自动打印信息" class="headerlink" title="3.自动打印信息"></a>3.自动打印信息</h2><hr><h3 id="①设置变量名自动显示"><a href="#①设置变量名自动显示" class="headerlink" title="①设置变量名自动显示"></a>①设置变量名自动显示</h3><blockquote><p>和 print 命令一样，display 命令也用于调试阶段查看某个变量或表达式的值<br>它们的区别是，<br>使用 <code>display</code> 命令查看变量或表达式的值，每当程序暂停执行（例如单步执行）时，GDB 调试器都会<code>自动打印</code>出来<br>而 <code>print</code> 命令则不会。<br>因此，想频繁查看某个变量或表达式的值从而观察它的变化情况时， display 命令可以一劳永逸。display 命令<code>没有缩写</code>形式</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在变量的有效取值范围内, 自动打印变量的值(设置一次, 以后就会自动显示)</span></span><br><span class="line">display 变量名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以指定的整形格式打印变量的值, 关于 fmt 的取值, 参考 print 命令</span></span><br><span class="line">display/fmt 变量名</span><br></pre></td></tr></table></figure><hr><h3 id="②查看自动显示列表"><a href="#②查看自动显示列表" class="headerlink" title="②查看自动显示列表"></a>②查看自动显示列表</h3><blockquote><p>对于使用 display 命令查看的目标变量或表达式，都会被记录在一张列表（称为自动显示列表）中。通过执行<code>info dispaly</code>命令，可以打印出这张表</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">info display</span><br><span class="line"></span><br><span class="line">Auto-display expressions now <span class="keyword">in</span> effect:</span><br><span class="line">Num Enb Expression</span><br><span class="line">1:   y  i</span><br><span class="line">2:   y  array[i]</span><br><span class="line">3:   y  /x array[i]</span><br></pre></td></tr></table></figure><ul><li><code>Num</code> : 变量或表达式的编号，GDB 调试器为每个变量或表达式都分配有唯一编号</li><li><code>Enb</code> : 表示当前变量（表达式）处于激活状态or禁用状态<br>如果处于激活状态（用 y 表示），则每次程序停止执行，该变量的值都会被打印出来；<br>如果处于禁用状态（用 n 表示），则该变量（表达式）的值不会被打印。</li><li><code>Expression</code> ：被自动打印值的变量或表达式的名字。</li></ul><hr><h3 id="③取消自动显示"><a href="#③取消自动显示" class="headerlink" title="③取消自动显示"></a>③取消自动显示</h3><blockquote><p>对于不需要再打印值的变量或表达式，可以将其删除或者禁用。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">undisplay num [num1 ...]</span><br><span class="line">undisplay num1-numN</span><br><span class="line"></span><br><span class="line">delete display num [num1 ...]</span><br><span class="line">delete display num1-numN</span><br></pre></td></tr></table></figure><ul><li>如果不想删除自动显示的变量, 也可以禁用自动显示列表中处于激活状态下的变量或表达式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disable</span> display num [num1 ...]</span><br><span class="line"></span><br><span class="line"><span class="built_in">disable</span> display num1-numN</span><br></pre></td></tr></table></figure><ul><li>当需要启用自动显示列表中被禁用的变量或表达式时</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enable</span>  display num [num1 ...]</span><br><span class="line"><span class="built_in">enable</span> display num1-numN</span><br></pre></td></tr></table></figure><hr><h2 id="3-单步调试"><a href="#3-单步调试" class="headerlink" title="3.单步调试"></a>3.单步调试</h2><blockquote><p>当程序阻塞到某个断点上之后, 可以通过以下命令对程序进行单步调试</p></blockquote><hr><h3 id="①step"><a href="#①step" class="headerlink" title="①step"></a>①step</h3><blockquote><p><code>step</code>命令可以缩写为<code>s</code>, 命令执行一次代码向下执行一行<br>如果这一行是函数调用，那么程序会进入到函数体内部。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#step==s</span></span><br><span class="line">step</span><br></pre></td></tr></table></figure><hr><h3 id="②finish"><a href="#②finish" class="headerlink" title="②finish"></a>②finish</h3><blockquote><p>如果通过 <code>s</code> 单步调试进入到函数内部, 想要跳出这个函数体， 可以执行<code>finish</code>命令<br>如果想要跳出函数体必须要保证函数体内不能有有效断点，否则无法跳出。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finish</span><br></pre></td></tr></table></figure><hr><h3 id="③next"><a href="#③next" class="headerlink" title="③next"></a>③next</h3><blockquote><p><code>next</code>命令和<code>step</code>命令功能是相似的<br>只是在使用next调试程序的时候<code>不会进入到函数体内部</code>，next可以缩写为 <code>n</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next</span><br></pre></td></tr></table></figure><hr><h3 id="④until"><a href="#④until" class="headerlink" title="④until"></a>④until</h3><blockquote><p> <code>until</code> 命令可直接跳出某个循环体，提高调试效率<br> 如果想直接从循环体中跳出, 必须要满足以下的条件，否则命令不会生效：</p></blockquote><ol><li>要跳出的循环体内部不能有有效的断点</li><li>必须要在循环体的开始&#x2F;结束行执行该命令</li></ol><hr><h2 id="4-设置变量值"><a href="#4-设置变量值" class="headerlink" title="4.设置变量值"></a>4.设置变量值</h2><blockquote><p>在调试程序的时候, 我们需要在某个变量等于某个特殊值的时候查看程序的运行状态<br>但通过程序运行让变量等于这个值又非常困难, 这种情况下就可以在 gdb 中直接对这个变量进行值的设置, 或在单步调试的时候通过设置循环因子的值直接跳出某个循环,<br>值设置的命令格式为: <code>set var 变量名=值</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可以在循环中使用, 直接设置循环因子的值</span></span><br><span class="line"><span class="built_in">set</span> var 变量名=值</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GDB调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile</title>
      <link href="/2023/10/22/Makefile/"/>
      <url>/2023/10/22/Makefile/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>gcc命令进行单个文件的编译是比较方便的,但是如果文件数目众多就会显得冗余<br>此时就可以借助make这个命令工具<br>make就好比建筑工人,makefile就是蓝图,make照着makefile进行工程<br>makefile文件的命名有<code>Makefile</code>和<code>makefile</code></p></blockquote><hr><h1 id="一、规则"><a href="#一、规则" class="headerlink" title="一、规则"></a>一、规则</h1><p>规则的基本语法格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target1,target2,...:depend1,depend2,...</span><br><span class="line"><span class="built_in">command</span></span><br><span class="line">.......</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p>规则主要有三部分组成:目标(target),依赖(depend),命令(command)</p><ul><li><p>目标(target)<br>  通过执行规则中的命令，可以生成一个和目标同名的文件<br>  规则可以有多个命令, 通过这多条命令来生成多个目标, 所有目标也可有很多个<br> 通过执行命令，可以只执行一个动作，不生成任何文件，这样的目标被称为<code>伪目标</code></p></li><li><p>依赖(depend)<br>  如果规则的命令中不需要任何依赖，那么规则的依赖可以为空<br> 当前规则中的依赖可以是其他规则中的某个目标，这样就形成了规则之间的嵌套<br> 依赖可以根据要执行的命令的实际需求, 指定很多个</p></li><li><p>命令(command):一般来说是一个shell命令<br>  动作可是多个，每个命令前必须有一个<code>Tab缩进并且独占占一行</code>。</p></li></ul><p>eg:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eg1: 有源文件 a.c b.c c.c, 生成可执行程序 app</span></span><br><span class="line">app:a.c b.c c.c</span><br><span class="line">gcc a.c b.c c.c -o app</span><br><span class="line"></span><br><span class="line"><span class="comment"># eg2:有多个目标, 多个依赖, 多个命令</span></span><br><span class="line">app,app1:a.c b.c c.c d.c</span><br><span class="line">gcc a.c b.c -o app</span><br><span class="line">gcc c.c d.c -o app1</span><br><span class="line"></span><br><span class="line"><span class="comment"># eg3:规则之间的嵌套</span></span><br><span class="line">app:a.o b.o c.o</span><br><span class="line">gcc a.o b.o c.o -o app</span><br><span class="line"><span class="comment"># a.o 是第一条规则中的依赖</span></span><br><span class="line">a.o:a.c</span><br><span class="line">gcc -c a.c</span><br><span class="line"><span class="comment"># b.o 是第一条规则中的依赖</span></span><br><span class="line">b.o:b.c</span><br><span class="line">gcc -c b.c</span><br><span class="line"><span class="comment"># c.o 是第一条规则中的依赖</span></span><br><span class="line">c.o:c.c</span><br><span class="line">gcc -c c.c</span><br></pre></td></tr></table></figure><hr><h1 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h1><hr><h2 id="1-规则的执行"><a href="#1-规则的执行" class="headerlink" title="1.规则的执行"></a>1.规则的执行</h2><p>在调用 make 命令编译程序的时候，make 会首先找到 Makefile 文件中的第 1 个规则，分析并执行相关的动作。<br>ps:很多时候要执行的动作（命令）中的依赖是不存在的，如果使用的依赖不存在，这个动作也就不会被执行。</p><p>解决方案是先将需要的依赖生成出来，我们可以在makefile中添加新的规则，将不存在的依赖作为这个新的规则中的目标，当这条新规则对应的命令执行完毕，对应的目标就被生成了，同时另一条规则中需要的依赖也就存在了。</p><p>这样，makefile中的某一条规则在需要的时候，就会被其他的规则调用，直到makefile中的第一条规则中的所有的依赖全部被生成，第一条规则中的命令就可以基于这些依赖生成对应的目标，make 的任务也就完成了。</p><p>以上即使嵌套的原理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 规则1</span></span><br><span class="line">app:a.o b.o c.o</span><br><span class="line">gcc a.o b.o c.o -o app</span><br><span class="line"><span class="comment"># 规则2</span></span><br><span class="line">a.o:a.c</span><br><span class="line">gcc -c a.c</span><br><span class="line"><span class="comment"># 规则3</span></span><br><span class="line">b.o:b.c</span><br><span class="line">gcc -c b.c</span><br><span class="line"><span class="comment"># 规则4</span></span><br><span class="line">c.o:c.c</span><br><span class="line">gcc -c c.c</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，如果执行 make 命令就会根据这个 makefile 中的4条规则编译这三个源文件。在解析第一条规则的时候发现里边的三个依赖都是不存在的，因此规则1对应的命令也就不能被执行。<br>当依赖不存在的时候，make就是查找其他的规则，看哪一条规则是用来生成需要的这个依赖的，找到之后就会执行这条规则中的命令。因此规则2， 规则3， 规则4里的命令会相继被执行，当规则1中依赖全部被生成之后对应的命令也就被执行了，因此规则1的目标被生成，make工作结束。</p></blockquote><ul><li>如果想要执行 makefile 中非第一条规则对应的命令, 那么就不能直接 make, 需要将那条规则的目标也写到 make的后边, 比如只需要执行规则3中的命令, 就需要: make b.o。</li></ul><hr><h2 id="2-文件的时间戳"><a href="#2-文件的时间戳" class="headerlink" title="2.文件的时间戳"></a>2.文件的时间戳</h2><blockquote><p>make 命令执行的时候会根据文件的时间戳判定是否执行makefile文件中相关规则中的命令。<br>即make的执行要根据时间来判断</p></blockquote><p>主要有三种情况</p><ol><li>如果规则中的目标对应的文件根本就不存在， 那么规则中的命令肯定会被执行。</li><li>当依赖文件被更新了, 文件时间戳也会随之被更新, 这时候 <code>目标时间戳 &lt; 某些依赖的时间戳</code>, 在这种情况下目标文件会通过规则中的命令被重新生成。</li><li>目标是通过依赖生成的，因此正常情况下：<code>目标时间戳 &gt; 所有依赖的时间戳</code>, 如果执行 make 命令的时候检测到规则中的目标和依赖满足这个条件, 那么规则中的命令就不会被执行。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 规则1</span></span><br><span class="line">app:a.o b.o c.o</span><br><span class="line">gcc a.o b.o c.o -o app</span><br><span class="line"><span class="comment"># 规则2</span></span><br><span class="line">a.o:a.c</span><br><span class="line">gcc -c a.c</span><br><span class="line"><span class="comment"># 规则3</span></span><br><span class="line">b.o:b.c</span><br><span class="line">gcc -c b.c</span><br><span class="line"><span class="comment"># 规则4</span></span><br><span class="line">c.o:c.c</span><br><span class="line">gcc -c c.c</span><br></pre></td></tr></table></figure><p>修改例子中的 a.c, 再次通过make编译这几个源文件<br>那么这个时候先执行规则2更新目标文件a.o， 然后再执行规则1更新目标文件app<br>其余的规则是不会被执行的。</p><hr><h2 id="3-自动推导"><a href="#3-自动推导" class="headerlink" title="3.自动推导"></a>3.自动推导</h2><blockquote><p>有时漏写一些构建规则,程序还是会执行成功<br>make 有自动推导的能力，不会完全依赖 makefile。</p></blockquote><p>假设目录中只有.c文件,没有 .o 文件,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">calc:add.o  div.o  main.o  mult.o  sub.o</span><br><span class="line">        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc</span><br></pre></td></tr></table></figure><p>依赖中所有的 .o文件在本地项目目录中是不存在的, 并且没有规则用来生成这些依赖文件<br>这时 make 会使用内部默认的构造规则(<code>cc -c</code>)先将这些依赖文件生成出来, 然后在执行规则中的命令, 最后生成目标文件 calc。</p><hr><h1 id="三、变量"><a href="#三、变量" class="headerlink" title="三、变量"></a>三、变量</h1><blockquote><p>makefile中的变量分为三种：自定义变量，预定义变量和自动变量。</p></blockquote><hr><h2 id="1-自定义变量"><a href="#1-自定义变量" class="headerlink" title="1.自定义变量"></a>1.自定义变量</h2><blockquote><p>makefile 中的变量是没有类型的，直接创建变量然后给其赋值就可以了。<br>其操作类似于shell</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义变量并赋值</span></span><br><span class="line">obj=add.o  div.o  main.o  mult.o  sub.o</span><br><span class="line"></span><br><span class="line"><span class="comment">#取变量值</span></span><br><span class="line">$(obj)</span><br></pre></td></tr></table></figure><p>通过自定义变量我们可以有新的写法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj=add.o  div.o  main.o  mult.o  sub.o</span><br><span class="line">target=calc</span><br><span class="line">$(target):$(obj)</span><br><span class="line">        gcc  $(obj) -o $(target)</span><br></pre></td></tr></table></figure><hr><h2 id="2-预定义变量"><a href="#2-预定义变量" class="headerlink" title="2.预定义变量"></a>2.预定义变量</h2><blockquote><p>Makefile 中有一些已经定义的变量，用户可以直接使用这些变量，不用进行定义。<br>预定义变量的名字一般都是大写的</p></blockquote><table><thead><tr><th>变量名</th><th>含义</th><th>默认值</th></tr></thead><tbody><tr><td>AR</td><td>生成静态库库文件的程序名称</td><td>ar</td></tr><tr><td>AS</td><td>汇编编译器的名称</td><td>as</td></tr><tr><td>CC</td><td>C 语言编译器的名称</td><td>cc</td></tr><tr><td>CPP</td><td>C 语言预编译器的名称</td><td>$(CC) -E</td></tr><tr><td>CXX</td><td>C++ 语言编译器的名称</td><td>g++</td></tr><tr><td>FC</td><td>FORTRAN 语言编译器的名称</td><td>f77</td></tr><tr><td>RM</td><td>删除文件程序的名称</td><td>rm -f</td></tr><tr><td>ARFLAGS</td><td>生成静态库库文件程序的选项</td><td>无默认值</td></tr><tr><td>ASFLAGS</td><td>汇编语言编译器的编译选项</td><td>无默认值</td></tr><tr><td>CFLAGS</td><td>C 语言编译器的编译选项</td><td>无默认值</td></tr><tr><td>CPPFLAGS</td><td>C 语言预编译的编译选项</td><td>无默认值</td></tr><tr><td>CXXFLAGS</td><td>C++ 语言编译器的编译选项</td><td>无默认值</td></tr><tr><td>FFLAGS</td><td>FORTRAN 语言编译器的编译选项</td><td>无默认值</td></tr></tbody></table><p>由此我们可以进一步优化上述代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj=add.o  div.o  main.o  mult.o  sub.o</span><br><span class="line">target=calc</span><br><span class="line">CFLAGS=-O3 <span class="comment">#编译器代码优化等级(最高)</span></span><br><span class="line">$(target):$(obj)</span><br><span class="line">        $(CC)  $(obj) -o $(target) $(CFLAGS)</span><br></pre></td></tr></table></figure><hr><h2 id="3-自动变量"><a href="#3-自动变量" class="headerlink" title="3.自动变量"></a>3.自动变量</h2><blockquote><p>自动变量用来代表这些规则中的目标文件和依赖文件，并且它们<code>只能在规则的命令中使用</code>。</p></blockquote><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>$*</td><td>表示目标文件的名称，不包含目标文件的扩展名</td></tr><tr><td>$+</td><td>表示所有的依赖文件，这些依赖文件之间以空格分开，按照出现的先后顺序，可能包含重复的依赖文件</td></tr><tr><td>$&lt;</td><td>表示依赖项中第一个依赖文件的名称</td></tr><tr><td>$?</td><td>依赖项中，所有比目标文件时间戳晚的依赖文件，依赖文件之间以空格分开</td></tr><tr><td>$@</td><td>表示目标文件的名称，包含文件扩展名</td></tr><tr><td>$^</td><td>依赖项中，所有不重复的依赖文件，这些文件之间以空格分开</td></tr></tbody></table><p>较为常用的由 $^ ,$&lt;,$@</p><p>由以上也可进行优化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">calc:add.o  div.o  main.o  mult.o  sub.o</span><br><span class="line">gcc $^ -o <span class="variable">$@</span> </span><br></pre></td></tr></table></figure><hr><h1 id="四、模式匹配"><a href="#四、模式匹配" class="headerlink" title="四、模式匹配"></a>四、模式匹配</h1><p>先观察以下makefile文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">calc:add.o  div.o  main.o  mult.o  sub.o</span><br><span class="line">        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc</span><br><span class="line"><span class="comment"># 语法格式重复的规则, 将 .c -&gt; .o, 使用的命令都是一样的 gcc *.c -c</span></span><br><span class="line">add.o:add.c</span><br><span class="line">        gcc add.c -c</span><br><span class="line"></span><br><span class="line">div.o:div.c</span><br><span class="line">        gcc div.c -c</span><br><span class="line"></span><br><span class="line">main.o:main.c</span><br><span class="line">        gcc main.c -c</span><br><span class="line"></span><br><span class="line">sub.o:sub.c</span><br><span class="line">        gcc sub.c -c</span><br><span class="line"></span><br><span class="line">mult.o:mult.c</span><br><span class="line">        gcc mult.c -c</span><br></pre></td></tr></table></figure><p>发现规则2-规则6几乎是重复做同样的事<br>解决冗余可以将规则像以下这样写,这种操作就是模式匹配</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o:%.c            <span class="comment"># %是通配符,类似于*</span></span><br><span class="line">gcc $&lt; -c</span><br></pre></td></tr></table></figure><hr><h1 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a>五、函数</h1><blockquote><p>makefile中有函数并且所有的函数都是有返回值的。makefile中函数的格式和C&#x2F;C++中函数也不同，其写法是这样的<br> <code>$(函数名 参数1, 参数2, 参数3, ...)</code><br> 主要目的是让我们能够快速方便的得到函数的返回值。<br>主要介绍两个 makefile 中使用频率比较高的函数：<code>wildcard</code>和<code>patsubst</code>。</p></blockquote><hr><h2 id="1-wildcard"><a href="#1-wildcard" class="headerlink" title="1.wildcard"></a>1.wildcard</h2><blockquote><p>主要作用是获取指定目录下指定类型的文件名，其返回值是以空格分割的、指定目录下的所有符合条件的文件名列表。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数原型为:</span></span><br><span class="line"><span class="comment"># 该函数的参数只有一个, 但是这个参数可以分成若干个部分, 通过空格间隔</span></span><br><span class="line">$(wildcard PATTERN...)</span><br><span class="line">参数:指定某个目录, 搜索这个路径下指定类型的文件，比如： *.c</span><br></pre></td></tr></table></figure><ul><li>参数功能<br>   1.PATTERN 指的是某个或多个目录下的对应的某种类型的文件<br>   比如<code>当前目录下的.c文件</code>可以写成 <code>*.c</code><br>   2.可以指定多个目录，每个路径之间使用<code>空格间隔</code></li><li>返回值<br> 得到的若干个文件的文件列表， 文件名之间使用空格间隔</li></ul><p>eg:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分别搜索三个不同目录下的 .c 格式的源文件</span></span><br><span class="line">src = $(wildcard /home/robin/a/*.c /home/robin/b/*.c *.c)  <span class="comment"># *.c == ./*.c</span></span><br><span class="line"><span class="comment"># 返回值: 得到一个大的字符串, 里边有若干个满足条件的文件名, 文件名之间使用空格间隔</span></span><br><span class="line">/home/robin/a/a.c /home/robin/a/b.c /home/robin/b/c.c /home/robin/b/d.c e.c f.c</span><br></pre></td></tr></table></figure><hr><h2 id="2-patsubst"><a href="#2-patsubst" class="headerlink" title="2.patsubst"></a>2.patsubst</h2><blockquote><p>按照指定的模式替换指定的文件名的后缀</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数原型为</span></span><br><span class="line"><span class="comment"># 有三个参数, 参数之间使用 逗号间隔</span></span><br><span class="line">$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span><br></pre></td></tr></table></figure><p>参数功能</p><ul><li><p>pattern: 这是一个模式字符串, 需要指定出要被替换的文件名中的后缀是什么</p></li><li><p><input disabled="" type="checkbox"> 文件名和路径不需要关心, 因此使用 % 表示即可 [通配符]</p></li><li><p><input disabled="" type="checkbox"> 在通配符后边指定出要被替换的后缀, 比如: %.c, 意味着 .c的后缀要被替换掉</p></li><li><p>replacement: 这是一个模式字符串, 指定参数pattern中的后缀最终要被替换为什么</p></li><li><p><input disabled="" type="checkbox"> 还是使用 % 来表示参数pattern 中文件的路径和名字</p></li><li><p><input disabled="" type="checkbox"> 在通配符 % 后边指定出新的后缀名, 比如: %.o 这表示原来的后缀被替换为 .o</p></li><li><p>text<br> 该参数中存储这要被替换的原始数据</p></li><li><p>返回值<br> 函数返回被替换过后的字符串。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eg:把变量 src 中的所有文件名的后缀从 .cpp 替换为 .o</span></span><br><span class="line">src = a.cpp b.cpp c.cpp e.cpp</span><br><span class="line">obj = $(patsubst %.cpp, %.o, $(src)) </span><br><span class="line"><span class="comment"># obj 的值为: a.o b.o c.o e.o</span></span><br></pre></td></tr></table></figure><hr><h1 id="六、makefile的编写"><a href="#六、makefile的编写" class="headerlink" title="六、makefile的编写"></a>六、makefile的编写</h1><blockquote><p>基于一个简单的项目, 演示一下编写一个makefile从不标准到标准的过程。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目目录结构</span></span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br><span class="line"><span class="comment"># 需要编写makefile对该项目进行自动化编译</span></span><br></pre></td></tr></table></figure><hr><h2 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">calc:add.c  div.c  main.c  mult.c  sub.c</span><br><span class="line">        gcc add.c  div.c  main.c  mult.c  sub.c -o calc</span><br></pre></td></tr></table></figure><blockquote><p>优点:书写简单<br>缺点：只要依赖中的某一个源文件被修改，<code>所有</code>的源文件都需要被重新编译,效率低<br>改进方式：提高效率，修改哪一个源文件, 哪个源文件被重新编译, 不修改就不重新编译</p></blockquote><hr><h2 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认所有的依赖都不存在, 需要使用其他规则生成这些依赖</span></span><br><span class="line"><span class="comment"># 因为 add.o 被更新, 需要使用最新的依赖, 生成最新的目标</span></span><br><span class="line">calc:add.o  div.o  main.o  mult.o  sub.o</span><br><span class="line">        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果修改了add.c, add.o 被重新生成</span></span><br><span class="line">add.o:add.c</span><br><span class="line">        gcc add.c -c</span><br><span class="line"></span><br><span class="line">div.o:div.c</span><br><span class="line">        gcc div.c -c</span><br><span class="line"></span><br><span class="line">main.o:main.c</span><br><span class="line">        gcc main.c -c</span><br><span class="line"></span><br><span class="line">sub.o:sub.c</span><br><span class="line">        gcc sub.c -c</span><br><span class="line"></span><br><span class="line">mult.o:mult.c</span><br><span class="line">        gcc mult.c -c</span><br></pre></td></tr></table></figure><blockquote><p>优点：相较于版本1效率提升<br>缺点：规则比较冗余, 需要精简<br>改进方式：在 makefile 中使用变量 和 模式匹配</p></blockquote><hr><h2 id="版本3"><a href="#版本3" class="headerlink" title="版本3"></a>版本3</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">obj=add.o  div.o  main.o  mult.o  sub.o</span><br><span class="line">target=calc</span><br><span class="line"></span><br><span class="line">$(target):$(obj)</span><br><span class="line">        gcc $(obj)  -o $(target)</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">        gcc $&lt; -c</span><br></pre></td></tr></table></figure><blockquote><p>优点：简洁<br>缺点：变量 obj 的值需要手动的写出来, 当需要编译的项目文件很多，用手写不现实<br>改进方式：在makefile中使用函数</p></blockquote><hr><h2 id="版本4"><a href="#版本4" class="headerlink" title="版本4"></a>版本4</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用函数搜索当前目录下的源文件 .c</span></span><br><span class="line">src=$(wildcard *.c)</span><br><span class="line"><span class="comment"># 将源文件的后缀替换为 .o</span></span><br><span class="line">obj=$(patsubst %.c, %.o, $(src))</span><br><span class="line">target=calc</span><br><span class="line"></span><br><span class="line">$(target):$(obj)</span><br><span class="line">        gcc $(obj)  -o $(target)</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">        gcc $&lt; -c</span><br></pre></td></tr></table></figure><blockquote><p>优点：解决了自动加载项目文件的问题，解放了双手<br>缺点：没有文件删除的功能，不能删除项目编译过程中生成的目标文件（*.o）和可执行程序<br>改进方式: 在makefile文件中添加新的规则用于删除生成的目标文件（*.o）和可执行程序</p></blockquote><hr><h2 id="版本5"><a href="#版本5" class="headerlink" title="版本5"></a>版本5</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">src=$(wildcard *.c)</span><br><span class="line">obj=$(patsubst %.c, %.o, $(src))</span><br><span class="line">target=calc</span><br><span class="line">$(target):$(obj)</span><br><span class="line">        gcc $(obj)  -o $(target)</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">        gcc $&lt; -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加规则, 删除生成文件 *.o 可执行程序</span></span><br><span class="line"><span class="comment"># 这个规则比较特殊, clean根本不会生成, 这是一个伪目标</span></span><br><span class="line">clean:</span><br><span class="line">        <span class="built_in">rm</span> $(obj) $(target)</span><br></pre></td></tr></table></figure><blockquote><p>优点: 添加了新的规则（16行）用于文件的删除, 直接 make clean 就可以执行规则中的删除命令了<br>缺点: goto flag;<br>改进方式: 在makefile文件中声明 clean是一个伪目标，让 make 放弃对它的时间戳检测。</p></blockquote><p>flag:</p><p>正常情况下这个版本的makefile是可以正常工作的，如果在这个项目目录中添加一个叫做clean的文件（和规则中的目标名称相同），再进行 make clean发现这个规则就不能正常工作了。</p><blockquote><p>这个问题的关键在于 clean是一个伪目标, 不对应任何实体文件<br> 在前边关于文件时间戳更新问题的时说过，如果目标不存在的命令肯定被执行， 如果目标文件存在了就需要比较规则中目标文件和依赖文件的时间戳，满足条件才执行规则的命令，否则不执行。<br>解决这个问题需要在 makefile 中声明 clean是一个伪目标，这样 make 就不会对文件的时间戳进行检测，规则中的命令也就每次都会被执行了。<br>在 makefile 中声明一个伪目标需要使用 <code>.PHONY </code>关键字, 声明方式为: <code>.PHONY:伪文件名称</code></p></blockquote><hr><h2 id="版本6"><a href="#版本6" class="headerlink" title="版本6"></a>版本6</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">src=$(wildcard *.c)</span><br><span class="line">obj=$(patsubst %.c, %.o, $(src))</span><br><span class="line">target=calc</span><br><span class="line"></span><br><span class="line">$(target):$(obj)</span><br><span class="line">        gcc $(obj)  -o $(target)</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">        gcc $&lt; -c</span><br><span class="line"><span class="comment"># 声明clean为伪文件</span></span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">        <span class="comment"># shell命令前的 - 表示强制这个指令执行, 如果执行失败也不会终止</span></span><br><span class="line">        -<span class="built_in">rm</span> $(obj) $(target) </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;test, test&quot;</span></span><br></pre></td></tr></table></figure><p>说一下<code>-</code> :<br>如果第一条命令执行失败,且没有加<code>-</code>,那么第二条命令就不会执行<br>如果加上<code>-</code>,不论执行失败或者成功都会继续将命令执行下去</p><hr><h1 id="七、一道例题"><a href="#七、一道例题" class="headerlink" title="七、一道例题"></a>七、一道例题</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目录结构</span></span><br><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h==&gt; 头文件, 声明了加减乘除四个函数</span><br><span class="line">├── main.c==&gt; 测试程序, 调用了head.h中的函数</span><br><span class="line">└── src</span><br><span class="line">    ├── add.c==&gt; 加法运算</span><br><span class="line">    ├── div.c==&gt; 除法运算</span><br><span class="line">    ├── mult.c  ==&gt; 乘法运算</span><br><span class="line">    └── sub.c   ==&gt; 减法运算</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最终的目标名 app</span></span><br><span class="line">target = app</span><br><span class="line"><span class="comment"># 搜索当前项目目录下的源文件</span></span><br><span class="line">src=$(wildcard *.c ./src/*.c)</span><br><span class="line"><span class="comment"># 将文件的后缀替换掉 .c -&gt; .o</span></span><br><span class="line">obj=$(patsubst %.c, %.o, $(src))</span><br><span class="line"><span class="comment"># 头文件目录</span></span><br><span class="line">include=./include</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一条规则</span></span><br><span class="line"><span class="comment"># 依赖中都是 xx.o yy.o zz.o</span></span><br><span class="line"><span class="comment"># gcc命令执行的是链接操作</span></span><br><span class="line">$(target):$(obj)</span><br><span class="line">        gcc $^ -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式匹配规则</span></span><br><span class="line"><span class="comment"># 执行汇编操作, 前两步: 预处理, 编译是自动完成</span></span><br><span class="line">%.o:%.c</span><br><span class="line">        gcc $&lt; -c -I $(include) -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一个清除文件的规则</span></span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">        -<span class="built_in">rm</span> $(obj) $(target) -f</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态库和动态库</title>
      <link href="/2023/10/22/%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/"/>
      <url>/2023/10/22/%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、静态库"><a href="#一、静态库" class="headerlink" title="一、静态库"></a>一、静态库</h1><hr><blockquote><p>Linux中静态库是由 <strong>ar</strong> 生成的<br>现在的静态库已经不再普遍了,大部分程序都在使用动态库</p></blockquote><ul><li>Linux中静态库以 <code>lib</code>作为前缀, <code>.a</code> 作为后缀,即 <code>libxxx.a</code></li><li>Windows中静态库<strong>一般</strong>以<code>lib</code>作为前缀, 以<code>lib</code>作为后缀,, 即 <code>libxxx.lib</code></li></ul><hr><h2 id="1-生成静态链接库"><a href="#1-生成静态链接库" class="headerlink" title="1.生成静态链接库"></a>1.生成静态链接库</h2><blockquote><p>  静态库的生成需要先对源文件进行汇编操作(gcc -c)<br> 以得到二进制文件格式(.o)<br> 然后通过ar工具将目标文件打包以得到静态库文件(libxxx.a)</p></blockquote><p>ar工具创建静态库有三个参数</p><ul><li>参数c：创建一个库，不管库是否存在，都将创建。</li><li>参数s：创建目标文件索引，这在创建较大的库时能加快时间。</li><li>参数r：在库中插入模块(替换)。默认新的成员添加在库的结尾处，如果模块名已经在库中存在，则替换同名的模块。</li></ul><p><img src="/img/8.12.png" alt="在这里插入图片描述"></p><p>具体步骤如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.对源文件进行汇编,得到二进制(.o)文件</span></span><br><span class="line">gcc 源文件(*.c) -c  <span class="comment">#-c位置没有要求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.将.o文件进行打包,得到静态库</span></span><br><span class="line">ar csr 静态库的名字(libxxx.a) 原材料(*.o)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.发布静态库</span></span><br><span class="line">提供头文件 **.h文件</span><br><span class="line">提供静态库 libxxx.a</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成.o</span></span><br><span class="line">gcc add.c div.c mult.c sub.c -c</span><br><span class="line"></span><br><span class="line"><span class="comment">#可能会提示头文件找不到,添加参数 -I 重写头文件路径</span></span><br><span class="line">gcc add.c div.c mult.c sub.c -c -I ./include/</span><br><span class="line"></span><br><span class="line"><span class="comment">#将.o打包</span></span><br><span class="line">ar rcs libcalc.a *.o</span><br><span class="line"></span><br><span class="line"><span class="comment">#发布 /include 中的头文件和打包出来的 libcalc.a </span></span><br></pre></td></tr></table></figure><hr><h2 id="2-静态库的使用"><a href="#2-静态库的使用" class="headerlink" title="2.静态库的使用"></a>2.静态库的使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#假设我们已经将测试程序,头文件,静态库都放在了当前同一个目录中</span></span><br><span class="line"><span class="comment">#编译测试程序,生成可执行文件</span></span><br><span class="line">gcc main.c -o app  <span class="comment">#此时会报错 undefined reference</span></span><br></pre></td></tr></table></figure><p>报错原因:</p><blockquote><p>编译的源文件中包含了头文件 head.h, 这个头文件中声明的函数对应的定义（也就是函数体实现）在静态库中，程序在编译的时候<strong>没有找到函数实现</strong>，因此提示 undefined reference to xxxx。</p></blockquote><p>解决方案:</p><ul><li>-L: 指定库所在的目录(相对或者绝对路径)</li><li>-l: 指定库的名字, 需要掐头(lib)去尾(.a) 剩下的才是需要的静态库的名字</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o app -L ./ -l calc</span><br></pre></td></tr></table></figure><hr><h1 id="二、动态库"><a href="#二、动态库" class="headerlink" title="二、动态库"></a>二、动态库</h1><hr><blockquote><p>动态链接库是程序运行时加载的库，当动态链接库正确部署之后，运行的多个程序可以使用同一个加载到内存中的动态库，因此在Linux中动态链接库也可称之为<strong>共享库</strong>。<br>库中函数和变量的地址使用的是相对地址（静态库中使用的是绝对地址），其真实地址是在应用程序加载动态库时形成的。</p></blockquote><ul><li>在Linux中动态库以<code>lib</code>作为前缀, 以<code>.so</code>作为后缀, 即: <code>libxxx.so</code></li><li>在Windows中动态库一般以<code>lib</code>作为前缀, 以<code>dll</code>作为后缀, 即: <code>libxxx.dll</code></li></ul><hr><h2 id="1-生成动态链接库"><a href="#1-生成动态链接库" class="headerlink" title="1.生成动态链接库"></a>1.生成动态链接库</h2><blockquote><p>生成动态链接库是直接使用<code>gcc</code>命令并且需要添加<code>-fPIC（-fpic）</code> 以及<code>-shared</code> 参数。</p></blockquote><ul><li>-fPIC 或 -fpic 参数的作用是使得 gcc 生成的代码是与位置无关的，也就是使用相对位置。</li><li>-shared参数的作用是告诉编译器生成一个动态链接库。</li></ul><p><img src="/img/8.13.png" alt="在这里插入图片描述"></p><p>具体步骤如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将源文件进行汇编,并添加 -fpic参数</span></span><br><span class="line">gcc 源文件(*.c) -c -fpic</span><br><span class="line"></span><br><span class="line"><span class="comment">#打包.o文件成动态库,使用gcc的 -shared参数</span></span><br><span class="line">gcc -shared 与位置无关的目标文件(*.o) -o 动态库(libxxx.so)</span><br><span class="line"></span><br><span class="line"><span class="comment">#发布动态库和头文件</span></span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#汇编</span></span><br><span class="line">gcc add.c div.c mult.c sub.c -c -fpic -I ./include/</span><br><span class="line"></span><br><span class="line"><span class="comment">#打包</span></span><br><span class="line">gcc -shared add.o div.o mult.o sub.o -o libcalc.so  </span><br><span class="line"></span><br><span class="line"><span class="comment">#发布</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-动态库的使用"><a href="#2-动态库的使用" class="headerlink" title="2.动态库的使用"></a>2.动态库的使用</h2><p>当我们同静态库一样编译测试程序为可执行程序后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o app -L ./ -l calc</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./app </span><br><span class="line"><span class="comment">#./app: error while loading shared libraries: libcalc.so: </span></span><br><span class="line"><span class="comment">#cannot open shared object file: No such file or directory</span></span><br></pre></td></tr></table></figure><p>会有以上错误:<code>无法加载到动态库</code></p><hr><h2 id="3-解决动态库无法加载的问题"><a href="#3-解决动态库无法加载的问题" class="headerlink" title="3.解决动态库无法加载的问题"></a>3.解决动态库无法加载的问题</h2><h3 id="①库的工作原理"><a href="#①库的工作原理" class="headerlink" title="①库的工作原理"></a>①库的工作原理</h3><ul><li><p>静态库如何被加载?<br>在程序编译的最后一个阶段也就是链接阶段，提供的静态库会被打包到可执行程序中。当可执行程序被执行，静态库中的代码也会一并被加载到内存中，因此不会出现静态库找不到无法被加载的问题。</p></li><li><p>动态库如何被加载?</p></li><li><p><input disabled="" type="checkbox"> 在程序编译的最后一个阶段也就是链接阶段：<br>在gcc命令中虽然指定了库路径(使用参数 -L ), 但是这个路径并没有记录到可执行程序中，只是检查了这个路径下的库文件是否存在。<br>同样对应的动态库文件也没有被打包到可执行程序中，只是在可执行程序中记录了库的名字。</p></li><li><p><input disabled="" type="checkbox"> 可执行程序被执行起来之后:<br> 程序执行的时候会先检测需要的动态库是否可以被加载，加载不到就会提示上边的错误信息<br>当动态库中的函数在程序中被调用了, 这个时候动态库才加载到内存，如果不被调用就不加载<br>动态库的检测和内存加载操作都是由动态连接器来完成的</p></li></ul><h3 id="②动态链接器"><a href="#②动态链接器" class="headerlink" title="②动态链接器"></a>②动态链接器</h3><blockquote><p>动态链接器是一个独立于应用程序的进程, 属于操作系统, 当用户的程序需要加载动态库的时候动态连接器就开始工作了，显然动态连接器不知道用户通过 gcc 编译程序的时候通过参数 -L指定的路径。<br>那么动态链接器是如何搜索某一个动态库的呢，在它内部有一个默认的搜索顺序，按照优先级从高到低的顺序分别是：</p></blockquote><ol><li>可执行文件内部的 DT_RPATH 段</li><li>系统的环境变量 <code>LD_LIBRARY_PATH</code></li><li>系统动态库的缓存文件 <code>/etc/ld.so.cache</code></li><li>存储动态库&#x2F;静态库的系统目录 <code>/lib/</code>, <code>/usr/lib</code>等</li></ol><p>找到后结束遍历,找不到就报错</p><h3 id="③解决方法"><a href="#③解决方法" class="headerlink" title="③解决方法"></a>③解决方法</h3><blockquote><p>只需要将动态库的路径放到对应的环境变量或者系统配置文件中，同样也可以将动态库拷贝到系统库目录（或者是将动态库的软链接文件放到这些系统库目录中）。</p></blockquote><h4 id="方法1-将库路径添加到环境变量-LD-LIBRARY-PATH-中"><a href="#方法1-将库路径添加到环境变量-LD-LIBRARY-PATH-中" class="headerlink" title="方法1:将库路径添加到环境变量 LD_LIBRARY_PATH 中"></a>方法1:将库路径添加到环境变量 LD_LIBRARY_PATH 中</h4><ol><li>找到相关的配置文件<br>  <code>用户级别: ~/.bashrc</code><br>  <code>系统级别: /etc/profile</code>  </li><li>使用vim打开配置文件,文件最后添加</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LIBRARY_PATH=<span class="variable">$LIBRARY_PATH</span>:动态库的绝对路径</span><br></pre></td></tr></table></figure><ol start="3"><li>让修改的配置文件生效<br>1.修改了用户级别的配置文件,关闭当前终端,打开一个新的就生效<br>2.修改了系统级别的配置文件,注销关闭系统,再开机,配置就生效了<br>3.或者执行命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改的是哪一个就执行对应的那个命令</span></span><br><span class="line"><span class="comment"># source 可以简写为一个 . , 作用是让文件内容被重新加载</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc          (. ~/.bashrc)</span><br><span class="line"><span class="built_in">source</span> /etc/profile       (. /etc/profile)</span><br></pre></td></tr></table></figure><h4 id="方法2-更新-etc-ld-so-cache-文件"><a href="#方法2-更新-etc-ld-so-cache-文件" class="headerlink" title="方法2:更新 &#x2F;etc&#x2F;ld.so.cache 文件"></a>方法2:更新 &#x2F;etc&#x2F;ld.so.cache 文件</h4><ol><li>找到动态库所在的绝对路径（不包括库的名字）比如：&#x2F;home&#x2F;robin&#x2F;Library&#x2F;</li><li>使用vim 修改 <code>/etc/ld.so.conf</code> 文件, 将上边的路径添加到文件中(独自占一行)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.打开文件</span></span><br><span class="line">sudo vim /etc/ld.so.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.添加动态库路径,并且保存退出</span></span><br></pre></td></tr></table></figure><ol start="3"><li>更新 <code>/etc/ld.so.conf</code>中的数据到 <code>/etc/ld.so.cache</code> 中</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig   </span><br></pre></td></tr></table></figure><h4 id="方法3-拷贝动态库文件到系统库目录-lib-或者-usr-lib-中-库的软链接文件放进去"><a href="#方法3-拷贝动态库文件到系统库目录-lib-或者-usr-lib-中-库的软链接文件放进去" class="headerlink" title="方法3:拷贝动态库文件到系统库目录 &#x2F;lib&#x2F; 或者 &#x2F;usr&#x2F;lib 中 (库的软链接文件放进去)"></a>方法3:拷贝动态库文件到系统库目录 &#x2F;lib&#x2F; 或者 &#x2F;usr&#x2F;lib 中 (库的软链接文件放进去)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 库拷贝</span></span><br><span class="line">sudo <span class="built_in">cp</span> /xxx/xxx/libxxx.so /usr/lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建软连接</span></span><br><span class="line">sudo <span class="built_in">ln</span> -s /xxx/xxx/libxxx.so /usr/lib/libxxx.so</span><br></pre></td></tr></table></figure><blockquote><p>但并不建议直接拷贝,否则再更新时会很麻烦,还要重新拷贝<br>二者中优解是软链接</p></blockquote><hr><h3 id="④验证"><a href="#④验证" class="headerlink" title="④验证"></a>④验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法格式</span></span><br><span class="line">ldd 可执行程序名</span><br></pre></td></tr></table></figure><p>通过这种方法可以知道程序是否可以通过动态链接器加载到对应的动态库<br>如果其后都有<strong>地址</strong>就说明可以</p><hr><h1 id="三、优缺点"><a href="#三、优缺点" class="headerlink" title="三、优缺点"></a>三、优缺点</h1><hr><h2 id="1-静态库"><a href="#1-静态库" class="headerlink" title="1.静态库"></a>1.静态库</h2><ul><li><p>优点</p></li><li><p><input disabled="" type="checkbox"> 静态库被打包到应用程序中加载速度快</p></li><li><p><input disabled="" type="checkbox"> 发布程序无需提供静态库，移植方便</p></li><li><p>缺点</p></li><li><p><input disabled="" type="checkbox"> 相同的库文件数据可能在内存中被加载多份, 消耗系统资源，浪费内存</p></li><li><p><input disabled="" type="checkbox"> 库文件更新需要重新编译项目文件, 生成新的可执行程序, 浪费时间。</p></li></ul><p><img src="/img/8.14.png" alt="在这里插入图片描述"></p><hr><h2 id="2-动态库"><a href="#2-动态库" class="headerlink" title="2.动态库"></a>2.动态库</h2><ul><li><p>优点</p></li><li><p><input disabled="" type="checkbox"> 可实现不同进程间的资源共享</p></li><li><p><input disabled="" type="checkbox"> 动态库升级简单, 只需要替换库文件, 无需重新编译应用程序</p></li><li><p><input disabled="" type="checkbox"> 程序⚪可以控制何时加载动态库, 不调用库函数动态库不会被加载</p></li><li><p>缺点</p></li><li><p><input disabled="" type="checkbox"> 载速度比静态库慢, 但以现在计算机的性能<strong>可以忽略</strong></p></li><li><p><input disabled="" type="checkbox"> 发布程序需要提供依赖的动态库</p></li></ul><p><img src="/img/8.15.png" alt="在这里插入图片描述"></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态库和动态库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc/g++</title>
      <link href="/2023/10/22/gcc-g/"/>
      <url>/2023/10/22/gcc-g/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、安装gcc"><a href="#一、安装gcc" class="headerlink" title="一、安装gcc"></a>一、安装gcc</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Ubuntu</span></span><br><span class="line">sudo apt update   <span class="comment">#更新本地的软件下载列表, 得到最新的下载地址</span></span><br><span class="line">sudo apt install gcc g++</span><br><span class="line"></span><br><span class="line"><span class="comment">#centos</span></span><br><span class="line">sudo yum update </span><br><span class="line">sudo yum install gcc g++</span><br></pre></td></tr></table></figure><blockquote><p>之所以更新下载列表,是因为这样可以下载最新的gcc g++ 以支持c++11</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#两种方法查看gcc g++版本</span></span><br><span class="line">gcc -v</span><br><span class="line">gcc --version</span><br><span class="line"></span><br><span class="line">g++ -v</span><br><span class="line">g++ --version</span><br></pre></td></tr></table></figure><p><code>最低4.8.5的版本才支持C++11</code></p><hr><h1 id="二、gcc工作流程"><a href="#二、gcc工作流程" class="headerlink" title="二、gcc工作流程"></a>二、gcc工作流程</h1><hr><blockquote><p>gcc工作分为四步<br>1.预处理: 在这个阶段主要做了三件事: 展开头文件 、宏替换 、去掉注释行<br>这个阶段需要GCC调用预处理器来完成, 最终得到的还是源文件, 文本格式<br>2.编译: 这个阶段需要GCC调用编译器对文件进行编译, 最终得到一个汇编文件<br>3.汇编: 这个阶段需要GCC调用汇编器对文件进行汇编, 最终得到一个二进制文件<br>4.链接: 这个阶段需要GCC调用链接器对程序需要调用的库进行链接, 最终得到一个可执行的二进制文件</p></blockquote><table><thead><tr><th>文件名后缀</th><th>说明</th><th>gcc参数</th></tr></thead><tbody><tr><td>.c</td><td>源文件</td><td>无</td></tr><tr><td>.i</td><td>预处理后的 C 文件</td><td>-E</td></tr><tr><td>.s</td><td>编译之后得到的汇编语言的源文件</td><td>-S</td></tr><tr><td>.o</td><td>汇编后得到的二进制文件</td><td>-c</td></tr></tbody></table><blockquote><p>如果要编译单个文件非常简单,只需要<br>gcc c源文件<br>会自动生成文件名为a.out的可执行文件(若已经存在会覆盖)<br>也可以通过 -o 参数指定生成的文件名</p></blockquote><p>以下是4个步骤单独执行的方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对源文件进行预处理,gcc使用-E参数</span></span><br><span class="line"><span class="comment">#1. 预处理,-o指定生成的文件名</span></span><br><span class="line">gcc -E test.c -o test.i</span><br><span class="line"></span><br><span class="line"><span class="comment">#2. 编译,得到汇编文件</span></span><br><span class="line">gcc -S test.i -o test.s</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.汇编</span></span><br><span class="line">gcc -c test.s -o test.o</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.链接</span></span><br><span class="line">gcc test.o -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><blockquote><p>如果直接执行汇编或者链接,前面几步会自动执行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数 -c 是进行文件的汇编, 汇编之前的两步会自动执行</span></span><br><span class="line">gcc test.c -c -o app.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该命令是直接进行链接生成可执行程序, 链接之前的三步会自动执行</span></span><br><span class="line">gcc test.c -o app    </span><br></pre></td></tr></table></figure><hr><h1 id="三、gcc常用参数"><a href="#三、gcc常用参数" class="headerlink" title="三、gcc常用参数"></a>三、gcc常用参数</h1><hr><p><code>参数在gcc命令中并没有位置要求,指定即可</code></p><table><thead><tr><th>gcc编译选项</th><th>选项的意义</th></tr></thead><tbody><tr><td>-E</td><td>预处理指定的源文件，不进行编译</td></tr><tr><td>-S</td><td>编译指定的源文件，但是不进行汇编</td></tr><tr><td>-c</td><td>编译、汇编指定的源文件，但是不进行链接</td></tr><tr><td>-o [file1] [file2] &#x2F; [file2] -o [file1]</td><td>将文件 file2 编译成文件 file1</td></tr><tr><td>-I directory</td><td>指定 include 包含文件的搜索目录</td></tr><tr><td>-g</td><td>在编译的时候，生成调试信息，该程序可以被调试器调试</td></tr><tr><td>-D</td><td>在程序编译的时候，指定一个宏</td></tr><tr><td>-w</td><td>不生成任何警告信息, 不建议使用, 有些时候警告就是错误</td></tr><tr><td>-Wall</td><td>生成所有警告信息</td></tr><tr><td>-On</td><td>n的取值范围：0~3。编译器的优化选项的4个级别</td></tr><tr><td>-l</td><td>在程序编译的时候，指定使用的库</td></tr><tr><td>-L</td><td>指定编译的时候，搜索的库的路径。</td></tr><tr><td>-fPIC&#x2F;fpic</td><td>生成与位置无关的代码</td></tr><tr><td>-shared</td><td>生成共享目标文件。通常用在建立共享库时</td></tr><tr><td>-std</td><td>指定C方言，如:-std&#x3D;c99，gcc默认的方言是GNU C</td></tr></tbody></table><hr><h2 id="1-指定生成的文件名-o"><a href="#1-指定生成的文件名-o" class="headerlink" title="1.指定生成的文件名(-o)"></a>1.指定生成的文件名(-o)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数 -o的用法 , 原材料 test.c 最终生成的文件名为 app</span></span><br><span class="line"><span class="comment"># test.c 写在 -o 之前</span></span><br><span class="line">$ gcc test.c -o app</span><br><span class="line"></span><br><span class="line"><span class="comment"># test.c 写在 -o 之后</span></span><br><span class="line">gcc -o app test.c</span><br></pre></td></tr></table></figure><hr><h2 id="2-搜索头文件-I"><a href="#2-搜索头文件-I" class="headerlink" title="2.搜索头文件(-I)"></a>2.搜索头文件(-I)</h2><blockquote><p>如果在程序中包含了一些头文件, 但是包含的一些头文件在程序预处理的时候因为找不到无法被展开，导致程序编译失败，这时候我们可以在gcc命令中添加 -I参数重新指定要引用的头文件路径, 保证编译顺利完成。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc *.c -o calc -I ./include <span class="comment">#编译当前目录内所有的c程序,命名为calc </span></span><br><span class="line"><span class="comment">#头文件在include文件中,指明头文件所在地</span></span><br><span class="line"><span class="comment">#如果头文件就在当前目录中不加-I也可以执行</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-指定一个宏-D"><a href="#3-指定一个宏-D" class="headerlink" title="3.指定一个宏(-D)"></a>3.指定一个宏(-D)</h2><blockquote><p>如果不想在程序中定义某个宏， 但是又想让它存在，通过gcc的参数 -D就可以实现，编译器会认为参数后边指定的宏在程序中是存在的。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o app -D DEBUG <span class="comment">#编译中定义DEBUG这个宏</span></span><br></pre></td></tr></table></figure><blockquote><p>-D 参数的应用场景:<br>在发布程序的时候, 一般都会要求将程序中所有的log(日志)输出去掉,<br>如果不去掉会影响程序的执行效率，删除这些打印log的源代码是很麻烦的<br>解决方案是这样的：<br>将所有的打印log的代码都写到一个宏判定中, 可以模仿上边的例子<br>在编译程序的时候指定 -D 就会有log输出<br>在编译程序的时候不指定 -D, log就不会输出</p></blockquote><hr><h1 id="四、多文件编译"><a href="#四、多文件编译" class="headerlink" title="四、多文件编译"></a>四、多文件编译</h1><p>gcc是可以多文件一起编译的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成可执行程序test</span></span><br><span class="line">gcc -o <span class="built_in">test</span> string.c main.c</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行test</span></span><br><span class="line">./test</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先将源文件编成目标文件，然后进行链接得到可执行程序</span></span><br><span class="line"><span class="comment"># 汇编生成二进制目标文件, 指定了 -c 参数之后, 源文件会自动生成 string.o 和 main.o</span></span><br><span class="line">$ gcc –c string.c main.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接目标文件, 生成可执行程序 test</span></span><br><span class="line">$ gcc –o <span class="built_in">test</span> string.o main.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行可执行程序</span></span><br><span class="line">$ ./test</span><br></pre></td></tr></table></figure><hr><h1 id="五、gcc与g"><a href="#五、gcc与g" class="headerlink" title="五、gcc与g++"></a>五、gcc与g++</h1><hr><p>以下是gcc和g++的区别</p><ol><li>在代码编译阶段（第二个阶段）:<br>后缀为 .c 的，gcc 把它当作是C程序，而 g++ 当作是 C++ 程序<br>后缀为.cpp的，两者都会认为是 C++ 程序，C++ 的语法规则更加严谨一些<br>g++会调用gcc，对于C++代码，两者是等价的, 也就是说 gcc 和 g++ 都可以编译 C&#x2F;C++代码</li><li>在链接阶段（最后一个阶段）:<br>gcc 和 g++ 都可以自动链接到标准C库<br>g++ 可以自动链接到标准C++库, gcc如果要链接到标准C++库需要加参数 -lstdc++</li><li>关于 __cplusplus宏的定义<br>g++ 会自动定义__cplusplus宏，但是这个不影响它去编译C程序<br>gcc 需要根据文件后缀判断是否需要定义 __cplusplus 宏 （规则参考第一条）</li></ol><blockquote><p>综上所述：<br>不管是 gcc 还是 g++ 都可以编译 C 程序，编译程序的规则和参数都相同<br>g++可以直接编译C++程序， <strong>gcc 编译 C++程序需要添加额外参数 -lstdc++</strong><br>不管是 gcc 还是 g++ 都可以定义 __cplusplus宏</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译 c 程序</span></span><br><span class="line">gcc test.c -o <span class="built_in">test</span><span class="comment"># 使用gcc</span></span><br><span class="line">g++ test.c -o <span class="built_in">test</span><span class="comment"># 使用g++</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#编译 c++ 程序</span></span><br><span class="line">gcc test.cpp -lstdc++ -o <span class="built_in">test</span>     <span class="comment"># 使用gcc</span></span><br><span class="line">g++ test.cpp -o <span class="built_in">test</span>              <span class="comment"># 使用g++</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcc/g++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim</title>
      <link href="/2023/10/22/vim/"/>
      <url>/2023/10/22/vim/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、vim的模式"><a href="#一、vim的模式" class="headerlink" title="一、vim的模式"></a>一、vim的模式</h1><hr><table><thead><tr><th>模式</th><th>功能</th></tr></thead><tbody><tr><td>命令模式</td><td>进行查看文件内容, 修改文件, 关键的搜索等操作。</td></tr><tr><td>编辑模式</td><td>对文件内容进行修改和内容添加</td></tr><tr><td>末行模式</td><td>执行Linux命令, 保存文件, 进行行的跳转, 窗口分屏等操作</td></tr></tbody></table><p>具体关系如图<br><img src="/img/8.11.png" alt="在这里插入图片描述"></p><hr><h1 id="二、命令模式"><a href="#二、命令模式" class="headerlink" title="二、命令模式"></a>二、命令模式</h1><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以vim方式打开/创建 文件</span></span><br><span class="line">vim 文件名</span><br></pre></td></tr></table></figure><hr><h2 id="1-保存退出"><a href="#1-保存退出" class="headerlink" title="1.保存退出"></a>1.保存退出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZZ</span><br></pre></td></tr></table></figure><hr><h2 id="2-代码格式化"><a href="#2-代码格式化" class="headerlink" title="2.代码格式化"></a>2.代码格式化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gg=G</span><br></pre></td></tr></table></figure><hr><h2 id="3-光标移动"><a href="#3-光标移动" class="headerlink" title="3.光标移动"></a>3.光标移动</h2><table><thead><tr><th>快捷键</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>h</td><td>光标左移</td><td>&lt;–</td></tr><tr><td>j</td><td>光标下移</td><td>↓</td></tr><tr><td>k</td><td>光标上移</td><td>↑</td></tr><tr><td>l</td><td>光标右移</td><td>–&gt;</td></tr><tr><td>0</td><td>光标移动到行首</td><td>&#x2F;</td></tr><tr><td>$</td><td>光标移动到行尾部</td><td>&#x2F;</td></tr><tr><td>gg</td><td>光标移动到文件头</td><td>第一行的开始</td></tr><tr><td>G</td><td>光标移动到文件尾部</td><td>最后一行的开始</td></tr><tr><td>nG</td><td>行跳转</td><td>跳转到第n行</td></tr><tr><td>n+回车</td><td>相对跳转 n 行</td><td>向下跳转n行</td></tr></tbody></table><hr><h2 id="4-删除命令"><a href="#4-删除命令" class="headerlink" title="4.删除命令"></a>4.删除命令</h2><blockquote><p>vim中其实没有删除操作,所谓的删除都是剪切</p></blockquote><table><thead><tr><th>快捷键</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>x</td><td>删除光标后边的字符</td><td>光标盖住的字符</td></tr><tr><td>X</td><td>删除光标前边的字符</td><td>&#x2F;</td></tr><tr><td>dw</td><td>删除单词</td><td>要先把光标移动到单词的第一个字母上再删除,否则单词只能被删除一部分</td></tr><tr><td>d0</td><td>删除光标前的字符串</td><td>从字符串开头到光标当前位置的字符串被删除了</td></tr><tr><td>d$</td><td>删除光标后的字符串</td><td>从光标当前位置到字符串尾部的字符串被删除了</td></tr><tr><td>dd</td><td>删除光标所在行</td><td>无</td></tr><tr><td>ndd</td><td>删除n行</td><td>从光标所在行开始删除n行，n对应的是一个整数</td></tr></tbody></table><hr><h2 id="5-撤销和反撤销"><a href="#5-撤销和反撤销" class="headerlink" title="5.撤销和反撤销"></a>5.撤销和反撤销</h2><table><thead><tr><th>快捷键</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>u</td><td>撤销</td><td>相当于windows中的 ctrl+z</td></tr><tr><td>ctrl+r</td><td>反撤销</td><td>相当于ctrl+y</td></tr></tbody></table><hr><h2 id="6-复制和粘贴"><a href="#6-复制和粘贴" class="headerlink" title="6.复制和粘贴"></a>6.复制和粘贴</h2><blockquote><p>由于vim没有删除只有剪切,所以删除的数据可以用来粘贴</p></blockquote><table><thead><tr><th>快捷键</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>p</td><td>粘贴到光标所在行的下边</td><td>小写的 p</td></tr><tr><td>P</td><td>粘贴到光标所在行的上边</td><td>大写的 P</td></tr><tr><td>yy</td><td>复制光标所在行</td><td>&#x2F;</td></tr><tr><td>nyy</td><td>从光标所在行向下复制 n 行</td><td>n 是要复制的行数，代表一个整数</td></tr></tbody></table><hr><h2 id="7-可视模式"><a href="#7-可视模式" class="headerlink" title="7.可视模式"></a>7.可视模式</h2><blockquote><p>可视模式类似于windows中鼠标选择一块区域(进行多选)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v： 进入的字符可视化模式（Characterwise visual mode)，文本选择是以字符为单位的。</span><br><span class="line">V ：进入的行可视化模式（Linewise visual mode)，文本选择是以行为单位的。</span><br><span class="line">ctrl-v： 进入的块可视化模式（Blockwise visual mode），可以选择一个矩形内的文本。</span><br></pre></td></tr></table></figure><table><thead><tr><th>快捷键</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>h</td><td>光标向左移动</td><td>移动光标用于可视模式下的数据块选择</td></tr><tr><td>j</td><td>光标向下移动</td><td>移动光标用于可视模式下的数据块选择</td></tr><tr><td>k</td><td>光标向上移动</td><td>移动光标用于可视模式下的数据块选择</td></tr><tr><td>l</td><td>光标向右移动</td><td>移动光标用于可视模式下的数据块选择</td></tr><tr><td>d</td><td>删除(剪切)</td><td>删除可视模式下选中的数据块</td></tr><tr><td>y</td><td>复制</td><td>复制可视模式下选中的数据块</td></tr><tr><td>p</td><td>数据粘贴到光标的后边</td><td>粘贴在可视模式下复制或剪切的数据块</td></tr><tr><td>P</td><td>数据粘贴到光标的前边</td><td>粘贴在可视模式下复制或剪切的数据块</td></tr></tbody></table><p><strong>通过可视模式进行代码注释</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.通过 ctrl+v 进入块可视模式</span><br><span class="line">2.移动光标上移（k）或者下移（j），选中多个代码行的开头</span><br><span class="line">3.选择完毕后，按大写的的I键，进入“insert” 模式，输入注释符，例如: //</span><br><span class="line">4.最后按ESC键</span><br><span class="line"></span><br><span class="line">同样 Ctrl+v 进入列选择模式，移动光标把要删除的注释符选中，按下d，注释就被删除了</span><br></pre></td></tr></table></figure><hr><h2 id="8-替换"><a href="#8-替换" class="headerlink" title="8.替换"></a>8.替换</h2><blockquote><p>命令模式下的替换功能并不强大,常用于单字符的切换</p></blockquote><table><thead><tr><th>快捷键</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>r</td><td>替换光标后的单个字符</td><td>无</td></tr><tr><td>R</td><td>替换光标后的多个字符</td><td>按 esc 结束替换</td></tr></tbody></table><hr><h2 id="9-查找"><a href="#9-查找" class="headerlink" title="9.查找"></a>9.查找</h2><blockquote><p>&#x2F;查找的关键词<br>回车<br>使用n&#x2F;N切换搜索到的关键词们</p></blockquote><table><thead><tr><th>搜索快捷键</th><th>关键字遍历</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>&#x2F;</td><td>n</td><td>从当前位置向下</td><td>&#x2F;</td></tr><tr><td></td><td>N</td><td>从当前位置向上</td><td>&#x2F;</td></tr><tr><td>?</td><td>n</td><td>从当前位置向上</td><td>&#x2F;</td></tr><tr><td></td><td>N</td><td>从当前位置向下</td><td>&#x2F;</td></tr><tr><td>#</td><td>n</td><td>从当前位置向上</td><td>光标需要先放在被搜索的关键字上，键盘上按 #</td></tr><tr><td></td><td>N</td><td>从当前位置向下</td><td></td></tr></tbody></table><hr><h2 id="10-查看man文档"><a href="#10-查看man文档" class="headerlink" title="10.查看man文档"></a>10.查看man文档</h2><blockquote><p>man 文档, 是Linux中自带的帮助文档, 可查询shell命令或标准API函数或系统自带的配置文件格式的说明等信息。</p></blockquote><p>但是man也是分章节的</p><table><thead><tr><th>章节</th><th>说明</th></tr></thead><tbody><tr><td>section 1</td><td>Linux提供的所有shell命令</td></tr><tr><td>section 2</td><td>系统函数（由内核提供的）</td></tr><tr><td>section 3</td><td>库调函数(程序库中的函数)</td></tr><tr><td>section 4</td><td>特殊文件(通常在&#x2F;dev目录中可以找到)</td></tr><tr><td>section 5</td><td>系统配置文件格式和约定，比如：&#x2F;etc&#x2F;passwd</td></tr><tr><td>section 6</td><td>游戏（如果有的话）</td></tr><tr><td>section 7</td><td>杂项(包括宏包和约定)</td></tr><tr><td>section 8</td><td>系统管理命令(通常仅针对root用户)</td></tr><tr><td>section 9</td><td>内核例程[非标准]</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询第一章的shell命令</span></span><br><span class="line">man 1 <span class="built_in">cp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查询第二章的系统函数 (如: read, write, open 等)</span></span><br><span class="line">man 2 <span class="built_in">read</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询第三章的标准的库函数 (如: fread, fwrite, fopen 等)</span></span><br><span class="line">man 3 fread</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询第五章的特殊的配置文件说明, 比如: /etc/passwd 或者 /etc/group</span></span><br><span class="line">man 5 passwd</span><br></pre></td></tr></table></figure><blockquote><p>如果不写章节号，从第一章开始搜索查询的关键字，如果查询到了, 直接就结束了<br>比如当查询 printf 函数时不加章节号,就得不到我们我们想要的结果</p></blockquote><blockquote><p>当我们在vim的命令模式下使用man<br>1.找到要查看的函数,将光标放上去<br>2.输入  <strong>章节号 + K</strong> ,就可以了</p></blockquote><hr><h1 id="三、编辑模式"><a href="#三、编辑模式" class="headerlink" title="三、编辑模式"></a>三、编辑模式</h1><blockquote><p>如果要切换到编辑模式需要从命令模式通过快捷键来切换</p></blockquote><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>i</td><td>从光标前边开始输入</td></tr><tr><td>a</td><td>从光标的后边开始输入</td></tr><tr><td>o</td><td>在光标下边创建新行，在新行中输入</td></tr><tr><td>s</td><td>删除光标后边的字符，从删除位置开始输入</td></tr><tr><td>I</td><td>从当前行行首开始输入</td></tr><tr><td>A</td><td>从当前行行尾开始输入</td></tr><tr><td>O</td><td>在光标上边创建新行，在新行中输入</td></tr><tr><td>S</td><td>删除当前行，从当前行开始输入</td></tr></tbody></table><blockquote><p>编辑完成后,按 Esc 就可以回到命令模式</p></blockquote><hr><h1 id="四、末行模式"><a href="#四、末行模式" class="headerlink" title="四、末行模式"></a>四、末行模式</h1><h2 id="1-模式切换"><a href="#1-模式切换" class="headerlink" title="1.模式切换"></a>1.模式切换</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#命令模式切换到末行模式</span></span><br><span class="line">:</span><br><span class="line"></span><br><span class="line"><span class="comment">#末行模式切换到命令模式</span></span><br><span class="line">1. 按两下 Esc</span><br><span class="line">2. 在末行模式执行一个完整指令后自动回到命令模式</span><br></pre></td></tr></table></figure><hr><h2 id="2-保存退出"><a href="#2-保存退出" class="headerlink" title="2.保存退出"></a>2.保存退出</h2><table><thead><tr><th>末行模式下输入的命令</th><th>功能</th></tr></thead><tbody><tr><td>q</td><td>退出，如果退出时文件没有保存，vim会提示是否要保存</td></tr><tr><td>q!</td><td>直接退出，不保存 (强制退出)</td></tr><tr><td>w</td><td>保存，不退出 (相当于在Windows中按了 Ctrl + S)</td></tr><tr><td>wq</td><td>保存并退出</td></tr><tr><td>x</td><td>保存并退出</td></tr></tbody></table><hr><h2 id="3-替换"><a href="#3-替换" class="headerlink" title="3.替换"></a>3.替换</h2><blockquote><p>末行模式下的替换功能强大的多</p></blockquote><table><thead><tr><th>末行模式下的替换命令</th><th>说明</th></tr></thead><tbody><tr><td>s&#x2F;被替换的关键字&#x2F;新的关键字&#x2F;g</td><td>只对光标所在行进行替换</td></tr><tr><td>行号1, 行号2s&#x2F;被替换的关键字&#x2F;新的关键字&#x2F;g</td><td>[行号1, 行号2] 是一个从小到大的范围，对这个范围进行替换</td></tr><tr><td>%s&#x2F;被替换的关键字&#x2F;新的关键字&#x2F;g</td><td>% 代表对所有行进行替换</td></tr></tbody></table><p><code>g的功能是一整行都进行替换</code><br>如果不加g,效果是每一行的第一个关键词被替换</p><hr><h2 id="4-分屏"><a href="#4-分屏" class="headerlink" title="4.分屏"></a>4.分屏</h2><table><thead><tr><th>末行模式命令或者快捷键</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>sp</td><td>水平分屏，多个窗口垂直排列</td><td>多个窗口中显示同一个文件里的内容</td></tr><tr><td>vsp</td><td>垂直分屏，多个窗口水平排列</td><td>多个窗口中显示同一个文件里的内容</td></tr><tr><td>ctrl+w+w</td><td>光标在打开的屏幕之间切换</td><td>快捷键操作 (按住 Ctrl 然后按两次 w)</td></tr><tr><td>qall</td><td>同时退出多个屏幕</td><td>&#x2F;</td></tr><tr><td>wqall</td><td>同时保存退出多个屏幕</td><td>&#x2F;</td></tr><tr><td>sp 文件名</td><td>分屏的同时指定打开的文件的名字</td><td>在新窗口中显示指定的文件的内容</td></tr><tr><td>vsp 文件名</td><td>分屏的同时指定打开的文件的名字</td><td>在新窗口中显示指定的文件的内容</td></tr></tbody></table><blockquote><p>除了在命令模式下分屏, 我们也可以在使用vim打开文件的时候直接分屏, 下边是需要用到的参数:<br>-o: 水平分屏<br>-O: 垂直分屏</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 水平分屏</span></span><br><span class="line">vim -o 文件1, 文件2, 文件3 ...</span><br><span class="line"><span class="comment"># 垂直分屏</span></span><br><span class="line">vim -O 文件1, 文件2, 文件3 ...</span><br></pre></td></tr></table></figure><hr><h2 id="5-行跳转"><a href="#5-行跳转" class="headerlink" title="5.行跳转"></a>5.行跳转</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:行号 <span class="comment">#即可跳转到指定行号</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-执行shell命令"><a href="#6-执行shell命令" class="headerlink" title="6.执行shell命令"></a>6.执行shell命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法格式</span></span><br><span class="line">:!shell命令</span><br><span class="line"></span><br><span class="line"><span class="comment">#eg:</span></span><br><span class="line">:!ll   <span class="comment">#回车即可</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板</title>
      <link href="/2023/10/22/%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/10/22/%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、非类型模板参数"><a href="#一、非类型模板参数" class="headerlink" title="一、非类型模板参数"></a>一、非类型模板参数</h1><hr><p>以Array来举例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> num&gt; <span class="comment">//T就是类型参数,N就是非类型模板参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Array&lt;<span class="type">int</span>,<span class="number">100</span>&gt; a; </span><br></pre></td></tr></table></figure><blockquote><p>非类型模板参数类型一般为  long long&#x2F;long&#x2F;int&#x2F;char&#x2F;short<br>像string,double,float等都不能作为非类型模板参数,会报错</p></blockquote><hr><h1 id="二、函数模板的特化"><a href="#二、函数模板的特化" class="headerlink" title="二、函数模板的特化"></a>二、函数模板的特化</h1><hr><h2 id="1-特化的简单使用"><a href="#1-特化的简单使用" class="headerlink" title="1.特化的简单使用"></a>1.特化的简单使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEqual</span><span class="params">(T&amp; left, T&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left == right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">//模板函数的特化</span></span><br><span class="line"><span class="type">bool</span> <span class="built_in">IsEqual</span>&lt;<span class="type">char</span>*&gt;(<span class="type">char</span>*&amp; left, <span class="type">char</span>*&amp; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(left, right) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;class A&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">//类模板的特化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;string&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;class A&lt;string&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">IsEqual</span>(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* pc1 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* pc2 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">IsEqual</span>(pc1, pc2) &lt;&lt; endl;</span><br><span class="line"><span class="comment">//两个指针传过去比较的是地址,虽然是正确的(创建字符串相同时的指针指向的位置是一样的(节约空间)因此两个指针哪怕都指向&quot;abcd&quot;还是有正确结果</span></span><br><span class="line"><span class="comment">//但是比较的是地址,违背了我们的本意,但是如果为此专门再写一个函数显的麻烦</span></span><br><span class="line"></span><br><span class="line">A&lt;<span class="type">int</span>&gt; a1;</span><br><span class="line">A&lt;string&gt; a2;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-全特化和偏特化"><a href="#2-全特化和偏特化" class="headerlink" title="2.全特化和偏特化"></a>2.全特化和偏特化</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板的特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Data</span>() &#123; cout &lt;&lt; <span class="string">&quot;原函数:Data&lt;T1,T2&gt;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T1 _d1;</span><br><span class="line">T2 _d2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//全特化,全部的参数都特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&lt;<span class="type">int</span>, <span class="type">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Data</span>() &#123; cout &lt;&lt; <span class="string">&quot;全特化:Data&lt;int,char&gt;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//偏特化,特化部分参数/对参数的进一步限制</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&lt;<span class="type">int</span>, T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Data</span>() &#123; cout &lt;&lt; <span class="string">&quot;偏特化:Data&lt;int,T2&gt;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&lt;T1*, T2*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Data</span>() &#123; cout &lt;&lt; <span class="string">&quot;偏特化:Data&lt;T1*,T2*&gt;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&lt;T1&amp;, T2&amp;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Data</span>() &#123; cout &lt;&lt; <span class="string">&quot;偏特化:Data&lt;T1&amp;,T2&amp;&gt;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Data&lt;<span class="type">char</span>, <span class="type">char</span>&gt; d1;</span><br><span class="line">Data&lt;<span class="type">int</span>, <span class="type">char</span>&gt; d2;</span><br><span class="line">Data&lt;<span class="type">int</span>, <span class="type">double</span>&gt; d3; <span class="comment">//自动匹配最接近的特化类型</span></span><br><span class="line"></span><br><span class="line">Data&lt;<span class="type">char</span>*, <span class="type">char</span>*&gt; d4;</span><br><span class="line">Data&lt;<span class="type">char</span>&amp;, <span class="type">char</span>&amp;&gt; d5;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="三、模板的分离编译"><a href="#三、模板的分离编译" class="headerlink" title="三、模板的分离编译"></a>三、模板的分离编译</h1><hr><p>一般的函数可以在头文件声明,cpp文件定义<br>但是模板函数却无法做到<br>并且会报错,<code>链接错误</code></p><blockquote><p>1.预处理 : 展开头文件,宏替换,条件编译,去掉注释,模板;<br>21processcon.cpp -&gt; 21processcon.i   21process.cpp -&gt; 21process.i<br>.<br>2.编译   : 检查语法,生成汇编代码;<br>procon.i -&gt; procon.s   pro.i -&gt; pro.s<br>.<br>3.汇编   : 将汇编代码转换为二进制机器码;<br>procon.s -&gt; procon.o   pro.s -&gt; pro.o<br>.<br>4.链接   : 将目标文件合在一起,编译时F1F2函数有声名,所以编译通过了.<br>连接时要去procon.o找F1F2地址,F1能找到,F2找不到;符号表; a.out</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于类型没有确定,导致在符号表中找不到函数定义的地址</span><br></pre></td></tr></table></figure><hr><p>一般模板函数不分离编译,直接在头文件声明定义</p><p>也可,显示实例化,不常用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.hpp</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F2</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp中</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F2</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;F2(const T&amp; x)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">F2</span>&lt;<span class="type">int</span>&gt;(<span class="type">const</span> <span class="type">int</span>&amp; x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">F2</span>&lt;<span class="type">double</span>&gt;(<span class="type">const</span> <span class="type">double</span>&amp; x);</span><br></pre></td></tr></table></figure><p>当实例化函数为另一个类型就又要显示实例化一次,过于麻烦.</p><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>压缩查找命令</title>
      <link href="/2023/10/21/linux-%E5%8E%8B%E7%BC%A9%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/10/21/linux-%E5%8E%8B%E7%BC%A9%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、压缩命令"><a href="#一、压缩命令" class="headerlink" title="一、压缩命令"></a>一、压缩命令</h1><hr><h2 id="1-tar"><a href="#1-tar" class="headerlink" title="1.tar"></a>1.tar</h2><hr><blockquote><p>Linux系统中自带两个原始压缩工具 : gzip , bzip2<br>但他们都有<strong>不能打包压缩文件</strong>和<strong>压缩后不会保留原有文件</strong>的问题<br>同时Linux中有自带的打包工具 : tar , 将他们联合起来可以各司其职发挥作用</p></blockquote><p>关于tar的参数作用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c : 创建压缩文件</span><br><span class="line">x : 释放压缩文件内容</span><br><span class="line">z : 使用gzip方式进行文件压缩</span><br><span class="line">j : 使用bzip2方式进行文件压缩</span><br><span class="line">v : 压缩过程中显示压缩信息, 可省略</span><br><span class="line">f : 指定压缩包的名字</span><br></pre></td></tr></table></figure><hr><h3 id="①压缩"><a href="#①压缩" class="headerlink" title="①压缩"></a>①压缩</h3><p>关于tar的压缩语法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar 参数 生成的压缩包的名字 要压缩的文件(文件或者目录) (要压缩的文件)</span><br><span class="line"></span><br><span class="line">压缩包的名字后缀最好使用标准后缀</span><br><span class="line">gzip方式压缩 后缀为 : .tar.gz (.tgz)</span><br><span class="line">bzip2 压缩 后缀为  : .tar.bz2</span><br></pre></td></tr></table></figure><p>eg : 使用gzip进行压缩:</p><p><img src="/img/8.1.png" alt="在这里插入图片描述"></p><p>eg : 使用bzip2进行压缩<br><img src="/img/8.2.png" alt="在这里插入图片描述"></p><hr><h3 id="②-解压缩"><a href="#②-解压缩" class="headerlink" title="② 解压缩"></a>② 解压缩</h3><p>解压的语法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 解压到当前目录</span></span><br><span class="line">tar 参数 压缩包名</span><br><span class="line"></span><br><span class="line"><span class="comment">#2. 解压到指定目录</span></span><br><span class="line">tar 参数 压缩包名 -C 解压目录</span><br></pre></td></tr></table></figure><p>eg : 使用gzip方式进行解压</p><p><img src="/img/8.3.png" alt="在这里插入图片描述"></p><p>eg : 使用bzip2方式进行解压<br><img src="/img/8.4.png" alt="在这里插入图片描述"></p><hr><h2 id="2-zip"><a href="#2-zip" class="headerlink" title="2.zip"></a>2.zip</h2><hr><blockquote><p>zip并不是Linux自带的,需要安装才能使用</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ubuntu</span></span><br><span class="line">sudo apt install zip</span><br><span class="line">sudo apt install unzip</span><br><span class="line"></span><br><span class="line"><span class="comment">#centos</span></span><br><span class="line">sudo yum install zip</span><br><span class="line">sudo yum install unzip</span><br></pre></td></tr></table></figure><h3 id="①压缩-1"><a href="#①压缩-1" class="headerlink" title="①压缩"></a>①压缩</h3><p>压缩的语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zip [-r] 压缩包名 要压缩的文件 <span class="comment"># 加入 -r 参数才能将要压缩的文件中的子目录一起压缩</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#压缩包名不用指定后缀 .zip  会自行添加</span></span><br></pre></td></tr></table></figure><p>eg:<br><img src="/img/8.5.png" alt="在这里插入图片描述"></p><hr><h3 id="②解压缩"><a href="#②解压缩" class="headerlink" title="②解压缩"></a>②解压缩</h3><p>解压缩的语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#压缩到当前目录</span></span><br><span class="line">unzip 压缩包名</span><br><span class="line"></span><br><span class="line"><span class="comment">#压缩到指定目录</span></span><br><span class="line">unzip 压缩包名 -d 解压目录</span><br></pre></td></tr></table></figure><p>eg:</p><p><img src="/img/8.6.png" alt="在这里插入图片描述"></p><hr><h2 id="3-rar"><a href="#3-rar" class="headerlink" title="3.rar"></a>3.rar</h2><hr><blockquote><p>rar这种压缩格式在Linux中并不常用,而是在windows中常用的格式<br>如果在Linux中压缩解压这种格式的文件需要额外安装</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Ubuntu</span></span><br><span class="line">sudo apt install rar</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#centos 等各种Linux版本</span></span><br><span class="line">先在  https://www.rarlab.com/download.htm 找到Linux版本下载</span><br><span class="line"></span><br><span class="line">然后使用 Xftp 等工具传输给 Linux 中</span><br><span class="line"></span><br><span class="line">再对压缩包进行解压缩</span><br><span class="line">tar xzvf rarlinux-x64-623.tar.gz </span><br><span class="line"></span><br><span class="line">再移动至opt</span><br><span class="line"><span class="built_in">mv</span> rar /opt</span><br><span class="line"></span><br><span class="line">添加软链接方便命令解析器找到该命令</span><br><span class="line"><span class="built_in">ln</span> -s /opt/rar/rar /usr/local/bin/rar</span><br><span class="line"><span class="built_in">ln</span> -s /opt/rar/unrar /usr/local/bin/unrar</span><br></pre></td></tr></table></figure><h3 id="①压缩-2"><a href="#①压缩-2" class="headerlink" title="①压缩"></a>①压缩</h3><blockquote><p>rar 同 zip 类似,如果压缩目录就加入参数 -r<br>且rar也会自动添加后缀</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#压缩语法</span></span><br><span class="line">rar [-r] a 压缩包名 要压缩的文件 <span class="comment">#参数a(archive) 压缩归档</span></span><br></pre></td></tr></table></figure><p>eg:<br><img src="/img/8.7.png" alt="在这里插入图片描述"></p><h3 id="②解压缩-1"><a href="#②解压缩-1" class="headerlink" title="②解压缩"></a>②解压缩</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解压缩语法</span></span><br><span class="line"><span class="comment">#解压到当前目录</span></span><br><span class="line">rar/unrar x 压缩包名字</span><br><span class="line"></span><br><span class="line"><span class="comment">#解压到指定目录</span></span><br><span class="line">rar/unrar x 压缩包名字 解压目录</span><br></pre></td></tr></table></figure><p>eg:<br><img src="/img/8.8.png" alt="在这里插入图片描述"></p><hr><h2 id="4-xz"><a href="#4-xz" class="headerlink" title="4.xz"></a>4.xz</h2><hr><blockquote><p>.xz格式的压缩解压缩都较为繁琐,需要借助tar进行打包</p></blockquote><h3 id="①压缩-3"><a href="#①压缩-3" class="headerlink" title="①压缩"></a>①压缩</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#压缩语法</span></span><br><span class="line"><span class="comment">#一:</span></span><br><span class="line">tar cvf xxx.tar 要压缩的文件</span><br><span class="line"><span class="comment">#二:</span></span><br><span class="line">xz -z xxx.tar</span><br></pre></td></tr></table></figure><p>eg:<br><img src="/img/8.9.png" alt="在这里插入图片描述"></p><hr><h3 id="②解压缩-2"><a href="#②解压缩-2" class="headerlink" title="②解压缩"></a>②解压缩</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解压缩语法</span></span><br><span class="line"><span class="comment">#一:</span></span><br><span class="line">xz -d xxx.tar.xz</span><br><span class="line"><span class="comment">#二:</span></span><br><span class="line">tar xvf xxx.tar</span><br></pre></td></tr></table></figure><p>eg: 由于释放到原本的目录会覆盖展现不出效果,因此移动到另一文件观察效果<br><img src="/img/8.10.png" alt="在这里插入图片描述"></p><hr><h1 id="二、查找命令"><a href="#二、查找命令" class="headerlink" title="二、查找命令"></a>二、查找命令</h1><hr><blockquote><p>当查找的需求比较简单时可以使用 locate which whereis<br>复杂时可以使用find和grep</p></blockquote><p><code>对应要搜索的文件内容, 建议放到引号中, 因为关键字中可能有特殊字符, 或者有空格, 从而导致解析错误。 关于引号， 单双都可以</code></p><h2 id="1-find"><a href="#1-find" class="headerlink" title="1.find"></a>1.find</h2><blockquote><p>find 的功能非常强大,可根据文件属性进行查找</p></blockquote><h3 id="①文件名-name"><a href="#①文件名-name" class="headerlink" title="①文件名(-name)"></a>①文件名(-name)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据文件名搜索的语法</span></span><br><span class="line">find 搜索路径 -name 要搜索的文件名</span><br><span class="line"><span class="comment">##可以使用模糊搜索(*,?)这些模糊搜索关键字</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#eg:搜索 root 家目录下文件后缀为txt的文件</span></span><br><span class="line">find /root -name <span class="string">&quot;*.txt&quot;</span>  </span><br></pre></td></tr></table></figure><h3 id="②文件类型-type"><a href="#②文件类型-type" class="headerlink" title="②文件类型(-type)"></a>②文件类型(-type)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法格式</span></span><br><span class="line">find 搜索路径 -<span class="built_in">type</span> 文件类型</span><br></pre></td></tr></table></figure><table><thead><tr><th>文件类型</th><th>类型的字符描述</th></tr></thead><tbody><tr><td>普通文件类型</td><td>f</td></tr><tr><td>目录类型</td><td>d</td></tr><tr><td>软连接类型</td><td>l</td></tr><tr><td>字符设备类型</td><td>c</td></tr><tr><td>块设备类型</td><td>b</td></tr><tr><td>管道类型</td><td>p</td></tr><tr><td>本地套接字类型</td><td>s</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#eg:root目录下软链接类型的文件</span></span><br><span class="line">find /root -<span class="built_in">type</span> l</span><br></pre></td></tr></table></figure><hr><h3 id="③文件大小-size"><a href="#③文件大小-size" class="headerlink" title="③文件大小(-size)"></a>③文件大小(-size)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法格式</span></span><br><span class="line">find 搜索路径 -size [ +|- ] 文件大小</span><br><span class="line"><span class="comment">#文件大小需要加单位</span></span><br><span class="line"><span class="comment">#-k(小写)</span></span><br><span class="line"><span class="comment">#-M</span></span><br><span class="line"><span class="comment">#-G</span></span><br></pre></td></tr></table></figure><blockquote><p>文件大小区间非常重要<br>1.-size 4k : 表示的区间为(3k,4k]<br>2.-size -4k : 表示的区间为(0k,3k]<br>3.-size -4k : 表示的区间为(4k,无穷)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#eg:搜索当前目录下大于1M且小于等于3M的文件</span></span><br><span class="line">find ./ -size +1M -size -3M</span><br></pre></td></tr></table></figure><hr><h3 id="④目录层级"><a href="#④目录层级" class="headerlink" title="④目录层级"></a>④目录层级</h3><blockquote><p>由于Linux目录是树形,所以目录可能有很多层</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法格式</span></span><br><span class="line">find 搜索路径 -maxdepth n 搜索属性 属性参数 <span class="comment">#搜索最多n层</span></span><br><span class="line">find 搜索路径 -mindepth n 搜索属性 属性参数 <span class="comment">#搜索最少n层</span></span><br></pre></td></tr></table></figure><blockquote><p>这两个参数不能单独使用,必须和其他属性一起使用</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#eg:从根目录开始搜索,最多5层,文件后缀为.txt</span></span><br><span class="line">sudo find / -maxdepth 5 -name <span class="string">&quot;*.txt&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="⑤同时执行多个操作"><a href="#⑤同时执行多个操作" class="headerlink" title="⑤同时执行多个操作"></a>⑤同时执行多个操作</h3><h4 id="5-1-exec"><a href="#5-1-exec" class="headerlink" title="5.1: -exec"></a>5.1: -exec</h4><blockquote><p>-exec 是find的参数, 可以在exec参数后添加其他需要被执行的shell命令。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法格式</span></span><br><span class="line">find 路径 参数 参数值 -<span class="built_in">exec</span> shell命令 &#123;&#125; \;</span><br><span class="line"><span class="comment">#结尾要加上&#123;&#125; \;</span></span><br><span class="line">且&#123;&#125; \之间有空格</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#eg: 搜索最多两层目录,以 .txt结尾的文件,并查看文件信息</span></span><br><span class="line">find ./ -maxdepth 2 -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">exec</span> <span class="built_in">ls</span> -l &#123;&#125; \;</span><br></pre></td></tr></table></figure><hr><h4 id="5-2-ok"><a href="#5-2-ok" class="headerlink" title="5.2: -ok"></a>5.2: -ok</h4><blockquote><p>加入 -ok 执行shell时会向用户发起询问，比如在删除搜索结果的时候</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法格式</span></span><br><span class="line">find 路径 参数 参数值 -ok shell命令 &#123;&#125; \;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#eg:</span></span><br><span class="line">find ./ -maxdepth 1  -name <span class="string">&quot;*.txt&quot;</span> -ok <span class="built_in">ls</span> -l &#123;&#125; \; </span><br><span class="line"><span class="comment">##之后同意显示文件信息,同理删除时询问是否删除</span></span><br></pre></td></tr></table></figure><hr><h4 id="5-3-xargs"><a href="#5-3-xargs" class="headerlink" title="5.3: xargs"></a>5.3: xargs</h4><blockquote><p>xargs 参数不同于 -exec和-ok 需要在结尾加符号,有着更直观简便的写法<br>并且在处理数据时 xargs更高效<br>-exec:  将find查询的结果逐条传递给后边的shell命令<br>    xargs: 将find查询的结果一次性传递给后边的shell命令</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法格式</span></span><br><span class="line">find 路径 参数 参数值 | xargs shell命令 </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#eg:查找文件并显示信息</span></span><br><span class="line">find ./ -maxdepth 1  -name <span class="string">&quot;*.cpp&quot;</span> | xargs <span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure><hr><h2 id="2-grep"><a href="#2-grep" class="headerlink" title="2.grep"></a>2.grep</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法格式</span></span><br><span class="line">grep <span class="string">&quot;搜索内容&quot;</span> 搜索的路径/文件 参数</span><br><span class="line"><span class="comment">#参数: -r :搜索目录中的文件内容时,必须加上-r</span></span><br><span class="line"><span class="comment">#     -i :忽略大小写</span></span><br><span class="line"><span class="comment">#  -n :显示符合搜索结果那一行之前显示行号</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#eg:搜索指定目录中哪些文件中包含字符串 include 并且显示关键字所在的行号</span></span><br><span class="line">grep <span class="string">&quot;include&quot;</span> ./ -rn </span><br></pre></td></tr></table></figure><hr><h2 id="3-locate"><a href="#3-locate" class="headerlink" title="3.locate"></a>3.locate</h2><blockquote><p>locate可看作是一个简化版的find,  但是locate的效率比find要高很多。<br>原因在于它不搜索具体目录，而是搜索一个本地的数据库文件，这个数据库中含有本地所有文件信息。<br>Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动的文件。<br>为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先进行数据库更新</span></span><br><span class="line">sudo update</span><br><span class="line"></span><br><span class="line"><span class="comment">#语法格式</span></span><br><span class="line">locate xxx  <span class="comment">#搜索所有目录下以 xxx 开头的文件</span></span><br><span class="line">locate /home/sewerperson/xxx <span class="comment">#指定搜索目录下以 xxx 开头的文件</span></span><br><span class="line">locate XxX -i <span class="comment">#-i 忽略搜索文件名的大小写(以xxx开头的文件也能搜索出来)</span></span><br><span class="line">locate xxx -n 5   <span class="comment">#搜索前缀为xxx的文件,并且只显示前5个匹配到的</span></span><br><span class="line">locate -r <span class="string">&quot;\.cpp$&quot;</span> <span class="comment">#-r 表示可以使用正则表达式 (以.cpp结尾的文件)</span></span><br></pre></td></tr></table></figure><p>关于正则表达式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在正则表达式中 .可以匹配任意一个 非 \n的单字符</span><br><span class="line">上边的命令中使用转译字符\对特殊字符.转译, 就得到了普通的字符.</span><br><span class="line">在正则表达式中 $放到字符尾部, 表示字符串必须以这个字符结尾, 上边的命令中修饰的是字符p</span><br><span class="line">正则表达式中的 字符c和后边的字符p需要进行字节匹配, 没有特殊含义</span><br><span class="line">通过上面的解释 \.cpp$ 说的就是以 .cpp结尾的字符串</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tips</title>
      <link href="/2023/10/21/linux-tips/"/>
      <url>/2023/10/21/linux-tips/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、Linux目录结构"><a href="#一、Linux目录结构" class="headerlink" title="一、Linux目录结构"></a>一、Linux目录结构</h1><hr><p><img src="/img/5.5.png" alt="在这里插入图片描述"></p><blockquote><p>Linux中 根目录和子目录结构是相对固定的,不同的目录功能也是固定的</p></blockquote><table><thead><tr><th>目录名称</th><th>功能</th></tr></thead><tbody><tr><td>bin</td><td>二进制文件目录, 存储了可执行程序, 命令对应的可执行程序都在这个目录中</td></tr><tr><td>sbin</td><td>super binary, root用户使用的一些二进制可执行程序</td></tr><tr><td>etc</td><td>配置文件目录, 系统的或者用户自己安装的应用程序的配置文件都存储在这个目录中</td></tr><tr><td>lib</td><td>library, 存储了一些动态库和静态库，给系统或者安装的软件使用</td></tr><tr><td>media</td><td>挂载目录, 挂载外部设备，比如: 光驱, 扫描仪</td></tr><tr><td>mnt</td><td>临时挂载目录, 比如我们可以将U盘临时挂载到这个目录下</td></tr><tr><td>proc</td><td>内存使用的一个映射目录, 给操作系统使用的</td></tr><tr><td>tmp</td><td>临时目录, 存放临时数据, 重启电脑数据就被自动删除了</td></tr><tr><td>boot</td><td>存储了开机相关的设置</td></tr><tr><td>home</td><td>存储了普通用户的家目录，家目录名和用户名相同</td></tr><tr><td>root</td><td>root用户的家目录</td></tr><tr><td>dev</td><td>device , 设备目录, Linux中一切皆文件, 所有的硬件会抽象成文件存储起来，比如：键盘， 鼠标</td></tr><tr><td>lost+found</td><td>一般时候是空的, 电脑异常关闭&#x2F;崩溃时用来存储这些无家可归的文件, 用于用户系统恢复</td></tr><tr><td>opt</td><td>第三方软件的安装目录</td></tr><tr><td>var</td><td>存储了系统使用的一些经常会发生变化的文件， 比如：日志文件</td></tr><tr><td>usr</td><td>unix system resource, 系统的资源目录</td></tr><tr><td>&#x2F;usr&#x2F;bin</td><td>可执行的二进制应用程序</td></tr><tr><td>&#x2F;usr&#x2F;games</td><td>游戏目录</td></tr><tr><td>&#x2F;usr&#x2F;include</td><td>包含的标准头文件目录</td></tr><tr><td>&#x2F;usr&#x2F;local</td><td>和opt目录作用相同, 安装第三方软件</td></tr></tbody></table><hr><h1 id="二、命令解析器"><a href="#二、命令解析器" class="headerlink" title="二、命令解析器"></a>二、命令解析器</h1><hr><h2 id="1-命令提示行"><a href="#1-命令提示行" class="headerlink" title="1.命令提示行"></a>1.命令提示行</h2><p><img src="/img/5.6.png" alt="在这里插入图片描述"></p><p>root : 表示当前登录用户的用户名</p><p>@ : 在(相当于一个分隔符)</p><p>sewerperson : 即自定义的主机名</p><p>“~” :表示当前的家目录 (普通用户:&#x2F;home&#x2F;用户名 — root用户 : &#x2F;root</p><p><img src="/img/5.7.png" alt="在这里插入图片描述"></p><p>shcode : 表示当前用户所在的目录</p><p>“#” : 表示当前用户为root用户</p><p>“$” : 表示当前用户为普通用户</p><hr><h2 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2.工作原理"></a>2.工作原理</h2><p>命令解析器在Linux操作系统中就是一个进程(运行的应用程序)</p><blockquote><p>有bash和shell<br>unix版本时的命令解析器为shell<br>Linux版本时有人(Bourne)进行了更改 取名为bash(Bourne Again SHell)即shell的更新版 </p></blockquote><p>在Linux操作系统中默认使用的命令解析器是 bash, 当然也同样支持使用sh。<br>当我们打开窗口,输入指令,按下回车键,此时命令解析器就开始了工作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Linux中有 PATH 环境变量,存储了一些系统目录 (window : path)</span><br><span class="line">命令解析器依次搜索PATH路径中的目录,检查是否有对应指令</span><br></pre></td></tr></table></figure><p><img src="/img/5.8.png" alt="在这里插入图片描述"></p><hr><h2 id="3-命令行快捷键"><a href="#3-命令行快捷键" class="headerlink" title="3.命令行快捷键"></a>3.命令行快捷键</h2><table><thead><tr><th>快捷键</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>Tab</td><td>命令自动补全</td><td>&#x2F;</td></tr><tr><td>Ctrl+p</td><td>显示输入的上一个历史命令</td><td>也可以使用 ↑键</td></tr><tr><td>Ctrl+n</td><td>显示输入的下一个历史命令</td><td>也可以使用 ↓键</td></tr><tr><td>Ctrl+a</td><td>光标移动命命令行首</td><td>也可以使用 Home键</td></tr><tr><td>Ctrl+e</td><td>光标移动命命令行尾</td><td>也可以使用 End键</td></tr><tr><td>Ctrl+u</td><td>删除光标前的部分字符串</td><td>&#x2F;</td></tr><tr><td>Ctrl+k</td><td>删除光标后的部分字符串</td><td>&#x2F;</td></tr></tbody></table><hr><h1 id="三、文件管理命令"><a href="#三、文件管理命令" class="headerlink" title="三、文件管理命令"></a>三、文件管理命令</h1><hr><h2 id="1-cd"><a href="#1-cd" class="headerlink" title="1.cd"></a>1.cd</h2><p>对于切换为根目录的三种方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">cd</span> /home/用户名</span><br></pre></td></tr></table></figure><p>对于在两个较深且复杂的目录下一直切换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /目录1</span><br><span class="line"><span class="built_in">cd</span> /目录2</span><br><span class="line"><span class="built_in">cd</span> -  <span class="comment">#可以一直在两个目录之间进行切换</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-ls"><a href="#2-ls" class="headerlink" title="2.ls"></a>2.ls</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> [args]        <span class="comment">#查看当前目录</span></span><br><span class="line"><span class="built_in">ls</span> [args] 目录名  <span class="comment">#查看指定目录</span></span><br><span class="line"><span class="built_in">ls</span> [args] 文件名  <span class="comment">#查看文件信息</span></span><br></pre></td></tr></table></figure><p>ls -l :(list)显示文件详细信息</p><p><img src="/img/5.9.png" alt="在这里插入图片描述"></p><p>查询文件详细信息有简单写法 : ll</p><blockquote><p>有的版本ll等价于 ls -l<br>有的则是 ls -laF</p></blockquote><hr><p>ls -a : (all) 显示所有文件,包括隐藏文件<br>默认情况下,隐藏的文件不会被显现出来<br>文件名前有一个 . 就说明文件有隐藏属性</p><p><img src="/img/5.10.png" alt="在这里插入图片描述"></p><hr><p>ls -h :(human) 人性化的将ls -l中显示文件大小的数据显示出来<br>原本的默认大小单位是字节(byte)<br><img src="/img/5.11.png" alt="在这里插入图片描述"></p><hr><p>ls -F : 将文件类型的前面加上&#x2F;<br><img src="/img/5.12.png" alt="在这里插入图片描述"></p><hr><h2 id="3-文件详细信息"><a href="#3-文件详细信息" class="headerlink" title="3.文件详细信息"></a>3.文件详细信息</h2><p><img src="/img/5.13.png" alt="在这里插入图片描述"><br><img src="/img/5.14.png" alt="在这里插入图片描述"><br><code>如果文件名所表示的是一个目录,那么其大小只是表示目录的大小,而并非其子目录/文件的和</code></p><p>文件类型又分为7种</p><table><thead><tr><th>-</th><th>普通的文件, 在Linux终端中没有执行权限的为白色, 压缩包为红色, 可执行程序为绿色字体</th></tr></thead><tbody><tr><td>d</td><td>目录(directory), 在Linux终端中为蓝色字体, 如果目录的所有权限都是开放的, 有绿色的背景色</td></tr><tr><td>l</td><td>软链接文件(link), 相当于windows中的快捷方式, 在Linux终端中为淡蓝色(青色)字体</td></tr><tr><td>c</td><td>字符设备(char)(键盘..), 在Linux终端中为黄色字体</td></tr><tr><td>b</td><td>块设备(block)(u盘,磁盘…), 在Linux终端中为黄色字体</td></tr><tr><td>p</td><td>管道文件(pipe), 在Linux终端中为棕黄色字体</td></tr><tr><td>s</td><td>本地套接字文件(socket), 在Linux终端中为粉色字体</td></tr></tbody></table><p><img src="/img/5.15.png" alt="在这里插入图片描述"></p><h2 id="4-目录的创建和删除"><a href="#4-目录的创建和删除" class="headerlink" title="4.目录的创建和删除"></a>4.目录的创建和删除</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> 目录名     <span class="comment">#单层目录的创建</span></span><br><span class="line"><span class="built_in">mkdir</span> -p 目录名  <span class="comment">#多层目录的创建</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> 目录名     <span class="comment">#只能删除空目录(如果目录种有子文件/目录就无法删除)</span></span><br><span class="line"><span class="built_in">rm</span> 文件          <span class="comment">#删除文件</span></span><br><span class="line"><span class="built_in">rm</span> -r 目录名     <span class="comment">#(递归)删除目录</span></span><br><span class="line"><span class="built_in">rm</span> -i           <span class="comment">#删除时给提示</span></span><br><span class="line"><span class="built_in">rm</span> -f           <span class="comment">#强制删除文件,没有提示且不能恢复</span></span><br></pre></td></tr></table></figure><hr><h2 id="5-cp"><a href="#5-cp" class="headerlink" title="5.cp"></a>5.cp</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> 要拷贝的文件 得到的文件</span><br><span class="line"><span class="built_in">cp</span> 文件A 文件B </span><br><span class="line">如果文件B不存在就创建文件B</span><br><span class="line">如果文件B存在就被文件A覆盖</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r 目录A 目录B</span><br><span class="line">1:目录B不存在就创建且拷贝</span><br><span class="line">2:目录B存在,A目录就会将自己全部拷贝到B的子目录中</span><br></pre></td></tr></table></figure><hr><h2 id="6-mv"><a href="#6-mv" class="headerlink" title="6.mv"></a>6.mv</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件/目录的移动</span></span><br><span class="line"><span class="built_in">mv</span> 目录/文件 目录</span><br><span class="line"><span class="built_in">mv</span> A B<span class="comment">#A既可以是文件也可以是目录,B必须是目录且必须存在</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件/目录改名</span></span><br><span class="line"><span class="built_in">mv</span> 文件名/目录名 文件名/目录名</span><br><span class="line"><span class="built_in">mv</span> A B<span class="comment">#A可以是文件也可以是目录,B是必须不存在的</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件覆盖</span></span><br><span class="line"><span class="built_in">mv</span> 存在的文件 存在的文件</span><br><span class="line"><span class="built_in">mv</span> A B<span class="comment">#AB必须都是文件且存在,A的内容覆盖B,A被删除</span></span><br></pre></td></tr></table></figure><hr><h2 id="7-查看文件内容"><a href="#7-查看文件内容" class="headerlink" title="7.查看文件内容"></a>7.查看文件内容</h2><blockquote><p>终端是有缓存的,因此显示的字节也会受限,需要用合适的命令</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 文件名 <span class="comment">#直接显示所有</span></span><br><span class="line"></span><br><span class="line">more 文件名<span class="comment">#可用翻屏查看</span></span><br><span class="line"><span class="comment">#more快捷键 回车:下一行 空格:向下一屏 b:向上一屏 q:退出</span></span><br><span class="line">less 文件名<span class="comment">#同more类似,多出来可以用上下箭头滚动</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">head</span> 文件名<span class="comment">#默认显示文件前十行</span></span><br><span class="line"><span class="built_in">head</span> -行数 文件名 <span class="comment">#显示文件前n行</span></span><br><span class="line"><span class="built_in">tail</span> 文件名<span class="comment">#默认显示文件尾十行</span></span><br><span class="line"><span class="built_in">tail</span> -行数 文件名 <span class="comment">#显示文件后n行</span></span><br></pre></td></tr></table></figure><hr><h2 id="8-链接的创建"><a href="#8-链接的创建" class="headerlink" title="8.链接的创建"></a>8.链接的创建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#软链接的创建</span></span><br><span class="line"><span class="built_in">ln</span> -s 源文件的路径 软链接的路径(名字)</span><br><span class="line"><span class="comment">#注意:源文件的路径最好是绝对路径,否则可能会:软链接的移动使得软链接无法使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#硬链接的创建</span></span><br><span class="line"><span class="built_in">ln</span> 源文件 硬链接的路径(名字)</span><br><span class="line"><span class="comment">#硬链接和软链接不同, 它是通话文件名直接找对应的硬盘地址, 而不是基于路径</span></span><br><span class="line"><span class="comment">#因此 源文件使用相对路径即可,无需为其制定绝对路径</span></span><br><span class="line"><span class="comment">#目录是不允许创建硬链接的</span></span><br></pre></td></tr></table></figure><hr><h2 id="9-更改文件权限"><a href="#9-更改文件权限" class="headerlink" title="9.更改文件权限"></a>9.更改文件权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文字设定法</span></span><br><span class="line"><span class="built_in">chmod</span> <span class="built_in">who</span> [+|-|=] mod 文件名</span><br><span class="line">- <span class="built_in">who</span>:</span><br><span class="line">u: user  -&gt; 文件所有者</span><br><span class="line">g: group -&gt; 文件所属组用户</span><br><span class="line">o: other -&gt; 其他</span><br><span class="line">a: all, 以上是三类人 u+g+o</span><br><span class="line">- 对权限的操作:</span><br><span class="line">+: 添加权限</span><br><span class="line">-: 去除权限</span><br><span class="line">=: 权限的覆盖</span><br><span class="line">- mod: 权限</span><br><span class="line">r: <span class="built_in">read</span>, 读</span><br><span class="line">w: write, 写</span><br><span class="line">x: execute, 执行</span><br><span class="line">-: 没有权限</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#数字设定法</span></span><br><span class="line"><span class="built_in">chmod</span> [+|-|=] mod 文件名</span><br><span class="line">权限操作中=可以不写</span><br><span class="line">- mod:</span><br><span class="line">4: <span class="built_in">read</span>, r</span><br><span class="line">2: write, w</span><br><span class="line">1: execute , x</span><br><span class="line">0: 没有权限</span><br></pre></td></tr></table></figure><hr><h2 id="10-修改文件所有者-组"><a href="#10-修改文件所有者-组" class="headerlink" title="10.修改文件所有者&#x2F;组"></a>10.修改文件所有者&#x2F;组</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改文件所有者</span></span><br><span class="line">sudo <span class="built_in">chown</span> 新的所有者 文件名<span class="comment">#只修改文件所有者</span></span><br><span class="line">sudo <span class="built_in">chown</span> 新的所有者:新的组名 文件名  <span class="comment">#修改文件所有者和所属组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改文件所属组</span></span><br><span class="line">sudo <span class="built_in">chgrp</span> 新的组 文件名</span><br></pre></td></tr></table></figure><p>对于普通用户无法使用sudo的解决方式</p><p><img src="/img/5.16.png" alt="在这里插入图片描述"><br><img src="/img/5.17.png" alt="在这里插入图片描述"></p><hr><h2 id="11-其他命令"><a href="#11-其他命令" class="headerlink" title="11.其他命令"></a>11.其他命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tree [目录名] -L n  <span class="comment">#树状显示(目录)n层</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> 文件名 <span class="comment">#如果文件已经存在则只会更新文件的修改日期</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">which</span> 命令 <span class="comment">#查看要执行命令的实际路径</span></span><br><span class="line"><span class="comment">#该命令只能查看非内建的shell指令所在的实际路径, 有些命令是直接写到内核中的, 无法查看</span></span><br><span class="line"></span><br><span class="line">&gt;  <span class="comment">#将文件内容写入到指定文件中, 如果文件中已有数据, 则会使用新数据覆盖原数据</span></span><br><span class="line">&gt;&gt; <span class="comment">#将输出的内容追加到指定的文件尾部</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">id</span> 用户名 <span class="comment">#显示其id,组id</span></span><br></pre></td></tr></table></figure><hr><h1 id="四、用户管理命令"><a href="#四、用户管理命令" class="headerlink" title="四、用户管理命令"></a>四、用户管理命令</h1><hr><h2 id="1-用户的切换"><a href="#1-用户的切换" class="headerlink" title="1.用户的切换"></a>1.用户的切换</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">su 用户名 <span class="comment">#此时切换工作目录并不会发生变化</span></span><br><span class="line">su - 用户名  <span class="comment">#此时切换会切换为当前用户的家目录</span></span><br><span class="line"></span><br><span class="line">如果A-&gt;B用户,此时又想切回A</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-添加删除用户"><a href="#2-添加删除用户" class="headerlink" title="2.添加删除用户"></a>2.添加删除用户</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加用户</span></span><br><span class="line">sudo adduser 用户名 <span class="comment">#centos和Ubuntu通用</span></span><br><span class="line">sudo useradd 用户名 <span class="comment">#centos</span></span><br><span class="line">sudo useradd -m -s /bin/bash  用户名 <span class="comment">#Ubuntu</span></span><br></pre></td></tr></table></figure><p>检测是否真的添加成功</p><blockquote><p>1.在home下观察是否有新用户名目录<br>2.在etc&#x2F;passwd文件中观察(vim)</p></blockquote><p><img src="/img/5.18.png" alt="在这里插入图片描述"><br><code>用户名:加密后的密码:用户id:所属组id:用户家目录:用户默认使用的命令解析器</code></p><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除用户</span></span><br><span class="line">sudo userdel 用户名 -r <span class="comment">#删除用户的同时删除其家目录 (centos &amp;&amp; Ubuntu 支持)</span></span><br><span class="line"></span><br><span class="line">sudo deluser 用户名    <span class="comment">#不能添加参数 -r,并且删除后家目录依然存在(Ubuntu特有)</span></span><br><span class="line"><span class="comment">#若要删除家目录</span></span><br><span class="line">sudo <span class="built_in">rm</span> /home/用户名 -r </span><br></pre></td></tr></table></figure><hr><h2 id="3-添加删除用户组"><a href="#3-添加删除用户组" class="headerlink" title="3.添加删除用户组"></a>3.添加删除用户组</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd 组名 <span class="comment">#添加组</span></span><br><span class="line">sudo groupdel 组名 <span class="comment">#删除组</span></span><br></pre></td></tr></table></figure><blockquote><p>可通过&#x2F;etc&#x2F;group文件检验(vim)</p></blockquote><p><img src="/img/5.19.png" alt="在这里插入图片描述"></p><p><strong>最后的数字是用户组的id</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在Ubuntu中可以使用 addgroup/groupadd 和 delgroup/groupdel</span><br><span class="line">在CentOS中只能使用 groupadd 和 groupdel</span><br><span class="line">可通过 <span class="built_in">which</span> 命令查看该Linux版本是否支持使用该命令了。</span><br></pre></td></tr></table></figure><hr><h2 id="4-更改用户所属组"><a href="#4-更改用户所属组" class="headerlink" title="4.更改用户所属组"></a>4.更改用户所属组</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加用户时直接指定组</span></span><br><span class="line">useradd -g 组 用户名 <span class="comment">#如果想加入多个组,组后跟&quot;,&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#更改用户所属组</span></span><br><span class="line">usermod -g 组 用户名 <span class="comment">#更改</span></span><br></pre></td></tr></table></figure><hr><h2 id="5-修改密码"><a href="#5-修改密码" class="headerlink" title="5.修改密码"></a>5.修改密码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">passwd <span class="comment">#修改自己的用户密码</span></span><br><span class="line">sudo passwd 用户名 <span class="comment">#修改其他用户的密码</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="/2023/10/21/cpp-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2023/10/21/cpp-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-智能指针介绍"><a href="#1-智能指针介绍" class="headerlink" title="1. 智能指针介绍"></a>1. 智能指针介绍</h1><h2 id="1-1-为什么使用智能指针"><a href="#1-1-为什么使用智能指针" class="headerlink" title="1.1 为什么使用智能指针"></a>1.1 为什么使用智能指针</h2><hr><p>根据所需构建一个智能指针</p><blockquote><p>RAII (Resource Acquisition Is Initialization) 是一种利用对象生命周期来控制程序资源<br>智能指针就是依靠RAII实现的</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Smart_Ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Smart_Ptr</span>(T* ptr)</span><br><span class="line">:_ptr(ptr)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~<span class="built_in">Smart_Ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line">_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line">cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;/0 error&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> m / n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时有内存泄漏的风险</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">Fun2</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">//以下是解决方案</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.重新抛异常解决</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Fun2</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...) <span class="comment">//一般接受类型为...,否则其他类型可能接受不到</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="comment">//但是如果: new了很多对象,new失败了抛异常,就很难处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.智能指针解决</span></span><br><span class="line"><span class="function">Smart_Ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(p)</span></span>; <span class="comment">//直接将指针交给智能指针,任其生命周期结束调用析构函数从而达到释放空间的目的</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">Fun2</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出了这个作用域sp生命周期结束进行析构</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Fun1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-2-智能指针遇到的问题"><a href="#1-2-智能指针遇到的问题" class="headerlink" title="1.2 智能指针遇到的问题"></a>1.2 智能指针遇到的问题</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Smart_Ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">*sp1 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">Smart_Ptr&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">sp2</span>(<span class="keyword">new</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;);</span><br><span class="line">sp2-&gt;first = <span class="number">30</span>;</span><br><span class="line">sp2-&gt;second = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是不仅仅这么简单</span></span><br><span class="line"><span class="function">Smart_Ptr&lt;<span class="type">int</span>&gt; <span class="title">sp3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">Smart_Ptr&lt;<span class="type">int</span>&gt; <span class="title">sp4</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">sp3 = sp4; </span><br><span class="line"><span class="comment">//如果赋值后两个指针指向同一空间</span></span><br><span class="line"><span class="comment">//析构时重复释放一块空间两次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>有三种解决方法</p><blockquote><p>C++98 : 管理权转移<br>C++11 : 防拷贝 , 计数</p></blockquote><hr><h1 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h1><h2 id="2-1-管理权转移-auto-ptr"><a href="#2-1-管理权转移-auto-ptr" class="headerlink" title="2.1 管理权转移(auto_ptr)"></a>2.1 管理权转移(auto_ptr)</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="number">9</span>TSe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">auto_ptr</span>(T* ptr)</span><br><span class="line">:_ptr(ptr)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//p1(p2)</span></span><br><span class="line"><span class="built_in">auto_ptr</span>(auto_ptr&lt;T&gt;&amp; ap)</span><br><span class="line">:_ptr(ap._ptr)</span><br><span class="line">&#123;</span><br><span class="line">ap._ptr = <span class="literal">nullptr</span>; <span class="comment">//直接将p2置空,将管理权全部转移给p1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> auto_ptr&lt;T&gt;&amp; ap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;ap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr)</span><br><span class="line"><span class="keyword">delete</span> _ptr; <span class="comment">//释放原本指向的空间</span></span><br><span class="line"></span><br><span class="line">_ptr = ap._ptr;  <span class="comment">//指向新空间</span></span><br><span class="line">ap._ptr = <span class="literal">nullptr</span>;  <span class="comment">//管理权全部转移给_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">auto_ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line">_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当同时指向一块空间时<br>将一个指针赋空,权力全部转移给另一个指针</p></blockquote><blockquote><p>但同时又有问题,赋空的指针无法进行访问,会导致空指针操作<br>当代码量大时难以发现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">bsy::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">ap1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">bsy::auto_ptr&lt;<span class="type">int</span>&gt; ap2 = ap1;    <span class="comment">//直接将ap1置空,管理权全部转移给ap2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是缺陷很大,有时会没有注意</span></span><br><span class="line"><span class="comment">//*ap1 = 3; //空指针访问,导致出错</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-2-防拷贝-unique-ptr"><a href="#2-2-防拷贝-unique-ptr" class="headerlink" title="2.2 防拷贝(unique_ptr)"></a>2.2 防拷贝(unique_ptr)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="number">9</span>TSe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unique_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">unique_ptr</span>(T* ptr)</span><br><span class="line">:_ptr(ptr)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//p1(p2)</span></span><br><span class="line"><span class="built_in">unique_ptr</span>(unique_ptr&lt;T&gt;&amp; up) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">unique_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&lt;T&gt;&amp; up) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">unique_ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line">_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>根本上解决了问题<br>但是如果有需要拷贝的场景,就没法使用</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">bsy::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">bsy::unique_ptr&lt;<span class="type">int</span>&gt; up2 = (<span class="keyword">new</span> <span class="type">int</span>);</span><br><span class="line"><span class="comment">//bsy::unique_ptr&lt;int&gt; up2 = up1; </span></span><br><span class="line"><span class="comment">//up1 = up2;//直接报错,不让拷贝构造</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-3-计数-shared-ptr"><a href="#2-3-计数-shared-ptr" class="headerlink" title="2.3 计数(shared_ptr)"></a>2.3 计数(shared_ptr)</h2><h3 id="2-3-1-基本模拟实现"><a href="#2-3-1-基本模拟实现" class="headerlink" title="2.3.1 基本模拟实现"></a>2.3.1 基本模拟实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="number">9</span>TSe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">shared_ptr</span>(T* ptr)</span><br><span class="line">:_ptr(ptr)</span><br><span class="line">,_pcount (<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>(shared_ptr&lt;T&gt;&amp; sp)</span><br><span class="line">:_ptr(sp._ptr)</span><br><span class="line">,_pcount(sp._pcount)</span><br><span class="line">&#123;</span><br><span class="line">++(*_pcount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">shared_ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (--(*_pcount) == <span class="number">0</span> &amp;&amp; _ptr)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;delete : &quot;</span> &lt;&lt; _ptr &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line">_ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> _pcount;</span><br><span class="line">_pcount = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sp1 = sp2</span></span><br><span class="line">shared_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(shared_ptr&lt;T&gt;&amp; sp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;sp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (--(*_pcount) == <span class="number">0</span>) </span><br><span class="line"><span class="comment">//当sp1原本管的空间在sp1走后便没人管理时,释放原本空间</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _pcount;</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_ptr = sp._ptr;</span><br><span class="line">_pcount = sp._pcount;</span><br><span class="line">++(*_pcount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line"><span class="type">int</span>* _pcount;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过计数来判断是否需要析构,是较好的处理方法</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">bsy::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">bsy::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">bsy::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">bsy::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp4</span><span class="params">(sp3)</span></span>;</span><br><span class="line"><span class="function">bsy::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp5</span><span class="params">(sp3)</span></span>;</span><br><span class="line"></span><br><span class="line">sp1 = sp3;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-2-线程问题"><a href="#2-3-2-线程问题" class="headerlink" title="2.3.2 线程问题"></a>2.3.2 线程问题</h3><blockquote><p>由于智能指针涉及到公共资源，难免会在多线程下使用，那么此时就会出现线程安全问题。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_share_ptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">([&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; sp2(sp1);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">([&amp;]()</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; sp3(sp1);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于线程问题导致得到的结果并不正确</p><hr><h3 id="2-3-3-线程问题的解决"><a href="#2-3-3-线程问题的解决" class="headerlink" title="2.3.3 线程问题的解决"></a>2.3.3 线程问题的解决</h3><blockquote><p>加锁<br>2.不过，对于我们而言，放在类的对象中的锁这个做法是行不通的，因为这样构造出来的指针明明指向的是同一个结构，但是所谓的锁不是同一把锁，那么就算是加锁这个操作也是没有意义的<br>3.基于2的问题，我们需要的是不同对象拥有同一把锁，那么做法其实加入计数器的做法一样，都传入的是其指针</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>(T* ptr)</span><br><span class="line">:_ptr(ptr)</span><br><span class="line">,_pcount(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>))</span><br><span class="line">,_pmtx(<span class="keyword">new</span> mutex)</span><br><span class="line">&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">_pmtx-&gt;<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (--(*_pcount) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line"><span class="keyword">delete</span> _pcount;</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">_pmtx-&gt;<span class="built_in">unlock</span>();</span><br><span class="line"><span class="keyword">if</span> (flag) <span class="comment">//如果是最后一个指针已经销毁了,那么销毁锁</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _pmtx;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)</span><br><span class="line">:_ptr(sp._ptr)</span><br><span class="line">, _pcount(sp._pcount)</span><br><span class="line">, _pmtx(sp._pmtx)</span><br><span class="line">&#123;</span><br><span class="line">_pmtx-&gt;<span class="built_in">lock</span>();</span><br><span class="line">++(*_pcount);</span><br><span class="line">_pmtx-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">shared_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(sp._ptr!=_ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">release</span>();</span><br><span class="line">_ptr = sp._ptr;</span><br><span class="line">_pcount=(sp._pcount);</span><br><span class="line"></span><br><span class="line">_pmtx-&gt;<span class="built_in">lock</span>();</span><br><span class="line">++(*_pcount);</span><br><span class="line">_pmtx-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">T* _ptr;</span><br><span class="line"><span class="type">int</span>* _pcount;</span><br><span class="line">mutex* _pmtx;</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-4-循环引用问题"><a href="#2-3-4-循环引用问题" class="headerlink" title="2.3.4 循环引用问题"></a>2.3.4 循环引用问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">~<span class="built_in">ListNode</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~ListNode()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">shared_ptr&lt;ListNode&gt; _next;</span><br><span class="line">shared_ptr&lt;ListNode&gt; _prev;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_share_ptr2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::shared_ptr&lt;ListNode&gt; <span class="title">n1</span><span class="params">(<span class="keyword">new</span> ListNode)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;ListNode&gt; <span class="title">n2</span><span class="params">(<span class="keyword">new</span> ListNode)</span></span>;</span><br><span class="line"> </span><br><span class="line">n1-&gt;_next = n2;</span><br><span class="line">n2-&gt;_prev = n1;</span><br><span class="line">    cout &lt;&lt; n1.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-4-循环引用解决方案-weak-ptr"><a href="#2-4-循环引用解决方案-weak-ptr" class="headerlink" title="2.4 循环引用解决方案(weak_ptr)"></a>2.4 循环引用解决方案(weak_ptr)</h2><blockquote><p>weak_ptr 本质上是不计数的shared_ptr</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">weak_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">weak_ptr</span>()</span><br><span class="line">:_ptr(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">weak_ptr</span>(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)</span><br><span class="line">:_ptr(sp.<span class="built_in">get</span>())</span><br><span class="line">&#123;&#125;</span><br><span class="line"> </span><br><span class="line">weak_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)</span><br><span class="line">&#123;</span><br><span class="line">_ptr = sp.<span class="built_in">get</span>();</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//像指针一样</span></span><br><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *_ptr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="3-定制删除器"><a href="#3-定制删除器" class="headerlink" title="3. 定制删除器"></a>3. 定制删除器</h1><blockquote><p>默认的删除其实只是针对指针，如果我们构造的智能指针指向一个特定的结构体，就无法删除</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DeleteArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">delete</span>[] ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//MY::test_share_ptr1();</span></span><br><span class="line"><span class="comment">//MY::test_share_ptr2();</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], DeleteArray&lt;<span class="type">int</span>&gt;())</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;string&gt; <span class="title">sp2</span><span class="params">(<span class="keyword">new</span> string[<span class="number">10</span>], DeleteArray&lt;string&gt;())</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;string&gt; <span class="title">sp3</span><span class="params">(<span class="keyword">new</span> string[<span class="number">10</span>], [](string* ptr) &#123;<span class="keyword">delete</span>[] ptr; &#125;)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;FILE&gt; <span class="title">sp4</span><span class="params">(fopen(<span class="string">&quot;Test.cpp&quot;</span>, <span class="string">&quot;r&quot;</span>), [](FILE* ptr) &#123;fclose(ptr); &#125;)</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>定制删除器，在库中的智能指针在构造时会传入删除器，随后传入内部自动删除指定结构体的内存，防止内存泄漏。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fclose</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fclose</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">BSY::shared_ptr &lt; FILE, Fclose&lt;FILE&gt;&gt; <span class="built_in">n2</span>(<span class="built_in">fopen</span>(<span class="string">&quot;Text.cpp&quot;</span>, <span class="string">&quot;r&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><p>一般使用仿函数来定制删除器</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟实现 </tag>
            
            <tag> 智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11</title>
      <link href="/2023/10/21/cpp11-2/"/>
      <url>/2023/10/21/cpp11-2/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-自动类型推导"><a href="#1-自动类型推导" class="headerlink" title="1. 自动类型推导"></a>1. 自动类型推导</h1><h2 id="1-1-auto"><a href="#1-1-auto" class="headerlink" title="1.1 auto"></a>1.1 auto</h2><blockquote><p>C++11之前auto和static是对应的,表示变量是自动存储的，但是非static的局部变量默认都是自动存储的，因此这个关键字变得非常鸡肋，<br>在C++11中他们赋予了新的含义，使用这个关键字能够像别的语言一样自动推导出变量的实际类型。</p></blockquote><h3 id="1-1-1-推导规则"><a href="#1-1-1-推导规则" class="headerlink" title="1.1.1 推导规则"></a>1.1.1 推导规则</h3><ul><li><p>使用auto声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在<code>编译时</code>将auto占位符替换为真正的类型。</p></li><li><p>当变量不是指针或者引用类型时，推导的结果中不会保留const、volatile关键字</p></li><li><p>当变量是指针或者引用类型时，推导的结果中会保留const、volatile关键字</p></li></ul><h3 id="1-1-2-auto的限制"><a href="#1-1-2-auto的限制" class="headerlink" title="1.1.2 auto的限制"></a>1.1.2 auto的限制</h3><ol><li>不能作为函数参数使用。因为只有在函数调用的时候才会给函数参数传递实参，auto要求必须要给修饰的变量赋值，因此二者矛盾。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)</span><span class="comment">// error</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt;<span class="string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>不能使用auto关键字定义数组</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> array[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  <span class="comment">// 定义数组</span></span><br><span class="line">    <span class="keyword">auto</span> t1 = array;            <span class="comment">// ok, t1被推导为 int* 类型</span></span><br><span class="line">    <span class="keyword">auto</span> t2[] = array;          <span class="comment">// error, auto无法定义数组</span></span><br><span class="line">    <span class="keyword">auto</span> t3[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;;   <span class="comment">// error, auto无法定义数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>无法使用auto推导出模板参数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test&lt;<span class="type">double</span>&gt; t;</span><br><span class="line">    Test&lt;<span class="keyword">auto</span>&gt; t1 = t;           <span class="comment">// error, 无法推导出模板类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-3-auto的应用"><a href="#1-1-3-auto的应用" class="headerlink" title="1.1.3 auto的应用"></a>1.1.3 auto的应用</h3><p>下面列举几个比较常用的场景：</p><ol><li><code>用于STL的容器遍历。</code></li></ol><p>在C++11之前，定义了一个stl容器之后，遍历的时候常常会写出这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; person;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt;::iterator it = person.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (; it != person.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在定义迭代器变量 it 的时候代码是很长的，写起来就很麻烦，使用了auto之后，就变得清爽了不少：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; person;</span><br><span class="line">    <span class="comment">// 代码简化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = person.<span class="built_in">begin</span>(); it != person.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>用于泛型编程</code></li></ol><p>在使用模板的时候，很多情况下我们不知道变量应该定义为什么类型，比如下面的代码：</p><p>#include <iostream><br>#include <string><br>using namespace std;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> string <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> val = A::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val: &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>&lt;T1&gt;();</span><br><span class="line">    <span class="built_in">func</span>&lt;T2&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中定义了泛型函数func，在函数中调用了类A的静态方法 get() ，这个函数的返回值是不能确定的，如果不使用auto，就需要再定义一个模板参数，并且在外部调用时手动指定get的返回值类型，具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> string <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">A</span>, <span class="keyword">typename</span> B&gt;        <span class="comment">// 添加了模板参数 B</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B val = A::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val: &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>&lt;T1, <span class="type">int</span>&gt;();                  <span class="comment">// 手动指定返回值类型 -&gt; int</span></span><br><span class="line">    <span class="built_in">func</span>&lt;T2, string&gt;();               <span class="comment">// 手动指定返回值类型 -&gt; string</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-1-4-范围for"><a href="#1-1-4-范围for" class="headerlink" title="1.1.4 范围for"></a>1.1.4 范围for</h3><p>对应基于范围的for循环来说，冒号后边的表达式只会被执行一次。在得到遍历对象之后会先确定好迭代的范围，基于这个范围直接进行遍历。如果是普通的for循环，在每次迭代的时候都需要判断是否已经到了结束边界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt;&amp; <span class="title">getRange</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;get vector range...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : <span class="built_in">getRange</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get vector range...</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><hr><h2 id="1-2-decltype"><a href="#1-2-decltype" class="headerlink" title="1.2 decltype"></a>1.2 decltype</h2><blockquote><p>在某些情况下，不需要或者不能定义变量，但是希望得到某种类型，这时候就可以使用C++11提供的<code>decltype</code>关键字了，它的作用是在编译器编译的时候推导出一个表达式的类型</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line"><span class="keyword">decltype</span> (表达式)</span><br></pre></td></tr></table></figure><p>decltype 是“declare type”的缩写，意思是“声明类型”。<br>decltype的推导是在<code>编译期完成</code>的，它只是用于表达式类型的推导，并不会计算表达式的值。</p><p>一组简单的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">99</span>;                 <span class="comment">// b -&gt; int</span></span><br><span class="line"><span class="keyword">decltype</span>(a+<span class="number">3.14</span>) c = <span class="number">52.13</span>;         <span class="comment">// c -&gt; double</span></span><br><span class="line"><span class="keyword">decltype</span>(a+b*c) d = <span class="number">520.1314</span>;       <span class="comment">// d -&gt; double</span></span><br></pre></td></tr></table></figure><p>可以看到decltype推导的表达式可简单可复杂，在这一点上auto是做不到的，auto只能推导已初始化的变量类型。</p><hr><h3 id="1-2-1-推导规则"><a href="#1-2-1-推导规则" class="headerlink" title="1.2.1 推导规则"></a>1.2.1 推导规则</h3><p>通过上面的例子我们初步感受了一下 decltype 的用法，但不要认为 decltype 就这么简单，在它简单的背后隐藏着很多的细节<br>分三个场景依次讨论一下：</p><ol><li><code>表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用decltype推导出的类型和表达式的类型是一致的。</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string text;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">110</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">99</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;y = x;</span><br><span class="line">    <span class="keyword">decltype</span>(x) a = x;</span><br><span class="line">    <span class="keyword">decltype</span>(y) b = x;</span><br><span class="line">    <span class="keyword">decltype</span>(Test::value) c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">decltype</span>(t.text) d = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>变量a被推导为 int类型</li><li>变量b被推导为 const int &amp;类型</li><li>变量c被推导为 const int类型</li><li>变量d被推导为 string类型</li></ul><ol start="2"><li><code>表达式是函数调用，使用decltype推导出的类型和函数返回值一致。</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;...&#125;;</span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func_int</span><span class="params">()</span></span>;                 <span class="comment">// 返回值为 int</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func_int_r</span><span class="params">()</span></span>;              <span class="comment">// 返回值为 int&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">func_int_rr</span><span class="params">()</span></span>;            <span class="comment">// 返回值为 int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">func_cint</span><span class="params">()</span></span>;          <span class="comment">// 返回值为 const int</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">func_cint_r</span><span class="params">()</span></span>;       <span class="comment">// 返回值为 const int&amp;</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp;&amp; <span class="title">func_cint_rr</span><span class="params">()</span></span>;     <span class="comment">// 返回值为 const int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Test <span class="title">func_ctest</span><span class="params">()</span></span>;        <span class="comment">// 返回值为 const Test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype类型推导</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int</span>()) a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_r</span>()) b = n;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_rr</span>()) c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint</span>())  d = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_r</span>())  e = n;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_rr</span>()) f = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_ctest</span>()) g = <span class="built_in">Test</span>();</span><br></pre></td></tr></table></figure><ul><li>变量a被推导为 int类型</li><li>变量b被推导为 int&amp;类型</li><li>变量c被推导为 int&amp;&amp;类型</li><li>变量d被推导为 int类型</li><li>变量e被推导为 const int &amp;类型</li><li>变量f被推导为 const int &amp;&amp;类型</li><li>变量g被推导为 const Test类型</li></ul><p>函数 <code>func_cint()</code> 返回的是一个纯右值（在表达式执行结束后不再存在的数据，也就是临时性的数据）<br><code>对于纯右值而言，只有类类型可以携带const、volatile限定符，除此之外需要忽略掉这两个限定符</code><br>因此推导出的变量d的类型为 int 而不是 const int。</p><ol start="3"><li><code>表达式是一个左值，或者被括号( )包围，使用 decltype推导出的是表达式类型的引用（如果有const、volatile限定符不能忽略）。</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> Test obj;</span><br><span class="line">    <span class="comment">//带有括号的表达式</span></span><br><span class="line">    <span class="keyword">decltype</span>(obj.num) a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>((obj.num)) b = a;</span><br><span class="line">    <span class="comment">//加法表达式</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n + m) c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n = n + m) d = n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>obj.num 为类的成员访问表达式，符合场景1，因此 a 的类型为int</li><li>obj.num 带有括号，符合场景3，因此b 的类型为 const int&amp;。</li><li>n+m 得到一个右值，符合场景1，因此c的类型为 int</li><li>n&#x3D;n+m 得到一个左值 n，符合场景3，因此d的类型为 int&amp;</li></ul><h3 id="1-2-2-decltype的应用"><a href="#1-2-2-decltype的应用" class="headerlink" title="1.2.2 decltype的应用"></a>1.2.2 decltype的应用</h3><blockquote><p>关于<code>decltype</code>的应用多出现在泛型编程中。比如我们编写一个类模板，在里边添加遍历容器的函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (m_it = c.<span class="built_in">begin</span>(); m_it != c.<span class="built_in">end</span>(); ++m_it)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; *m_it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ??? m_it;  <span class="comment">// 这里不能确定迭代器类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> list&lt;<span class="type">int</span>&gt; lst;</span><br><span class="line">    Container&lt;<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&gt; obj;</span><br><span class="line">    obj.<span class="built_in">func</span>(lst);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序的???行出了问题，关于迭代器变量一共有两种类型：<br>只读（T::const_iterator）和读写（T::iterator）<br>有了decltype就可以完美的解决这个问题了<br>当 T 是一个 非 const 容器得到一个 T::iterator<br>当 T 是一个 const 容器时就会得到一个 T::const_iterator。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (m_it = c.<span class="built_in">begin</span>(); m_it != c.<span class="built_in">end</span>(); ++m_it)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; *m_it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">T</span>().<span class="built_in">begin</span>()) m_it;  <span class="comment">// 这里不能确定迭代器类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> list&lt;<span class="type">int</span>&gt; lst&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    Container&lt;<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&gt; obj;</span><br><span class="line">    obj.<span class="built_in">func</span>(lst);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-返回类型后置"><a href="#1-3-返回类型后置" class="headerlink" title="1.3 返回类型后置"></a>1.3 返回类型后置</h2><blockquote><p>在泛型编程中，可能需要通过参数的运算来得到返回值的类型</p></blockquote><p>比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// R-&gt;返回值类型, T-&gt;参数1类型, U-&gt;参数2类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">520</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">13.14</span>;</span><br><span class="line">    <span class="comment">// auto z = add&lt;decltype(x + y), int, double&gt;(x, y);</span></span><br><span class="line">    <span class="keyword">auto</span> z = <span class="built_in">add</span>&lt;<span class="keyword">decltype</span>(x + y)&gt;(x, y);<span class="comment">// 简化之后的写法</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;z: &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于返回值，从上面的代码可以推断出和表达式<code>t+u</code>的结果类型是一样的,因此可以通过decltype进行推导<br>关于模板函数的参数t和u可以通过实参自动推导出来，因此在程序中就也可以不写。<br>虽然通过上述方式问题被解决了，但是解决方案有点过于理想化，因为对于调用者来说，是不知道函数内部执行了什么样的处理动作的。</p><p>因此如果要想解决这个问题就得直接在 add 函数身上做文章，先来看第一种写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(t+u) <span class="built_in">add</span>(T t, U u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在编译器中将这几行代码改出来后就直接<code>报错</code>了，因为decltype中的 t 和 u 都是函数参数，直接这样写相当于变量还没有定义就直接用上了，这时候变量还不存在</p><p><code>C++11中增加了返回类型后置语法，说明白一点就是将decltype和auto结合起来</code>完成返回类型的推导。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法格式</span></span><br><span class="line"><span class="comment">// 符号 -&gt; 后边跟随的是函数返回值的类型</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...)</span> -&gt; <span class="title">decltype</span><span class="params">(参数表达式)</span></span></span><br></pre></td></tr></table></figure><p><code>auto 会追踪 decltype() 推导出的类型</code><br>因此上边的add()函数可以做如下的修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="comment">// 返回类型后置语法</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t+u)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">520</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">13.14</span>;</span><br><span class="line">    <span class="comment">// auto z = add&lt;int, double&gt;(x, y);</span></span><br><span class="line">    <span class="keyword">auto</span> z = <span class="built_in">add</span>(x, y);<span class="comment">// 简化之后的写法</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;z: &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了进一步说明再看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test</span><span class="params">(<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">test</span><span class="params">(<span class="type">double</span> &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d = d + <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 返回类型后置语法</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">myFunc</span><span class="params">(T&amp; t)</span> -&gt; <span class="title">decltype</span><span class="params">(test(t))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">test</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">520</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">13.14</span>;</span><br><span class="line">    <span class="comment">// auto z = myFunc&lt;int&gt;(x);</span></span><br><span class="line">    <span class="keyword">auto</span> z = <span class="built_in">myFunc</span>(x);             <span class="comment">// 简化之后的写法</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;z: &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// auto z = myFunc&lt;double&gt;(y);</span></span><br><span class="line">    <span class="keyword">auto</span> z1 = <span class="built_in">myFunc</span>(y);            <span class="comment">// 简化之后的写法</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;z1: &quot;</span> &lt;&lt; z1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，通过decltype结合返回值后置语法很容易推导出来 test(t)函数可能出现的返回值类型，并将其作用到了函数myFunc()上。</p><p>&#x2F;&#x2F; 输出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z: <span class="number">520</span></span><br><span class="line">z1: <span class="number">113.14</span></span><br></pre></td></tr></table></figure><hr><h1 id="2-可调用对象包装器、绑定器"><a href="#2-可调用对象包装器、绑定器" class="headerlink" title="2.可调用对象包装器、绑定器"></a>2.可调用对象包装器、绑定器</h1><blockquote><p>C++11通过提供std::function 和 std::bind统一了可调用对象的各种操作。</p></blockquote><h2 id="2-1-可调用对象包装器"><a href="#2-1-可调用对象包装器" class="headerlink" title="2.1 可调用对象包装器"></a>2.1 可调用对象包装器</h2><blockquote><p><code>std::function</code>是可调用对象的包装器。它是一个类模板，可以容纳除了类成员（函数）指针之外的所有可调用对象。<br>通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们。</p></blockquote><h3 id="2-1-1-基本用法"><a href="#2-1-1-基本用法" class="headerlink" title="2.1.1 基本用法"></a>2.1.1 基本用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line">std::function&lt;返回值类型(参数类型列表)&gt; diy_name = 可调用对象;</span><br></pre></td></tr></table></figure><p>下面的实例代码中演示了可调用对象包装器的基本使用方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a - b &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a * b &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 绑定一个普通函数</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = add;</span><br><span class="line">    <span class="comment">// 绑定以静态类成员函数</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f2 = T1::sub;</span><br><span class="line">    <span class="comment">// 绑定一个仿函数</span></span><br><span class="line">    T2 t;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f3 = t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">f2</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">f3</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入结果如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> + <span class="number">3</span> = <span class="number">12</span></span><br><span class="line"><span class="number">9</span> - <span class="number">3</span> = <span class="number">6</span></span><br><span class="line"><span class="number">9</span> * <span class="number">3</span> = <span class="number">27</span></span><br></pre></td></tr></table></figure><p>通过测试代码可以得到结论：<code>std::function</code>可以将可调用对象进行包装，得到一个统一的格式<br>包装完成得到的对象相当于一个函数指针，和函数指针的使用方式相同，通过包装器对象就可以完成对包装的函数的调用了。</p><hr><h3 id="2-1-2-作为回调函数使用"><a href="#2-1-2-作为回调函数使用" class="headerlink" title="2.1.2 作为回调函数使用"></a>2.1.2 作为回调函数使用</h3><p>因为回调函数本身就是通过函数指针实现的，使用对象包装器可以取代函数指针的作用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数参数是一个包装器对象</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> function&lt;<span class="built_in">void</span>()&gt;&amp; f) : <span class="built_in">callback</span>(f)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">callback</span>(); <span class="comment">// 调用通过构造函数得到的函数指针</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    function&lt;<span class="type">void</span>()&gt; callback;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我是要成为海贼王的男人!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(b)</span></span>; <span class="comment">// 仿函数通过包装器对象进行包装</span></span><br><span class="line">    a.<span class="built_in">notify</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用对象包装器<code>std::function</code>可以非常方便的将仿函数转换为一个函数指针<br>通过进行函数指针的传递，在其他函数的合适的位置就可以调用这个包装好的仿函数了。</p><p>另外，使用std::function作为函数的传入参数，可以将定义方式不同的可调用对象进行统一的传递，这样大大增加了程序的灵活性。</p><h2 id="2-2-绑定器"><a href="#2-2-绑定器" class="headerlink" title="2.2 绑定器"></a>2.2 绑定器</h2><blockquote><p><code>std::bind</code>用来将可调用对象与其参数一起进行绑定。<br>绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候。</p></blockquote><p>通俗来讲有两大作用</p><ol><li>将可调用对象与其参数一起绑定成一个仿函数。</li><li>将多元（参数个数为n，n&gt;1）可调用对象转换为一元或者（n-1）元可调用对象，即只绑定部分参数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法格式</span></span><br><span class="line"><span class="comment">// 绑定非类成员函数/变量</span></span><br><span class="line"><span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(可调用对象地址, 绑定的参数/占位符);</span><br><span class="line"><span class="comment">// 绑定类成员函/变量</span></span><br><span class="line"><span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(类函数/成员地址, 类实例对象地址, 绑定的参数/占位符);</span><br></pre></td></tr></table></figure><p>一个关于绑定器的实际使用的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callFunc</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_add</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; x + <span class="number">10</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用绑定器绑定可调用对象和参数</span></span><br><span class="line">    <span class="keyword">auto</span> f1 = <span class="built_in">bind</span>(output, placeholders::_1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">callFunc</span>(i, f1);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f2 = <span class="built_in">bind</span>(output_add, placeholders::_1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">callFunc</span>(i, f2);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码输出的结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span></span><br></pre></td></tr></table></figure><p>使用std::bind绑定器，在函数外部通过绑定不同的函数，控制了最后执行的结果。<br>std::bind绑定器返回的是一个仿函数类型，得到的返回值可以直接赋值给一个<code>std::function</code><br>在使用的时候我们并不需要关心绑定器的返回值类型，使用auto进行自动类型推导就可以了。</p><p><code>placeholders::_1</code>是一个占位符，代表这个位置将在函数调用时被传入的第一个参数所替代。同样还有其他的占位符placeholders::_2、placeholders::_3、placeholders::_4、placeholders::_5等……</p><p>有了占位符的概念之后，使得std::bind的使用变得非常灵活:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用绑定器绑定可调用对象和参数, 并调用得到的仿函数</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">1</span>, <span class="number">2</span>)();</span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_1, <span class="number">2</span>)(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">2</span>, placeholders::_1)(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// error, 调用时没有第二个参数</span></span><br><span class="line">    <span class="comment">// bind(output, 2, placeholders::_2)(10);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用时第一个参数10被吞掉了，没有被使用</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">2</span>, placeholders::_2)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_1, placeholders::_2)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_2, placeholders::_1)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码执行的结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="number">2</span><span class="comment">// bind(output, 1, 2)();</span></span><br><span class="line"><span class="number">10</span> <span class="number">2</span><span class="comment">// bind(output, placeholders::_1, 2)(10);</span></span><br><span class="line"><span class="number">2</span> <span class="number">10</span><span class="comment">// bind(output, 2, placeholders::_1)(10);</span></span><br><span class="line"><span class="number">2</span> <span class="number">20</span><span class="comment">// bind(output, 2, placeholders::_2)(10, 20);</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span><span class="comment">// bind(output, placeholders::_1, placeholders::_2)(10, 20);</span></span><br><span class="line"><span class="number">20</span> <span class="number">10</span><span class="comment">// bind(output, placeholders::_2, placeholders::_1)(10, 20);</span></span><br></pre></td></tr></table></figure><p>通过测试可以看到，std::bind可以直接绑定函数的所有参数，也可以仅绑定部分参数。在绑定部分参数的时候，通过使用std::placeholders来决定空位参数将会属于调用发生时的第几个参数。</p><p>可调用对象包装器std::function是不能实现对类成员函数指针或者类成员指针的包装的，但是通过绑定器std::bind的配合之后，就可以完美的解决这个问题了</p><p>一个例子，然后解释细节：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_number = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 绑定类成员函数</span></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = </span><br><span class="line">        <span class="built_in">bind</span>(&amp;Test::output, &amp;t, placeholders::_1, placeholders::_2);</span><br><span class="line">    <span class="comment">// 绑定类成员变量(公共)</span></span><br><span class="line">    function&lt;<span class="type">int</span>&amp;(<span class="type">void</span>)&gt; f2 = <span class="built_in">bind</span>(&amp;Test::m_number, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用</span></span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">520</span>, <span class="number">1314</span>);</span><br><span class="line">    <span class="built_in">f2</span>() = <span class="number">2333</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t.m_number: &quot;</span> &lt;&lt; t.m_number &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码输出的结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x: <span class="number">520</span>, y: <span class="number">1314</span></span><br><span class="line">t.m_number: <span class="number">2333</span></span><br></pre></td></tr></table></figure><p>在用绑定器绑定类成员函数或者成员变量的时候需要将它们所属的实例对象一并传递到绑定器函数内部。<br><code>f1的类型是function&lt;void(int, int)&gt;，通过使用std::bind将Test的成员函数output的地址和对象t绑定，并转化为一个仿函数并存储到对象f1中。</code></p><p>使用绑定器绑定的类成员变量m_number得到的仿函数被存储到了类型为function&lt;int&amp;(void)&gt;的包装器对象f2中，并且可以在需要的时候修改这个成员。其中<code>int是绑定的类成员的类型，并且允许修改绑定的变量，因此需要指定为变量的引用，由于没有参数因此参数列表指定为void。</code></p><p>示例程序中是使用function包装器保存了bind返回的仿函数，如果不知道包装器的模板类型如何指定，可以直接使用<code>auto</code>进行类型的自动推导，这样使用起来会更容易一些。</p><hr><h1 id="3-using"><a href="#3-using" class="headerlink" title="3. using"></a>3. using</h1><h2 id="3-1-定义别名"><a href="#3-1-定义别名" class="headerlink" title="3.1 定义别名"></a>3.1 定义别名</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用typedef定义函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*func_ptr)</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用using定义函数指针</span></span><br><span class="line"><span class="keyword">using</span> func_ptr1 = <span class="built_in">int</span>(*)(<span class="type">int</span>, <span class="type">double</span>);</span><br></pre></td></tr></table></figure><p>效果是一样的,但是使用using更加清晰</p><hr><h2 id="3-2-模板的别名"><a href="#3-2-模板的别名" class="headerlink" title="3.2 模板的别名"></a>3.2 模板的别名</h2><p>typedef对模板的别名简单并不容易实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>, T&gt; type;<span class="comment">// error, 语法错误</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 定义外敷类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyMap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> map&lt;<span class="type">int</span>, T&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyMap&lt;string&gt;::type m;</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;luffy&quot;</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;ace&quot;</span>));</span><br><span class="line"></span><br><span class="line">    MyMap&lt;<span class="type">int</span>&gt;::type m1;</span><br><span class="line">    m1.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    m1.<span class="built_in">insert</span>(<span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在C++11中，新增了一个特性就是可以通过使用using来为一个模板定义别名</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> mymap = map&lt;<span class="type">int</span>, T&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> mymap = map&lt;<span class="type">int</span>, T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// map的value指定为string类型</span></span><br><span class="line">    mymap&lt;string&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;luffy&quot;</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;ace&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map的value指定为int类型</span></span><br><span class="line">    mymap&lt;<span class="type">int</span>&gt; m1;</span><br><span class="line">    m1.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    m1.<span class="built_in">insert</span>(<span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次强调,using的语法和typedef是一样的,并不会创建新的类型,只是定义别名,<br>using相较于typedef的优势在于定义函数指针别名时看起来更加直观，并可给模板定义别名。</p><hr><h1 id="4-智能指针的使用"><a href="#4-智能指针的使用" class="headerlink" title="4. 智能指针的使用"></a>4. 智能指针的使用</h1><h2 id="4-1-shared-ptr"><a href="#4-1-shared-ptr" class="headerlink" title="4.1 shared_ptr"></a>4.1 shared_ptr</h2><h3 id="4-1-1-通过构造函数初始化"><a href="#4-1-1-通过构造函数初始化" class="headerlink" title="4.1.1 通过构造函数初始化"></a>4.1.1 通过构造函数初始化</h3><blockquote><p>如果智能指针被初始化了一块有效内存，那么这块内存的引用计数+1，如果智能指针没有被初始化或者被初始化为nullptr空指针，引用计数不会+1。另外，不要使用一个原始指针初始化多个shared_ptr。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块字符数组对应的堆内存</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">char</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[<span class="number">12</span>])</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 创建智能指针对象, 不管理任何内存</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 创建智能指针对象, 初始化为空</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(p)</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p)</span></span>;<span class="comment">// error, 编译不会报错, 运行会出错</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-1-2-通过拷贝和移动构造函数初始化"><a href="#4-1-2-通过拷贝和移动构造函数初始化" class="headerlink" title="4.1.2 通过拷贝和移动构造函数初始化"></a>4.1.2 通过拷贝和移动构造函数初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用移动构造函数</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(std::move(ptr1))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr5 = std::<span class="built_in">move</span>(ptr2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr5管理的内存引用计数: &quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ptr1管理的内存引用计数: <span class="number">1</span></span><br><span class="line">ptr2管理的内存引用计数: <span class="number">2</span></span><br><span class="line">ptr3管理的内存引用计数: <span class="number">3</span></span><br><span class="line">ptr4管理的内存引用计数: <span class="number">3</span></span><br><span class="line">ptr5管理的内存引用计数: <span class="number">3</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-1-3-通过std-make-shared初始化"><a href="#4-1-3-通过std-make-shared初始化" class="headerlink" title="4.1.3 通过std::make_shared初始化"></a>4.1.3 通过std::make_shared初始化</h3><blockquote><p>通过C++提供的std::make_shared() 就可以完成内存对象的创建并将其初始化给智能指针</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">make_shared</span><span class="params">( Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>T</code>：模板参数的数据类型</li><li><code>Args&amp;&amp;... args</code> ：要初始化的数据，如果是通过make_shared创建对象，需按照构造函数的参数列表指定</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> x) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(string str) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destruct Test ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Test&gt; ptr2 = <span class="built_in">make_shared</span>&lt;Test&gt;();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Test&gt; ptr3 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="number">520</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Test&gt; ptr4 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="string">&quot;我是要成为海贼王的男人!!!&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ptr1管理的内存引用计数: <span class="number">1</span></span><br><span class="line">construct Test...</span><br><span class="line">ptr2管理的内存引用计数: <span class="number">1</span></span><br><span class="line">construct Test, x = <span class="number">520</span></span><br><span class="line">ptr3管理的内存引用计数: <span class="number">1</span></span><br><span class="line">construct Test, str = 我是要成为海贼王的男人!!!</span><br><span class="line">ptr4管理的内存引用计数: <span class="number">1</span></span><br><span class="line">destruct Test ...</span><br><span class="line">destruct Test ...</span><br><span class="line">destruct Test ...</span><br></pre></td></tr></table></figure><hr><h3 id="4-1-4-通过-reset方法初始化"><a href="#4-1-4-通过-reset方法初始化" class="headerlink" title="4.1.4 通过 reset方法初始化"></a>4.1.4 通过 reset方法初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">( Y* ptr )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y, <span class="keyword">class</span> Deleter &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">( Y* ptr, Deleter d )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y, <span class="keyword">class</span> Deleter, <span class="keyword">class</span> Alloc &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">( Y* ptr, Deleter d, Alloc alloc )</span></span>;</span><br></pre></td></tr></table></figure><ul><li>ptr：指向要取得所有权的对象的指针</li><li>d：指向要取得所有权的对象的指针</li><li>aloc：内部存储所用的分配器</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr1;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr4 = ptr1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ptr4.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr5;</span><br><span class="line">    ptr5.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr5管理的内存引用计数: &quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ptr1管理的内存引用计数: <span class="number">4</span></span><br><span class="line">ptr2管理的内存引用计数: <span class="number">4</span></span><br><span class="line">ptr3管理的内存引用计数: <span class="number">4</span></span><br><span class="line">ptr4管理的内存引用计数: <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">ptr1管理的内存引用计数: <span class="number">3</span></span><br><span class="line">ptr2管理的内存引用计数: <span class="number">3</span></span><br><span class="line">ptr3管理的内存引用计数: <span class="number">3</span></span><br><span class="line">ptr4管理的内存引用计数: <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">ptr5管理的内存引用计数: <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>对于一个未初始化的共享智能指针，可以通过reset方法来初始化，当智能指针中有值的时候，调用reset会使引用计数减1。</p></blockquote><hr><h3 id="4-1-5-获取原始指针"><a href="#4-1-5-获取原始指针" class="headerlink" title="4.1.5 获取原始指针"></a>4.1.5 获取原始指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取原始地址</span></span><br><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">128</span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">char</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[len])</span></span>;</span><br><span class="line">    <span class="comment">// 得到指针的原始地址</span></span><br><span class="line">    <span class="type">char</span>* add = ptr.<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">memset</span>(add, <span class="number">0</span>, len);</span><br><span class="line">    <span class="built_in">strcpy</span>(add, <span class="string">&quot;我是要成为海贼王的男人!!!&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;string: &quot;</span> &lt;&lt; add &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; p.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string: 我是要成为海贼王的男人!!!</span><br><span class="line"><span class="number">0000026F</span>48FE9410  <span class="number">100</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-2-weak-ptr"><a href="#4-2-weak-ptr" class="headerlink" title="4.2 weak_ptr"></a>4.2 weak_ptr</h2><blockquote><p>弱引用智能指针<code>std::weak_ptr</code>可以看做是<code>shared_ptr</code>的助手，<br>它不管理shared_ptr内部的指针。<code> std::weak_ptr没有重载操作符*和-&gt;，因为它不共享指针，不能操作资源，所以它的构造不会增加引用计数，析构也不会减少引用计数</code><br>它的主要作用就是作为一个旁观者监视shared_ptr中管理的资源是否存在。</p></blockquote><h3 id="4-2-1-基本使用方式"><a href="#4-2-1-基本使用方式" class="headerlink" title="4.2.1 基本使用方式"></a>4.2.1 基本使用方式</h3><h4 id="4-2-1-1-初始化"><a href="#4-2-1-1-初始化" class="headerlink" title="4.2.1.1 初始化"></a>4.2.1.1 初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">weak_ptr</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="built_in">weak_ptr</span> (<span class="type">const</span> weak_ptr&amp; x) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="built_in">weak_ptr</span> (<span class="type">const</span> weak_ptr&lt;U&gt;&amp; x) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// 通过shared_ptr对象构造</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="built_in">weak_ptr</span> (<span class="type">const</span> shared_ptr&lt;U&gt;&amp; x) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>具体使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp1;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span><span class="params">(wp1)</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp3</span><span class="params">(sp)</span></span>;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp4;</span><br><span class="line">    wp4 = sp;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp5;</span><br><span class="line">    wp5 = wp3;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>weak_ptr<int> wp1;构造了一个空weak_ptr对象</li><li>weak_ptr<int> wp2(wp1);通过一个空weak_ptr对象构造了另一个空weak_ptr对象</li><li>weak_ptr<int> wp3(sp);通过一个shared_ptr对象构造了一个可用的weak_ptr实例对象</li><li>wp4 &#x3D; sp;通过一个<code>shared_ptr</code>对象构造了一个可用的weak_ptr实例对象（这是一个隐式类型转换）</li><li>wp5 &#x3D; wp3;通过一个weak_ptr对象构造了一个可用的weak_ptr实例对象</li></ul><hr><h4 id="4-2-1-2-其他常用方法"><a href="#4-2-1-2-其他常用方法" class="headerlink" title="4.2.1.2 其他常用方法"></a>4.2.1.2 其他常用方法</h4><h5 id="4-2-1-2-1-use-count"><a href="#4-2-1-2-1-use-count" class="headerlink" title="4.2.1.2.1 use_count()"></a>4.2.1.2.1 use_count()</h5><p>通过调用<code>std::weak_ptr</code>类提供的<code>use_count()</code>方法可以获得当前所观测资源的引用计数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">// 函数返回所监测的资源的引用计数</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>修改一下上面的测试程序，添加打印资源引用计数的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp1;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span><span class="params">(wp1)</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp3</span><span class="params">(sp)</span></span>;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp4;</span><br><span class="line">    wp4 = sp;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp5;</span><br><span class="line">    wp5 = wp3;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wp1: &quot;</span> &lt;&lt; wp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wp2: &quot;</span> &lt;&lt; wp2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wp3: &quot;</span> &lt;&lt; wp3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wp4: &quot;</span> &lt;&lt; wp4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wp5: &quot;</span> &lt;&lt; wp5.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序输出的结果为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use_count:</span><br><span class="line">wp1: <span class="number">0</span></span><br><span class="line">wp2: <span class="number">0</span></span><br><span class="line">wp3: <span class="number">1</span></span><br><span class="line">wp4: <span class="number">1</span></span><br><span class="line">wp5: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>虽然弱引用智能指针wp3、wp4、wp5监测的资源是同一个，但是它的引用计数并没有发生任何的变化，也进一步证明了<code>weak_ptr只是监测资源，并不管理资源</code>。</p><hr><h5 id="4-2-1-2-2-expired"><a href="#4-2-1-2-2-expired" class="headerlink" title="4.2.1.2.2 expired()"></a>4.2.1.2.2 expired()</h5><p>通过调用<code>std::weak_ptr</code>类提供的<code>expired()</code>方法来判断观测的资源是否已经被释放，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">// 返回true表示资源已经被释放, 返回false表示资源没有被释放</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">expired</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>函数的使用方法如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">shared</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">weak</span><span class="params">(shared)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1. weak &quot;</span> &lt;&lt; (weak.<span class="built_in">expired</span>() ? <span class="string">&quot;is&quot;</span> : <span class="string">&quot;is not&quot;</span>) &lt;&lt; <span class="string">&quot; expired&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2. weak &quot;</span> &lt;&lt; (weak.<span class="built_in">expired</span>() ? <span class="string">&quot;is&quot;</span> : <span class="string">&quot;is not&quot;</span>) &lt;&lt; <span class="string">&quot; expired&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码输出的结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> weak is <span class="keyword">not</span> expired</span><br><span class="line"><span class="number">2.</span> weak is expired</span><br></pre></td></tr></table></figure><p>weak_ptr监测的就是shared_ptr管理的资源<br>当共享智能指针调用<code>shared.reset();</code>之后管理的资源被释放，因此weak.expired()函数的结果返回true，表示监测的资源已经不存在了。</p><hr><h5 id="4-2-1-2-3-lock"><a href="#4-2-1-2-3-lock" class="headerlink" title="4.2.1.2.3 lock()"></a>4.2.1.2.3 lock()</h5><p>通过调用<code>std::weak_ptr</code>类提供的<code>lock()</code>方法来获取管理所监测资源的shared_ptr对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="function">shared_ptr&lt;element_type&gt; <span class="title">lock</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>函数的使用方法如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; sp1, sp2;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp;</span><br><span class="line"></span><br><span class="line">    sp1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br><span class="line">    wp = sp1;</span><br><span class="line">    sp2 = wp.<span class="built_in">lock</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    sp1.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    sp1 = wp.<span class="built_in">lock</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*sp1: &quot;</span> &lt;&lt; *sp1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*sp2: &quot;</span> &lt;&lt; *sp2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码输出的结果为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use_count: <span class="number">2</span></span><br><span class="line">use_count: <span class="number">1</span></span><br><span class="line">use_count: <span class="number">2</span></span><br><span class="line">*sp1: <span class="number">520</span></span><br><span class="line">*sp2: <span class="number">520</span></span><br></pre></td></tr></table></figure><ul><li>sp2 &#x3D; wp.lock();通过调用lock()方法得到一个用于管理weak_ptr对象所监测的资源的共享智能指针对象，使用这个对象初始化sp2，此时所监测资源的引用计数为2</li><li>sp1.reset();共享智能指针sp1被重置，weak_ptr对象所监测的资源的引用计数减1</li><li>sp1 &#x3D; wp.lock();sp1重新被初始化，并且管理的还是weak_ptr对象所监测的资源，因此引用计数加1</li><li>共享智能指针对象sp1和sp2管理的是同一块内存，因此最终打印的内存中的结果是相同的，都是520</li></ul><hr><h5 id="4-2-1-2-4-reset"><a href="#4-2-1-2-4-reset" class="headerlink" title="4.2.1.2.4 reset()"></a>4.2.1.2.4 reset()</h5><p>通过调用<code>std::weak_ptr</code>类提供的<code>reset()</code>方法来清空对象，使其不监测任何资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型如下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>函数的使用非常简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1. wp &quot;</span> &lt;&lt; (wp.<span class="built_in">expired</span>() ? <span class="string">&quot;is&quot;</span> : <span class="string">&quot;is not&quot;</span>) &lt;&lt; <span class="string">&quot; expired&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    wp.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2. wp &quot;</span> &lt;&lt; (wp.<span class="built_in">expired</span>() ? <span class="string">&quot;is&quot;</span> : <span class="string">&quot;is not&quot;</span>) &lt;&lt; <span class="string">&quot; expired&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码输出的结果为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> wp is <span class="keyword">not</span> expired</span><br><span class="line"><span class="number">2.</span> wp is expired</span><br></pre></td></tr></table></figure><p>weak_ptr对象sp被重置之后,变成了空对象，不再监测任何资源，因此wp.expired()返回true</p><hr><h3 id="4-2-2-返回管理this的shared-ptr"><a href="#4-2-2-返回管理this的shared-ptr" class="headerlink" title="4.2.2 返回管理this的shared_ptr"></a>4.2.2 返回管理this的shared_ptr</h3><p>如果在一个类中编写了一个函数，通过这个得到管理当前对象的共享智能指针<br>我们可能会写出如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">getSharedPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Test&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Test is disstruct ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Test)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;Test&gt; sp2 = sp1-&gt;<span class="built_in">getSharedPtr</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的测试代码，运行中会出现异常，在终端还是能看到对应的日志输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use_count: <span class="number">1</span></span><br><span class="line">use_count: <span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> is disstruct ...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> is disstruct ...</span><br></pre></td></tr></table></figure><p>通过输出的结果可以看到一个对象被析构了两次<br>其原因是这样的：在这个例子中使用同一个指针this构造了两个智能指针对象sp1和sp2，这二者之间是没有任何关系的，因为sp2并不是通过sp1初始化得到的实例对象。<br>在离开作用域之后this将被构造的两个智能指针各自析构，导致重复析构的错误。</p><p>这个问题可以通过weak_ptr来解决，通过wek_ptr返回管理this资源的共享智能指针对象shared_ptr。<br>C++11中为我们提供了一个模板类叫做<code>std::enable_shared_from_this&lt;T&gt;</code>，这个类中有一个方法叫做<code>shared_from_this()</code>，通过这个方法可以返回一个共享智能指针，在函数的内部就是使用weak_ptr来监测this对象，并通过调用<code>weak_ptr</code>的<code>lock()</code>方法返回一个shared_ptr对象。</p><p>修改之后的代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> : <span class="keyword">public</span> enable_shared_from_this&lt;Test&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">getSharedPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Test is disstruct ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Test)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;Test&gt; sp2 = sp1-&gt;<span class="built_in">getSharedPtr</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码输出的结果为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use_count: <span class="number">1</span></span><br><span class="line">use_count: <span class="number">2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> is disstruct ...</span><br></pre></td></tr></table></figure><p><code>注意</code>：在调用<code>enable_shared_from_this</code>类的<code>shared_from_this()</code>方法之前<br>必须要先初始化函数内部<code>weak_ptr</code>对象，否则该函数无法返回一个有效的<code>shared_ptr</code>对象<br>（具体处理方法可以参考上面的示例代码）。</p><h3 id="4-2-3-解决循环引用问题"><a href="#4-2-3-解决循环引用问题" class="headerlink" title="4.2.3. 解决循环引用问题"></a>4.2.3. 解决循环引用问题</h3><p>智能指针如果循环引用会导致内存泄露，比如下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TA</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TA</span></span><br><span class="line">&#123;</span><br><span class="line">    shared_ptr&lt;TB&gt; bptr;</span><br><span class="line">    ~<span class="built_in">TA</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class TA is disstruct ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TB</span></span><br><span class="line">&#123;</span><br><span class="line">    shared_ptr&lt;TA&gt; aptr;</span><br><span class="line">    ~<span class="built_in">TB</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class TB is disstruct ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;TA&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> TA)</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;TB&gt; <span class="title">bp</span><span class="params">(<span class="keyword">new</span> TB)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TA object use_count: &quot;</span> &lt;&lt; ap.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TB object use_count: &quot;</span> &lt;&lt; bp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ap-&gt;bptr = bp;</span><br><span class="line">    bp-&gt;aptr = ap;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TA object use_count: &quot;</span> &lt;&lt; ap.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TB object use_count: &quot;</span> &lt;&lt; bp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testPtr</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序输出的结果如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TA object use_count: <span class="number">1</span></span><br><span class="line">TB object use_count: <span class="number">1</span></span><br><span class="line">TA object use_count: <span class="number">2</span></span><br><span class="line">TB object use_count: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>在测试程序中，共享智能指针ap、bp对TA、TB实例对象的引用计数变为2，在共享智能指针离开作用域之后引用计数只能减为1<br>这种情况下不会去删除智能指针管理的内存，导致类TA、TB的实例对象不能被析构，最终造成内存泄露。<br>通过使用weak_ptr可以解决这个问题，只要将类TA或者TB的<code>任意一个成员改为weak_ptr</code><br>修改之后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TA</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TA</span></span><br><span class="line">&#123;</span><br><span class="line">    weak_ptr&lt;TB&gt; bptr;</span><br><span class="line">    ~<span class="built_in">TA</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class TA is disstruct ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TB</span></span><br><span class="line">&#123;</span><br><span class="line">    shared_ptr&lt;TA&gt; aptr;</span><br><span class="line">    ~<span class="built_in">TB</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class TB is disstruct ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;TA&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> TA)</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;TB&gt; <span class="title">bp</span><span class="params">(<span class="keyword">new</span> TB)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TA object use_count: &quot;</span> &lt;&lt; ap.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TB object use_count: &quot;</span> &lt;&lt; bp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ap-&gt;bptr = bp;</span><br><span class="line">    bp-&gt;aptr = ap;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TA object use_count: &quot;</span> &lt;&lt; ap.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TB object use_count: &quot;</span> &lt;&lt; bp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testPtr</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出的结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TA object use_count: <span class="number">1</span></span><br><span class="line">TB object use_count: <span class="number">1</span></span><br><span class="line">TA object use_count: <span class="number">2</span></span><br><span class="line">TB object use_count: <span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TB</span> is disstruct ...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TA</span> is disstruct ...</span><br></pre></td></tr></table></figure><p>通过输出的结果可以看到类TA或者TB的对象被成功析构了。</p><p>上面程序中，在对类TA成员赋值时ap-&gt;bptr &#x3D; bp;<code>由于bptr是weak_ptr类型，这个赋值操作并不会增加引用计数</code>，所以bp的引用计数仍然为1，在离开作用域之后bp的引用计数减为0，类TB的实例对象被析构。</p><p>在类TB的实例对象被析构的时候，内部的aptr也被析构，其对TA对象的管理解除，内存的引用计数减为1，当共享智能指针ap离开作用域之后，对TA对象的管理也解除了，内存的引用计数减为0，类TA的实例对象被析构。</p><hr><h1 id="5-constexpr"><a href="#5-constexpr" class="headerlink" title="5. constexpr"></a>5. constexpr</h1><h2 id="5-1-constexpr-介绍"><a href="#5-1-constexpr-介绍" class="headerlink" title="5.1 constexpr 介绍"></a>5.1 constexpr 介绍</h2><blockquote><p>在C++11中添加了一个新的关键字<code>constexpr</code>，这个关键字是用来修饰常量表达式的。<br>所谓常量表达式，指的就是由多个（≥1）常量（值不会改变）组成并且在编译过程中就得到计算结果的表达式。</p></blockquote><p>在介绍gcc&#x2F;g++工作流程的时候说过，C++ 程序从编写完毕到执行分为四个阶段：预处理、 编译、汇编和链接4个阶段，得到可执行程序之后就可以运行了。<br>需要额外强调的是，常量表达式和非常量表达式的计算时机不同<br>非常量表达式只能在程序运行阶段计算出结果<br>常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p><p>那么问题来了，编译器如何识别表达式是不是常量表达式呢？在C++11中添加了constexpr关键字之后就可以在程序中使用它来修饰常量表达式，用来提高程序的执行效率。<br>在使用中建议将 const 和 constexpr 的功能区分开<br>即<code>凡是表达“只读”语义的场景都使用 const，表达“常量”语义的场景都使用 constexpr。</code></p><p>在定义常量时，const 和 constexpr 是等价的，都可以在程序的编译阶段计算出结果，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> m = <span class="built_in">f</span>();  <span class="comment">// 不是常量表达式，m的值只有在运行时才会获取。</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i=<span class="number">520</span>;    <span class="comment">// 是一个常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j=i+<span class="number">1</span>;    <span class="comment">// 是一个常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i=<span class="number">520</span>;    <span class="comment">// 是一个常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> j=i+<span class="number">1</span>;    <span class="comment">// 是一个常量表达式</span></span><br></pre></td></tr></table></figure><blockquote><p>对于 C++ 内置类型的数据，可以直接用 constexpr 修饰<br>但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处的constexpr修饰是无效的</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果要定义一个结构体&#x2F;类常量对象，可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> Test t&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> id = t.id;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> num = t.num;</span><br><span class="line">    <span class="comment">// error，不能修改常量</span></span><br><span class="line">    t.num += <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;id: &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, num: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>t.num +&#x3D; 100;的操作是错误的，对象t是常量，因此它的成员也是常量，常量是不能被修改的。</p><hr><h2 id="5-2-常量表达式函数"><a href="#5-2-常量表达式函数" class="headerlink" title="5.2 常量表达式函数"></a>5.2 常量表达式函数</h2><blockquote><p>为了提高C++程序的执行效率 我们可以将程序中值不需要发生变化的变量定义为常量<br>也可以使用<code>constexpr</code>修饰函数的返回值，这种函数被称作<code>常量表达式函数</code>，这些函数主要包括以下几种：<code>普通函数/类成员函数</code>、<code>类的构造函数</code>、<code>模板函数</code>。</p></blockquote><h3 id="5-2-1-修饰函数"><a href="#5-2-1-修饰函数" class="headerlink" title="5.2.1 修饰函数"></a>5.2.1 修饰函数</h3><p>constexpr并不能修改任意函数的返回值，使这些函数成为常量表达式函数<br>必须要满足以下几个条件：</p><ol><li><code>函数必须要有返回值，并且return 返回的表达式必须是常量表达式。</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error，不是常量表达式函数</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error，不是常量表达式函数</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数func1()没有返回值，不满足常量表达式函数要求</li><li>函数func2()返回值不是常量表达式，不满足常量表达式函数要求</li></ul><p><img src="/img/5.3.png" alt="在这里插入图片描述"></p><p>由此可见在<code>更新的C++标准</code>里边放宽了对constexpr的语法限制。</p><ol start="2"><li><code>函数在使用之前，必须有对应的定义语句。</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> num = <span class="built_in">func1</span>();<span class="comment">// error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试程序constexpr int num &#x3D; func1();中，还没有定义func1()就直接调用了<br>应该将func1()函数的定义放到main()函数的上边。</p><ol start="3"><li>整个函数的函数体中，不能出现非常量表达式之外的语句（using 指令、typedef 语句以及 static_assert 断言、return语句除外）。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> mytype = <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> mytype a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> mytype b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> mytype c = a * b;</span><br><span class="line">    <span class="keyword">return</span> c - (a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为func1()是一个常量表达式函数，在函数体内部是不允许出现非常量表达式以外的操作，因此函数体内部的<code>for</code>循环是一个非法操作。</p><blockquote><p>以上三条规则不仅对应普通函数适用，对应类的成员函数也是适用的：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">int</span> var = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> * var;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> num = t.<span class="built_in">func</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-2-2-修饰模板函数"><a href="#5-2-2-修饰模板函数" class="headerlink" title="5.2.2 修饰模板函数"></a>5.2.2 修饰模板函数</h3><blockquote><p>C++11 语法中，constexpr可以修饰函数模板，但由于模板中类型的不确定性，因此函数模板实例化后的模板函数是否符合常量表达式函数的要求也是不确定的。<br><code>如果constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">dispaly</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> p &#123; <span class="string">&quot;luffy&quot;</span>, <span class="number">19</span> &#125;;</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> ret = <span class="built_in">dispaly</span>(p);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;luffy&#x27;s name: &quot;</span> &lt;&lt; ret.name &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; ret.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//常量表达式函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> ret1 = <span class="built_in">dispaly</span>(<span class="number">250</span>);</span><br><span class="line">    cout &lt;&lt; ret1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Person</span> p1 &#123; <span class="string">&quot;luffy&quot;</span>, <span class="number">19</span> &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Person</span> p2 = <span class="built_in">dispaly</span>(p1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;luffy&#x27;s name: &quot;</span> &lt;&lt; p2.name &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面示例程序中定义了一个函数模板 <code>display()</code>，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：</p><ul><li><code>struct Person ret = dispaly( p );</code>由于参数p是变量，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的</li><li><code>constexpr int ret1 = dispaly(250);</code>参数是常量，符合常量表达式函数的要求，此时 constexpr 是有效的</li><li><code>constexpr struct Person p2 = dispaly(p1);</code>参数是常量，符合常量表达式函数的要求，此时 constexpr 是有效的</li></ul><hr><h3 id="5-2-3-修饰构造函数"><a href="#5-2-3-修饰构造函数" class="headerlink" title="5.2.3 修饰构造函数"></a>5.2.3 修饰构造函数</h3><blockquote><p>如果想用直接得到一个常量对象，也可以使用constexpr修饰一个构造函数，这样就可以得到一个常量构造函数了。<br>常量构造函数有一个要求：<code>构造函数的函数体必须为空，并且必须采用初始化列表的方式为各个成员赋值。</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Person</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p, <span class="type">int</span> age)</span> </span></span><br><span class="line"><span class="function">    :name(p), age(age)</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Person</span> <span class="built_in">p1</span>(<span class="string">&quot;luffy&quot;</span>, <span class="number">19</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;luffy&#x27;s name: &quot;</span> &lt;&lt; p1.name &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="6-委托构造和继承构造函数"><a href="#6-委托构造和继承构造函数" class="headerlink" title="6. 委托构造和继承构造函数"></a>6. 委托构造和继承构造函数</h1><h2 id="6-1-委托构造函数"><a href="#6-1-委托构造函数" class="headerlink" title="6.1 委托构造函数"></a>6.1 委托构造函数</h2><p>委托构造函数允许使用同一个类中的一个构造函数调用其它的构造函数，从而简化相关变量的初始化。<br>下面举例说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;              <span class="comment">// 冗余代码</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;             <span class="comment">// 冗余代码</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;  <span class="comment">// 冗余代码</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_middle = mid &lt; max &amp;&amp; mid &gt; min ? mid : <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_min;</span><br><span class="line">    <span class="type">int</span> m_max;</span><br><span class="line">    <span class="type">int</span> m_middle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">90</span>, <span class="number">30</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;min: &quot;</span> &lt;&lt; t.m_min &lt;&lt; <span class="string">&quot;, middle: &quot;</span> </span><br><span class="line">         &lt;&lt; t.m_middle &lt;&lt; <span class="string">&quot;, max: &quot;</span> &lt;&lt; t.m_max &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的程序中有三个构造函数，但是这三个函数中都有重复的代码，在C++11之前构造函数是不能调用构造函数的，加入了委托构造之后，我们就可以轻松地完成代码的优化了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min):<span class="built_in">Test</span>(max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> mid):<span class="built_in">Test</span>(max, min)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_middle = mid &lt; max &amp;&amp; mid &gt; min ? mid : <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_min;</span><br><span class="line">    <span class="type">int</span> m_max;</span><br><span class="line">    <span class="type">int</span> m_middle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">90</span>, <span class="number">30</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;min: &quot;</span> &lt;&lt; t.m_min &lt;&lt; <span class="string">&quot;, middle: &quot;</span> </span><br><span class="line">         &lt;&lt; t.m_middle &lt;&lt; <span class="string">&quot;, max: &quot;</span> &lt;&lt; t.m_max &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在修改之后的代码中可以看到，重复的代码全部没有了，并且在一个构造函数中调用了其他的构造函数用于相关数据的初始化，相当于是一个链式调用。在使用委托构造函数的时候还需要注意一些几个问题：</p><ol><li><p><code>这种链式的构造函数调用不能形成一个闭环（死循环），否则会在运行期抛异常。</code></p></li><li><p><code>如果要进行多层构造函数的链式调用，建议将构造函数的调用的写在初始列表中而不是函数体内部，否则编译器会提示形参的重复定义。</code></p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Test</span>(max);<span class="comment">// error, 此处编译器会报错, 提示形参max被重复定义</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在初始化列表中调用了代理构造函数初始化某个类成员变量之后，就不能在初始化列表中再次初始化这个变量了。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误, 使用了委托构造函数就不能再次m_max初始化了</span></span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min) : <span class="built_in">Test</span>(max), <span class="built_in">m_max</span>(max)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="6-2-继承构造函数"><a href="#6-2-继承构造函数" class="headerlink" title="6.2 继承构造函数"></a>6.2 继承构造函数</h2><blockquote><p>C++11中提供的继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写。</p></blockquote><p>没有继承构造函数之前的处理方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="type">double</span> m_j;</span><br><span class="line">    string m_k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Child</span>(<span class="type">int</span> i) :<span class="built_in">Base</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Child</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">Base</span>(i, j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Child</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">Base</span>(i, j, k) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Child <span class="title">c</span><span class="params">(<span class="number">520</span>, <span class="number">13.14</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; c.m_i &lt;&lt; <span class="string">&quot;, double: &quot;</span> </span><br><span class="line">         &lt;&lt; c.m_j &lt;&lt; <span class="string">&quot;, string: &quot;</span> &lt;&lt; c.m_k &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子类中初始化从基类继承的类成员，需要在子类中重新定义和基类一致的构造函数，这是非常繁琐的<br>C++11中通过添加继承构造函数这个新特性完美的解决了这个问题，使得代码更加精简。</p><p>继承构造函数的使用方法是这样的：通过使用<code>using 类名::构造函数名</code>（其实类名和构造函数名是一样的）来声明使用基类的构造函数，这样子类中就可以不定义相同的构造函数了，直接使用基类的构造函数来构造派生类对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="type">double</span> m_j;</span><br><span class="line">    string m_k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Child <span class="title">c1</span><span class="params">(<span class="number">520</span>, <span class="number">13.14</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; c1.m_i &lt;&lt; <span class="string">&quot;, double: &quot;</span> &lt;&lt; c1.m_j &lt;&lt; endl;</span><br><span class="line">    <span class="function">Child <span class="title">c2</span><span class="params">(<span class="number">520</span>, <span class="number">13.14</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; c2.m_i &lt;&lt; <span class="string">&quot;, double: &quot;</span> </span><br><span class="line">         &lt;&lt; c2.m_j &lt;&lt; <span class="string">&quot;, string: &quot;</span> &lt;&lt; c2.m_k &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在修改之后的子类中，没有添加任何构造函数，而是添加了<code>using Base::Base;</code>这样就可以在子类中直接继承父类的所有的构造函数，通过他们去构造子类对象了。</p><p>另外如果在子类中隐藏了父类中的<code>同名函数</code>，也可以通过<code>using</code>的方式在子类中使用基类中的这些父类函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base class: i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i, string str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base class: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="type">double</span> m_j;</span><br><span class="line">    string m_k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="keyword">using</span> Base::func;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;child class: i&#x27;am luffy!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Child <span class="title">c</span><span class="params">(<span class="number">250</span>)</span></span>;</span><br><span class="line">    c.<span class="built_in">func</span>();</span><br><span class="line">    c.<span class="built_in">func</span>(<span class="number">19</span>);</span><br><span class="line">    c.<span class="built_in">func</span>(<span class="number">19</span>, <span class="string">&quot;luffy&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例代码输出的结果为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child <span class="keyword">class</span>: i<span class="number">&#x27;</span>am luffy!!!</span><br><span class="line">base <span class="keyword">class</span>: i = <span class="number">19</span></span><br><span class="line">base <span class="keyword">class</span>: i = <span class="number">19</span>, str = luffy</span><br></pre></td></tr></table></figure><p>子类中的func()函数<code>隐藏</code>了基类中的两个func()因此默认情况下通过子类对象只能调用无参的func()<br>在上面的子类代码中添加了using Base::func;之后，就可以通过子类对象直接调用父类中被隐藏的带参func()函数了。</p><hr><h1 id="7-原始字面量"><a href="#7-原始字面量" class="headerlink" title="7. 原始字面量"></a>7. 原始字面量</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R “<span class="built_in">xxx</span>(原始字符串)xxx”</span><br></pre></td></tr></table></figure><p>一个例子直接带入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;D:\hello\world\test.text&quot;</span>;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    string str1 = <span class="string">&quot;D:\\hello\\world\\test.text&quot;</span>;</span><br><span class="line">    cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    string str2 = <span class="string">R&quot;(D:\hello\world\test.text)&quot;</span>;</span><br><span class="line">    cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:helloworld    est.text</span><br><span class="line">D:\hello\world\test.text</span><br><span class="line">D:\hello\world\test.text</span><br></pre></td></tr></table></figure><p>在<code>R “xxx(raw string)xxx”</code> 中，<code>原始字符串必须用括号（）括起来，括号的前后可以加其他字符串，所加的字符串会被忽略，并且加的字符串必须在括号两边同时出现。</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1 = <span class="string">R&quot;(D:\hello\world\test.text)&quot;</span>;</span><br><span class="line">    cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    string str2 = <span class="string">R&quot;luffy(D:\hello\world\test.text)luffy&quot;</span>;</span><br><span class="line">    cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    string str3 = <span class="string">R&quot;luffy(D:\hello\world\test.text)robin&quot;;// 语法错误，编译不通过</span></span><br><span class="line"><span class="string">    cout &lt;&lt; str3 &lt;&lt; endl;</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\hello\world\test.text</span><br><span class="line">D:\hello\world\test.text</span><br></pre></td></tr></table></figure><p><code>结论</code>:使用原始字面量<code>R “xxx(raw string)xxx”</code>，<code>（）两边的字符串在解析的时候是会被忽略的</code>，因此一般不用指定。如果在（）前后指定了字符串，那么前后的字符串<code>必须相同</code>，否则会出现语法错误。</p><hr><h1 id="8-chrono库"><a href="#8-chrono库" class="headerlink" title="8. chrono库"></a>8. chrono库</h1><blockquote><p>C++11中提供了日期和时间相关的库chrono，通过chrono库可以很方便地处理日期和时间，为程序的开发提供了便利。<br>chrono库主要包含三种类型的类：<code>时间间隔duration</code>、<code>时钟clocks</code>、<code>时间点time point</code>。</p></blockquote><h2 id="8-1-时间间隔"><a href="#8-1-时间间隔" class="headerlink" title="8.1 时间间隔"></a>8.1 时间间隔</h2><h3 id="8-1-1-常用类成员"><a href="#8-1-1-常用类成员" class="headerlink" title="8.1.1 常用类成员"></a>8.1.1 常用类成员</h3><blockquote><p><code>duration</code>表示一段时间间隔，用来记录时间长度，可以表示几秒、几分钟、几个小时的时间间隔。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="comment">// 定义于头文件 &lt;chrono&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Rep</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Period</span> = std::ratio&lt;<span class="number">1</span>&gt;</span><br><span class="line">&gt; <span class="keyword">class</span> duration;</span><br></pre></td></tr></table></figure><ul><li><p>Rep：这是一个数值类型，表示时钟数（周期）的类型（默认为整形）。<br>若 Rep 是浮点数，则 duration 能使用小数描述时钟周期的数目。</p></li><li><p>Period：表示时钟的周期，它的原型如下：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义于头文件 &lt;ratio&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    std::<span class="type">intmax_t</span> Num,</span><br><span class="line">    std::<span class="type">intmax_t</span> Denom = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">class</span> ratio;</span><br></pre></td></tr></table></figure><p><code>ratio</code>类表示每个时钟周期的秒数，其中第一个模板参数<code>Num</code>代表分子，<code>Denom</code>代表分母，该分母值默认为1<br>因此，ratio代表的是一个分子除以分母的数值，<br>比如：ratio&lt;2&gt;代表一个时钟周期是2秒，ratio&lt;60&gt;代表一分钟，ratio&lt;60*60&gt;代表一个小时，ratio&lt;60*60*24&gt;代表一天。<br>而ratio&lt;1,1000&gt;代表的是1&#x2F;1000秒，也就是1毫秒，ratio&lt;1,1000000&gt;代表一微秒，ratio&lt;1,1000000000&gt;代表一纳秒。</p><blockquote><p>为了方便使用，在标准库中定义了一些常用的时间间隔，比如：时、分、秒、毫秒、微秒、纳秒，它们都位于chrono命名空间下，定义如下：</p></blockquote><table><thead><tr><th>类型</th><th>定义</th></tr></thead><tbody><tr><td>纳秒：std::chrono::nanoseconds</td><td>duration&lt;Rep*&#x2F;*至少 64 位的有符号整数类型*&#x2F;*, std::nano&gt;</td></tr><tr><td>微秒：std::chrono::microseconds</td><td>duration&lt;Rep*&#x2F;*至少 55 位的有符号整数类型*&#x2F;*, std::micro&gt;</td></tr><tr><td>毫秒：std::chrono::milliseconds</td><td>duration&lt;Rep*&#x2F;*至少 45 位的有符号整数类型*&#x2F;*, std::milli&gt;</td></tr><tr><td>秒：std::chrono::seconds</td><td>duration&lt;Rep*&#x2F;*至少 35 位的有符号整数类型*&#x2F;*&gt;</td></tr><tr><td>分钟：std::chrono::minutes</td><td>duration&lt;Rep*&#x2F;*至少 29 位的有符号整数类型*&#x2F;*, std::ratio&lt;60&gt;&gt;</td></tr><tr><td>小时：std::chrono::hours</td><td>duration&lt;Rep*&#x2F;*至少 23 位的有符号整数类型*&#x2F;*, std::ratio&lt;3600&gt;&gt;</td></tr></tbody></table><p><code>注意</code>：到 hours 为止的每个预定义时长类型至少涵盖 ±292 年的范围。</p><p>duration类的构造函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 拷贝构造函数</span></span><br><span class="line"><span class="built_in">duration</span>( <span class="type">const</span> duration&amp; ) = <span class="keyword">default</span>;</span><br><span class="line"><span class="comment">// 2. 通过指定时钟周期的类型来构造对象</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Rep2 &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">explicit</span> <span class="title">duration</span><span class="params">( <span class="type">const</span> Rep2&amp; r )</span></span>;</span><br><span class="line"><span class="comment">// 3. 通过指定时钟周期类型，和时钟周期长度来构造对象</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Rep2, <span class="keyword">class</span> Period2 &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">duration</span><span class="params">( <span class="type">const</span> duration&lt;Rep2,Period2&gt;&amp; d )</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>为了更加方便的进行duration对象之间的操作，类内部进行了操作符重载：</p></blockquote><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>operator&#x3D;</td><td>对应复制内容 (公开成员函数)</td></tr><tr><td>operator+ <br>  operator-</td><td>实现一元 + 和一元 - (公开成员函数)</td></tr><tr><td>operator++  <br> operator++(int) <br>  operator–  <br> operator–(int)</td><td>递增或递减周期计数 (公开成员函数)</td></tr><tr><td>operator+&#x3D; <br>  operator-&#x3D;  <br> operator*&#x3D;   <br>  operator&#x2F;&#x3D;   <br>  operator%&#x3D;</td><td>实现二个时长间的复合赋值 (公开成员函数)</td></tr></tbody></table><blockquote><p>duration类还提供了获取时间间隔的时钟周期数的方法count()</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> rep <span class="title">count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><h3 id="8-1-2-类的使用"><a href="#8-1-2-类的使用" class="headerlink" title="8.1.2 类的使用"></a>8.1.2 类的使用</h3><blockquote><p>通过构造函数构造事件间隔对象示例代码如下：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">chrono::hours <span class="title">h</span><span class="params">(<span class="number">1</span>)</span></span>;                          <span class="comment">// 一小时</span></span><br><span class="line">    chrono::milliseconds ms&#123; <span class="number">3</span> &#125;;                <span class="comment">// 3 毫秒 花括号也可以初始化</span></span><br><span class="line">    chrono::duration&lt;<span class="type">int</span>, ratio&lt;<span class="number">1000</span>&gt;&gt; <span class="built_in">ks</span>(<span class="number">3</span>);    <span class="comment">// 3000 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// chrono::duration&lt;int, ratio&lt;1000&gt;&gt; d3(3.5);  // error</span></span><br><span class="line">    <span class="function">chrono::duration&lt;<span class="type">double</span>&gt; <span class="title">dd</span><span class="params">(<span class="number">6.6</span>)</span></span>;               <span class="comment">// 6.6 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用小数表示时钟周期的次数</span></span><br><span class="line">    chrono::duration&lt;<span class="type">double</span>, std::ratio&lt;<span class="number">1</span>, <span class="number">30</span>&gt;&gt; <span class="built_in">hz</span>(<span class="number">3.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>h(1)</code>时钟周期为1小时，共有1个时钟周期，所以h表示的时间间隔为1小时</li><li><code>ms(3)</code>时钟周期为1毫秒，共有3个时钟周期，所以ms表示的时间间隔为3毫秒</li><li><code>ks(3)</code>时钟周期为1000秒，一共有三个时钟周期，所以ks表示的时间间隔为3000秒</li><li><code>d3(3.5)</code>时钟周期为1000秒，时钟周期数量只能用整形来表示，但是此处指定的是浮点数，因此语法错误</li><li><code>dd(6.6)</code>时钟周期为默认的1秒，共有6.6个时钟周期，所以dd表示的时间间隔为6.6秒</li><li><code>hz(3.5)</code>时钟周期为1&#x2F;30秒，共有3.5个时钟周期，所以hz表示的时间间隔为1&#x2F;30*3.5秒</li></ul><p>chrono库中根据duration类封装了不同长度的时钟周期（也可以自定义），基于这个时钟周期再进行周期次数的设置就可以得到总的时间间隔了（<code>时钟周期 * 周期次数 = 总的时间间隔</code>）。</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::chrono::milliseconds ms&#123;<span class="number">3</span>&#125;;         <span class="comment">// 3 毫秒</span></span><br><span class="line">    std::chrono::microseconds us = <span class="number">2</span>*ms;     <span class="comment">// 6000 微秒</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间间隔周期为 1/30 秒</span></span><br><span class="line">    std::chrono::duration&lt;<span class="type">double</span>, std::ratio&lt;<span class="number">1</span>, <span class="number">30</span>&gt;&gt; <span class="built_in">hz</span>(<span class="number">3.5</span>);</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt;  <span class="string">&quot;3 ms duration has &quot;</span> &lt;&lt; ms.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; ticks\n&quot;</span></span><br><span class="line">              &lt;&lt;  <span class="string">&quot;6000 us duration has &quot;</span> &lt;&lt; us.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; ticks\n&quot;</span></span><br><span class="line">              &lt;&lt;  <span class="string">&quot;3.5 hz duration has &quot;</span> &lt;&lt; hz.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; ticks\n&quot;</span>;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> ms duration has <span class="number">3</span> ticks</span><br><span class="line"><span class="number">6000</span> us duration has <span class="number">6000</span> ticks</span><br><span class="line"><span class="number">3.5</span> hz duration has <span class="number">3.5</span> ticks</span><br></pre></td></tr></table></figure><ul><li>ms时间单位为毫秒，初始化操作ms{3}表示时间间隔为3毫秒，一共有3个时间周期，每个周期为1毫秒</li><li>us时间单位为微秒，初始化操作2*ms表示时间间隔为6000微秒，一共有6000个时间周期，每个周期为1微秒</li><li>hz时间单位为秒，初始化操作hz(3.5)表示时间间隔为1&#x2F;30*3.5秒，一共有3.5个时间周期，每个周期为1&#x2F;30秒</li></ul><p>由于在duration类内部做了操作符重载，因此时间间隔之间可以直接进行算术运算，比如我们要计算两个时间间隔的差值，就可以在代码中做如下处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">chrono::minutes <span class="title">t1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">chrono::seconds <span class="title">t2</span><span class="params">(<span class="number">60</span>)</span></span>;</span><br><span class="line">    chrono::seconds t3 = t1 - t2;</span><br><span class="line">    cout &lt;&lt; t3.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; second&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">540</span> second</span><br></pre></td></tr></table></figure><p>在上面的测试程序中，t1代表10分钟，t2代表60秒，t3是t1减去t2，也就是60*10-60&#x3D;540，这个540表示的时钟周期，每个时钟周期是1秒，因此两个时间间隔之间的差值为540秒。</p><p><code>注意</code>：duration的加减运算有一定的规则，当两个duration时钟周期不相同的时候，会先统一成一种时钟，然后再进行算术运算<br>统一的规则如下：假设有<code>ratio&lt;x1,y1&gt;</code> 和 <code>ratio&lt;x2,y2&gt;</code>两个时钟周期，首先需要求出<code>x1，x2的最大公约数X</code>，然后求出<code>y1，y2的最小公倍数Y</code>，统一之后的时钟周期ratio为<code>ratio&lt;X,Y&gt;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    chrono::duration&lt;<span class="type">double</span>, ratio&lt;<span class="number">9</span>, <span class="number">7</span>&gt;&gt; <span class="built_in">d1</span>(<span class="number">3</span>);</span><br><span class="line">    chrono::duration&lt;<span class="type">double</span>, ratio&lt;<span class="number">6</span>, <span class="number">5</span>&gt;&gt; <span class="built_in">d2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// d1 和 d2 统一之后的时钟周期</span></span><br><span class="line">    chrono::duration&lt;<span class="type">double</span>, ratio&lt;<span class="number">3</span>, <span class="number">35</span>&gt;&gt; d3 = d1 - d2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于分子6,、9最大公约数为3，对于分母7、5最小公倍数为35，因此推导出的时钟周期为<code>ratio&lt;3,35&gt;</code></p><hr><h2 id="8-2-时间点-time-point"><a href="#8-2-时间点-time-point" class="headerlink" title="8.2 时间点 time point"></a>8.2 时间点 time point</h2><p>chrono库中提供了一个表示时间点的类<code>time_point</code>，</p><p>类的定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义于头文件 &lt;chrono&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Clock</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Duration</span> = <span class="keyword">typename</span> Clock::duration</span><br><span class="line">&gt; <span class="keyword">class</span> time_point;</span><br></pre></td></tr></table></figure><p>它被实现成如同存储一个 <code>Duration</code> 类型的自 <code>Clock</code> 的纪元起始开始的时间间隔的值，通过这个类最终可以得到时间中的某一个时间点。</p><ul><li><code>Clock</code>：此时间点在此时钟上计量</li><li><code>Duration</code>：用于计量从纪元起时间的 <code>std::chrono::duration</code> 类型</li></ul><p>time_point类的构造函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 构造一个以新纪元(epoch，即：1970.1.1)作为值的对象，需要和时钟类一起使用，不能单独使用该无参构造函数</span></span><br><span class="line"><span class="built_in">time_point</span>();</span><br><span class="line"><span class="comment">// 2. 构造一个对象，表示一个时间点，其中d的持续时间从epoch开始，需要和时钟类一起使用，不能单独使用该构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">time_point</span><span class="params">( <span class="type">const</span> duration&amp; d )</span></span>;</span><br><span class="line"><span class="comment">// 3. 拷贝构造函数，构造与t相同时间点的对象，使用的时候需要指定模板参数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Duration2 &gt;</span></span><br><span class="line"><span class="function"><span class="title">time_point</span><span class="params">( <span class="type">const</span> time_point&lt;Clock,Duration2&gt;&amp; t )</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>在这个类中除了构造函数还提供了另外一个<code>time_since_epoch()</code>函数<br>用来获得1970年1月1日到<code>time_point</code>对象中记录的时间经过的时间间隔（duration）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="function">duration <span class="title">time_since_epoch</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>除此之外，时间点<code>time_point</code>对象和时间段对象<code>duration</code>之间还支持直接进行算术运算（即加减运算），时间点对象之间可以进行逻辑运算，具体细节可以参考下面的表格：</p><p>其中 <code>tp</code> 和 <code>tp2</code> 是<code>time_point</code> 类型的对象， <code>dtn</code> 是<code>duration</code>类型的对象。</p></blockquote><table><thead><tr><th>描述</th><th>操作</th><th>返回值</th></tr></thead><tbody><tr><td>复合赋值(成员函数)   operator+&#x3D;</td><td>tp +&#x3D; dtn</td><td>*this</td></tr><tr><td>复合赋值(成员函数)     operator-&#x3D;</td><td>tp -&#x3D; dtn</td><td>*this</td></tr><tr><td>算术运算符(非成员函数)    operator+</td><td>tp + dtn</td><td>a time_point value</td></tr><tr><td>算术运算符(非成员函数)      operator+</td><td>dtn + tp</td><td>a time_point value</td></tr><tr><td>算术运算符(非成员函数)     operator-</td><td>tp - dtn</td><td>a time_point  value</td></tr><tr><td>算术运算符(非成员函数)    operator-</td><td>tp - tp2</td><td>a duration  value</td></tr><tr><td>关系操作符(非成员函数)   operator&#x3D;&#x3D;</td><td>tp &#x3D;&#x3D; tp2</td><td>a bool value</td></tr><tr><td>关系操作符(非成员函数)    operator!&#x3D;</td><td>tp !&#x3D; tp2</td><td>a bool value</td></tr><tr><td>关系操作符(非成员函数)    operator&lt;</td><td>tp &lt; tp2</td><td>a bool value</td></tr><tr><td>关系操作符(非成员函数)    operator&gt;</td><td>tp &gt; tp2</td><td>a bool value</td></tr><tr><td>关系操作符(非成员函数)   operator&gt;&#x3D;</td><td>tp &gt;&#x3D; tp2</td><td>a bool value</td></tr><tr><td>关系操作符(非成员函数)    operator&lt;&#x3D;</td><td>tp &lt;&#x3D; tp2</td><td>a bool value</td></tr></tbody></table><p>由于该时间点类经常和下面要介绍的时钟类一起使用，所以在此先不举例<br>在时钟类的示例代码中会涉及到时间点类的使用，到此为止只需要搞明白时间点类的提供的这几个函数的作用就可以了。</p><hr><h2 id="8-3-时钟clocks"><a href="#8-3-时钟clocks" class="headerlink" title="8.3 时钟clocks"></a>8.3 时钟clocks</h2><p>chrono库中提供了获取当前的系统时间的时钟类，包含的时钟一共有三种：</p><ul><li><code>system_clock</code>：系统的时钟，系统的时钟可以修改，甚至可以网络对时，因此使用系统时间计算时间差可能不准。</li><li><code>steady_clock</code>：是固定的时钟，相当于秒表。开始计时后，时间只会增长并且不能修改，适合用于记录程序耗时</li><li><code>high_resolution_clock</code>：和时钟类 <code>steady_clock</code> 是等价的（是它的别名）。</li></ul><p>在这些时钟类的内部有<code>time_point</code>、<code>duration</code>、<code>Rep</code>、<code>Period</code>等信息，基于这些信息来获取当前时间，以及实现<code>time_t</code>和<code>time_point</code>之间的相互转换。</p><table><thead><tr><th>时钟类成员类型</th><th>描述</th></tr></thead><tbody><tr><td>rep</td><td>表示时钟周期次数的有符号算术类型</td></tr><tr><td>period</td><td>表示时钟计次周期的 std::ratio 类型</td></tr><tr><td>duration</td><td>时间间隔，可以表示负时长</td></tr><tr><td>time_point</td><td>表示在当前时钟里边记录的时间点</td></tr></tbody></table><p><code>在使用chrono提供的时钟类的时候，不需创建类对象，直接调用类的静态方法就可以得到想要的时间。</code></p><h3 id="8-3-1-system-clock"><a href="#8-3-1-system-clock" class="headerlink" title="8.3.1 system_clock"></a>8.3.1 system_clock</h3><blockquote><p>具体来说，时钟类<code>system_clock</code>是一个系统范围的实时时钟。<br><code>system_clock</code>提供了对当前时间点<code>time_point</code>的访问，将得到时间点转换为<code>time_t</code>类型的时间对象，就可以基于这个时间对象获取到当前的时间信息了。</p></blockquote><p>system_clock时钟类在底层源码中的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">system_clock</span> &#123; <span class="comment">// wraps GetSystemTimePreciseAsFileTime/GetSystemTimeAsFileTime</span></span><br><span class="line">    <span class="keyword">using</span> rep                       = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="keyword">using</span> period                    = ratio&lt;<span class="number">1</span>, <span class="number">10&#x27;000&#x27;000</span>&gt;; <span class="comment">// 100 nanoseconds</span></span><br><span class="line">    <span class="keyword">using</span> duration                  = chrono::duration&lt;rep, period&gt;;</span><br><span class="line">    <span class="keyword">using</span> time_point                = chrono::time_point&lt;system_clock&gt;;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_steady = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">static</span> time_point <span class="title">now</span><span class="params">()</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// get current time</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">time_point</span>(<span class="built_in">duration</span>(_Xtime_get_ticks()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">static</span> <span class="type">__time64_t</span> <span class="title">to_time_t</span><span class="params">(<span class="type">const</span> time_point&amp; _Time)</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// convert to __time64_t</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">duration_cast</span>&lt;seconds&gt;(_Time.<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">static</span> time_point <span class="title">from_time_t</span><span class="params">(<span class="type">__time64_t</span> _Tm)</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// convert from __time64_t</span></span><br><span class="line">        <span class="keyword">return</span> time_point&#123;seconds&#123;_Tm&#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过以上源码可以了解到在system_clock类中的一些细节信息：</p><ul><li><code>rep</code>：时钟周期次数是通过整形来记录的<code>long long</code></li><li><code>period</code>：一个时钟周期是100纳秒<code>ratio&lt;1, 10&#39;000&#39;000&gt;</code></li><li><code>duration</code>：时间间隔为rep*period纳秒<code>chrono::duration&lt;rep, period&gt;</code></li><li><code>time_point</code>：时间点通过系统时钟做了初始化<code>chrono::time_point&lt;system_clock&gt;</code>，里面记录了新纪元时间点</li></ul><p>另外还可以看到system_clock类一共提供了三个静态成员函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回表示当前时间的时间点。</span></span><br><span class="line"><span class="type">static</span> std::<span class="function">chrono::time_point&lt;std::chrono::system_clock&gt; <span class="title">now</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">// 将 time_point 时间点类型转换为 std::time_t 类型</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::<span class="type">time_t</span> <span class="title">to_time_t</span><span class="params">( <span class="type">const</span> time_point&amp; t )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">// 将 std::time_t 类型转换为 time_point 时间点类型</span></span><br><span class="line"><span class="type">static</span> std::chrono::<span class="function">system_clock::time_point <span class="title">from_time_t</span><span class="params">( std::<span class="type">time_t</span> t )</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>比如，我们要获取当前的系统时间，并且需要将其以能够识别的方式打印出来，示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 新纪元1970.1.1时间</span></span><br><span class="line">    system_clock::time_point epoch;</span><br><span class="line"></span><br><span class="line">    duration&lt;<span class="type">int</span>, ratio&lt;<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>&gt;&gt; <span class="built_in">day</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 新纪元1970.1.1时间 + 1天</span></span><br><span class="line">    <span class="function">system_clock::time_point <span class="title">ppt</span><span class="params">(day)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> dday = duration&lt;<span class="type">int</span>, ratio&lt;<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>&gt;&gt;;</span><br><span class="line">    <span class="comment">// 新纪元1970.1.1时间 + 10天</span></span><br><span class="line">    <span class="function">time_point&lt;system_clock, dday&gt; <span class="title">t</span><span class="params">(dday(<span class="number">10</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统当前时间</span></span><br><span class="line">    system_clock::time_point today = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换为time_t时间类型</span></span><br><span class="line">    <span class="type">time_t</span> tm = system_clock::<span class="built_in">to_time_t</span>(today);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;今天的日期是:    &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;tm);</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> tm1 = system_clock::<span class="built_in">to_time_t</span>(today+day);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;明天的日期是:    &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;tm1);</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> tm2 = system_clock::<span class="built_in">to_time_t</span>(epoch);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;新纪元时间:      &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;tm2);</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> tm3 = system_clock::<span class="built_in">to_time_t</span>(ppt);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;新纪元时间+1天:  &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;tm3);</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> tm4 = system_clock::<span class="built_in">to_time_t</span>(t);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;新纪元时间+10天: &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;tm4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码打印的结果为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">今天的日期是:    Sun Aug <span class="number">20</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">21</span> <span class="number">2023</span></span><br><span class="line">明天的日期是:    Mon Aug <span class="number">21</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">21</span> <span class="number">2023</span></span><br><span class="line">新纪元时间:      Thu Jan  <span class="number">1</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">1970</span></span><br><span class="line">新纪元时间+<span class="number">1</span>天:  Fri Jan  <span class="number">2</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">1970</span></span><br><span class="line">新纪元时间+<span class="number">10</span>天: Sun Jan <span class="number">11</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">1970</span></span><br></pre></td></tr></table></figure><h3 id="8-3-2-steady-clock"><a href="#8-3-2-steady-clock" class="headerlink" title="8.3.2 steady_clock"></a>8.3.2 steady_clock</h3><blockquote><p>如果我们通过时钟不是为了获取当前的系统时间，而是进行程序耗时的时长，此时使用syetem_clock就不合适了，因为这个时间可以跟随系统的设置发生变化。<br>在C++11中提供的时钟类steady_clock相当于秒表，只要启动就会进行时间的累加，并且不能被修改，非常适合于进行耗时的统计。</p></blockquote><p>steady_clock时钟类在底层源码中的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">steady_clock</span> &#123; <span class="comment">// wraps QueryPerformanceCounter</span></span><br><span class="line">    <span class="keyword">using</span> rep                       = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="keyword">using</span> period                    = nano;</span><br><span class="line">    <span class="keyword">using</span> duration                  = nanoseconds;</span><br><span class="line">    <span class="keyword">using</span> time_point                = chrono::time_point&lt;steady_clock&gt;;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_steady = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get current time</span></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">static</span> time_point <span class="title">now</span><span class="params">()</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// doesn&#x27;t change after system boot</span></span><br><span class="line">        <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> _Freq = _Query_perf_frequency(); </span><br><span class="line">        <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> _Ctr  = _Query_perf_counter();</span><br><span class="line">        <span class="built_in">static_assert</span>(period::num == <span class="number">1</span>, <span class="string">&quot;This assumes period::num == 1.&quot;</span>);</span><br><span class="line">        <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> _Whole = (_Ctr / _Freq) * period::den;</span><br><span class="line">        <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> _Part  = (_Ctr % _Freq) * period::den / _Freq;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">time_point</span>(<span class="built_in">duration</span>(_Whole + _Part));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过以上源码可以了解到在steady_clock类中的一些细节信息：</p><ul><li><code>rep</code>：时钟周期次数是通过整形来记录的<code>long long</code></li><li><code>period</code>：一个时钟周期是<code>1纳秒nano</code></li><li><code>duration</code>：时间间隔为<code>1纳秒nanoseconds</code></li><li><code>time_point</code>：时间点通过系统时钟做了初始化<code>chrono::time_point&lt;steady_clock&gt;</code></li></ul><blockquote><p>另外，在这个类中也提供了一个静态的now()方法，用于得到当前的时间点，</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="type">static</span> std::<span class="function">chrono::time_point&lt;std::chrono::steady_clock&gt; <span class="title">now</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>假设要测试某一段程序的执行效率，可以计算它执行期间消耗的总时长</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取开始时间点</span></span><br><span class="line">    steady_clock::time_point start = steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 执行业务流程</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;print 1000 stars ....&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 获取结束时间点</span></span><br><span class="line">    steady_clock::time_point last = steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 计算差值</span></span><br><span class="line">    <span class="keyword">auto</span> dt = last - start;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;总共耗时: &quot;</span> &lt;&lt; dt.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;纳秒&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="8-3-3-high-resolution-clock"><a href="#8-3-3-high-resolution-clock" class="headerlink" title="8.3.3 high_resolution_clock"></a>8.3.3 high_resolution_clock</h3><blockquote><p><code>high_resolution_clock</code>提供的时钟<code>精度</code>比<code>system_clock</code>要高<br>它也是不可以修改的。在底层源码中，这个类其实是<code>steady_clock</code>类的别名。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> high_resolution_clock = steady_clock;</span><br></pre></td></tr></table></figure><p>因此high_resolution_clock的使用方式和steady_clock是一样的</p><hr><h2 id="8-4-转换函数"><a href="#8-4-转换函数" class="headerlink" title="8.4 转换函数"></a>8.4 转换函数</h2><h3 id="8-4-1-duration-cast"><a href="#8-4-1-duration-cast" class="headerlink" title="8.4.1 duration_cast"></a>8.4.1 duration_cast</h3><blockquote><p><code>duration_cast</code>是<code>chrono</code>库提供的一个模板函数,这个函数不属于duration类。<br>通过这个函数可以对duration类对象内部的时钟周期Period，和周期次数的类型Rep进行<code>修改</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ToDuration</span>, <span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>&gt;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> ToDuration <span class="title">duration_cast</span> <span class="params">(<span class="type">const</span> duration&lt;Rep,Period&gt;&amp; dtn)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>如果是对时钟周期进行转换：源时钟周期必须能整除目的时钟周期（比如：小时到分钟）。</li><li>如果是对时钟周期次数的类型进行转换：低等类型默认可以向高等类型进行转换（比如：int 转 double）。</li><li>如果时钟周期和时钟周期次数类型都变了,根据第二点推导（也就是看时间周期次数类型）。</li><li>以上条件都不满足，那么就需要使用 <code>duration_cast</code> 进行显示转换。</li></ol><p>我们可以修改一下上面测试程序执行时间的代码，在代码中修改duration对象的属性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;print 1000 stars ....&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t1 = steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">auto</span> t2 = steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数时长：时钟周期纳秒 转 毫秒，要求 duration_cast</span></span><br><span class="line">    <span class="keyword">auto</span> int_ms = <span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(t2 - t1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小数时长：不要求 duration_cast</span></span><br><span class="line">    duration&lt;<span class="type">double</span>, ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;&gt; fp_ms = t2 - t1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;f() took &quot;</span> &lt;&lt; fp_ms.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; ms, &quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;or &quot;</span> &lt;&lt; int_ms.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; whole milliseconds\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码输出的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print <span class="number">1000</span> stars ....</span><br><span class="line">*************************************************************************************************************</span><br><span class="line"><span class="built_in">f</span>() took <span class="number">40.2547</span> ms, <span class="keyword">or</span> <span class="number">40</span> whole milliseconds</span><br></pre></td></tr></table></figure><hr><h3 id="8-4-2-time-point-cast"><a href="#8-4-2-time-point-cast" class="headerlink" title="8.4.2 time_point_cast"></a>8.4.2 time_point_cast</h3><blockquote><p><code>time_point_cast</code>也是chrono库提供的一个模板函数，这个函数不属于time_point类。<br>函数的作用是对时间点进行<code>转换</code>，因为不同的时间点对象内部的时钟周期Period，和周期次数的类型Rep可能也是不同的，一般情况下它们之间可以进行隐式类型转换，也可以通过该函数显示的进行转换</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ToDuration</span>, <span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line"><span class="function">time_point&lt;Clock, ToDuration&gt; <span class="title">time_point_cast</span><span class="params">(<span class="type">const</span> time_point&lt;Clock, Duration&gt; &amp;t)</span></span>;</span><br></pre></td></tr></table></figure><p>关于函数的使用，示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Clock = chrono::high_resolution_clock;</span><br><span class="line"><span class="keyword">using</span> Ms = chrono::milliseconds;</span><br><span class="line"><span class="keyword">using</span> Sec = chrono::seconds;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line"><span class="keyword">using</span> TimePoint = chrono::time_point&lt;Clock, Duration&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_ms</span><span class="params">(<span class="type">const</span> TimePoint&lt;Ms&gt;&amp; time_point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; time_point.<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; ms\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">TimePoint&lt;Sec&gt; <span class="title">time_point_sec</span><span class="params">(Sec(<span class="number">6</span>))</span></span>;</span><br><span class="line">    <span class="comment">// 无精度损失, 可以进行隐式类型转换</span></span><br><span class="line">    <span class="function">TimePoint&lt;Ms&gt; <span class="title">time_point_ms</span><span class="params">(time_point_sec)</span></span>;</span><br><span class="line">    <span class="built_in">print_ms</span>(time_point_ms);    <span class="comment">// 6000 ms</span></span><br><span class="line"></span><br><span class="line">    time_point_ms = <span class="built_in">TimePoint</span>&lt;Ms&gt;(<span class="built_in">Ms</span>(<span class="number">6789</span>));</span><br><span class="line">    <span class="comment">// error，会损失精度，不允许进行隐式的类型转换(ms类型转换为sec类型)</span></span><br><span class="line">    <span class="function">TimePoint&lt;Sec&gt; <span class="title">sec</span><span class="params">(time_point_ms)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示类型转换,会损失精度。6789 truncated to 6000</span></span><br><span class="line">    time_point_sec = std::chrono::<span class="built_in">time_point_cast</span>&lt;Sec&gt;(time_point_ms);</span><br><span class="line">    <span class="built_in">print_ms</span>(time_point_sec); <span class="comment">// 6000 ms</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>注意</code>：关于时间点的转换如果没有没有精度的损失可以直接进行隐式类型转换<br>如果会损失精度只能通过显示类型转换，也就是调用<code>time_point_cast</code>函数来完成该操作。</p><hr><h1 id="9-静态断言"><a href="#9-静态断言" class="headerlink" title="9. 静态断言"></a>9. 静态断言</h1><blockquote><p>静态断言<code>static_assert</code>，所谓静态就是在<code>编译时就能够进行检查的断言</code>，使用时<code>不需要引用头文件</code>。静态断言的另一个好处是，可以自定义违反断言时的错误提示信息。</p></blockquote><p>静态断言使用起来非常简单，它接收两个参数：</p><ul><li>参数1：断言表达式，这个表达式通常需要返回一个 bool值</li><li>参数2：警告信息，它通常就是一段字符串，在违反断言（表达式为false）时提示该信息</li></ul><p>一个判断Linux是否为32位平台的小程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>                                         </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">long</span>) == <span class="number">4</span>, <span class="string">&quot;错误, 不是32位平台...&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;64bit Linux 指针大小: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>*) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;64bit Linux long 大小: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt;endl;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ assert.cpp -std=c++11</span><br><span class="line">assert.cpp: In <span class="keyword">function</span> ‘int main()’:</span><br><span class="line">assert.cpp:6:5: error: static assertion failed: 错误, 不是32位平台...</span><br><span class="line">static_assert(sizeof(long) == 4, <span class="string">&quot;错误, 不是32位平台...&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>注意</code> : 由于静态断言的表达式是在编译阶段进行检测，所以在它的表达式中不能出现变量，也就是说这个表达式必须是常量表达式。</p><hr><h1 id="10-POD类型"><a href="#10-POD类型" class="headerlink" title="10. POD类型"></a>10. POD类型</h1><h2 id="10-1-POD类型"><a href="#10-1-POD类型" class="headerlink" title="10.1 POD类型"></a>10.1 POD类型</h2><p><code>POD</code>是英文中 <code>Plain Old Data</code> 的缩写，翻译过来就是普通的旧数据 。<br>POD在C++中是非常重要的一个概念，<code>通常用于说明一个类型的属性，尤其是用户自定义类型的属性。</code></p><p>POD属性在C++11中往往是构建其他C++概念的基础</p><ul><li>Plain ：表示是个普通的类型</li><li>Old ：体现了其与C的兼容性，支持标准C函数</li></ul><p>在C++11中将 POD划分为两个基本概念的合集，即∶<code>平凡的（trivial）</code> 和标准布局的<code>（standard layout ） </code></p><p> </p><hr><h2 id="10-2-“平凡”类型"><a href="#10-2-“平凡”类型" class="headerlink" title="10.2  “平凡”类型"></a>10.2  “平凡”类型</h2><p>一个平凡的类或者结构体应该符合以下几点要求：</p><ol><li><strong>拥有平凡的默认构造函数（trivial constructor）和析构函数（trivial destructor）。</strong></li></ol><p>平凡的默认构造函数就是说构造函数什么都不干。</p><ul><li>通常情况下，不定义类的构造函数，编译器就会为我们生成一个<code>平凡的默认构造函数</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认的构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><ul><li>一旦定义了构造函数，即使构造函数不包含参数，函数体里也没有任何的代码，那么该构造函数也不再是”平凡”的。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Test1</span>();<span class="comment">// 我们定义的构造函数, 非默认构造</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于析构函数也和上面列举的构造函数类似，一旦被定义就不平凡了。<br>但是这也并非无药可救，使用<code>=default</code>关键字可以显式地声明默认的构造函数，从而使得类型恢复 “平凡化”。</p><ol start="2"><li><strong>拥有平凡的拷贝构造函数（trivial copy constructor）和移动构造函数（trivial move constructor）。</strong></li></ol><ul><li>平凡的拷贝构造函数基本上等同于使用 <code>memcpy</code> 进行类型的构造。</li><li>同平凡的默认构造函数一样，不声明拷贝构造函数的话，编译器会帮程序员自动地生成。</li><li>可以显式地使用 <code>=default</code> 声明默认拷贝构造函数。 </li><li>而平凡移动构造函数跟平凡的拷贝构造函数类似，只不过是用于移动语义。</li></ul><ol start="3"><li><strong>拥有平凡的拷贝赋值运算符（trivial assignment operator）和移动赋值运算符（trivial move operator）。</strong></li></ol><p>这基本上与平凡的拷贝构造函数和平凡的移动构造运算符类似。</p><ol start="4"><li><strong>不包含虚函数以及虚基类。</strong></li></ol><ul><li>类中使用 <code>virtual</code> 关键字修饰的函数 叫做虚函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>虚基类是在创建子类的时候在继承的基类前加 <code>virtual</code> 关键字 修饰</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法: <span class="keyword">class</span> 派生类名：<span class="keyword">virtual</span>  继承方式  基类名</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 子类Child，虚基类：Base</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Child</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="10-3-“标准布局”类型"><a href="#10-3-“标准布局”类型" class="headerlink" title="10.3 “标准布局”类型"></a>10.3 “标准布局”类型</h2><p>标准布局类型主要主要指的是<code>类</code>或者<code>结构体</code>的结构或者组合方式。</p><p>标准布局类型的类应该符合以下五点定义，<code>最重要的是前两条</code>：</p><ol><li><strong>所有非静态成员有相同 的访问权限（public，private，protected）。</strong></li></ol><ul><li>类成员拥有不同的访问权限（非标准布局类型）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>类成员拥有相同的访问权限（标准布局类型）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><ol start="2"><li><strong>在类或者结构体继承时，满足以下两种情况之一∶</strong></li></ol><p> </p><ul><li>派生类中有非静态成员，基类中包含静态成员（或基类没有变量）。</li><li>基类有非静态成员，而派生类没有非静态成员。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123; <span class="type">static</span> <span class="type">int</span> a;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Child</span>: <span class="keyword">public</span> Base&#123; <span class="type">int</span> b;&#125;;          <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base1</span> &#123; <span class="type">int</span> a;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Child1</span>: <span class="keyword">public</span> Base1&#123; <span class="type">static</span> <span class="type">int</span> c;&#125;; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Child2</span>:<span class="keyword">public</span> Base, <span class="keyword">public</span> Base1 &#123; <span class="type">static</span> <span class="type">int</span> d;); <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Child3</span>:<span class="keyword">public</span> Base1&#123; <span class="type">int</span> d;&#125;;         <span class="comment">// error 有非静态和静态</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Child4</span>:<span class="keyword">public</span> Base1, <span class="keyword">public</span> Child     <span class="comment">// error 基类有多个非静态</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>结论</code>：</p><ol><li>非静态成员只要同时出现在派生类和基类间，即不属于标准布局。</li><li>对于多重继承，一旦非静态成员出现在多个基类中，即使派生类中没有非静态成员变量，派生类也不属于标准布局。</li></ol><hr><ol start="3"><li><strong>子类中第一个非静态成员的类型与其基类不同。</strong></li></ol><p> </p><p>此处基于G++编译器，如果使用VS的编译器和G++编译器得到的结果是不一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Parent</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line">    Parent p;<span class="comment">// 子类的第一个非静态成员</span></span><br><span class="line">    <span class="type">int</span> foo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的例子中<code>Child</code>不是一个标准布局类型<br>因为它的第一个非静态成员变量p和父类的类型相同<br>改成下面这样子类就变成了一个标准布局类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Parent</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Child1</span> : <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> foo;   <span class="comment">// 子类的第一个非静态成员</span></span><br><span class="line">    Parent p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这条规则对于我们来说是比较特别的，这样规定的目的主要是是节约内存，提高数据的读取效率。对于上面的两个子类Child和Child1来说它们的<code>内存结构是不一样的</code><br>在基类没有成员的情况下：</p><ul><li><p>C++标准允许标准布局类型（Child1）派生类的第一个成员foo与基类共享地址<br>此时基类并没有占据任何的实际空间（可以节省一点数据）</p></li><li><p>对于子类Child而言，如果子类的第一个成员仍然是基类类型<br>C++标准要求类型相同的对象它们的地址必须不同（基类地址不能和子类中的变量 p 类型相同），此时需要分配额外的地址空间将二者的地址错开。</p></li></ul><p><img src="/img/5.4.png" alt="在这里插入图片描述"></p><ol start="4"><li><p><strong>没有虚函数和虚基类。</strong> </p></li><li><p><strong>所有非静态数据成员均符合标准布局类型，其基类也符合标准布局，这是一个递归的定义。</strong></p></li></ol><h2 id="10-4-对-POD-类型的判断"><a href="#10-4-对-POD-类型的判断" class="headerlink" title="10.4 对 POD 类型的判断"></a>10.4 对 POD 类型的判断</h2><blockquote><p>如果我们想要判断某个数据类型是不是属于 POD 类型<br>可以使用C++11给我们提供的相关函数：</p></blockquote><h3 id="10-4-1-对“平凡”类型判断"><a href="#10-4-1-对“平凡”类型判断" class="headerlink" title="10.4.1 对“平凡”类型判断"></a>10.4.1 对“平凡”类型判断</h3><p>C++11提供的类模板叫做 <code>is_trivial</code>，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">std</span>::is_trivial;</span><br></pre></td></tr></table></figure><p><code>std::is_trivial</code> 的成员<code>value</code> 可以用于判断T的类型是否是一个平凡的类型（value 函数返回值为布尔类型）。<br>除了类和结构体外，<code>is_trivial</code>还可以对内置的标准类型数据（比如int、float都属于平凡类型）及数组类型（元素是平凡类型的数组总是平凡的）进行判断。</p><p>关于类型的判断，示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; <span class="built_in">B</span>() &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : B &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; std::boolalpha; <span class="comment">//通过这一句可以使value的输出从0/1,转换为false/true</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;is_trivial:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; is_trivial&lt;<span class="type">int</span>&gt;::value &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A: &quot;</span> &lt;&lt; is_trivial&lt;A&gt;::value &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;B: &quot;</span> &lt;&lt; is_trivial&lt;B&gt;::value &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C: &quot;</span> &lt;&lt; is_trivial&lt;C&gt;::value &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;D: &quot;</span> &lt;&lt; is_trivial&lt;D&gt;::value &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;E: &quot;</span> &lt;&lt; is_trivial&lt;E&gt;::value &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">is_trivial:</span><br><span class="line"><span class="type">int</span>: <span class="literal">true</span></span><br><span class="line">A: <span class="literal">true</span></span><br><span class="line">B: <span class="literal">false</span></span><br><span class="line">C: <span class="literal">false</span></span><br><span class="line">D: <span class="literal">false</span></span><br><span class="line">E: <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li>int ：内置标准数据类型，属于 trivial 类型</li><li>A ：拥有默认的构造和析构函数，属于 trivial 类型</li><li>B ：自定义了构造函数，因此不属于 trivial 类型</li><li>C ：基类中自定义了构造函数，因此不属于 trivial 类型(继承了B,B自定义了构造函数)</li><li>D ：类成员函数中有虚函数，因此不属于 trivial 类型</li><li>E ：继承关系中有虚基类，因此不属于 trivial 类型</li></ul><hr><h3 id="10-4-2-对“标准布局”类型的判断"><a href="#10-4-2-对“标准布局”类型的判断" class="headerlink" title="10.4.2 对“标准布局”类型的判断"></a>10.4.2 对“标准布局”类型的判断</h3><p>同样，在C++11中，我们可以使用模板类来帮助判断类型是否是一个标准布局的类型</p><p>其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">std</span>::is_standard_layout;</span><br></pre></td></tr></table></figure><p>通过 <code>is_standard_layout</code>模板类的成员 <code>value（is_standard_layout&lt;T&gt;∶∶value）</code>，我们可以在代码中打印出类型的标准布局属性，函数返回值为布尔类型。</p><p>示例程序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pod.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123; <span class="type">int</span> j; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span> &#123;  <span class="type">static</span> <span class="type">int</span> i; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span> &#123;  <span class="type">int</span> i; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E1</span> &#123; <span class="type">static</span> <span class="type">int</span> i; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E2</span> &#123; <span class="type">int</span> i; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : <span class="keyword">public</span> D1, <span class="keyword">public</span> E1 &#123; <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span> : <span class="keyword">public</span> D1, <span class="keyword">public</span> E2 &#123; <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">F</span> : <span class="keyword">public</span> D2, <span class="keyword">public</span> E2 &#123; <span class="type">static</span> <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">G</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> foo;</span><br><span class="line">    A a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">H</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="type">int</span> foo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; std::boolalpha;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;is_standard_layout:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A: &quot;</span> &lt;&lt; is_standard_layout&lt;A&gt;::value &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;B: &quot;</span> &lt;&lt; is_standard_layout&lt;B&gt;::value &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C: &quot;</span> &lt;&lt; is_standard_layout&lt;C&gt;::value &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;D: &quot;</span> &lt;&lt; is_standard_layout&lt;D&gt;::value &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;D1: &quot;</span> &lt;&lt; is_standard_layout&lt;D1&gt;::value &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;E: &quot;</span> &lt;&lt; is_standard_layout&lt;E&gt;::value &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;F: &quot;</span> &lt;&lt; is_standard_layout&lt;F&gt;::value &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;G: &quot;</span> &lt;&lt; is_standard_layout&lt;G&gt;::value &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;H: &quot;</span> &lt;&lt; is_standard_layout&lt;H&gt;::value &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VS2019输出的结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">is_standard_layout:</span><br><span class="line">A: <span class="literal">true</span></span><br><span class="line">B: <span class="literal">true</span></span><br><span class="line">C: <span class="literal">false</span></span><br><span class="line">D: <span class="literal">true</span></span><br><span class="line">D1: <span class="literal">true</span></span><br><span class="line">E: <span class="literal">false</span></span><br><span class="line">F: <span class="literal">false</span></span><br><span class="line">G: <span class="literal">false</span></span><br><span class="line">H: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>G++ 编译输出的结果:<br>编译命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ pod.cpp -std=c++11</span><br></pre></td></tr></table></figure><p>输出的结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">is_standard_layout:</span><br><span class="line">A: <span class="literal">true</span></span><br><span class="line">B: <span class="literal">true</span></span><br><span class="line">C: <span class="literal">false</span></span><br><span class="line">D: <span class="literal">true</span></span><br><span class="line">D1: <span class="literal">true</span></span><br><span class="line">E: <span class="literal">false</span></span><br><span class="line">F: <span class="literal">false</span></span><br><span class="line">G: <span class="literal">true</span></span><br><span class="line">H: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>关于输出的结果</p><ul><li>A ：没有虚基类和虚函数，属于 standard_layout 类型</li><li>B ：没有虚基类和虚函数，属于 standard_layout 类型</li><li>C ：所有非静态成员访问权限不一致，不属于 standard_layout 类型</li><li>D ：基类和子类没有同时出现非静态成员变量，属于 standard_layout 类型</li><li>D1 ：没有虚基类和虚函数，属于 standard_layout 类型</li><li>E ：基类和子类中同时出现了非静态成员变量，不属于 standard_layout 类型</li><li>F ：多重继承中在基类里同时出现了非静态成员变量，不属于 standard_layout 类型</li><li>G ：使用的编译器不同，得到的结果也不同。</li><li>H ：子类中第一个非静态成员的类型与其基类类型不能相同，不属于 standard_layout 类型</li></ul><h2 id="10-5-总结"><a href="#10-5-总结" class="headerlink" title="10.5 总结"></a>10.5 总结</h2><p>我们使用的很多内置类型默认都是 POD的。<br>POD 最为复杂的地方还是在类或者结构体的判断。<br>使用POD有什么好处呢？</p><ol><li>字节赋值，代码中我们可以安全地使用 <code>memset</code> 和 <code>memcpy</code> 对 POD类型进行初始化和拷贝等操作。 </li><li>提供对C内存布局兼容。C++程序可以与C 函数进行相互操作<br>因为POD类型的数据在C与C++ 间的操作总是安全的。 </li><li>保证了静态初始化的安全有效。静态初始化在很多时候能够提高程序的性能，而POD类型的对象初始化往往更加简单。</li></ol><p> <br>关于 POD 重在理解,以上</p><hr><h1 id="11-非受限联合体"><a href="#11-非受限联合体" class="headerlink" title="11. 非受限联合体"></a>11. 非受限联合体</h1><h2 id="11-1-什么是非受限联合体"><a href="#11-1-什么是非受限联合体" class="headerlink" title="11.1 什么是非受限联合体"></a>11.1 什么是非受限联合体</h2><p>联合体又叫共用体，又将其称之为<code>union</code>，它的使用方式和结构体类似，可以在联合体内部定义多种不同类型的数据成员，但是这些数据会共享同一块内存空间（也就是如果对多个数据成员同时赋值会发生数据的覆盖）。<br>在某些特定的场景下，通过这种特殊的数据结构我们就可以实现内存的复用，从而达到节省内存空间的目的。</p><p>在C++11之前我们使用的联合体是有局限性的，主要有以下三点：</p><ol><li>不允许联合体拥有非POD类型的成员</li><li>不允许联合体拥有静态成员</li><li>不允许联合体拥有引用类型的成员</li></ol><p>在新的C++11标准中，取消了关于联合体对于数据成员类型的限定，<code>规定任何非引用类型都可以成为联合体的数据成员，这样的联合体称之为非受限联合体（Unrestricted Union）</code></p><h2 id="11-2-非受限联合体的使用"><a href="#11-2-非受限联合体的使用" class="headerlink" title="11.2 非受限联合体的使用"></a>11.2 非受限联合体的使用</h2><h3 id="11-2-1-静态类型的成员"><a href="#11-2-1-静态类型的成员" class="headerlink" title="11.2.1 静态类型的成员"></a>11.2.1 静态类型的成员</h3><p>对于非受限联合体来说，静态成员有两种分别是<code>静态成员变量</code>和<code>静态成员函数</code></p><p>看一下下面代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">long</span> id;</span><br><span class="line">    <span class="comment">// int&amp; tmp = age; // error</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> c;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c value: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> Test::c;</span><br><span class="line"><span class="comment">// char Test::c = &#x27;a&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    Test t1;</span><br><span class="line">    t.c = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    t1.c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    t1.age = <span class="number">666</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t.c: &quot;</span> &lt;&lt; t.c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t1.c: &quot;</span> &lt;&lt; t1.c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t1.age: &quot;</span> &lt;&lt; t1.age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t1.id: &quot;</span> &lt;&lt; t1.id &lt;&lt; endl;</span><br><span class="line">    t.<span class="built_in">print</span>();</span><br><span class="line">    Test::<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行程序输出的结果如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t.c: c</span><br><span class="line">t1.c: c</span><br><span class="line">t1.age: <span class="number">666</span></span><br><span class="line">t1.id: <span class="number">666</span></span><br><span class="line">c value: c</span><br><span class="line">c value: c</span><br></pre></td></tr></table></figure><p>接下来我们逐一分析一下上面的代码:</p><ul><li><p>第5行：语法错误，非受限联合体中不允许出现引用类型</p></li><li><p>第6行：非受限联合体中的静态成员变量</p><ol><li>需要在非受限联合体外部声明或者初始化之后才能使用</li><li>通过打印的结果可以发现t和t1对象共享这个静态成员变量（和类 class&#x2F;struct 中的静态成员变量的使用是一样的）。</li></ol></li><li><p>第7行：非受限联合体中的静态成员函数</p><ol><li>在静态函数print()只能访问非受限联合体Test中的静态变量，对于非静态成员变量（age、id）是无法访问的。</li><li>调用这个静态方法可以通过对象也可以通过类名实现。</li></ol></li><li><p>第24、25、26行：通过打印的结果可以得出结论在非受限联合体中静态成员变量和非静态成员变量使用的不是同一块内存。</p></li></ul><h3 id="11-2-2-非POD类型成员"><a href="#11-2-2-非POD类型成员" class="headerlink" title="11.2.2 非POD类型成员"></a>11.2.2 非POD类型成员</h3><p>在 C++11标准中会默认删除一些非受限联合体的默认函数。<br>比如，非受限联合体有一个非 POD 的成员，而该非 POD成员类型拥有 非平凡的构造函数，那么非受限联合体的默认构造函数将被编译器删除。<br>其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将遵从此规则。</p><p>举例说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译程序会看到如下的错误提示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">warning C4624: “Student”: 已将析构函数隐式定义为“已删除”</span><br><span class="line">error C2280: “Student::<span class="built_in">Student</span>(<span class="type">void</span>)”: 尝试引用已删除的函数</span><br></pre></td></tr></table></figure><p>上面代码中的非受限联合体<code>Student</code>中拥有一个非PDO类型的成员<code>string name</code><br>string 类中有非平凡构造函数，因此Student的构造函数被删除（通过警告信息可以得知它的析构函数也被删除了）导致对象无法被成功创建出来。<br>解决这个问题的办法就是由自己为非受限联合体定义构造函数<br>在定义构造函数的时候我们需要用到定位放置 <code>new</code> 操作。</p><p><strong>placement new</strong></p><p>一般情况下，使用new申请空间时，是从系统的堆（heap）中分配空间，申请所得的空间的位置是根据当时的内存的实际使用情况决定的。<br>但是，在某些特殊情况下，可能需要在已分配的特定内存创建对象，这种操作就叫做<code>placement new</code>即定位放置 new。</p><p>定位放置new操作的语法形式不同于普通的new操作：</p><ul><li><p>使用new申请内存空间：<code>Base* ptr = new Base;</code></p></li><li><p>使用定位放置new申请内存空间：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName* ptr = <span class="built_in">new</span> (定位的内存地址)ClassName;</span><br></pre></td></tr></table></figure><p>我们来看下面的示例程序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;number value: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line">    Base* b = <span class="built_in">new</span> (&amp;n)Base;</span><br><span class="line">    b-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行输出的结果为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number value: <span class="number">100</span></span><br></pre></td></tr></table></figure><p>在程序的new部分中，使用定位放置的方式为指针b申请了一块内存，也就是说此时指针 b 指向的内存地址和变量 n对应的内存地址是同一块（栈内存）<br>而在Base类中成员变量 number 的起始地址和Base对象的起始地址是相同的，所以打印出 number 的值为100也就是整形变量 n 的值。</p><p>最后，总结一下关于placement new的一些细节：</p><ol><li>使用定位放置new操作，既可以在栈(stack)上生成对象，也可以在堆（heap）上生成对象，这取决于定位时指定的内存地址是在堆还是在栈上。</li><li>从表面上看，定位放置new操作是申请空间，其本质是利用已经申请好的空间，真正的申请空间的工作是在此之前完成的。</li><li>使用定位放置new 创建对象时会自动调用对应类的构造函数，但是由于对象的空间不会自动释放，如果需要释放堆内存必须显示调用类的析构函数。</li><li>使用定位放置new操作，我们可以反复动态申请到同一块堆内存，这样可以避免内存的重复创建销毁，从而提高程序的执行效率（比如网络通信中数据的接收和发送）。</li></ol><hr><p><strong>自定义非受限联合体构造函数</strong></p><p>掌握了placement new的使用，通过一段程序演示一下如何在非受限联合体中自定义构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setText</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        notes = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base notes: &quot;</span> &lt;&lt; notes &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string notes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Student</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> (&amp;name)string;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Student</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    Base tmp;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student s;</span><br><span class="line">    s.name = <span class="string">&quot;蒙奇·D·路飞&quot;</span>;</span><br><span class="line">    s.tmp.<span class="built_in">setText</span>(<span class="string">&quot;我是要成为海贼王的男人!&quot;</span>);</span><br><span class="line">    s.tmp.<span class="built_in">print</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Student name: &quot;</span> &lt;&lt; s.name &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序打印的结果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base notes: 我是要成为海贼王的男人!</span><br><span class="line">Student name: 我是要成为海贼王的男人!</span><br></pre></td></tr></table></figure><p>我们在上面的程序里边给非受限制联合体显示的指定了构造函数和析构函数<br>在程序的第31行 (Student s;) 需要创建一个非受限联合体对象，这时便调用了联合体内部的构造函数，在构造函数的第20行通过定位放置 new 的方式将构造出的对象地址定位到了联合体的成员string name的地址上了<br>这样联合体内部其他非静态成员也就可以访问这块地址了（通过输出的结果可以看到对联合体内的tmp对象赋值，会覆盖name对象中的数据）。</p><hr><p><strong>匿名的非受限联合体</strong><br>一般情况下我们使用的非受限联合体都是具名的（有名字），但是我们也可以定义匿名的非受限联合体，一个比较实用的场景就是配合着类的定义使用。设定一个场景：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进行村内人口普查，人员的登记方式如下：</span><br><span class="line">    - 学生只需要登记所在学校的编号</span><br><span class="line">    - 本村学生以外的人员需要登记其身份证号码</span><br><span class="line">    - 本村外来人员需要登记户口所在地+联系方式</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外来人口信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foreigner</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Foreigner</span>(string s, string ph) : <span class="built_in">addr</span>(s), <span class="built_in">phone</span>(ph) &#123;&#125;</span><br><span class="line">    string addr;</span><br><span class="line">    string phone;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登记人口信息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">Category</span> : <span class="type">char</span> &#123;Student, Local, Foreign&#125;;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> num) </span><br><span class="line">    : <span class="built_in">number</span>(num), <span class="built_in">type</span>(Category::Student) &#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(string id) </span><br><span class="line">    : <span class="built_in">idNum</span>(id), <span class="built_in">type</span>(Category::Local) &#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(string addr, string phone) </span><br><span class="line">: foreign(addr, phone), <span class="built_in">type</span>(Category::Foreign) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person category: &quot;</span> &lt;&lt; (<span class="type">int</span>)type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> Category::Student:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Student school number: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Category::Local:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Local people ID number: &quot;</span> &lt;&lt; idNum &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Category::Foreign:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Foreigner address: &quot;</span> &lt;&lt; foreign.addr</span><br><span class="line">                &lt;&lt; <span class="string">&quot;, phone: &quot;</span> &lt;&lt; foreign.phone &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Category type;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> number;</span><br><span class="line">        string idNum;</span><br><span class="line">        Foreigner foreign;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">9527</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;1101122022X&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;砂隐村村北&quot;</span>, <span class="string">&quot;1301810001&quot;</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">print</span>();</span><br><span class="line">    p2.<span class="built_in">print</span>();</span><br><span class="line">    p3.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person category: <span class="number">0</span></span><br><span class="line">Student school number: <span class="number">9527</span></span><br><span class="line">Person category: <span class="number">1</span></span><br><span class="line">Local people ID number: <span class="number">1101122022</span>X</span><br><span class="line">Person category: <span class="number">2</span></span><br><span class="line">Foreigner address: 砂隐村村北, phone: <span class="number">1301810001</span></span><br></pre></td></tr></table></figure><p>根据需求我们将木叶村的人口分为了三类并通过枚举记录了下来，在Person类中添加了一个匿名的非受限联合体用来存储人口信息，仔细分析之后就会发现这种处理方式的优势非常明显：<br>尽可能地节省了内存空间。</p><ul><li><p>Person类可以直接访问匿名非受限联合体内部的数据成员。</p></li><li><p>不使用匿名非受限联合体申请的内存空间等于 number、 idNum 、 foreign 三者内存之和。</p></li><li><p>使用匿名非受限联合体之后number、 idNum 、 foreign 三者共用同一块内存。</p></li></ul><hr><h1 id="12-强枚举类型"><a href="#12-强枚举类型" class="headerlink" title="12. 强枚举类型"></a>12. 强枚举类型</h1><h2 id="12-1-枚举"><a href="#12-1-枚举" class="headerlink" title="12.1 枚举"></a>12.1 枚举</h2><h3 id="12-1-1-枚举的使用"><a href="#12-1-1-枚举的使用" class="headerlink" title="12.1.1 枚举的使用"></a>12.1.1 枚举的使用</h3><p>枚举类型是C及C++中一个基本的内置类型，不过也是一个有点”奇怪”的类型。从枚举的本意上来讲，就是要定义一个类别，并穷举同一类别下的个体以供代码中使用。<br>由于枚举来源于C，所以出于设计上的简单的目的，枚举值常常是对应到整型数值的一些名字</p><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名枚举</span></span><br><span class="line"><span class="keyword">enum</span> &#123;Red, Green, Blue&#125;;</span><br><span class="line"><span class="comment">// 有名枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Colors</span>&#123;Red, Green, Blue&#125;;</span><br></pre></td></tr></table></figure><p>在枚举类型中的枚举值编译器会默认从0开始赋值，而后依次向下递增，也就是说<br>Red&#x3D;0，Green&#x3D;1，Blue&#x3D;2。</p><hr><h3 id="12-1-2-枚举的缺陷"><a href="#12-1-2-枚举的缺陷" class="headerlink" title="12.1.2 枚举的缺陷"></a>12.1.2 枚举的缺陷</h3><p>C&#x2F;C++的enum有个很”奇怪” 的设定，就是<code>具名（有名字）的enum类型的名字，以及 enum 的成员的名字都是全局可见的</code><br>这与 C++中具名的 namespace、class&#x2F;struct 及 union 必须通过名字::成员名的方式访问相比是格格不入的，编码过程中一不小心程序员就容易遇到问题。</p><p>比如∶</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">China</span> &#123;Shanghai, Dongjing, Beijing, Nanjing&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Japan</span> &#123;Dongjing, Daban, Hengbin, Fudao&#125;;</span><br></pre></td></tr></table></figure><p>上面定义的两个枚举在编译的时候，编译器会报错，具体信息如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error C2365: “Dongjing”: 重定义；以前的定义是“枚举数”</span><br></pre></td></tr></table></figure><p>错误的原因上面也提到了，在这两个具名的枚举中Dongjing是全局可见的，所有编译器就会提示其重定义了。</p><p>另外，由于C中枚举被设计为常量数值的”别名”的本性，所以枚举的成员总是可以被隐式地转换为整型，但是很多时候我们并不想这样。</p><hr><h2 id="12-2-强类型枚举"><a href="#12-2-强类型枚举" class="headerlink" title="12.2 强类型枚举"></a>12.2 强类型枚举</h2><h3 id="12-2-1-优势"><a href="#12-2-1-优势" class="headerlink" title="12.2.1 优势"></a>12.2.1 优势</h3><p>针对枚举的缺陷，C++11标准引入了一种新的枚举类型，即<code>枚举类</code>，又称<code>强类型枚举（strong-typed enum）</code></p><p>声明强类型枚举非常简单，只需要在 enum 后加上关键字 class。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义强类型枚举</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Colors</span>&#123;Red, Green, Blue&#125;;</span><br></pre></td></tr></table></figure><p>强类型枚举具有以下几点优势∶ </p><ul><li><p>强作用域，强类型枚举成员的名称不会被输出到其父作用域空间。</p><ul><li>强类型枚举只能是有名枚举，如果是匿名枚举会导致枚举值无法使用（因为没有作用域名称）。</li></ul></li><li><p>转换限制，强类型枚举成员的值不可以与整型隐式地相互转换。 </p></li><li><p>可以指定底层类型。强类型枚举默认的底层类型为 int，但也可以显式地指定底层类型， 具体方法为在枚举名称后面加上<code>∶type</code>，其中 type 可以是除 <code>wchar_t</code> 以外的任何整型。比如:</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Colors</span> :<span class="type">char</span> &#123; Red, Green, Blue &#125;;</span><br></pre></td></tr></table></figure><p><strong>wchar_t 是什么?</strong></p><blockquote><p>双字节类型，或宽字符类型，是C&#x2F;C++的一种扩展的存储方式，一般为16位或32位，所能表示的字符数远超char型。<br>主要用在国际化程序的实现中，但它不等同于 unicode 编码。unicode 编码的字符一般以wchar_t类型存储。</p></blockquote><p>了解了强类型枚举的优势之后，看一段程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">China</span> &#123; Shanghai, Dongjing, Beijing, Nanjing, &#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Japan</span>:<span class="type">char</span> &#123; Dongjing, Daban, Hengbin, Fudao &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m = Shanghai;           <span class="comment">// error</span></span><br><span class="line">    <span class="type">int</span> n = China::Shanghai;    <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">int</span>)China::Beijing &gt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ok!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size1: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(China::Dongjing) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size2: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Japan::Dongjing) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第5行：该行的代码有两处错误<ol><li>强类型枚举属于强作用于类型，不能直接使用，枚举值前必须加枚举类型</li><li>强类型枚举不会进行隐式类型转换，因此枚举值不能直接给int行变量赋值（虽然强类型枚举的枚举值默认就是整形，但其不能作为整形使用）。</li></ol></li><li>第6行：语法错误，将强类型枚举值作为整形使用，此处不会进行隐式类型转换</li><li>第7行：语法正确，强类型枚举值在和整数比较之前做了强制类型转换。</li><li>第11行：打印的结果为4，<code>强类型枚举底层类型值默认为int</code>，因此占用的内存是4个字节</li><li>第12行：打印的结果为1，显示指定了强类型枚举值的类型为char，因此占用的内存大小为1个字节，这样我们就可以节省更多的内存空间了。</li></ul><hr><h3 id="12-2-2-对原有枚举的扩展"><a href="#12-2-2-对原有枚举的扩展" class="headerlink" title="12.2.2 对原有枚举的扩展"></a>12.2.2 对原有枚举的扩展</h3><p>相比于原来的枚举，强类型枚举更像是一个属于C++的枚举。<br>但为了配合新的枚举类型，C++11还对原有枚举类型进行了扩展：</p><p>原有枚举类型的底层类型在默认情况下，仍然由编译器来具体指定实现。<br>但也可以跟强类型枚举类一样，显式地由我们来指定。<br>其指定的方式跟强类型枚举一样，都是枚举名称后面加上<code>∶type</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Colors</span> : <span class="type">char</span> &#123; Red, Green, Blue &#125;;</span><br></pre></td></tr></table></figure><p>关于作用域，在C++11中，枚举成员的名字除了会自动输出到父作用域，也可以在枚举类型定义的作用域内有效。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Colors</span> : <span class="type">char</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Colors c1 = Green;          <span class="comment">// C++11以前的用法</span></span><br><span class="line">    Colors c2 = Colors::Green;  <span class="comment">// C++11的扩展语法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序中第4、5行的写法都是合法的。</p><p>我们在声明强类型枚举的时候，也可以使用关键字<code>enum struct</code>。<br><code>enum struct</code> 和 <code>enum class</code> 在语法上没有任何区别（enum class 的成员没有公有私有之分，也不会使用模板来支持泛化的声明 ）。</p><hr><h1 id="13-Lambda表达式"><a href="#13-Lambda表达式" class="headerlink" title="13. Lambda表达式"></a>13. Lambda表达式</h1><h2 id="13-1-语法格式"><a href="#13-1-语法格式" class="headerlink" title="13.1 语法格式"></a>13.1 语法格式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[capture](params) opt -&gt; ret &#123;body;&#125;;</span><br><span class="line">    - capture: 捕获列表</span><br><span class="line">    - params: 参数列表</span><br><span class="line">    - opt: 函数选项</span><br><span class="line">    - ret: 返回值类型</span><br><span class="line">    - body: 函数体</span><br></pre></td></tr></table></figure><p>关于Lambda表达式的细节介绍:</p><ol><li>捕获列表: 捕获一定范围内的变量<ul><li><code>[]</code> - 不捕捉任何变量</li><li><code>[&amp;]</code> - 捕获外部作用域中所有变量, 并作为引用在函数体内使用 (按引用捕获)</li><li><code>[=]</code> - 捕获外部作用域中所有变量, 并作为副本在函数体内使用 (按值捕获)<ul><li>拷贝的副本在匿名函数体内部是只读的</li></ul></li><li><code>[=, &amp;foo]</code> - 按值捕获外部作用域中所有变量, 并按照引用捕获外部变量 foo</li><li><code>[bar]</code> - 按值捕获 bar 变量, 同时不捕获其他变量</li><li><code>[&amp;bar]</code> - 按引用捕获 bar 变量, 同时不捕获其他变量</li><li><code>[this]</code> - 捕获当前类中的this指针<ul><li>让lambda表达式拥有和当前类成员函数同样的访问权限</li><li>如果已经使用了 &amp; 或者 &#x3D;, 默认添加此选项</li></ul></li></ul></li><li>参数列表: 和普通函数的参数列表一样</li><li>opt 选项 –&gt; <code>可以省略</code><ul><li>mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）</li><li>exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用throw();</li></ul></li><li>返回值类型:<ul><li>标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略</li></ul></li><li>函数体:<ul><li>函数的实现，这部分不能省略，但函数体可以为空。</li></ul></li></ol><hr><h3 id="13-2-定义和调用"><a href="#13-2-定义和调用" class="headerlink" title="13.2 定义和调用"></a>13.2 定义和调用</h3><p>因为Lambda表达式是一个匿名函数, 因此是没有函数声明的, 直接在程序中进行代码的定义即可, 但是如果只定义匿名函数在程序执行过程中是不会被调用的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名函数的定义, 程序执行这个匿名函数是不会被调用的</span></span><br><span class="line">[]()&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;hello, 我是一个lambda表达式...&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数的定义+调用:</span></span><br><span class="line"><span class="type">int</span> ret = [](<span class="type">int</span> a) -&gt; <span class="type">int</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">1</span>;</span><br><span class="line">&#125;(<span class="number">100</span>);  <span class="comment">// 100是传递给匿名函数的参数</span></span><br></pre></td></tr></table></figure><blockquote><p>在Lambda表达式的捕获列表中也就是 <code>[]</code> 内部添加不同的关键字, 就可以在函数体中使用外部变量了。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在匿名函数外部定义变量</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">100</span>, b=<span class="number">200</span>, c=<span class="number">300</span>;</span><br><span class="line"><span class="comment">// 调用匿名函数</span></span><br><span class="line">[]()&#123;</span><br><span class="line">    <span class="comment">// 打印外部变量的值</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, c:&quot;</span> &lt;&lt; c;  </span><br><span class="line">    <span class="comment">// error, 不能使用任何外部变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[&amp;]()&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;hello, 我是一个lambda表达式...&quot;</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;使用引用的方式传递数据: &quot;</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;a+1:&quot;</span> &lt;&lt; a++ &lt;&lt; <span class="string">&quot;, b+c= &quot;</span> &lt;&lt; b+c;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值拷贝的方式使用外部数据</span></span><br><span class="line">[=](<span class="type">int</span> m, <span class="type">int</span> n)<span class="keyword">mutable</span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;hello, 我是一个lambda表达式...&quot;</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;使用拷贝的方式传递数据: &quot;</span>;</span><br><span class="line">    <span class="comment">// 拷贝的外部数据在函数体内部是只读的</span></span><br><span class="line">    <span class="comment">// 如果不添加 mutable 关键字是不能修改这些只读数据的值的</span></span><br><span class="line">    <span class="comment">// 添加 mutable 允许修改的数据是拷贝到函数内部的副本, 对外部数据没有影响</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;a+1:&quot;</span> &lt;&lt; a++ &lt;&lt; <span class="string">&quot;, b+c= &quot;</span> &lt;&lt; b+c;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;m+1: &quot;</span> &lt;&lt; ++m &lt;&lt; <span class="string">&quot;, n: &quot;</span> &lt;&lt; n;</span><br><span class="line">&#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="14-单列模式"><a href="#14-单列模式" class="headerlink" title="*14. 单列模式"></a>*14. 单列模式</h1><blockquote><p>这并不属于C++11单独涉及到的区域,只是做一个小补充</p></blockquote><blockquote><p>一个类只能创建一个对象，即单例模式，该模式可以保证系统中该类只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。<br>使用样例：内存池的申请</p></blockquote><hr><h2 id="14-1-饿汉模式"><a href="#14-1-饿汉模式" class="headerlink" title="14.1 饿汉模式"></a>14.1 饿汉模式</h2><p>特点：</p><p>一main函数前就创造对象，程序启动时就创建一个唯一的实例对象</p><p>缺点：</p><ol><li><p>由于初始化在main函数之前，这样的类数据过多，会使得启动慢；</p></li><li><p>多个单例类有初始化依赖关系，饿汉模式无法控制类的初始化先后关系</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InfoSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> InfoSingleton&amp; <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _sins;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(string name, <span class="type">int</span> money)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_info[name] = money;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> kv : _info)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; kv.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; kv.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">InfoSingleton</span>()</span><br><span class="line">&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">InfoSingleton</span>(<span class="type">const</span> InfoSingleton&amp; info) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line">InfoSingleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> InfoSingleton&amp; info) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; _info;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> InfoSingleton _sins;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">InfoSingleton InfoSingleton::_sins;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">InfoSingleton::<span class="built_in">GetInstance</span>().<span class="built_in">Insert</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">InfoSingleton&amp; info = InfoSingleton::<span class="built_in">GetInstance</span>();</span><br><span class="line">info.<span class="built_in">Insert</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//InfoSingleton copy = InfoSingleton::GetInstance(); //拷贝构造</span></span><br><span class="line"><span class="comment">//copy.Insert(&quot;***&quot;, 10000);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="14-2-懒汉模式"><a href="#14-2-懒汉模式" class="headerlink" title="14.2 懒汉模式"></a>14.2 懒汉模式</h2><blockquote><p>如果单例对象构造十分耗时或者占用很多资源，比如加载插件，初始化网络连接，读取文件等等，而有可能该对象程序运行时不会用到，那么也要在程序一开始就进行初始化，就会导致程序启动时非常的缓慢。<br>这种情况使用懒汉模式（延迟加载）更好。<br>如果类之间存在依赖关系，也可以使用懒汉模式（延迟加载）。</p></blockquote><p>懒汉模式特点</p><ol><li><p>只创建一次，并且在main函数调用之后创建。</p></li><li><p>有线程安全问题，C++11可以解决。</p></li><li><p>饿汉模式不需要注意线程安全问题，在main调用之前就已存在，没有所谓的线程可以创建其他的对象。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Lock</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockGuard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LockGuard</span>(Lock&amp; lk)</span><br><span class="line">:_lk(lk)</span><br><span class="line">&#123;</span><br><span class="line">_lk.<span class="built_in">lock</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">~<span class="built_in">LockGuard</span>()</span><br><span class="line">&#123;</span><br><span class="line">_lk.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Lock&amp; _lk;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_InfoSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//线程安全问题,多线程一起调用创建对象</span></span><br><span class="line"><span class="function"><span class="type">static</span> _InfoSingleton&amp; <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//双检查增加效率</span></span><br><span class="line"><span class="keyword">if</span> (_psins == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="function">LockGuard&lt;mutex&gt; <span class="title">lock</span><span class="params">(*_smtx)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (_psins == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_psins = <span class="keyword">new</span> _InfoSingleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *_psins;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(string name, <span class="type">int</span> money)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_info[name] = money;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> kv : _info)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; kv.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; kv.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">_InfoSingleton()</span><br><span class="line">&#123;&#125;</span><br><span class="line"> </span><br><span class="line">_InfoSingleton(<span class="type">const</span> _InfoSingleton&amp; info) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line">_InfoSingleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> _InfoSingleton&amp; info) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; _info;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> _InfoSingleton* _psins;</span><br><span class="line"><span class="type">static</span> mutex* _smtx;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> _InfoSingleton* _psins = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">static</span> mutex* _smtx;</span><br></pre></td></tr></table></figure><p>懒汉模式需要注意线程安全问题，所以我们在类中需要有一个唯一的锁，确保判断时是串行访问</p><p>每次都先加锁再进行判断是否为空，非常低效<br>所以我们需要双判断，第一次判断是为了抛去已经创建过的节省加锁的时间，第二次判断是为了创建对象使用的，而锁夹在中间确保第二次的判断是串行的。</p><p><strong>单例对象释放问题</strong></p><ol><li><p>一般而言单例类不需要释放内存，因为单例出现的环境就是<code>全局的</code>，它的目的就是陪到进程执行到最后，进程结束后，操作系统也会将这一部分的资源回收。</p></li><li><p>如果有一定要求，我们可以手写出析构</p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++特性 </tag>
            
            <tag> 智能指针 </tag>
            
            <tag> chrono库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11</title>
      <link href="/2023/10/21/cpp11-1/"/>
      <url>/2023/10/21/cpp11-1/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、decltype-RTTI"><a href="#一、decltype-RTTI" class="headerlink" title="一、decltype(RTTI)"></a>一、decltype(RTTI)</h1><hr><blockquote><p>RTTI 即 run time type identification(程序运行对对象的类型识别)<br>auto和decltype</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型推导RTTI : run time type identification</span></span><br><span class="line"><span class="comment">//程序运行起来对对象的类型识别</span></span><br><span class="line"><span class="type">int</span> a&#123; <span class="number">10</span> &#125;, b&#123; <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">decltype</span>(a + b) c = <span class="number">30</span>; <span class="comment">//定一个c和a+b是一个类型的对象</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> d = a+b;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(d).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//auto不能作为形参和返回值</span></span><br><span class="line"><span class="comment">/*auto func(auto e)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">return e;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; func(a) &lt;&lt; endl;*/</span></span><br></pre></td></tr></table></figure><blockquote><p>虽然auto不能作为函数的形参和返回值<br>但是在C++14的标准中就有了lambda表达式内可以有auto</p></blockquote><hr><h1 id="二、C-11中的新容器"><a href="#二、C-11中的新容器" class="headerlink" title="二、C++11中的新容器"></a>二、C++11中的新容器</h1><hr><blockquote><p>c++98容器:<br>    string &#x2F; vector &#x2F; list &#x2F; deque &#x2F; map &#x2F; set &#x2F; bitset + stack &#x2F; queue &#x2F; priority_queue<br>    c++11新容器:<br>    array(定长数组) &#x2F; forward_list(单链表)<br>    array: #include&lt; array&gt;  缺点:定长+存储数据的空间在 栈上,栈的空间本来就不大<br>    forward_list: #include&lt; forward_list &gt;  缺点:不支持尾插尾删+insert数据也是在当前位置的后面<br>unordered_map&#x2F;unordered_set : 效率高于map &#x2F; set,推荐</p></blockquote><hr><h1 id="三、默认成员函数的控制"><a href="#三、默认成员函数的控制" class="headerlink" title="三、默认成员函数的控制"></a>三、默认成员函数的控制</h1><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//1.要生成默认构造函数</span></span><br><span class="line"><span class="built_in">B</span>() = <span class="keyword">default</span>;  <span class="comment">//加入default关键字,即可仍然生成默认构造函数</span></span><br><span class="line"><span class="built_in">B</span>(<span class="type">const</span> <span class="type">int</span>&amp; b) <span class="comment">//构造函数</span></span><br><span class="line">:_b(b)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.不能拷贝和赋值(防拷贝)</span></span><br><span class="line"><span class="comment">//c++98</span></span><br><span class="line"><span class="built_in">B</span>(<span class="type">const</span> B&amp; b);</span><br><span class="line">B&amp; <span class="keyword">operator</span>=(<span class="type">const</span> B&amp; b);</span><br><span class="line"><span class="comment">//1.通过只声明,不定义的方式,使得链接失败,但是可以在外部定义</span></span><br><span class="line"><span class="comment">//2.private限定声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c++11</span></span><br><span class="line"><span class="built_in">B</span>(<span class="type">const</span> B&amp; b) = <span class="keyword">delete</span>;</span><br><span class="line">B&amp; <span class="keyword">operator</span>=(<span class="type">const</span> B&amp; b) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//B(const B&amp; b);</span></span><br><span class="line"><span class="comment">//B&amp; operator=(const B&amp; b); //private限定声明</span></span><br><span class="line"><span class="type">int</span> _b = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B::<span class="built_in">B</span>(<span class="type">const</span> B&amp; b) <span class="comment">//可以在外部定义</span></span><br><span class="line">&#123;&#125; <span class="comment">//delete删除仍然可以在外部定义,但是拷贝构造时就会报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b1;     <span class="comment">//因为有显示构造函数了,没有生成默认构造函数</span></span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(b1)</span></span>; <span class="comment">//内部只声明,外部定义,仍然可以使用拷贝构造</span></span><br><span class="line">b1 = b2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="四、右值引用"><a href="#四、右值引用" class="headerlink" title="四、右值引用"></a>四、右值引用</h1><hr><h2 id="1-右值引用的基本使用"><a href="#1-右值引用的基本使用" class="headerlink" title="1.右值引用的基本使用"></a>1.右值引用的基本使用</h2><blockquote><pre><code>左右不是方向,和左移右移一样,是C留下的坑左值通常是变量右值通常是常量,表达式或者函数返回值等临时常量</code></pre></blockquote><pre><code>c++11将右值分为:纯右值 , 将亡值纯右值:基本类型的常量或者临时对象将亡值:自定义类型的临时对象</code></pre><blockquote><p> 总结<br> 右值引用做参数和做返回值减少拷贝的本质是利用了移动构造和移动赋值<br> 左值引用和右值引用本质的作用都是减少拷贝,右值引用本质可以认为是弥补左值引用不足的地方,他们相辅相成</p></blockquote><blockquote><p>左值引用: 解决的是传参过程中和返回值过程中的拷贝<br> 做参数 : void push(T x) -&gt; void push(T&amp; x) 解决的是传参过程中减少拷贝<br> 做返回值 : T f2() -&gt; T&amp; f2() 解决的是返回值过程中的拷贝<br> 注意: 这里有限制,如果返回对象出了作用域不在了就不能传引用,这个左值引用无法解决,等待C++11右值引用解决</p></blockquote><blockquote><p>右值引用 : 解决的是传参后,push&#x2F;insert 函数内部将对象移动到容器空间上的问题 + 传值返回接受返回值的拷贝<br> 做参数 : void push(T&amp;&amp; x) 解决的push内部不再使用拷贝构造x到容器空间上,而是移动构造过去<br> 做返回值: T&amp;&amp; f2() 解决的外面调用接收f2() 返回对象的拷贝,T ret &#x3D; f2() , 这里就是右值引用的移动给构造,减少了拷贝</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> T&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;void fun(const T&amp; a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> T&amp;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;void fun(const T&amp;&amp; a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>, a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp; b = a;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp; e = <span class="number">10</span>;   </span><br><span class="line"><span class="type">int</span>&amp; f = x + y;<span class="comment">//左值引用不能用右值初始化,这两段会出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加上const,左值引用可以引用右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; e = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; f = x + y;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右值引用</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; c = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; d = x + y;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用move后右值引用可以引用左值</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; m = a;  <span class="comment">//右值引用无法正常引用左值</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; m = <span class="built_in">move</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fun</span>(x);  <span class="comment">//调左值引用</span></span><br><span class="line"><span class="built_in">fun</span>(<span class="number">10</span>); <span class="comment">//调右值引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-右值引用的作用"><a href="#2-右值引用的作用" class="headerlink" title="2.右值引用的作用"></a>2.右值引用的作用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">_str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(_str, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//s2(s1)</span></span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;String(const String&amp; s) - 深拷贝&quot;</span> &lt;&lt; endl;</span><br><span class="line">_str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s._str) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(_str, s._str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(String&amp;&amp; s) <span class="comment">//传递进一个将亡值,直接交换</span></span><br><span class="line">:_str(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;String(const String&amp;&amp; s) - 移动拷贝&quot;</span> &lt;&lt; endl; <span class="comment">//相对于深拷贝,效率高</span></span><br><span class="line"><span class="built_in">swap</span>(_str, s._str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* newstr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s._str) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(newstr, s._str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] _str;</span><br><span class="line">_str = newstr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String&amp; <span class="keyword">operator</span>=(String&amp;&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;String&amp; operator=(String&amp;&amp; s) - 移动赋值 - 高效&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">swap</span>(_str, s._str);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] _str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> String&amp; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//this-&gt;append(s);</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回的是左值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String <span class="keyword">operator</span>+(<span class="type">const</span> String&amp; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">String <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="comment">//ret.append(s);</span></span><br><span class="line"><span class="keyword">return</span> ret; <span class="comment">//返回的是右值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* _str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">String <span class="title">tmp</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp; <span class="comment">//返回tmp临时拷贝对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test1</span><span class="params">()</span> <span class="comment">//右值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;左值&quot;</span>)</span></span>; <span class="comment">//&quot;左值&quot;&quot;构造为string,性质为左值</span></span><br><span class="line"><span class="function">String <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">s3</span><span class="params">(move(s2))</span></span>; <span class="comment">//这里将s2转换为将亡值,移动拷贝</span></span><br><span class="line"><span class="function">String <span class="title">s4</span><span class="params">(f(<span class="string">&quot;右值,将亡值&quot;</span>))</span></span>; <span class="comment">//移动拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">s5</span><span class="params">(s1)</span></span>;</span><br><span class="line">s5 = s1;</span><br><span class="line">s5 = <span class="built_in">f</span>(<span class="string">&quot;rightval-dyingv&quot;</span>); <span class="comment">//tmp的临时拷贝对象就是将亡值</span></span><br><span class="line"><span class="comment">//在string的标准库中同样有右值引用,类似的list,vector等</span></span><br><span class="line"></span><br><span class="line">String s6 = s1 += s3;<span class="comment">//拷贝构造</span></span><br><span class="line">String s7 = s1 + s2; <span class="comment">//移动构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//右值引用的应用场景在于深拷贝大型类,会导致大量效率的浪费</span></span><br><span class="line"><span class="comment">//eg: vector&lt;vector&lt;int&gt;&gt; ...</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-emplace-back"><a href="#3-emplace-back" class="headerlink" title="3.emplace_back"></a>3.emplace_back</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">test2</span><span class="params">()</span> <span class="comment">//emplace_back</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//像vector,list等的插入基本都是两个重载实现,一个左值引用,一个右值引用</span></span><br><span class="line">vector&lt;string&gt; v;</span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;left val&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> val = <span class="number">123</span>;</span><br><span class="line">v.<span class="built_in">push_back</span>(s1);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="string">&quot;right val&quot;</span>);   <span class="comment">//右值引用</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(val));<span class="comment">//右值引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于emplace_back</span></span><br><span class="line"><span class="comment">//template&lt;class Arg&gt;</span></span><br><span class="line"><span class="comment">//void emplace_back(Arg &amp;&amp; arg); //emplace_back只有右值引用,但由于模板的存在(模板的可变参数),可以传左值引用.</span></span><br><span class="line"></span><br><span class="line">v.<span class="built_in">emplace_back</span>(s1); <span class="comment">//实际上并没有对其进行右值引用处理</span></span><br><span class="line">v.<span class="built_in">emplace_back</span>(<span class="built_in">move</span>(s1));      <span class="comment">//此时才有右值处理</span></span><br><span class="line">v.<span class="built_in">emplace_back</span>(<span class="string">&quot;right val&quot;</span>);   <span class="comment">//右值引用</span></span><br><span class="line"><span class="comment">//综上发现,emplace_back和push_back用法和作用完全一样,没有孰优孰劣</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是emplace_back的特征在于以下</span></span><br><span class="line">vector&lt;pair&lt;string, string&gt;&gt; vp;</span><br><span class="line"><span class="function">pair&lt;string, string&gt; <span class="title">kv</span><span class="params">(<span class="string">&quot;left v&quot;</span>, <span class="string">&quot;left v&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">vp.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;right v&quot;</span>, <span class="string">&quot;right v&quot;</span>));</span><br><span class="line">vp.<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;right v&quot;</span>, <span class="string">&quot;right v&quot;</span>));</span><br><span class="line">vp.<span class="built_in">push_back</span>(kv);</span><br><span class="line">vp.<span class="built_in">emplace_back</span>(kv);</span><br><span class="line"></span><br><span class="line">vp.<span class="built_in">emplace_back</span>(<span class="string">&quot;right v&quot;</span>, <span class="string">&quot;right v&quot;</span>); <span class="comment">//体现emplace_back模板的可变参数特点的地方(template)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-完美转发"><a href="#4-完美转发" class="headerlink" title="4.完美转发"></a>4.完美转发</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;leftv ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;rightv ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const leftv ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;&amp; x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const rightv ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectFoward</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//fun(t); //右值引用会在第二次之后参数传递过程中属性丢失,所以结果并不为我们所想</span></span><br><span class="line"><span class="built_in">fun</span>(std::forward&lt;T&gt;(t)); <span class="comment">//加入forward关键字即可保留其属性,完美转发解决</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">PerfectFoward</span>(<span class="number">10</span>);  <span class="comment">//rightv ref</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">PerfectFoward</span>(a);  <span class="comment">//leftv ref</span></span><br><span class="line"><span class="built_in">PerfectFoward</span>(std::<span class="built_in">move</span>(a));  <span class="comment">//rightv ref</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">PerfectFoward</span>(b);  <span class="comment">//const leftv ref</span></span><br><span class="line"><span class="built_in">PerfectFoward</span>(std::<span class="built_in">move</span>(b));  <span class="comment">//const rightv ref</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="五、lambda表达式"><a href="#五、lambda表达式" class="headerlink" title="五、lambda表达式"></a>五、lambda表达式</h1><hr><p>lambda表达式的轮廓为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[capture - list] (parameters) <span class="keyword">mutable</span> -&gt; <span class="keyword">return</span>-type &#123;statement&#125;</span><br><span class="line">      捕捉列表参数列表   取消常性      返回类型函数体</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//最简单的lambda表达式 : []&#123;&#125;</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> add1 = [](<span class="type">int</span> x, <span class="type">int</span> y)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="built_in">add1</span>(a, b);   <span class="comment">//调用的是lambda表达式(匿名函数)</span></span><br><span class="line">::<span class="built_in">add1</span>(a, b); <span class="comment">//调用的是顶上的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//auto add2 = [=]() &#123;return a + b; &#125;;  //=代表捕捉作用域内所有的值,同样的,&amp;捕捉作用域内所有数据的引用</span></span><br><span class="line"><span class="keyword">auto</span> add2 = [a, b]() &#123;<span class="keyword">return</span> a + b; &#125;; <span class="comment">//捕捉到a,b , 返回类型其实会自动推导,可以不写</span></span><br><span class="line"><span class="built_in">add2</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> add3 = [=]() &#123;<span class="keyword">return</span> <span class="built_in">add1</span>(a, b); &#125;; <span class="comment">//匿名函数调用匿名函数实现</span></span><br><span class="line"><span class="keyword">auto</span> add4 = [=]() &#123;<span class="keyword">return</span> ::<span class="built_in">add1</span>(a, b); &#125;;<span class="comment">//匿名函数调用函数实现</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> swap1 = [&amp;]() &#123;<span class="type">int</span> x = a; a = b; b = x; &#125;;</span><br><span class="line"><span class="built_in">swap1</span>();</span><br><span class="line">cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> swap2 = [&amp;a,&amp;b]() &#123;<span class="type">int</span> x = a; a = b; b = x; &#125;; <span class="comment">//捕捉的引用,而不是地址</span></span><br><span class="line"><span class="built_in">swap2</span>();</span><br><span class="line">cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> swap3 = [](<span class="type">int</span>&amp; x,<span class="type">int</span>&amp; y) &#123;<span class="type">int</span> z = x; x = y; y = z; &#125;;</span><br><span class="line"><span class="built_in">swap3</span>(a,b);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//mutable</span></span><br><span class="line"><span class="keyword">auto</span> test = [a, b]()<span class="keyword">mutable</span>&#123;<span class="type">int</span> c = a, a = <span class="number">20</span>, b = c; &#125;;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="comment">//默认情况下,lambda函数总是const函数,mutable可以取消其常量性,使用该修饰符时,参数列表不可省略(即使参数为空)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda表达式可以作为仿函数(其原理就是仿函数的operator()成员)(匿名函数)</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">76</span>, <span class="number">5</span>, <span class="number">342</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr, arr + <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]), [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)&#123;<span class="keyword">return</span> a &gt; b; &#125;); <span class="comment">//默认升序,改为降序</span></span><br><span class="line"><span class="built_in">sort</span>(arr, arr + <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">//默认升序,改为降序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : arr)</span><br><span class="line">cout &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//底层还是依靠仿函数来实现</span></span><br><span class="line"><span class="comment">//也就是定义lambda表达式,实际上是编译器会生成一个lambda_uuid类,仿函数的operator() 的参数和实现就是我们写的lambda</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="六、异常"><a href="#六、异常" class="headerlink" title="六、异常"></a>六、异常</h1><hr><h2 id="1-异常简介"><a href="#1-异常简介" class="headerlink" title="1.异常简介"></a>1.异常简介</h2><blockquote><p>传统处理错误的方式有:  1.返回错误码  2.终止程序:eg:exit()<br>其缺点是: 1.拿到错误码,需要查找错误码表才知道具体错误<br>       2.如果一个函数是通过返回值拿数据,发生错误很难处理(让传一个自定义类型,却传了个-1之类的)<br>        3.如果调用的函数栈很深,一层层返回错误码,处理很复杂</p></blockquote><blockquote><p>异常的优缺点:<br>优点:<br>1.清晰的包含错误信息<br>2.面对 T operator[](int i)这类函数越界错误,异常可以很好的解决<br>3.多层调用时,里面发生错误,不再需要层层处理,最外层直接捕获即可<br>4.很多第三方库都是用异常,使用异常可以更好的使用他们.eg:boost,gtest.gmock</p></blockquote><blockquote><p>缺点:<br>1.异常会导致执行流乱飞,会使得调试分析程序bug带来一些困难<br>2.异常可能导致资源泄露等异常安全问题,要学会RAII来解决<br>3.C++库里的异常体系不好用,常自己定义<br>4.C++异常语言可以抛任意类型异常,项目若没有规范管理,会非常混乱</p></blockquote><p>总的来说,异常利大于弊,实际小项目不使用</p><hr><h2 id="2-异常的基本使用"><a href="#2-异常的基本使用" class="headerlink" title="2.异常的基本使用"></a>2.异常的基本使用</h2><p>STL库中有的自带抛异常</p><blockquote><p>try和catch必须带有花括号,否则无法识别<br>如果try了没有catch到,程序会直接终止</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//STL中自带抛异常</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt;= v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">cout &lt;&lt; v.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//自带的抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Div</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="comment">//除零错误</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;/0 error&quot;</span>); <span class="comment">//throw 可以抛出任意类型的对象</span></span><br><span class="line"><span class="comment">//直接跳转到catch匹配的地方</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m / n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fun1</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//异常是可以截胡的,比如</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Div</span>(m, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> string&amp; err)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; __LINE__ &lt;&lt; err &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return Div(m, n);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> m, n; cin &gt;&gt; m&gt;&gt; n;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Fun1</span>(m, n) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> string&amp; err)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; __LINE__ &lt;&lt; err&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...) <span class="comment">//当throw的类型匹配不上以上的catch,就会都跳转到这里,避免异常没捕获时程序直接终止</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;none matched catch&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常的底层逻辑</p><blockquote><p>首先检查throw本身是否在try内部,如果是再查找匹配的catch.<br>    没有则退出当前函数栈,继续在调用函数的栈中寻找匹配的catch<br>    如果main函数的栈中还没有,则终止程序</p></blockquote><hr><h2 id="3-异常的重新抛出-自定义异常类"><a href="#3-异常的重新抛出-自定义异常类" class="headerlink" title="3.异常的重新抛出,自定义异常类"></a>3.异常的重新抛出,自定义异常类</h2><p><code>异常是很危险的,非常容易导致内存泄漏</code></p><blockquote><p>,throw后直接跑到catch那里不再回来了,导致throw后可能有的释放内存没有进行</p></blockquote><p>解决的方法就是让异常重新抛出<br>一个实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Exception</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Exception</span>(<span class="type">const</span> <span class="type">char</span>* errmsg,<span class="type">int</span> errid)</span><br><span class="line">:_errid(errid)</span><br><span class="line">,_errmsg(errmsg)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">what</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//纯虚函数,构成多态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _errid; <span class="comment">//错误码</span></span><br><span class="line">string _errmsg; <span class="comment">//错误信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlException</span> : <span class="keyword">public</span> Exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SqlException</span>(<span class="type">const</span> <span class="type">char</span>* errmsg, <span class="type">int</span> errid)</span><br><span class="line">:<span class="built_in">Exception</span>(errmsg, errid)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">what</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;sql error : &quot;</span> + _errmsg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkException</span> : <span class="keyword">public</span> Exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">NetworkException</span>(<span class="type">const</span> <span class="type">char</span>* errmsg, <span class="type">int</span> errid)</span><br><span class="line">:<span class="built_in">Exception</span>(errmsg,errid)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">what</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;internet error : &quot;</span> + _errmsg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ServeStart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//if (rand() % 6 == 0)</span></span><br><span class="line"><span class="comment">//throw SqlException(&quot;sql open error&quot;, 1);</span></span><br><span class="line"><span class="comment">//if (rand() % 7 == 0)</span></span><br><span class="line"><span class="comment">//throw NetworkException(&quot;internet connect error&quot;, 3);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;sucessful&quot; &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟一下出现问题抛异常报错</span></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">rand</span>() % <span class="number">6</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">SqlException</span>(<span class="string">&quot;sql open error&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">rand</span>() % <span class="number">7</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">NetworkException</span>(<span class="string">&quot;internet connect error&quot;</span>, <span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sucessful&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> Exception&amp; err) <span class="comment">//如果抛出异常</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] arr;  </span><br><span class="line"><span class="keyword">throw</span>; <span class="comment">//重新抛出异常,以正确输出所需内容</span></span><br><span class="line">   <span class="comment">//截胡处理一下,再把路让出来过去</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//自定义异常类(继承体系)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ServeStart</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (Exception&amp; err)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;catch error&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-异常规范"><a href="#4-异常规范" class="headerlink" title="4.异常规范"></a>4.异常规范</h2><blockquote><p> throw(A,B)<br>  函数会抛出A,B类型某个类的异常<br> throw(A)<br> 函数只会抛出A类型异常<br>throw()<br>函数不会抛出异常<br> noexcept<br> 函数不会抛出异常</p></blockquote><blockquote><p>void* operator new(std::size_t size) throw(std::bad_alloc);  &#x2F;&#x2F;表示这个函数只会抛出bad_alloc异常<br>void* operator delete(std::size_t size, void* ptr) throw();  &#x2F;&#x2F;表示这个函数不会抛出异常<br>void* operator delete(std::size_t size, void* ptr) noexcept; &#x2F;&#x2F;表示这个函数不会抛出异常</p></blockquote><hr><h1 id="七、类型转换"><a href="#七、类型转换" class="headerlink" title="七、类型转换"></a>七、类型转换</h1><hr><h2 id="1-隐式类型转换和显示类型转换"><a href="#1-隐式类型转换和显示类型转换" class="headerlink" title="1.隐式类型转换和显示类型转换"></a>1.隐式类型转换和显示类型转换</h2><blockquote><p>隐式类型转换:相近类型,也就是意义相似的类别之间的转换<br>显示类型转换:不相近类型,意义差别很大的类型的转换</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="number">3.33</span>;</span><br><span class="line">i = d;           <span class="comment">//C语言支持相近类型的隐式类型转换(相近类型,也就是意义相似的类别)</span></span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line">p = (<span class="type">int</span>*)i;     <span class="comment">//C语言支持不相近类型强制类型转换(不相近类型,意义差别很大的类型)</span></span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="2-C-11中的类型转换操作符"><a href="#2-C-11中的类型转换操作符" class="headerlink" title="2.C++11中的类型转换操作符"></a>2.C++11中的类型转换操作符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span> <span class="comment">//隐式类型转换</span></span><br><span class="line"><span class="keyword">reinterpret_cast</span>    <span class="comment">//强制类型转换</span></span><br><span class="line"><span class="keyword">const_cast</span> <span class="comment">//强制类型转换,并去掉const属性</span></span><br><span class="line"><span class="keyword">dynamic_cast</span> <span class="comment">//父子类转换</span></span><br></pre></td></tr></table></figure><h3 id="①static-cast-reinterpret-cast"><a href="#①static-cast-reinterpret-cast" class="headerlink" title="①static_cast,reinterpret_cast"></a>①static_cast,reinterpret_cast</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="number">3.33</span>;</span><br><span class="line"><span class="type">int</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(i);  <span class="comment">//对应C的隐式类型转换(相近类型)</span></span><br><span class="line">p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(i);    <span class="comment">//对应C的强制类型转换(不相近类型)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果用错操作符是没办法编译通过的</span></span><br><span class="line"><span class="comment">//d = reinterpret_cast&lt;double&gt;(i);</span></span><br><span class="line"><span class="comment">//p = static_cast&lt;int*&gt;(i);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="②const-cast"><a href="#②const-cast" class="headerlink" title="②const_cast"></a>②const_cast</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//const int ci = 10;</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">const</span> <span class="type">int</span> ci = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* pi = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;ci); <span class="comment">//强制类型转换,并去掉const属性</span></span><br><span class="line">*pi = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; *pi &lt;&lt; endl; <span class="comment">//20</span></span><br><span class="line">cout &lt;&lt; ci &lt;&lt; endl;  <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为什么监视窗口中(内存中)得到的ci是20,但是输出却是10呢?</span></span><br><span class="line"><span class="comment">//ci的内存中存储的值确实被改成了20,但是ci放进了寄存器,这里去寄存器中取,还是10</span></span><br><span class="line"><span class="comment">//本质上是编译器对const对象存取优化机制导致</span></span><br><span class="line"><span class="comment">//可以加入volatile关键字去内存中取值,可以禁止编译器的优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="③dynamic-cast"><a href="#③dynamic-cast" class="headerlink" title="③dynamic_cast"></a>③dynamic_cast</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun_cast</span><span class="params">(A* pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果想区分pa是指向父类还是子类</span></span><br><span class="line"><span class="comment">//pa指向子类对象则转换成功</span></span><br><span class="line"><span class="comment">//pa指向父类对象就转换失败,返回nullptr</span></span><br><span class="line">B* pb = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(pa);</span><br><span class="line"><span class="comment">//B* pb = (B*)pa;   //只会根据情况成功或 失败(程序崩溃)</span></span><br><span class="line"><span class="keyword">if</span> (pb != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;translated pa-&gt;parent&quot;</span> &lt;&lt; endl;</span><br><span class="line">pb-&gt;_a = <span class="number">10</span>;</span><br><span class="line">pb-&gt;_b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;translat error&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类对象可以赋值给父类的对象、指针、引用,这个过程叫做切片,这是天然支持的,称为 向上转换</span></span><br><span class="line"><span class="comment">//父类的对象、指针、引用传给子类的指针...,这个过程叫做向下转换,根据实际情况有可能成功</span></span><br><span class="line"></span><br><span class="line">A* pa = &amp;a;</span><br><span class="line"><span class="built_in">Fun_cast</span>(pa);  <span class="comment">//pa指向父类</span></span><br><span class="line"></span><br><span class="line">pa = &amp;b;</span><br><span class="line"><span class="built_in">Fun_cast</span>(pa);  <span class="comment">//pa指向子类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dynamic_cast向下转换只能针对继承中多态类型(父类必须含有虚函数)</span></span><br><span class="line"><span class="comment">//这就涉及到 dynamic_cast 的原理: 其如何实现识别父类子类的呢?</span></span><br><span class="line"><span class="comment">//dynamic_cast通过去虚表上方存储的标识信息,来判断指向的是父类还是子类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="④explicit"><a href="#④explicit" class="headerlink" title="④explicit"></a>④explicit</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">AA</span><span class="params">(<span class="type">int</span> a)</span>  <span class="comment">//加入explicit可以阻止隐式转换地构造</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;AA(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AA</span>(<span class="type">const</span> AA&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;AA(const AA&amp; a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">AA <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;  <span class="comment">//构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//隐式转换 : AA tmp(1) -&gt; AA a2(tmp)  先构造再拷贝构造被优化为只有构造,优化取决于编译器</span></span><br><span class="line"><span class="comment">//以防有些没有优化的编译器导致的低效,加入explicit可以阻止这种隐式转换</span></span><br><span class="line"><span class="comment">//AA a2 = 1; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="八、IO流"><a href="#八、IO流" class="headerlink" title="八、IO流"></a>八、IO流</h1><hr><h2 id="1-IO流-简单的使用"><a href="#1-IO流-简单的使用" class="headerlink" title="1.IO流 简单的使用"></a>1.IO流 简单的使用</h2><table><thead><tr><th>文件打开方式</th><th>作用</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件打开文件</td></tr><tr><td>ios::out</td><td>为写文件打开文件</td></tr><tr><td>ios::ate</td><td>初始位置:文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除,再创建</td></tr><tr><td>ios::binary</td><td>二进制方法</td></tr></tbody></table><blockquote><p>ofstream 写操作<br>ifstream 读操作<br>fstream 读写操作</p></blockquote><p>文本文件写文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ofstream ofs; <span class="comment">//其实前两行可以合并为 ofstream ofs(&quot;文件.txt&quot;,ios::out);</span></span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;文件.txt&quot;</span>,ios::out);</span><br><span class="line">ofs&lt;&lt;<span class="string">&quot;内容&quot;</span>&lt;&lt;endl;</span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文本文件读文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;文件.txt&quot;</span>,ios::in)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;文件打开失败&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读数据 多种方法</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(ifs&gt;&gt;buf)</span><br><span class="line">cout&lt;&lt;buf&lt;&lt;endl;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(ifs.<span class="built_in">getline</span>(buf,<span class="built_in">sizeof</span>(buf)))</span><br><span class="line">cout&lt;&lt;buf&lt;&lt;endl;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">string buf;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(ifs,buf))</span><br><span class="line">cout&lt;&lt;buf&lt;&lt;endl;</span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span>((c=ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">cout&lt;&lt;c;</span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二进制写文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ofstream ofs; <span class="comment">//ofstream ofs(&quot;文件.txt&quot;,ios::out | ios::binary);</span></span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;文件.txt&quot;</span>,ios::out | ios::binary); <span class="comment">//二进制方法写文件</span></span><br><span class="line"></span><br><span class="line">Person p = &#123;<span class="string">&quot;name&quot;</span>,<span class="number">18</span>&#125;;</span><br><span class="line">ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;p,<span class="built_in">sizeof</span>(Person));</span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二进制读文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;文件.txt&quot;</span>,ios::in | ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;文件打开失败&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">Person p;</span><br><span class="line">ifs.<span class="built_in">read</span>((<span class="type">char</span>*) &amp;p,<span class="built_in">sizeof</span>(Person));</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;name:&quot;</span>&lt;&lt;p.name&lt;&lt;<span class="string">&quot;age&quot;</span> &lt;&lt; p.age&lt;&lt;endl;</span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他写法读写文件"><a href="#其他写法读写文件" class="headerlink" title="其他写法读写文件"></a>其他写法读写文件<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;text.txt&quot;</span>)</span></span>;<span class="comment">//fopen( ,&quot;W&quot;);</span></span><br><span class="line">ofs.<span class="built_in">put</span>(<span class="string">&#x27;x&#x27;</span>);<span class="comment">//fputc</span></span><br><span class="line">ofs.<span class="built_in">write</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">5</span>);<span class="comment">//fwrite</span></span><br><span class="line">ofs.<span class="built_in">close</span>();<span class="comment">//fclose</span></span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;text.txt&quot;</span>)</span></span>;<span class="comment">//fopen( , &quot;R&quot;);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; (char)ifs.get() &lt;&lt; endl;  //fgetc</span></span><br><span class="line">cout&lt;&lt;ifs.<span class="built_in">rdbuf</span>();<span class="comment">//输出文件缓冲区外所有内容,如果前面已经输出了,就不再输出了</span></span><br><span class="line"><span class="comment">//ifs.read//fread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="2-读写结构体"><a href="#2-读写结构体" class="headerlink" title="2.读写结构体"></a>2.读写结构体</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Msg</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//使用起来和cin cout类似</span></span><br><span class="line">Msg per1&#123; <span class="string">&quot;jack&quot;</span>,<span class="number">18</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;text.txt&quot;</span>)</span></span>;</span><br><span class="line">ofs &lt;&lt; per1.name &lt;&lt; endl; <span class="comment">//要给上换行或者空格,否则在读文件时会无法分割</span></span><br><span class="line">ofs &lt;&lt; per1.age &lt;&lt; endl;</span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">Msg per2;</span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;text.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//ifs &gt;&gt; per2.name;</span></span><br><span class="line"><span class="comment">//ifs &gt;&gt; per2.age;</span></span><br><span class="line">cout &lt;&lt; ifs.<span class="built_in">rdbuf</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-序列化"><a href="#3-序列化" class="headerlink" title="3.序列化"></a>3.序列化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Msg</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Msg per1&#123; <span class="string">&quot;jack&quot;</span>,<span class="number">18</span> &#125;;</span><br><span class="line"><span class="comment">//序列化字符串</span></span><br><span class="line">ostringstream ost;</span><br><span class="line">ost &lt;&lt; per1.name &lt;&lt; endl;</span><br><span class="line">ost &lt;&lt; per1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str1 = ost.<span class="built_in">str</span>();</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;  <span class="comment">//网络中可以把这个str1发送给另一端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//网络另一端接收后就可以开始解析数据</span></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line">istringstream ist;</span><br><span class="line">Msg per2;</span><br><span class="line">ist &gt;&gt; per2.name;</span><br><span class="line">ist &gt;&gt; per2.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件IO </tag>
            
            <tag> C++特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位图,布隆过滤器</title>
      <link href="/2023/10/21/cpp-%E4%BD%8D%E5%9B%BE-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2023/10/21/cpp-%E4%BD%8D%E5%9B%BE-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、位图"><a href="#一、位图" class="headerlink" title="一、位图"></a>一、位图</h1><hr><blockquote><p>位图就是利用好每一个比特位进行利用<br>适用于海量数据,数据无重复的场景,通常用来判断数据是否存在</p></blockquote><p>位图的作用有</p><blockquote><p>排序,去重,集合的交并集</p></blockquote><p>模拟实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="number">9</span>TSe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bitset</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">bitset</span>(<span class="type">size_t</span> N)</span><br><span class="line">&#123;</span><br><span class="line">_bits.<span class="built_in">resize</span>(N/<span class="number">32</span>+<span class="number">1</span>,<span class="number">0</span>); <span class="comment">//开空间和初始化</span></span><br><span class="line">_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">size_t</span> x)</span> <span class="comment">//增</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> index = x / <span class="number">32</span>; <span class="comment">//算出映射的位置在第几个整形</span></span><br><span class="line"><span class="type">size_t</span> pos = x % <span class="number">32</span>; <span class="comment">//算出x在整形的第几位</span></span><br><span class="line"></span><br><span class="line">_bits[index] |= (<span class="number">1</span> &lt;&lt; pos); <span class="comment">//找到位置置1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">size_t</span> x)</span><span class="comment">//删</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> index = x / <span class="number">32</span>;</span><br><span class="line"><span class="type">size_t</span> pos = x % <span class="number">32</span>;</span><br><span class="line">_bits[index] &amp;= ~(<span class="number">1</span> &lt;&lt; pos); <span class="comment">//注意:左移的并不是位置,而是低位向高位移动,同理右移</span></span><br><span class="line"> <span class="comment">//找到位置置零</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test</span><span class="params">(<span class="type">size_t</span> x)</span> <span class="comment">//查,找到为1,没有为0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> index = x / <span class="number">32</span>;</span><br><span class="line"><span class="type">size_t</span> pos = x % <span class="number">32</span>;</span><br><span class="line"><span class="keyword">return</span> _bits[index] &amp; (<span class="number">1</span> &lt;&lt; pos); <span class="comment">//查1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; _bits;</span><br><span class="line"><span class="type">size_t</span> _num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_bitset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">bitset <span class="title">bs</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//存储100个,开100/32+1个空间</span></span><br><span class="line">bs.<span class="built_in">set</span>(<span class="number">99</span>);</span><br><span class="line">bs.<span class="built_in">set</span>(<span class="number">98</span>);</span><br><span class="line">bs.<span class="built_in">set</span>(<span class="number">97</span>);</span><br><span class="line">bs.<span class="built_in">set</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]:%d\n&quot;</span>, i, bs.<span class="built_in">test</span>(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果要创建出最大的空间</span></span><br><span class="line"><span class="comment">//bitset bss(-1); //-1转换为size_t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//库内的使用</span></span><br><span class="line">bitset&lt;100&gt; bs;</span><br><span class="line">bs.<span class="built_in">set</span>();  <span class="comment">//全1</span></span><br><span class="line">bs.<span class="built_in">set</span>(<span class="number">3</span>,<span class="number">0</span>); <span class="comment">//3位置0  并非从左往右,大小端不同,位置不同</span></span><br><span class="line">bs.<span class="built_in">set</span>(<span class="number">3</span>);   <span class="comment">//3位置1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="二、布隆过滤器"><a href="#二、布隆过滤器" class="headerlink" title="二、布隆过滤器"></a>二、布隆过滤器</h1><hr><blockquote><p>假如有100亿个ip地址在文件中，如何判断一个ip地址是否在这个文件中？<br>1.哈希表浪费空间<br>2.位图一般只能处理整形，如果内容编号是字符串，就无法处理。<br>3.将哈希与位图结合，即布隆过滤器</p></blockquote><p>所以布隆过滤器的底层就是bitset</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;bitset.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="number">9</span>TSe</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//BKDR</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Hashstr1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> theway = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">theway *= <span class="number">131</span>;</span><br><span class="line">theway += s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> theway;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RSHash</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Hashstr2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> theway = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> magic = <span class="number">63689</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">theway *= magic;</span><br><span class="line">theway += s[i];</span><br><span class="line">magic *= <span class="number">378551</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> theway;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SDBMHash</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Hashstr3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> theway = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">theway *= <span class="number">65599</span>;</span><br><span class="line">theway += s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> theway;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希函数太多效率会变低,哈希函数太少误报率会变高</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span> = std::string,<span class="keyword">class</span> Hash1 = Hashstr1,<span class="keyword">class</span> Hash2 = Hashstr2,<span class="keyword">class</span> Hash3 = Hashstr3&gt;</span><br><span class="line"><span class="keyword">class</span> bloomfilter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">bloomfilter</span>(<span class="type">size_t</span> num)</span><br><span class="line">:_bs(<span class="number">5</span>*num) <span class="comment">//算法,算出开空间并不为3*num,布隆过滤器越长其误报概率越小</span></span><br><span class="line">, _N(<span class="number">5</span>*num) <span class="comment">//空间小误报率高,空间大可能有空间浪费,4.3即为最优</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">set</span>(<span class="type">const</span> K&amp; k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//Hash1 hash1; ....</span></span><br><span class="line"><span class="type">size_t</span> index1 = <span class="built_in">Hash1</span>()(k) % _N; <span class="comment">//加括号构成匿名对象</span></span><br><span class="line"><span class="type">size_t</span> index2 = <span class="built_in">Hash2</span>()(k) % _N;</span><br><span class="line"><span class="type">size_t</span> index3 = <span class="built_in">Hash3</span>()(k) % _N;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; index1 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; index2 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; index3 &lt;&lt; endl&lt;&lt;endl; //观测一下插入位置</span></span><br><span class="line"></span><br><span class="line">_bs.<span class="built_in">set</span>(index1);</span><br><span class="line">_bs.<span class="built_in">set</span>(index2);</span><br><span class="line">_bs.<span class="built_in">set</span>(index3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test</span><span class="params">(<span class="type">const</span> K&amp; k)</span> <span class="comment">//都找到了,说明已经有了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> index1 = <span class="built_in">Hash1</span>()(k) % _N;</span><br><span class="line"><span class="keyword">if</span> (_bs.<span class="built_in">test</span>(index1) == <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> index2 = <span class="built_in">Hash2</span>()(k) % _N;</span><br><span class="line"><span class="keyword">if</span> (_bs.<span class="built_in">test</span>(index2) == <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> index3 = <span class="built_in">Hash3</span>()(k) % _N;</span><br><span class="line"><span class="keyword">if</span> (_bs.<span class="built_in">test</span>(index3) == <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">const</span> K&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//映射位置不能直接置零</span></span><br><span class="line"><span class="comment">//不支持删除,可能会存在误删,一般布隆过滤器不支持删除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">bitset _bs; <span class="comment">//位图</span></span><br><span class="line"><span class="type">size_t</span> _N;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_bloomfilter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">bloomfilter&lt;std::string&gt; <span class="title">bf</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">bf.<span class="built_in">set</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">bf.<span class="built_in">set</span>(<span class="string">&quot;aadd&quot;</span>);</span><br><span class="line">bf.<span class="built_in">set</span>(<span class="string">&quot;bcad&quot;</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; bf.<span class="built_in">test</span>(<span class="string">&quot;abcd&quot;</span>) &lt;&lt; endl; <span class="comment">//能找到</span></span><br><span class="line">cout &lt;&lt; bf.<span class="built_in">test</span>(<span class="string">&quot;aadd&quot;</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; bf.<span class="built_in">test</span>(<span class="string">&quot;bcad&quot;</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; bf.<span class="built_in">test</span>(<span class="string">&quot;cdbc&quot;</span>) &lt;&lt; endl;<span class="comment">//返回0找不到</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>其原理大概就是一个数据通过多个哈希函数(优质算法)映射到不同的位置<br>两个不同的数据映射位置完全相同的概率非常低(有可能不同数据映射相同位置)</p></blockquote><p>优点</p><blockquote><p>节省空间,高效,可以标记存储任何类型,<br>增查效率有O(K),k&#x3D;&#x3D;哈希函数个数</p></blockquote><p>缺点</p><blockquote><p>有误判(可以创建白名单:将可能出现误判的数据存入)<br>无法获取数据本身<br>一般情况无法删除数据<br>通过计数删除可能有计数环绕问题(8-&gt;0)</p></blockquote><p>计数删除:比特位扩展一个计数器(还要考虑要占几个bit位),便可以支持删除,不过哈希冲突仍然存在</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟实现 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希</title>
      <link href="/2023/10/21/cpp-%E5%93%88%E5%B8%8C/"/>
      <url>/2023/10/21/cpp-%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、哈希的基本介绍"><a href="#一、哈希的基本介绍" class="headerlink" title="一、哈希的基本介绍"></a>一、哈希的基本介绍</h1><hr><p>性能上</p><blockquote><p>查找数据，哈希时间复杂度为O(1)<br>大量随机数据插入，map和set性能快<br>大量随机数据删除，map和set性能快</p></blockquote><p>哈希映射方法</p><blockquote><p>1.直接定址法:每个值都有自己唯一的位置<br>优点:无哈希冲突,简单且均匀<br>缺点:如果空间分散会有很大的空间浪费<br>适应于范围小且连续的情况</p></blockquote><blockquote><p>2,除留余数法<br>优点:空间合适且不浪费过多的空间<br>缺点:可能存在有相同的映射地址(哈希冲突)</p></blockquote><p>哈希大部分都围绕着解决哈希冲突</p><blockquote><p>1.闭散列:冲突后占用下一个空位置<br>缺点：查找效率变低，互相冲突导致插入逻辑复杂<br>线性探测:线性找下一个空位置,++<br>二次探测:平方步调找下一个位置,^2</p></blockquote><blockquote><p>2.开散列(哈希桶)(拉链法):冲突的位置下加上链表(哈希桶),由此STL中并没有双向迭代器<br>缺点:链表太长有效率问题<br>优点:冲突不会相互影响</p></blockquote><hr><h1 id="二、闭散列的哈希表实现"><a href="#二、闭散列的哈希表实现" class="headerlink" title="二、闭散列的哈希表实现"></a>二、闭散列的哈希表实现</h1><hr><p>实际中开散列应用情况优于闭散列,点一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">KeyToCmp</span> <span class="comment">//得到可以进行比较的数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> K&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">size_t</span>)k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">KeyToCmp</span>&lt;string&gt; <span class="comment">//特化一个string的仿函数,使得字符也能有其映射的地址</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : k)</span><br><span class="line">&#123;</span><br><span class="line">hash += e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">State</span></span><br><span class="line">&#123;</span><br><span class="line">EMPTY,</span><br><span class="line">EXIST,</span><br><span class="line">DELETE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashData</span></span><br><span class="line">&#123;</span><br><span class="line">pair&lt;K,V&gt; _kv;</span><br><span class="line">State _state = EMPTY; <span class="comment">//通过加入状态成员来方便进行增删查改</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>,<span class="keyword">class</span> <span class="title class_">Hash</span> = KeyToCmp&lt;<span class="type">int</span>&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> HashTable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> HashData&lt;K,V&gt; Data;</span><br><span class="line"></span><br><span class="line"><span class="built_in">HashTable</span>() <span class="comment">//构造</span></span><br><span class="line">&#123;</span><br><span class="line">_tables.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子 = 表中数据/表的大小  衡量哈希表满的程度</span></span><br><span class="line"><span class="comment">//负载因子越大,插入数据越容易发生哈希冲突,冲突越多,效率越低</span></span><br><span class="line"><span class="comment">//所以哈希表并不是满了才增容,一般负载因子在0.7左右就开始增容</span></span><br><span class="line"><span class="comment">//控制的太小,会使得空间浪费</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> pair&lt;K,V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Find</span>(kv.first) != <span class="literal">nullptr</span>) <span class="comment">//已经有了</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_num * <span class="number">10</span> / _tables.<span class="built_in">size</span>() &gt;= <span class="number">7</span>) <span class="comment">//负载因子大了,开始增容</span></span><br><span class="line">&#123;</span><br><span class="line">HashTable&lt;K, V, Hash&gt; tmp;</span><br><span class="line">tmp._tables.<span class="built_in">resize</span>(<span class="number">2</span> * _tables.<span class="built_in">size</span>()); <span class="comment">//新创建一个哈希表,将其数组空间扩大至旧哈希表的两倍</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : _tables)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (e._state == EXIST) <span class="comment">//如果有数据</span></span><br><span class="line">tmp.<span class="built_in">Insert</span>(e._kv); <span class="comment">//插入,扩容已经在上面完成了,递归时判断增容条件进不去,不会造成死循环</span></span><br><span class="line">&#125;</span><br><span class="line">_tables.<span class="built_in">swap</span>(tmp._tables);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Hash get;</span><br><span class="line"><span class="type">size_t</span> index = <span class="built_in">get</span>(kv.first) % _tables.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (_tables[index]._state == EXIST)</span><br><span class="line">&#123;</span><br><span class="line">index++;</span><br><span class="line">index %= _tables.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_tables[index]._kv = kv;</span><br><span class="line">_tables[index]._state = EXIST;</span><br><span class="line">_num++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Data* <span class="title">Find</span><span class="params">(<span class="type">const</span> K&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Hash get;</span><br><span class="line"><span class="type">size_t</span> index = <span class="built_in">get</span>(k) % _tables.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (_tables[index]._state != EMPTY)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_tables[index]._state == EXIST &amp;&amp; _tables[index]._kv.first == k)</span><br><span class="line"><span class="keyword">return</span> &amp;_tables[index];</span><br><span class="line">index++;</span><br><span class="line">index %= _tables.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">//哈希冲突是连续的,如果第一个后面为空,说明后面也没有冲突的情况,直接返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Erase</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Data* ret = <span class="built_in">Find</span>(kv.first);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">ret-&gt;_state = DELETE;</span><br><span class="line">--_num;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;Data&gt; _tables;</span><br><span class="line"><span class="type">size_t</span> _num = <span class="number">0</span>; <span class="comment">//存储当前存储有效数据的个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="三、开散列模拟实现unordered-xxx"><a href="#三、开散列模拟实现unordered-xxx" class="headerlink" title="三、开散列模拟实现unordered_xxx"></a>三、开散列模拟实现unordered_xxx</h1><hr><p>unordered_xxx底层都是由开散列实现的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BsyOpen</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GetWay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> K&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">//特化处理字符串,使得其返回值能够被模</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GetWay</span>&lt;string&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> way = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; k.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">way *= <span class="number">131</span>; <span class="comment">//BKDR Hash,使得哈希冲突降低</span></span><br><span class="line">way += k[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> way;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">//一个哈希表节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashNode</span> </span><br><span class="line">&#123;</span><br><span class="line">T _data;</span><br><span class="line">HashNode&lt;T&gt;* _next;</span><br><span class="line"><span class="comment">//我们自己实现的哈希输出,并非输入的顺序,如果要实现按输入顺序输出就要多指针</span></span><br><span class="line"><span class="comment">//HashNode&lt;T&gt;* _linknext; //以按顺序输出</span></span><br><span class="line"><span class="comment">//HashNode&lt;T&gt;* _linkprev; //以删除</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">HashNode</span>(<span class="type">const</span> T&amp; data)</span><br><span class="line">:_data(data)</span><br><span class="line">,_next(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置声明一下, 否则在迭代器类中, 无法识别出HashTable是什么</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">TheKey</span>, <span class="keyword">class</span> <span class="title class_">GetWayy</span>&gt; <span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">TheKey</span>,<span class="keyword">class</span> <span class="title class_">GetWayy</span>&gt; <span class="comment">//哈希表迭代器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__HashIterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> __HashIterator&lt; K, T, TheKey, GetWayy&gt; Self;</span><br><span class="line"><span class="keyword">typedef</span> HashTable&lt;K, T, TheKey, GetWayy&gt; HT;</span><br><span class="line"><span class="keyword">typedef</span> HashNode&lt;T&gt; Node;</span><br><span class="line">Node* _node;</span><br><span class="line">HT* _pht; <span class="comment">//以便在后续operator++中起到作用</span></span><br><span class="line"></span><br><span class="line">__HashIterator(Node* node,HT* pht)</span><br><span class="line">:_node(node)</span><br><span class="line">,_pht(pht)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;_node-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Self <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_node-&gt;_next)</span><br><span class="line">&#123;</span><br><span class="line">_node = _node-&gt;_next; <span class="comment">//如果桶没走完接着往下走</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">TheKey thekey;</span><br><span class="line">GetWayy getway;</span><br><span class="line"><span class="comment">//计算数值应该位于哪个头节点</span></span><br><span class="line"><span class="type">size_t</span> i = <span class="built_in">getway</span>(<span class="built_in">thekey</span>(_node-&gt;_data)) % _pht-&gt;_tables.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">//size_t i = GetWayy()(TheKey()(_node-&gt;_data)) % _pht-&gt;_tables.size();</span></span><br><span class="line">i++; <span class="comment">//现在i就是下一个需要验证是否为空的数组下标</span></span><br><span class="line"><span class="keyword">for</span> (; i &lt; _pht-&gt;_tables.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">Node* cur = _pht-&gt;_tables[i];</span><br><span class="line"><span class="keyword">if</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">_node = cur;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时说明没有下一个节点了</span></span><br><span class="line">_node = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Self&amp; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node != s._node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">TheKey</span>,<span class="keyword">class</span> <span class="title class_">GetWayy</span>&gt; <span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">struct</span> <span class="title class_">__HashIterator</span>&lt; K, T, TheKey, GetWayy&gt;;</span><br><span class="line"><span class="keyword">typedef</span> HashNode&lt;T&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> __HashIterator&lt; K, T, TheKey,GetWayy&gt; iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _tables.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_tables[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(_tables[i],<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="literal">nullptr</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">HashTable</span>() <span class="comment">//销毁完桶之后,,析构自动销毁this,即vector会随着析构函数销毁</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _tables.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">Node* cur = _tables[i];</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">Node* next = cur-&gt;_next;</span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line">_tables[i] = <span class="literal">nullptr</span>; <span class="comment">//使得无法访问每个头节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">GetNextPrime</span><span class="params">(<span class="type">size_t</span> num)</span> <span class="comment">//这是一种算法,使得可以减小哈希冲突</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> primecount = <span class="number">28</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> primelist[primecount] = <span class="comment">//二倍关系质数表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="number">53</span>,<span class="number">97</span>,<span class="number">193</span>,<span class="number">389</span>,<span class="number">769</span>,</span><br><span class="line"><span class="number">1543</span>,<span class="number">3079</span>,<span class="number">6151</span>,<span class="number">12289</span>,<span class="number">24593</span>,</span><br><span class="line"><span class="number">49157</span>,<span class="number">98317</span>,<span class="number">1996613</span>,<span class="number">393241</span>,<span class="number">786433</span>,</span><br><span class="line"><span class="number">1572869</span>,<span class="number">3145739</span>,<span class="number">6291469</span>,<span class="number">12582917</span>,<span class="number">25165843</span>,</span><br><span class="line"><span class="number">50331653</span>,<span class="number">100663319</span>,<span class="number">201326611</span>,<span class="number">402653189</span>,<span class="number">805306457</span>,</span><br><span class="line"><span class="number">1610612741</span>,<span class="number">3221225473</span>,<span class="number">4294967291</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; primecount; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (primelist[i] &gt; num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> primelist[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> primelist[primecount - <span class="number">1</span>]; <span class="comment">//如果还大,就一直返回最后一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">Insert</span><span class="params">(<span class="type">const</span> T&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TheKey thekey;</span><br><span class="line">GetWayy getway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_num == _tables.<span class="built_in">size</span>()) <span class="comment">//此时负载因子为1,避免以后造成大量冲突,增容</span></span><br><span class="line">&#123;</span><br><span class="line">vector&lt;Node*&gt; newtable;</span><br><span class="line"><span class="type">size_t</span> newsize = <span class="built_in">GetNextPrime</span>(_num);</span><br><span class="line">newtable.<span class="built_in">resize</span>(newsize);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _tables.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">Node* cur = _tables[i]; <span class="comment">//取每个头</span></span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//旧表取下重新计算新表中的位置</span></span><br><span class="line">Node* next = cur-&gt;_next;</span><br><span class="line"><span class="type">size_t</span> index = <span class="built_in">getway</span>(<span class="built_in">thekey</span>(cur-&gt;_data)) % newtable.<span class="built_in">size</span>(); <span class="comment">//新表中的位置</span></span><br><span class="line">cur-&gt;_next = newtable[index]; <span class="comment">//头插进去</span></span><br><span class="line">newtable[index] = cur;</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line">_tables[i] = <span class="literal">nullptr</span>; </span><br><span class="line">&#125;</span><br><span class="line">_tables.<span class="built_in">swap</span>(newtable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> index = <span class="built_in">getway</span>(<span class="built_in">thekey</span>(data)) % _tables.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">Node* cur = _tables[index];</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">thekey</span>(cur-&gt;_data) == <span class="built_in">thekey</span>(data)) <span class="comment">//重复了,不插入,结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="built_in">iterator</span>(cur,<span class="keyword">this</span>),<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cur = cur-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检验完后走到这里说明可以插入了</span></span><br><span class="line"><span class="comment">//选择头插,因为有头节点的位置,不用找尾</span></span><br><span class="line">Node* newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(data);</span><br><span class="line">newnode-&gt;_next = _tables[index];</span><br><span class="line">_tables[index] = newnode;</span><br><span class="line"></span><br><span class="line">++_num;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="built_in">iterator</span>(newnode, <span class="keyword">this</span>), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">Find</span><span class="params">(<span class="type">const</span> K&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TheKey thekey;</span><br><span class="line">GetWayy getway;</span><br><span class="line"><span class="type">size_t</span> index = <span class="built_in">getway</span>(k) % _tables.<span class="built_in">size</span>();</span><br><span class="line">Node* cur = _tables[index];</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">thekey</span>(cur-&gt;_data) == k)</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cur = cur-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Erase</span><span class="params">(<span class="type">const</span> K&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TheKey thekey;</span><br><span class="line">GetWayy getway;</span><br><span class="line"><span class="type">size_t</span> index = <span class="built_in">getway</span>(k) % _tables.<span class="built_in">size</span>();</span><br><span class="line">Node* prev = <span class="literal">nullptr</span>;</span><br><span class="line">Node* cur = _tables[index]; <span class="comment">//找到需要找到数据的头</span></span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">thekey</span>(cur-&gt;_data) == k)<span class="comment">//找到了</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (prev == <span class="literal">nullptr</span>) <span class="comment">//说明要删除的对象就是第一个节点</span></span><br><span class="line">_tables[index] = cur-&gt;_next;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">prev-&gt;_next = cur-&gt;_next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">prev = cur;</span><br><span class="line">cur = cur-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;Node*&gt; _tables;</span><br><span class="line"><span class="type">size_t</span> _num = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-unordered-set"><a href="#1-unordered-set" class="headerlink" title="1.unordered_set"></a>1.unordered_set</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Open_Hash.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Bsy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">GetWayy</span> = BsyOpen::GetWay&lt;K&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unordered_set</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> TheKeyOfSet</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> K&amp; <span class="built_in">operator</span>()(<span class="type">const</span> K&amp; k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> BsyOpen::HashTable&lt;K, K, TheKeyOfSet, GetWayy&gt;::iterator iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _ht.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _ht.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _ht.<span class="built_in">Insert</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BsyOpen::HashTable&lt;K, K, TheKeyOfSet,GetWayy&gt; _ht;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_unordered_set1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != s.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-unordered-map"><a href="#2-unordered-map" class="headerlink" title="2.unordered_map"></a>2.unordered_map</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Open_Hash.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Bsy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">GetWayy</span> = BsyOpen::GetWay&lt;K&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unordered_map</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> TheKeyOfMap</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> K&amp; <span class="built_in">operator</span>()(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> kv.first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> BsyOpen::HashTable&lt;K, pair&lt;K,V&gt;, TheKeyOfMap, GetWayy&gt;::iterator iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _ht.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _ht.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _ht.<span class="built_in">Insert</span>(kv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V&amp; <span class="keyword">operator</span>[](<span class="type">const</span> K&amp; k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//pair&lt;iterator, bool&gt; ret = _ht.Insert(make_pair(k, V()));</span></span><br><span class="line"><span class="comment">//return ret.first-&gt;second;</span></span><br><span class="line"><span class="keyword">return</span> _ht.<span class="built_in">Insert</span>(<span class="built_in">make_pair</span>(k, <span class="built_in">V</span>())).first-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BsyOpen::HashTable&lt;K, pair&lt;K, V&gt;, TheKeyOfMap,GetWayy&gt; _ht;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_unordered_map1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">unordered_map&lt;string, string&gt; dict;</span><br><span class="line">dict.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;sort&quot;</span>, <span class="string">&quot;paixu&quot;</span>));</span><br><span class="line">dict.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;left&quot;</span>, <span class="string">&quot;zuo&quot;</span>));</span><br><span class="line">dict.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;long&quot;</span>, <span class="string">&quot;chang&quot;</span>));</span><br><span class="line">dict[<span class="string">&quot;left&quot;</span>] = <span class="string">&quot;you&quot;</span>;</span><br><span class="line">dict[<span class="string">&quot;hash&quot;</span>] = <span class="string">&quot;haxi&quot;</span>;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;string, string&gt;::iterator it = dict.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != dict.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;it-&gt;second&lt;&lt; endl;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟实现 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map,set</title>
      <link href="/2023/10/21/cpp-map-set/"/>
      <url>/2023/10/21/cpp-map-set/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、set"><a href="#一、set" class="headerlink" title="一、set"></a>一、set</h1><hr><h2 id="1-set简介和基本用法"><a href="#1-set简介和基本用法" class="headerlink" title="1.set简介和基本用法"></a>1.set简介和基本用法</h2><hr><blockquote><p>set底层的实现就是红黑树</p></blockquote><p>相较于算法中的  find O(N)<br>set用AVL树实现的find可以达到 O(logN)<br>用红黑树实现的find可以达到O(2logN)</p><p>将数据放入set中后会自动去重排序</p><hr><h2 id="2-multiset"><a href="#2-multiset" class="headerlink" title="2.multiset"></a>2.multiset</h2><blockquote><p>相较于set少了去重的部分,可以让数据重复</p></blockquote><p>find,erase等成员删除的都是中序遍历中第一个成员</p><hr><h1 id="二、map"><a href="#二、map" class="headerlink" title="二、map"></a>二、map</h1><hr><h2 id="1-pair-键值对"><a href="#1-pair-键值对" class="headerlink" title="1.pair(键值对)"></a>1.pair(键值对)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> T1 first_type;</span><br><span class="line"><span class="keyword">typedef</span> T2 second_type;</span><br><span class="line"></span><br><span class="line">T1 first;</span><br><span class="line">T2 second;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pair</span>()</span><br><span class="line">:<span class="built_in">first</span>(<span class="built_in">T1</span>()) <span class="comment">//传入类型默认值构造</span></span><br><span class="line">,<span class="built_in">second</span>(<span class="built_in">T2</span>())</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pair</span>(<span class="type">const</span> T1&amp; a,<span class="type">const</span> T2&amp; b)</span><br><span class="line">:<span class="built_in">first</span>(a)</span><br><span class="line">,<span class="built_in">second</span>(b)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-插入"><a href="#2-插入" class="headerlink" title="2.插入"></a>2.插入</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">//相当于传入pair临时构造的匿名对象</span></span><br><span class="line"><span class="comment">//pair构造函数,构造一个匿名对象</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">2</span>));      <span class="comment">//函数 模板 构造一个pair对象</span></span><br><span class="line"><span class="comment">//实际上更推荐用make_pair,不用声明模板参数,自动推断</span></span><br></pre></td></tr></table></figure><p>map的插入返回值为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">Insert</span><span class="params">(<span class="type">const</span> T&amp; data)</span></span></span><br><span class="line"><span class="function"><span class="comment">//当插入的数在map中没有时,则插入成功,返回插入val的迭代器(引用),和true</span></span></span><br><span class="line"><span class="function"><span class="comment">//当插入的数在map中已经有了,则插入失败,返回已经和val相同值的迭代器(引用),和false</span></span></span><br></pre></td></tr></table></figure><p>作为其operator[]的底层</p><hr><h2 id="3-operator"><a href="#3-operator" class="headerlink" title="3.operator[]"></a>3.operator[]</h2><hr><p>map用来计数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; countmap;</span><br><span class="line">string strs[] = &#123; <span class="string">&quot;iphone&quot;</span>,<span class="string">&quot;iphone&quot;</span>,<span class="string">&quot;huawei&quot;</span>,<span class="string">&quot;honor&quot;</span>,<span class="string">&quot;huawei&quot;</span>,<span class="string">&quot;summim&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : strs)</span><br><span class="line">&#123;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::iterator ret = countmap.<span class="built_in">find</span>(e);</span><br><span class="line"><span class="keyword">if</span> (ret != countmap.<span class="built_in">end</span>())</span><br><span class="line"><span class="comment">//(*ret).second++;</span></span><br><span class="line">ret-&gt;second++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">countmap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(e, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : countmap)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; e.first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; e.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用operator[]更加便捷</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; countmap;</span><br><span class="line">string strs[] = &#123; <span class="string">&quot;iphone&quot;</span>,<span class="string">&quot;iphone&quot;</span>,<span class="string">&quot;huawei&quot;</span>,<span class="string">&quot;honor&quot;</span>,<span class="string">&quot;huawei&quot;</span>,<span class="string">&quot;summim&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : strs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果不在map中,则operator[]会插入pair&lt;str,0&gt; (0 == int() 即默认类型值)  返回映射对象(次数)的引用并且++</span></span><br><span class="line"><span class="comment">//如果在map中,则operator[]返回key对应的映射对象(次数)的应用,对其++</span></span><br><span class="line">countmap[e]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>operator的底层可以看作为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mapped_type&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type&amp; k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (*((<span class="keyword">this</span>-&gt;<span class="built_in">insert</span> (<span class="built_in">make_pair</span>(k, <span class="built_in">mapped_type</span>()) )).first)).second;</span><br><span class="line"><span class="comment">//this-&gt;insert (make_pair(k, mapped_type()) 返回值为 pair&lt;map&lt;string,int&gt;::iterator,bool&gt;</span></span><br><span class="line"><span class="comment">//.first                                    取 map&lt;string,int&gt;::iterator</span></span><br><span class="line"><span class="comment">//*取 pair&lt;key_type,mapped_type&gt;</span></span><br><span class="line"><span class="comment">//.second取 mapped_type 并返回其引用</span></span><br><span class="line"><span class="comment">//返回引用的作用是,方便对其进行以后的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所以operator有三种用途<br>1.插入<br>2.查找k对应的映射对象<br>3.修改k对应的映射对象的值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; countmap;</span><br><span class="line">countmap[<span class="string">&quot;vivo&quot;</span>];     <span class="comment">//插入</span></span><br><span class="line">countmap[<span class="string">&quot;vivo&quot;</span>] = <span class="number">1</span>; <span class="comment">//修改</span></span><br><span class="line">cout &lt;&lt; countmap[<span class="string">&quot;vivo&quot;</span>] &lt;&lt; endl; <span class="comment">//查找</span></span><br><span class="line">countmap[<span class="string">&quot;oppo&quot;</span>] = <span class="number">2</span>; <span class="comment">//插入+修改</span></span><br><span class="line"></span><br><span class="line">map&lt;string, string&gt; dict;</span><br><span class="line">dict.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;string&quot;</span>, <span class="string">&quot;字符串&quot;</span>));</span><br><span class="line">dict[<span class="string">&quot;string&quot;</span>] = <span class="string">&quot;字字符串&quot;</span>;</span><br><span class="line">dict[<span class="string">&quot;sort&quot;</span>] = <span class="string">&quot;排序&quot;</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="4-multimap"><a href="#4-multimap" class="headerlink" title="4.multimap"></a>4.multimap</h2><blockquote><p>multimap也是去掉了查重的功能,但没有 operator[]<br>当有多个相同的键值时,不知道返回哪一个对应的val</p></blockquote><hr><h1 id="三、模拟实现set-map"><a href="#三、模拟实现set-map" class="headerlink" title="三、模拟实现set,map"></a>三、模拟实现set,map</h1><hr><p>底层都是由红黑树实现的,为了方便了解逻辑,删除了红黑树部分接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__BRTreeIterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> BRTreeNode &lt;T&gt; Node;</span><br><span class="line">Node* _node;</span><br><span class="line"><span class="keyword">typedef</span> __BRTreeIterator&lt;T, Ref, Ptr&gt; Self;</span><br><span class="line"><span class="keyword">typedef</span> __BRTreeIterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line"></span><br><span class="line">__BRTreeIterator(Node* node)</span><br><span class="line">:_node(node)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通迭代器时，是拷贝构造</span></span><br><span class="line"><span class="comment">//const迭代器，指出迭代器构造const迭代器</span></span><br><span class="line">__BRTreeIterator(<span class="type">const</span> iterator&amp; s)</span><br><span class="line">:_node(s._node)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Ref <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ptr <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;_node-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Self <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_node-&gt;_right)</span><br><span class="line">&#123;</span><br><span class="line">Node* min = _node-&gt;_right;</span><br><span class="line"><span class="keyword">while</span> (min-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">min = min-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line">_node = min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node* cur = _node;</span><br><span class="line">Node* parent = cur-&gt;_parent;</span><br><span class="line"><span class="keyword">while</span> (parent &amp;&amp; cur == parent-&gt;_right)</span><br><span class="line">&#123;</span><br><span class="line">cur = parent;</span><br><span class="line">parent = parent-&gt;_parent;</span><br><span class="line">&#125;</span><br><span class="line">_node = parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Self <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_node-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">Node* max = _node-&gt;_left;</span><br><span class="line"><span class="keyword">while</span> (max-&gt;_right)</span><br><span class="line">&#123;</span><br><span class="line">max = max-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line">_node = max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node* cur = _node;</span><br><span class="line">Node* parent = cur-&gt;_parent;</span><br><span class="line"><span class="keyword">while</span> (parent &amp;&amp; cur == parent-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">cur = parent;</span><br><span class="line">parent = parent-&gt;_parent;</span><br><span class="line">&#125;</span><br><span class="line">_node = parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Self&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node != s._node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Self&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node == s._node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">KeyOfT</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BRTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> BRTreeNode&lt;T&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> __BRTreeIterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line"><span class="keyword">typedef</span> __BRTreeIterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* left = _root;</span><br><span class="line"><span class="keyword">while</span> (left &amp;&amp; left-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">left = left-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* left = _root;</span><br><span class="line"><span class="keyword">while</span> (left &amp;&amp; left-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">left = left-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">const_iterator</span>(left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">const_iterator</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">Insert</span><span class="params">(<span class="type">const</span> T&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="keyword">new</span> <span class="built_in">Node</span>(data);</span><br><span class="line">_root-&gt;_col = Black;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="built_in">iterator</span>(_root), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">KeyOfT kot;</span><br><span class="line"><span class="comment">//父子节点确定插入的位置</span></span><br><span class="line">Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">Node* cur = _root;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">kot</span>(cur-&gt;_data) &gt; <span class="built_in">kot</span>(data))</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">kot</span>(cur-&gt;_data) &lt; <span class="built_in">kot</span>(data))</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="built_in">iterator</span>(cur), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//走到这cur就是要插入的位置</span></span><br><span class="line"><span class="comment">//cur要连接parent，parent也要连接cur---判断靠kv的大小</span></span><br><span class="line">cur = <span class="keyword">new</span> <span class="built_in">Node</span>(data);</span><br><span class="line">Node* newnode = cur;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">kot</span>(parent-&gt;_data) &gt; <span class="built_in">kot</span>(cur-&gt;_data))</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_left = cur;</span><br><span class="line">cur-&gt;_parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_right = cur;</span><br><span class="line">cur-&gt;_parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (parent &amp;&amp; parent-&gt;_col == Red)</span><br><span class="line">&#123;</span><br><span class="line">Node* grandparent = parent-&gt;_parent;</span><br><span class="line"><span class="comment">//parent分在grandparent左右</span></span><br><span class="line"><span class="keyword">if</span> (grandparent-&gt;_left == parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//关键是看uncle节点不存在/红色/黑色的情况</span></span><br><span class="line">Node* uncle = grandparent-&gt;_right;</span><br><span class="line"><span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;_col == Red)</span><br><span class="line">&#123;</span><br><span class="line">grandparent-&gt;_col = Red;</span><br><span class="line">parent-&gt;_col = uncle-&gt;_col = Black;</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="built_in">iterator</span>(newnode), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-set"><a href="#1-set" class="headerlink" title="1.set"></a>1.set</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RBTree.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="number">9</span>TSe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SetKeyOfT</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> K&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> BRTree&lt;K, K, SetKeyOfT&gt;::const_iterator iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> BRTree&lt;K, K, SetKeyOfT&gt;::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">Insert</span><span class="params">(<span class="type">const</span> K&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">Insert</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BRTree&lt;K, K, SetKeyOfT&gt; <span class="type">_t</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>set内数据本身是不能修改的<br>否则会破坏树的结构<br>所以迭代器都是由红黑树的const_iterator构成的</p></blockquote><hr><h2 id="2-map"><a href="#2-map" class="headerlink" title="2.map"></a>2.map</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RBTree.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="number">9</span>TSe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Map</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MapKeyOfT</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> kv.first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">V&amp; <span class="keyword">operator</span>[](<span class="type">const</span> K&amp; k)</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;iterator, <span class="type">bool</span>&gt; ret = <span class="built_in">Insert</span>(<span class="built_in">make_pair</span>(k, <span class="built_in">V</span>()));</span><br><span class="line"><span class="keyword">return</span> ret.first-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> BRTree&lt;K, pair&lt;<span class="type">const</span> K, V&gt;, MapKeyOfT&gt;::iterator iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> BRTree&lt;K, pair&lt;<span class="type">const</span> K, V&gt;, MapKeyOfT&gt;::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">Insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">Insert</span>(kv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BRTree&lt;K, pair&lt;<span class="type">const</span> K, V&gt;, MapKeyOfT&gt; <span class="type">_t</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟实现 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/2023/10/21/cpp-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2023/10/21/cpp-%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、红黑树简介"><a href="#一、红黑树简介" class="headerlink" title="一、红黑树简介"></a>一、红黑树简介</h1><hr><p>红黑树的规则有</p><blockquote><p>1.每个节点不是红色就是黑色<br>2.根节点是黑色<br>3.如果一个节点是红色，它的两个孩子节点是黑色<br>4.每条路径都有相同数量的黑色节点<br>5.叶子节点(Nullptr节点)是黑的</p></blockquote><p>这些规则可以推导出红黑树的特性</p><blockquote><p>其最长路径不超过最短路径的两倍,近似平衡<br>没有连续的红节点<br>左右子树的黑节点个数相同</p></blockquote><p>其相较于AVL树并没有过多的旋转<br>用较不平衡换取了性能</p><p>在实际中,红黑树的应用相较于AVL树更加常用</p><hr><h1 id="二、红黑树的模拟实现"><a href="#二、红黑树的模拟实现" class="headerlink" title="二、红黑树的模拟实现"></a>二、红黑树的模拟实现</h1><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">Red,</span><br><span class="line">Black</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">RBTreeNode* _left;</span><br><span class="line">RBTreeNode* _right;</span><br><span class="line">RBTreeNode* _parent;</span><br><span class="line"></span><br><span class="line">Color _col;</span><br><span class="line">pair&lt;K, V&gt; _kv;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RBTreeNode</span>(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span><br><span class="line">:_left(<span class="literal">nullptr</span>)</span><br><span class="line">, _right(<span class="literal">nullptr</span>)</span><br><span class="line">, _parent(<span class="literal">nullptr</span>)</span><br><span class="line">, _col(Red)</span><br><span class="line">, _kv(kv)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">//定义一个节点时要注意其颜色：不过黑红的地位有所不同，选择决定后续的执行是否简单</span></span><br><span class="line"><span class="comment">//选择红色：违背红色不能连续出现</span></span><br><span class="line"><span class="comment">//选择黑色：违背整体路径黑色数量一致</span></span><br><span class="line"><span class="comment">//红色更好，红色调节节点即可，黑色调节整个路径</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RBTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> RBTreeNode&lt;K, V&gt; Node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="keyword">new</span> <span class="built_in">Node</span>(kv);</span><br><span class="line">_root-&gt;_col = Black;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* cur = _root;</span><br><span class="line">Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_kv.first &gt; kv.first)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_kv.first &lt; kv.first)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到需要插入的位置后</span></span><br><span class="line">cur = <span class="keyword">new</span> <span class="built_in">Node</span>(kv);   <span class="comment">//默认插入为红色</span></span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_kv.first &gt; parent-&gt;_kv.first)</span><br><span class="line">parent-&gt;_right = cur;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">parent-&gt;_left = cur;</span><br><span class="line">cur-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始处理颜色</span></span><br><span class="line"><span class="keyword">while</span> (parent &amp;&amp; parent-&gt;_col == Red) <span class="comment">//</span></span><br><span class="line">&#123;</span><br><span class="line">Node* grandpa = parent-&gt;_parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分两种情况,更方便旋转,父在左 or 父在右</span></span><br><span class="line"><span class="keyword">if</span> (grandpa-&gt;_left == parent) <span class="comment">//父在左</span></span><br><span class="line">&#123;</span><br><span class="line">Node* uncle = grandpa-&gt;_right;</span><br><span class="line"><span class="comment">//情况1:uncle不为空且为红色</span></span><br><span class="line"><span class="comment">//parent和uncle变黑,grandpa变红</span></span><br><span class="line"><span class="comment">//grandpa的父亲为黑,停止</span></span><br><span class="line"><span class="comment">//grandpa的父亲为红,继续向上</span></span><br><span class="line"><span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;_col == Red) <span class="comment">//uncle不为空且为红</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_col = uncle-&gt;_col = Black;</span><br><span class="line">grandpa-&gt;_col = Red;</span><br><span class="line"></span><br><span class="line">cur = grandpa;</span><br><span class="line">grandpa = cur-&gt;_parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况2:uncle为空或者为黑色</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == parent-&gt;_right) <span class="comment">//此时需要双旋</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">RotateL</span>(parent); <span class="comment">//左旋</span></span><br><span class="line"><span class="built_in">swap</span>(parent, cur); <span class="comment">//cur和parent进行交换,使得变得和单旋时的条件一样,一举两得</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">RotateR</span>(grandpa);</span><br><span class="line">parent-&gt;_col = Black;</span><br><span class="line">grandpa-&gt;_col = Red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//处理完直接跳出来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//父在右</span></span><br><span class="line">&#123;</span><br><span class="line">Node* uncle = grandpa-&gt;_left;</span><br><span class="line"><span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;_col == Red)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_col = uncle-&gt;_col = Black;</span><br><span class="line">grandpa-&gt;_col = Red;</span><br><span class="line"></span><br><span class="line">cur = grandpa;</span><br><span class="line">grandpa = cur-&gt;_parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == parent-&gt;_left) <span class="comment">//双旋</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">RotateR</span>(parent);</span><br><span class="line"><span class="built_in">swap</span>(parent, cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">RotateL</span>(grandpa);</span><br><span class="line">grandpa-&gt;_col = Red;</span><br><span class="line">parent-&gt;_col = Black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">_root-&gt;_col = Black; <span class="comment">//确保根节点为黑,流氓方法</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_Print(_root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Inspect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _Inspect(_root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _Print(Node*&amp; cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">_Print(cur-&gt;_left);</span><br><span class="line">cout &lt;&lt; cur-&gt;_kv.first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">_Print(cur-&gt;_right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateL</span><span class="params">(Node*&amp; parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* pparent = parent-&gt;_parent;</span><br><span class="line">Node* subR = parent-&gt;_right;</span><br><span class="line">Node* subRL = subR-&gt;_left;</span><br><span class="line"><span class="keyword">if</span> (pparent == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = subR;</span><br><span class="line">subR-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pparent-&gt;_left == parent)</span><br><span class="line">pparent-&gt;_left = subR;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pparent-&gt;_right = subR;</span><br><span class="line">subR-&gt;_parent = pparent;</span><br><span class="line">&#125;</span><br><span class="line">parent-&gt;_parent = subR;</span><br><span class="line">subR-&gt;_left = parent;</span><br><span class="line">parent-&gt;_right = subRL;</span><br><span class="line"><span class="keyword">if</span> (subRL != <span class="literal">nullptr</span>)</span><br><span class="line">subRL-&gt;_parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateR</span><span class="params">(Node*&amp; parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* pparent = parent-&gt;_parent;</span><br><span class="line">Node* subL = parent-&gt;_left;</span><br><span class="line">Node* subLR = subL-&gt;_right;</span><br><span class="line"><span class="keyword">if</span> (pparent == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = subL;</span><br><span class="line">subL-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pparent-&gt;_left == parent)</span><br><span class="line">pparent-&gt;_left = subL;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pparent-&gt;_right = subL;</span><br><span class="line">subL-&gt;_parent = pparent;</span><br><span class="line">&#125;</span><br><span class="line">parent-&gt;_parent = subL;</span><br><span class="line">subL-&gt;_right = parent;</span><br><span class="line">parent-&gt;_left = subLR;</span><br><span class="line"><span class="keyword">if</span> (subLR != <span class="literal">nullptr</span>)</span><br><span class="line">subLR-&gt;_parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(Node* root, <span class="type">size_t</span>&amp; reference, <span class="type">size_t</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num != reference)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;路径长度有问题&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_col == Red &amp;&amp; root-&gt;_parent &amp;&amp; root-&gt;_parent-&gt;_col == Red)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;节点连续红色&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_col == Black)</span><br><span class="line">num++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">check</span>(root-&gt;_left, reference, num) &amp;&amp; <span class="built_in">check</span>(root-&gt;_right, reference, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> _Inspect(Node* root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//空树也是红黑树</span></span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测根节点是否为黑色</span></span><br><span class="line"><span class="keyword">if</span> (_root-&gt;_col != Black)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;根节点是红色的&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> leftNum = <span class="number">0</span>;</span><br><span class="line">Node* cur = _root;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_col == Black)</span><br><span class="line">leftNum++;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测所有路径黑色节点的数量是否一样</span></span><br><span class="line"><span class="comment">//检测相邻节点是不是都是红色的</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">check</span>(_root, leftNum, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="三、双红色问题解决原理图"><a href="#三、双红色问题解决原理图" class="headerlink" title="三、双红色问题解决原理图"></a>三、双红色问题解决原理图</h1><hr><h2 id="1-叔父同色"><a href="#1-叔父同色" class="headerlink" title="1.叔父同色"></a>1.叔父同色</h2><p><img src="/img/4.8.png" alt="在这里插入图片描述"></p><h2 id="2-叔不存在或为黑-单旋"><a href="#2-叔不存在或为黑-单旋" class="headerlink" title="2.叔不存在或为黑,单旋"></a>2.叔不存在或为黑,单旋</h2><p><img src="/img/4.9.png" alt="在这里插入图片描述"></p><h2 id="3-叔不存在或为黑-双旋"><a href="#3-叔不存在或为黑-双旋" class="headerlink" title="3.叔不存在或为黑,双旋"></a>3.叔不存在或为黑,双旋</h2><p><img src="/img/4.10.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟实现 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AVL树</title>
      <link href="/2023/10/21/cpp-AVL%E6%A0%91/"/>
      <url>/2023/10/21/cpp-AVL%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、模拟实现AVL树"><a href="#一、模拟实现AVL树" class="headerlink" title="一、模拟实现AVL树"></a>一、模拟实现AVL树</h1><hr><blockquote><p>AVL树就是高度平衡二叉搜索树<br>所有树的左右子树高度差不超过1<br>平衡因子 &#x3D; 右子树高度 - 左子树高度</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">AVLTreeNode&lt;K, V&gt;* _left;</span><br><span class="line">AVLTreeNode&lt;K, V&gt;* _right;</span><br><span class="line">AVLTreeNode&lt;K, V&gt;* _parent; <span class="comment">//三叉链</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _bf; <span class="comment">//平衡因子  balance factor</span></span><br><span class="line">pair&lt;K, V&gt; _kv;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVLTreeNode</span>(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span><br><span class="line">:_left(<span class="literal">nullptr</span>)</span><br><span class="line">,_right(<span class="literal">nullptr</span>)</span><br><span class="line">,_parent(<span class="literal">nullptr</span>)</span><br><span class="line">,_bf(<span class="number">0</span>)</span><br><span class="line">,_kv(kv)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> AVLTreeNode&lt;K, V&gt; Node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> pair&lt;K,V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="keyword">new</span> <span class="built_in">Node</span>(kv);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">Node* cur = _root;</span><br><span class="line"><span class="keyword">while</span> (cur!=<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_kv.first &gt; kv.first)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_kv.first &lt; kv.first)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = <span class="keyword">new</span> <span class="built_in">Node</span>(kv);</span><br><span class="line"><span class="comment">//开始连接</span></span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_kv.first &gt; parent-&gt;_kv.first)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_right = cur;</span><br><span class="line">cur-&gt;_parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_left = cur;</span><br><span class="line">cur-&gt;_parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.cur是parent的左,parent-&gt;_bf--,是右则++;</span></span><br><span class="line"><span class="comment">//2.更新后的_bf如果是0,说明parent高度没有发生变化 : 更新前_bf为 -1/1 ,变为0说明把矮的那边填上</span></span><br><span class="line"><span class="comment">//3.更新后的_bf为-1/1,说明parent变高了,继续向上更新</span></span><br><span class="line"><span class="comment">//4.更新后的_bf为-2/2,说明parent的子树出现了不平衡,需要进行旋转处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始更新平衡因子</span></span><br><span class="line"><span class="keyword">while</span> (parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == parent-&gt;_right)</span><br><span class="line">parent-&gt;_bf++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">parent-&gt;_bf--;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_bf == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//parent所在的子树高度没有变化,更新结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">1</span> || parent-&gt;_bf == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//parent所在的子树变高了,需要继续向上进行更新</span></span><br><span class="line">cur = parent;</span><br><span class="line">parent = parent-&gt;_parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">2</span> || parent-&gt;_bf == <span class="number">-2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//parent所在的子树出现了不平衡,需要旋转更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//右重,向左压,左单旋</span></span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_bf == <span class="number">2</span> &amp;&amp; cur-&gt;_bf == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">RotateL</span>(parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//左重,向右压,右单旋</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-2</span> &amp;&amp; cur-&gt;_bf == <span class="number">-1</span>)</span><br><span class="line"><span class="built_in">RotateR</span>(parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//头右重,左重,右左双旋</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">2</span> &amp;&amp; cur-&gt;_bf == <span class="number">-1</span>)</span><br><span class="line"><span class="built_in">RotateRL</span>(parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//头左重,右重,左右双旋</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-2</span> &amp;&amp; cur-&gt;_bf == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">RotateLR</span>(parent);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateL</span><span class="params">(Node*&amp; parent)</span> <span class="comment">//左旋,\ 右重</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* subR = parent-&gt;_right;</span><br><span class="line">Node* subRL = subR-&gt;_left;</span><br><span class="line">Node* ppNode = parent-&gt;_parent;</span><br><span class="line"></span><br><span class="line">subR-&gt;_left = parent;</span><br><span class="line">parent-&gt;_right = subRL;</span><br><span class="line">parent-&gt;_parent = subR;</span><br><span class="line"><span class="keyword">if</span> (subRL != <span class="literal">nullptr</span>) <span class="comment">//当其为空时不用赋值,且赋值时会访问错误 : nullptr-&gt;_parent</span></span><br><span class="line">&#123;</span><br><span class="line">subRL-&gt;_parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ppNode == <span class="literal">nullptr</span>) <span class="comment">//parent就是根</span></span><br><span class="line">&#123;</span><br><span class="line">_root = subR;</span><br><span class="line">subR-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//parent是子树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ppNode-&gt;_left == parent)</span><br><span class="line">ppNode-&gt;_left = subR;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ppNode-&gt;_right = subR;</span><br><span class="line"></span><br><span class="line">subR-&gt;_parent = ppNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">subR-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateR</span><span class="params">(Node*&amp; parent)</span> <span class="comment">//右旋,/ 左重 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* subL = parent-&gt;_left;</span><br><span class="line">Node* subLR = subL-&gt;_right;</span><br><span class="line">Node* ppNode = parent-&gt;_parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ppNode == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = subL;</span><br><span class="line">subL-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ppNode-&gt;_left == parent)</span><br><span class="line">ppNode-&gt;_left = subL;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ppNode-&gt;_right = subL;</span><br><span class="line"></span><br><span class="line">subL-&gt;_parent = ppNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (subLR != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">subLR-&gt;_parent = parent;</span><br><span class="line">&#125;</span><br><span class="line">parent-&gt;_left = subLR;</span><br><span class="line">parent-&gt;_parent = subL;</span><br><span class="line">subL-&gt;_right = parent;</span><br><span class="line"></span><br><span class="line">parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">subL-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateRL</span><span class="params">(Node*&amp; parent)</span> <span class="comment">//先右单旋再左单旋 \ </span></span></span><br><span class="line"><span class="function">                         <span class="comment">//                 /\;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* subR = parent-&gt;_right;</span><br><span class="line">Node* subRL = subR-&gt;_left;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tmp_bf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (subRL-&gt;_left == <span class="literal">nullptr</span> &amp;&amp; subRL-&gt;_right == <span class="literal">nullptr</span>) <span class="comment">//subRL无子树时,其他树也无子树,相当于只有三棵树</span></span><br><span class="line">&#123;</span><br><span class="line">tmp_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp_bf = subRL-&gt;_bf; <span class="comment">//通过判断tmp_bf大小来对旋转后的各树_bf进行不一样的赋值方式 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RotateR</span>(subR);   <span class="comment">//注意传入的参数</span></span><br><span class="line"><span class="built_in">RotateL</span>(parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmp_bf == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">subR-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tmp_bf == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_bf = <span class="number">-1</span>;</span><br><span class="line">subR-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tmp_bf == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">subR-&gt;_bf = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">subRL-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateLR</span><span class="params">(Node*&amp; parent)</span><span class="comment">//先左单旋再右单旋 / </span></span></span><br><span class="line"><span class="function">                         <span class="comment">//              /\;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* subL = parent-&gt;_left;</span><br><span class="line">Node* subLR = subL-&gt;_right;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tmp_bf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (subLR-&gt;_left == <span class="literal">nullptr</span> &amp;&amp; subLR-&gt;_right == <span class="literal">nullptr</span>)</span><br><span class="line">tmp_bf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tmp_bf = subLR-&gt;_bf;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RotateL</span>(subL);</span><br><span class="line"><span class="built_in">RotateR</span>(parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmp_bf == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">subL-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tmp_bf == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">subL-&gt;_bf = <span class="number">-1</span>;</span><br><span class="line">parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tmp_bf == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">subL-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">parent-&gt;_bf = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">subLR-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_Print(_root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _Print(Node*&amp; cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">_Print(cur-&gt;_left);</span><br><span class="line">cout &lt;&lt; cur-&gt;_kv.first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; cur-&gt;_kv.second &lt;&lt; endl;</span><br><span class="line">_Print(cur-&gt;_right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Height</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> left = <span class="number">1</span> + <span class="built_in">Height</span>(root-&gt;_left);</span><br><span class="line"><span class="type">int</span> right = <span class="number">1</span> + <span class="built_in">Height</span>(root-&gt;_right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> left &gt; right ? left : right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _Check(_root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> _Check(Node* root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> leftHeight = <span class="built_in">Height</span>(root-&gt;_left);</span><br><span class="line"><span class="type">int</span> rightHeight = <span class="built_in">Height</span>(root-&gt;_right);</span><br><span class="line"><span class="type">int</span> dif = rightHeight - leftHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dif != root-&gt;_bf)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(dif) &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Not&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _Check(root-&gt;_left) &amp;&amp; _Check(root-&gt;_right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="二、旋转原理图"><a href="#二、旋转原理图" class="headerlink" title="二、旋转原理图"></a>二、旋转原理图</h1><h2 id="1-右单旋原理图"><a href="#1-右单旋原理图" class="headerlink" title="1.右单旋原理图"></a>1.右单旋原理图</h2><p><img src="/img/4.4.png" alt="在这里插入图片描述"></p><h2 id="2-左单旋原理图"><a href="#2-左单旋原理图" class="headerlink" title="2.左单旋原理图"></a>2.左单旋原理图</h2><p><img src="/img/4.5.png" alt="在这里插入图片描述"></p><h2 id="3-右左双旋"><a href="#3-右左双旋" class="headerlink" title="3.右左双旋"></a>3.右左双旋</h2><p><img src="/img/4.6.png" alt="在这里插入图片描述"></p><h2 id="4-左右双旋"><a href="#4-左右双旋" class="headerlink" title="4.左右双旋"></a>4.左右双旋</h2><p><img src="/img/4.7.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟实现 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索二叉树</title>
      <link href="/2023/10/21/cpp-%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/10/21/cpp-%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、key模型搜索二叉树的模拟实现"><a href="#一、key模型搜索二叉树的模拟实现" class="headerlink" title="一、key模型搜索二叉树的模拟实现"></a>一、key模型搜索二叉树的模拟实现</h1><hr><h2 id="1-非递归实现"><a href="#1-非递归实现" class="headerlink" title="1.非递归实现"></a>1.非递归实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BSTNode</span> <span class="comment">//binary search tree</span></span><br><span class="line">&#123;</span><br><span class="line">BSTNode* _left;</span><br><span class="line">BSTNode* _right;</span><br><span class="line">K _key;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BSTNode</span>(<span class="type">const</span> K&amp; key)</span><br><span class="line">:_left(<span class="literal">nullptr</span>)</span><br><span class="line">,_right(<span class="literal">nullptr</span>)</span><br><span class="line">,_key(key)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> BSTNode&lt;K&gt; Node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> K&amp; key)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">Node* cur = _root;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = <span class="keyword">new</span> <span class="built_in">Node</span>(key);          <span class="comment">//找到位置后进行链接</span></span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_key &gt; parent-&gt;_key) <span class="comment">//判定插在左或者右</span></span><br><span class="line">parent-&gt;_right = cur;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">parent-&gt;_left = cur;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* cur = _root;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_key &gt; key)</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_key &lt; key)</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* cur = _root;</span><br><span class="line">Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//由于要用双指针,所以不能直接用Find来执行这一部分</span></span><br><span class="line"><span class="keyword">while</span> (cur!=<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//找到了</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.无左无右</span></span><br><span class="line"><span class="comment">//2.都有</span></span><br><span class="line"><span class="keyword">if</span>(cur-&gt;_left == <span class="literal">nullptr</span>) <span class="comment">//无左,和无左无右</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == _root) <span class="comment">//如果要删除的就是根</span></span><br><span class="line">&#123;</span><br><span class="line">_root = cur -&gt; _right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_right == cur)</span><br><span class="line">parent-&gt;_right = cur-&gt;_right;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">parent-&gt;_left = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_right == <span class="literal">nullptr</span>) <span class="comment">//无右</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == _root)</span><br><span class="line">&#123;</span><br><span class="line">_root = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_right == cur)</span><br><span class="line">parent-&gt;_right = cur-&gt;_left;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">parent-&gt;_left = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//找到左树最右叶,或者右树最左叶,替换cur</span></span><br><span class="line">&#123;</span><br><span class="line">Node* rightmin = cur-&gt;_right;</span><br><span class="line">Node* rightminparent = cur;</span><br><span class="line"><span class="keyword">while</span> (rightmin-&gt;_left != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">rightminparent = rightmin;</span><br><span class="line">rightmin = rightmin-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line">cur-&gt;_key = rightmin-&gt;_key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换为删除rightmin(rightmin左为空,删除他的右)</span></span><br><span class="line"><span class="keyword">if</span>(rightmin == rightminparent-&gt;_left) <span class="comment">//如果进入了循环</span></span><br><span class="line">rightminparent-&gt;_left = rightmin-&gt;_right;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">rightminparent-&gt;_right = rightmin-&gt;_right;</span><br><span class="line"><span class="keyword">delete</span> rightmin;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _InOrder(Node* root) <span class="comment">//中序打印数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">_InOrder(root-&gt;_left);</span><br><span class="line">cout &lt;&lt; root-&gt;_key &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">_InOrder(root-&gt;_right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">()</span> <span class="comment">//使中序打印函数使用更方便</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_InOrder(_root);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-递归实现"><a href="#2-递归实现" class="headerlink" title="2.递归实现"></a>2.递归实现</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BSTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">BSTreeNode</span>(<span class="type">const</span> K&amp; key)</span><br><span class="line">:_key(key)</span><br><span class="line">, _left(<span class="literal">nullptr</span>)</span><br><span class="line">, _right(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line">BSTreeNode&lt;K&gt;* _left;</span><br><span class="line">BSTreeNode&lt;K&gt;* _right;</span><br><span class="line">K _key;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> BSTreeNode&lt;K&gt; Node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BSTree</span>()</span><br><span class="line">:_root(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">Copy</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">Node* newroot = <span class="keyword">new</span> <span class="built_in">Node</span>(root-&gt;_key);</span><br><span class="line">newroot-&gt;_left = <span class="built_in">Copy</span>(root-&gt;_left);</span><br><span class="line">newroot-&gt;_right = <span class="built_in">Copy</span>(root-&gt;_right);</span><br><span class="line"><span class="keyword">return</span> newroot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BSTree</span>(<span class="type">const</span> BSTree&lt;K&gt;&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="built_in">Copy</span>(t._root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BSTree&lt;K&gt;&amp; <span class="keyword">operator</span>=(BSTree&lt;K&gt; t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(_root, t._root);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Destory</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Destory</span>(root-&gt;_left);</span><br><span class="line"><span class="built_in">Destory</span>(root-&gt;_right);</span><br><span class="line"><span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">BSTree</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Destory</span>(_root);</span><br><span class="line">_root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _Print(Node* root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">_Print(root-&gt;_left);</span><br><span class="line">cout &lt;&lt; root-&gt;_key &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">_Print(root-&gt;_right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_Print(_root);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> _InsertR(Node* root, <span class="type">const</span> K&amp; k, Node*&amp; parent)</span><br><span class="line">&#123;</span><br><span class="line">Node* cur = root;</span><br><span class="line"><span class="keyword">if</span> (cur != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_key &gt; k)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">_InsertR(cur-&gt;_left, k, parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_key &lt; k)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">_InsertR(cur-&gt;_right, k, parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cur = <span class="keyword">new</span> <span class="built_in">Node</span>(k);</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_key &gt; k)</span><br><span class="line">parent-&gt;_left = cur;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">parent-&gt;_right = cur;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;_key == k)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> K&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="keyword">new</span> <span class="built_in">Node</span>(k);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> _InsertR(_root, k, parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//进阶思路----引用的使用</span></span><br><span class="line"><span class="type">bool</span> _InsertR(Node*&amp; root, <span class="type">const</span> K&amp; k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">root = <span class="keyword">new</span> <span class="built_in">Node</span>(k); <span class="comment">//这里要修改指针指向的内容,所以要传指针的指针类型的参数(*&amp; || **)</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;_key &lt; k)</span><br><span class="line"><span class="keyword">return</span> _InsertR(root-&gt;_right, k);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;_key &gt; k)</span><br><span class="line"><span class="keyword">return</span> _InsertR(root-&gt;_left, k);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> K&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _InsertR(_root, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> _Find(Node* root, <span class="type">const</span> K&amp; k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;_key &gt; k)</span><br><span class="line">_Find(root-&gt;_left, k);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;_key &lt; k)</span><br><span class="line">_Find(root-&gt;_left, k);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">const</span> K&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _Find(_root, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> _Erase(Node*&amp; root, <span class="type">const</span> K&amp; k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_key &gt; k)</span><br><span class="line">_Erase(root-&gt;_left, k);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;_key &lt; k)</span><br><span class="line">_Erase(root-&gt;_right, k);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node* del = root; <span class="comment">//root的key对应k</span></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_left == <span class="literal">nullptr</span>)</span><br><span class="line">root = root-&gt;_right;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;_right == <span class="literal">nullptr</span>)</span><br><span class="line">root = root-&gt;_left;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node* minRight = root-&gt;_right;</span><br><span class="line"><span class="keyword">while</span> (minRight-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">minRight = minRight-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(root-&gt;_key, minRight-&gt;_key);</span><br><span class="line"><span class="keyword">return</span> _Erase(root-&gt;_right, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> del;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Erase</span><span class="params">(<span class="type">const</span> K&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _Erase(_root, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="二、Key-Value-模型搜索二叉树的模拟实现"><a href="#二、Key-Value-模型搜索二叉树的模拟实现" class="headerlink" title="二、Key&#x2F;Value 模型搜索二叉树的模拟实现"></a>二、Key&#x2F;Value 模型搜索二叉树的模拟实现</h1><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BSTNode</span> <span class="comment">//binary search tree</span></span><br><span class="line">&#123;</span><br><span class="line">BSTNode* _left;</span><br><span class="line">BSTNode* _right;</span><br><span class="line">K _key;</span><br><span class="line">V _value;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BSTNode</span>(<span class="type">const</span> K&amp; key,<span class="type">const</span> V&amp; value)</span><br><span class="line">: _left(<span class="literal">nullptr</span>)</span><br><span class="line">, _right(<span class="literal">nullptr</span>)</span><br><span class="line">, _key(key)</span><br><span class="line">, _value(value)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> BSTNode&lt;K,V&gt; Node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> K&amp; key,<span class="type">const</span> V&amp; value)</span> <span class="comment">//插入数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="keyword">new</span> <span class="built_in">Node</span>(key,value); <span class="comment">//new 自动调用构造函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">Node* cur = _root;</span><br><span class="line"><span class="keyword">while</span> (cur) <span class="comment">//cur为空时结束</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = <span class="keyword">new</span> <span class="built_in">Node</span>(key,value);          <span class="comment">//找到位置后进行链接</span></span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_key &gt; parent-&gt;_key) <span class="comment">//判定插在左或者右</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_right = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_left = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">Find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* cur = _root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_key &gt; key)</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_key &lt; key)</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* cur = _root;</span><br><span class="line">Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//由于要用双指针,所以不能直接用Find来执行这一部分</span></span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//找到了</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.无左无右</span></span><br><span class="line"><span class="comment">//2.都有</span></span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_left == <span class="literal">nullptr</span>) <span class="comment">//无左,和无左无右</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == _root) <span class="comment">//如果要删除的就是根</span></span><br><span class="line">&#123;</span><br><span class="line">_root = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_right == cur)</span><br><span class="line">parent-&gt;_right = cur-&gt;_right;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">parent-&gt;_left = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_right == <span class="literal">nullptr</span>) <span class="comment">//无右</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == _root)</span><br><span class="line">&#123;</span><br><span class="line">_root = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_right == cur)</span><br><span class="line">parent-&gt;_right = cur-&gt;_left;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">parent-&gt;_left = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//找到左树最右叶,或者右树最左叶,替换cur</span></span><br><span class="line">&#123;</span><br><span class="line">Node* rightmin = cur-&gt;_right;</span><br><span class="line">Node* rightminparent = cur;</span><br><span class="line"><span class="keyword">while</span> (rightmin-&gt;_left != <span class="literal">nullptr</span>) </span><br><span class="line">&#123;</span><br><span class="line">rightminparent = rightmin;</span><br><span class="line">rightmin = rightmin-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur-&gt;_key = rightmin-&gt;_key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换为删除rightmin(rightmin左为空,删除他的右)</span></span><br><span class="line"><span class="keyword">if</span> (rightmin == rightminparent-&gt;_left) <span class="comment">//如果进入while循环</span></span><br><span class="line">rightminparent-&gt;_left = rightmin-&gt;_right;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">rightminparent-&gt;_right = rightmin-&gt;_right;</span><br><span class="line"><span class="keyword">delete</span> rightmin;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _InOrder(Node* root) <span class="comment">//中序打印数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">_InOrder(root-&gt;_left);</span><br><span class="line">cout &lt;&lt; root-&gt;_key &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; root-&gt;_value &lt;&lt; endl;</span><br><span class="line">_InOrder(root-&gt;_right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">()</span> <span class="comment">//使中序打印函数使用更方便</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_InOrder(_root);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_BST3</span><span class="params">()</span> <span class="comment">//key/value模型可以做简单的英译汉</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BSTree&lt;string, string&gt; dict;</span><br><span class="line">dict.<span class="built_in">Insert</span>(<span class="string">&quot;sort&quot;</span>, <span class="string">&quot;排序&quot;</span>);</span><br><span class="line">dict.<span class="built_in">Insert</span>(<span class="string">&quot;int&quot;</span>, <span class="string">&quot;整形&quot;</span>);</span><br><span class="line">dict.<span class="built_in">Insert</span>(<span class="string">&quot;computer&quot;</span>, <span class="string">&quot;计算机&quot;</span>);</span><br><span class="line">dict.<span class="built_in">Insert</span>(<span class="string">&quot;mouse&quot;</span>, <span class="string">&quot;老鼠&quot;</span>);</span><br><span class="line"></span><br><span class="line">string eng;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; eng)</span><br><span class="line">&#123;</span><br><span class="line">BSTNode&lt;string, string&gt;* ret = dict.<span class="built_in">Find</span>(eng);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">cout &lt;&lt; ret-&gt;_value &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Not Found&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_BST4</span><span class="params">()</span><span class="comment">//也可以做到统计数据出现次数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string Arr[] = &#123; <span class="string">&quot;hehe&quot;</span>,<span class="string">&quot;haha&quot;</span>, <span class="string">&quot;haha&quot;</span>, <span class="string">&quot;hehe&quot;</span>, <span class="string">&quot;hehe&quot;</span>&#125;;</span><br><span class="line">BSTree&lt;string, <span class="type">int</span>&gt; CountV;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> str : Arr)</span><br><span class="line">&#123;</span><br><span class="line">BSTNode&lt;string, <span class="type">int</span>&gt;* ret = CountV.<span class="built_in">Find</span>(str);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">ret-&gt;_value++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">CountV.<span class="built_in">Insert</span>(str, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">CountV.<span class="built_in">InOrder</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟实现 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承</title>
      <link href="/2023/10/21/cpp-%E7%BB%A7%E6%89%BF/"/>
      <url>/2023/10/21/cpp-%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、继承方式和访问方式"><a href="#一、继承方式和访问方式" class="headerlink" title="一、继承方式和访问方式"></a>一、继承方式和访问方式</h1><hr><p>注意:<code>友元不能继承</code>,<code>静态成员只会在父类创造一次</code></p><blockquote><p>父类如果用private修饰的成员,子类无法访问<br>protected修饰的子类可以访问,但除此之外不可访问</p></blockquote><blockquote><p>继承方式为private,struct为public ,一般继承方式都为public<br>基类的成员在子类的访问方式 &#x3D; &#x3D;&#x3D;Min(成员在基类的访问限定符,继承方式)</p></blockquote><hr><h1 id="二、赋值兼容规则"><a href="#二、赋值兼容规则" class="headerlink" title="二、赋值兼容规则"></a>二、赋值兼容规则</h1><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1.子类对象可以赋值给父类对象/指针/引用</span></span><br><span class="line">person p;</span><br><span class="line">student s;</span><br><span class="line">p = s;<span class="comment">//对象赋值</span></span><br><span class="line">s = p;<span class="comment">//不行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子类赋值给父类,通过切割(切片)可以进行赋值</span></span><br><span class="line">person* ptr = &amp;s; <span class="comment">//指针</span></span><br><span class="line">person&amp; ref = s;  <span class="comment">//引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//student* sptr = &amp;p;//父类赋值给子类,不行</span></span><br><span class="line"></span><br><span class="line">student* sptr = (student*)&amp;s; <span class="comment">//ptr指向的本来就是子类,强制转换下可以赋值</span></span><br><span class="line"></span><br><span class="line">sptr = (student*)&amp;p; <span class="comment">//强行转换可以运行,但容易导致越界访问,访问到子类独有的类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以通过C++11中的类型操作符来进行试探</span></span><br><span class="line">sptr = <span class="built_in">dynamic_cast</span>&lt;student*&gt;(ptr); <span class="comment">//注意此时父类必须有虚函数构成多态</span></span><br><span class="line"><span class="comment">//如果ptr指向父类,返回nullptr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//student&amp; sref = p;//引用赋值,不行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="三、默认函数的继承"><a href="#三、默认函数的继承" class="headerlink" title="三、默认函数的继承"></a>三、默认函数的继承</h1><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>(<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;peter&quot;</span>)</span><br><span class="line">:_name(name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;person()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">person</span>(<span class="type">const</span> person&amp; p)</span><br><span class="line">:_name(p._name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;person(const person&amp; p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;person&amp; operator=(const person&amp; p)&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">_name = p._name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~person()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> : <span class="keyword">public</span> person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">student</span>(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> num)</span><br><span class="line">:<span class="comment">//_name(name) 父类归父类管,所以这样初始化错误</span></span><br><span class="line"><span class="built_in">person</span>(name) <span class="comment">//直接调用父类的构造就行了</span></span><br><span class="line">, _num(num)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;student()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">student</span>(<span class="type">const</span> student&amp; s)</span><br><span class="line">:<span class="comment">//_name(s._name)</span></span><br><span class="line"><span class="built_in">person</span>(s) <span class="comment">//同上</span></span><br><span class="line">,_num(s._num)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;student(const student&amp; s)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student&amp; <span class="keyword">operator</span>=(<span class="type">const</span> student&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;student&amp; operator=(const student&amp; s)&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//operator=(s); 此时会无限递归,自己调用自己,要声明域才行</span></span><br><span class="line">person::<span class="keyword">operator</span>=(s);</span><br><span class="line">_num = s._num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">student</span>() <span class="comment">//子类的析构函数和父类的析构函数构成 隐藏(重定义) ,他们的名字会被编译器同一处理成destructor </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//person::~person(); //派生类没必要再调用父类的析构函数,析构的顺序不对,不符合栈形式</span></span><br><span class="line"><span class="comment">//结束时会自动调用父类的析构函数,因为这样才能保证先析构子类,再析构父类</span></span><br><span class="line"><span class="comment">//并且如果再调用会导致重复释放同一块空间</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~student()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">student <span class="title">s1</span><span class="params">(<span class="string">&quot;jack&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">student <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="function">student <span class="title">s3</span><span class="params">(<span class="string">&quot;rose&quot;</span>, <span class="number">19</span>)</span></span>;</span><br><span class="line">s1 = s3;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="四、不能被继承的类"><a href="#四、不能被继承的类" class="headerlink" title="四、不能被继承的类"></a>四、不能被继承的类</h1><hr><blockquote><p>1.将父类全部私有,使得子类无法调用父类的析构<br>2.利用final关键字</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">final</span>&#123;<span class="keyword">public</span>:<span class="built_in">A</span>()&#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A&#123;&#125;; <span class="comment">//此时B就无法继承A</span></span><br></pre></td></tr></table></figure><hr><h1 id="五、菱形继承"><a href="#五、菱形继承" class="headerlink" title="五、菱形继承"></a>五、菱形继承</h1><hr><h2 id="1-菱形继承的问题"><a href="#1-菱形继承的问题" class="headerlink" title="1.菱形继承的问题"></a>1.菱形继承的问题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单继承:一个子类只有一个直接定义父类时称为单继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> : <span class="keyword">public</span> person&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span> : <span class="keyword">public</span> student&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承:一个子类有两个以上或以上直接父类时称为多继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">assistant</span> : <span class="keyword">public</span> student,<span class="keyword">public</span> teacher&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菱形继承</span></span><br><span class="line">                          <span class="keyword">class</span> <span class="title class_">person</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> : <span class="keyword">public</span> person &#123;&#125;;    <span class="keyword">class</span> <span class="title class_">teacher</span> : <span class="keyword">public</span> student &#123;&#125;;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">assistant</span> : <span class="keyword">public</span> student, <span class="keyword">public</span> teacher &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菱形继承的问题是:数据冗余和二义性</span></span><br></pre></td></tr></table></figure><blockquote><p>菱形继承时有两个问题<br>数据冗余:即派生类有多份相同类型的数据<br>二义性:   即因为有多相同类型的数据而导致对数据处理时,不知道要处理谁</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> person <span class="comment">//中间人都加上virtual 即可解决</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> person <span class="comment">//中间人都加上virtual 即可解决</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">assistant</span> : <span class="keyword">public</span> student, <span class="keyword">public</span> teacher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _course;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assistant a;</span><br><span class="line">a._name = <span class="string">&quot;peter&quot;</span>; <span class="comment">//此时二义性导致不知道要赋给哪个_name,加上关键词virtual即可解决二义性和冗余性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示指定访问可以解决,但是冗余性还是没有解决(两个name)</span></span><br><span class="line">a.student::_name = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">a.teacher::_name = <span class="string">&quot;yyy&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-菱形继承virtual解决的原理"><a href="#2-菱形继承virtual解决的原理" class="headerlink" title="2.菱形继承virtual解决的原理"></a>2.菱形继承virtual解决的原理</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _a;</span><br><span class="line"> <span class="comment">//int _a[10000];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">D d;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(d) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">d.B::_a = <span class="number">1</span>;</span><br><span class="line">d.C::_a = <span class="number">2</span>;</span><br><span class="line">d._b = <span class="number">3</span>;</span><br><span class="line">d._c = <span class="number">4</span>;</span><br><span class="line">d._d = <span class="number">5</span>;</span><br><span class="line">d._a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所以实际上,不到万不得已,不要把类的关系设计为菱形继承</span></span><br><span class="line"><span class="comment">//virtual解决了冗余性和二义性,但是会有略微的效率损失</span></span><br><span class="line"><span class="comment">//这个例子size变大了,但是如果父类成员size很大,那么在virtual继承后会减小很多</span></span><br></pre></td></tr></table></figure><p><img src="/img/3.8.png" alt="在这里插入图片描述"></p><hr><h1 id="六、继承和组合"><a href="#六、继承和组合" class="headerlink" title="六、继承和组合"></a>六、继承和组合</h1><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;&#125;;   <span class="comment">//继承是白箱复用,父类对子类的是透明的,但是一定程度上破坏了父类的封装,继承的类是一种高耦合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span><span class="comment">//组合是黑箱封装,C对D不透明,C保持他的封装,组合的类耦合度更低</span></span><br><span class="line">&#123;C c;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//都完成了类层次的复用</span></span><br><span class="line"><span class="comment">//综合来看,还是组合合适</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//符合 is-a  使用继承  ,eg:奔驰是车</span></span><br><span class="line"><span class="comment">//符合 has-a 使用组合  ,eg:车有轮子</span></span><br><span class="line"><span class="comment">//如果都可以,优先使用组合</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/2023/10/21/cpp-%E5%A4%9A%E6%80%81/"/>
      <url>/2023/10/21/cpp-%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、虚函数"><a href="#一、虚函数" class="headerlink" title="一、虚函数"></a>一、虚函数</h1><hr><h2 id="1-重载-重写-覆盖-重定义-隐藏-的对比"><a href="#1-重载-重写-覆盖-重定义-隐藏-的对比" class="headerlink" title="1.重载,重写(覆盖),重定义(隐藏)的对比"></a>1.重载,重写(覆盖),重定义(隐藏)的对比</h2><blockquote><p>重载:        两个函数在一个作用域,函数名相同,参数不同<br>.<br>重写(覆盖):  两个函数分别在基类和派生类的作用域<br>函数名,返回类型,参数都必须相同(协变例外),两个函数必须是虚函数<br>.<br>重定义(隐藏): 两个函数分别在基类和派生类的作用域<br>函数名相同,两个基类和派生类的同名函数不构成重写(覆盖)就是重定义</p></blockquote><hr><h2 id="2-虚函数的重写"><a href="#2-虚函数的重写" class="headerlink" title="2.虚函数的重写"></a>2.虚函数的重写</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuyTicket</span><span class="params">()</span>      <span class="comment">//输出全为all</span></span></span><br><span class="line"><span class="function"><span class="comment">//virtual void BuyTicket()  //正确的输出</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;all&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> : <span class="keyword">public</span> person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuyTicket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//virtual void BuyTicket()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;half&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun1</span><span class="params">(person&amp; p)</span> <span class="comment">//注意引用  有子类赋值给父类(切割,切片)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">BuyTicket</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun2</span><span class="params">(person* p)</span> <span class="comment">//指针也可以</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p-&gt;<span class="built_in">BuyTicket</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student s;</span><br><span class="line">person p;</span><br><span class="line"><span class="built_in">Fun1</span>(s);</span><br><span class="line"><span class="built_in">Fun1</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Fun2</span>(&amp;s);</span><br><span class="line"><span class="built_in">Fun2</span>(&amp;p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//virtual 关键字: 可以修饰成员函数,为了完成虚函数的重写,满足多态的条件之一</span></span><br><span class="line"><span class="comment">//             : 可以在零菱形继承中,去完成虚继承,解决数据冗余和二义性</span></span><br><span class="line"><span class="comment">//虽然关键字一样,但他们之间没有一点关联</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态的两个条件:</span></span><br><span class="line"><span class="comment">//1.虚函数的重写</span></span><br><span class="line"><span class="comment">//2.父类对象的指针或引用去调用虚函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//满足多态:跟指向对象有关,指向哪个对象调用的就是他的虚函数</span></span><br><span class="line"><span class="comment">//不满足多态:跟对象调用的类型有关,类型是什么调用的就是谁</span></span><br></pre></td></tr></table></figure><hr><h3 id="①协变"><a href="#①协变" class="headerlink" title="①协变"></a>①协变</h3><blockquote><p>基类与派生类虚函数的返回值类型不同<br>却仍然可以构成重写</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基类虚函数返回类型为基类对象的指针或引用,派生类虚拟函数返回类型为派生类对象的指针或引用,称为协变</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> person* <span class="title">BuyTicket</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"><span class="comment">//virtual A* BuyTicket()    //而且不限于本父子类</span></span></span><br><span class="line"><span class="function"><span class="comment">//virtual B* BuyTicket()//但必须对应父子类,否则会出错</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;all&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> : <span class="keyword">public</span> person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> student* <span class="title">BuyTicket</span><span class="params">()</span> <span class="comment">//如果虚函数返回类型是基类和派生类的指针或引用时,就会构成协变,此时无错误</span></span></span><br><span class="line"><span class="function"><span class="comment">//virtual B* BuyTicket()        </span></span></span><br><span class="line"><span class="function"><span class="comment">//virtual A* BuyTicket()         </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;half&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun1</span><span class="params">(person&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">BuyTicket</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student s;</span><br><span class="line">person p;</span><br><span class="line"><span class="built_in">Fun1</span>(s);</span><br><span class="line"><span class="built_in">Fun1</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="②析构函数的重写"><a href="#②析构函数的重写" class="headerlink" title="②析构函数的重写"></a>②析构函数的重写</h3><blockquote><p>基类与派生类的函数名不同<br>但仍然可以构成重写</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//virtual ~person()</span></span><br><span class="line">~<span class="built_in">person</span>() <span class="comment">//析构函数名被编译器处理为同一名称destruct</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~person&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> : <span class="keyword">public</span> person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//virtual ~student()</span></span><br><span class="line">~<span class="built_in">student</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~student&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">person* p1 = <span class="keyword">new</span> person;</span><br><span class="line">person* p2 = <span class="keyword">new</span> student; <span class="comment">//不加virtual会使得只调用person的析构</span></span><br><span class="line">                          <span class="comment">//调用不了student的析构函数,会内存泄漏</span></span><br><span class="line"><span class="comment">//virtual: `person  `student  `person  , 感觉到了继承,根据情况调用不同的&quot;同名&quot;函数</span></span><br><span class="line"><span class="comment">//加上virtual,构成多态,调用的指针指向谁就调用谁的析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//没有virtual:  `person  `person ,            函数只调一个,知道有继承,但就是只能调一个</span></span><br><span class="line"><span class="comment">//不加上virtual,不构成多态,调用的指针类型是谁,调用的就是谁的析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="③虚函数的一些点"><a href="#③虚函数的一些点" class="headerlink" title="③虚函数的一些点"></a>③虚函数的一些点</h3><blockquote><p>虚函数有一个指针的大小<br>虚函数重写生效的只是内容,而不是参数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> val = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A-&gt;&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="comment">//传入的是对象B指针,所以调用B中的func</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> val = <span class="number">0</span>)</span> <span class="comment">//重写生效的只是内容,而不是参数,所以缺省参数中 int val = 0 无效,所以 val == 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B-&gt;&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A* p = <span class="keyword">new</span> B;</span><br><span class="line">p-&gt;<span class="built_in">test</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="④抽象类-纯虚函数"><a href="#④抽象类-纯虚函数" class="headerlink" title="④抽象类(纯虚函数)"></a>④抽象类(纯虚函数)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在虚函数后面加上 =0 ,则这个函数就是纯虚函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">car</span>  <span class="comment">//有了纯虚函数,这个类就被成为抽象类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">drive</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数,不需要实现,实现了不报错,但也没用</span></span><br><span class="line"><span class="comment">//virtual void drive() = 0 </span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;aa&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">benz</span> : <span class="keyword">public</span> car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">drive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;benz&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//car autocar; //抽象类实例化不出对象</span></span><br><span class="line">benz autoccar; <span class="comment">//抽象类的子类,也实例化不出对象,继承了纯虚函数(没有重写)</span></span><br><span class="line">               <span class="comment">//重写后即可以实例化出对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>纯虚函数的作用是</p><blockquote><p>强迫重写<br>表示抽象的类型(现实中没有对应实体的)</p></blockquote><hr><h1 id="二、两个关键字"><a href="#二、两个关键字" class="headerlink" title="二、两个关键字"></a>二、两个关键字</h1><hr><h2 id="1-final"><a href="#1-final" class="headerlink" title="1.final"></a>1.final</h2><blockquote><p>修饰虚函数:可以阻止函数被重写,final无法对类中非虚函数进行修饰<br>修饰类: 可以阻止类被继承</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuyTicket</span><span class="params">()</span> <span class="keyword">final</span> <span class="comment">//此后,该函数不能再被重写</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;all&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> : <span class="keyword">public</span> person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuyTicket</span><span class="params">()</span> <span class="comment">//此时会报错,无法继承</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;half&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">final</span>&#123;&#125;;  <span class="comment">//final后A不能被继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2-override"><a href="#2-override" class="headerlink" title="2.override"></a>2.override</h2><blockquote><p>可以检查出虚函数是否被成功重写</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//virtual void out()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;111&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">out</span><span class="params">()</span> <span class="keyword">override</span> <span class="comment">//如果检查出错则无法编译通过</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;222&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="三、多态的原理"><a href="#三、多态的原理" class="headerlink" title="三、多态的原理"></a>三、多态的原理</h1><hr><h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;base:fun1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;base:fun2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;derive:fun1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _d = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function1</span><span class="params">(base&amp; b)</span> <span class="comment">//运行时,到指向对象的虚表中,查找对应的虚函数的地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b.<span class="built_in">fun1</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多态如何实现的指向谁就调用谁的虚函数?</span></span><br><span class="line"><span class="comment">//多态是在 运行时 到指向对象的虚表中,查找要调用虚函数的地址来调用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function2</span><span class="params">(base b)</span> <span class="comment">//编译时,直接确定通过p的类型确定要调用函数的地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b.<span class="built_in">fun1</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">base b1;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(base) &lt;&lt; endl; <span class="comment">//16   8+4+对齐 == 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//监视窗口中的_vfptr就是 虚函数表指针:简称虚表指针</span></span><br><span class="line"><span class="comment">//其本质是 指针数组(虚函数指针)</span></span><br><span class="line"></span><br><span class="line">derive d1;</span><br><span class="line"><span class="built_in">function1</span>(b1);</span><br><span class="line"><span class="built_in">function1</span>(d1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类里面有一个虚表,虚表里面存的指针指向虚函数<br>重写了,子指针改变指向<br>没重写,父指哪,子指哪</p></blockquote><p><img src="/img/3.2.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">监视窗口中的_vfptr就是 虚函数表指针:简称虚表指针</span><br><span class="line">其本质是 指针数组(虚函数指针)</span><br><span class="line">一般来说对象前八个字节存的虚表指针</span><br><span class="line">虚表指针数组最后一个指针为<span class="number">0x0000000000000000</span> 表示这个虚函数数组结束了</span><br></pre></td></tr></table></figure><p><img src="/img/3.3.png" alt="在这里插入图片描述"></p><hr><h2 id="2-验证虚函数和虚表的位置都是在代码段"><a href="#2-验证虚函数和虚表的位置都是在代码段" class="headerlink" title="2.验证虚函数和虚表的位置都是在代码段"></a>2.验证虚函数和虚表的位置都是在代码段</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;base::fun1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;base::fun2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;base::fun3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;derive::fun1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _d = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">base b1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;_vftptr:%p\n&quot;</span>, *(<span class="type">double</span>*)&amp;b1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;_vftptr:%p\n&quot;</span>, *(<span class="type">long</span> <span class="type">long</span>*)&amp;b1);</span><br><span class="line"><span class="comment">//printf(&quot;_vftptr:%p\n&quot;, (long long)b1);  直接强制转换语法不接受 取对象前八个字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* p1 = &amp;i;</span><br><span class="line"><span class="type">int</span>* p2 = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p3 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;栈变量:%p\n&quot;</span>, p1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;堆变量:%p\n&quot;</span>, p2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;代码段常量:%p\n&quot;</span>, p3);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;代码段函数地址:%p\n&quot;</span>, &amp;base::fun3);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;代码段函数地址:%p\n&quot;</span>, test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">base b1;</span><br><span class="line">derive d1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//vs2022没有显示不出fun3()的情况</span></span><br><span class="line"><span class="comment">//有虚函数的对象,前八个字节是虚表指针的地址</span></span><br></pre></td></tr></table></figure><p><img src="/img/3.4.png" alt="在这里插入图片描述"></p><hr><h1 id="四、动静态绑定"><a href="#四、动静态绑定" class="headerlink" title="四、动静态绑定"></a>四、动静态绑定</h1><hr><blockquote><p>静态的绑定:编译时确定函数地址<br>动态的绑定:运行时到虚表中找虚函数的地址</p></blockquote><blockquote><p>编译时 是指: 高级语言转换为汇编语言时(初次检查错误)<br>运行时 是指: 程序开始运行,开始占用cpu和内存</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;base::fun1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;derive::fun1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _d = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">double</span> d)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态的绑定 静态的多态 (静态:编译时确定函数地址)</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="number">1.1</span>;</span><br><span class="line"><span class="built_in">f1</span>(i);</span><br><span class="line"><span class="built_in">f2</span>(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态绑定 动态的多态  (动态:运行时到虚表中找虚函数的地址)</span></span><br><span class="line">base* p = <span class="keyword">new</span> base;</span><br><span class="line">p-&gt;<span class="built_in">fun1</span>();</span><br><span class="line">p = <span class="keyword">new</span> derive;</span><br><span class="line">p-&gt;<span class="built_in">fun1</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="五、设计函数展现-vftptr所有函数"><a href="#五、设计函数展现-vftptr所有函数" class="headerlink" title="五、设计函数展现_vftptr所有函数"></a>五、设计函数展现_vftptr所有函数</h1><hr><h2 id="1-单继承展现虚表"><a href="#1-单继承展现虚表" class="headerlink" title="1. 单继承展现虚表"></a>1. 单继承展现虚表</h2><hr><p><img src="/img/3.5.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;base::fun1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;base::fun2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;derive::fun1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;derive::fun3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;derive::fun4()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void(*p)() 定义一个函数指针变量</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*VF_PTR)</span><span class="params">()</span></span>; <span class="comment">//函数指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印虚表</span></span><br><span class="line"><span class="comment">//void PrintVFTable(VF_PTR* pTable)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVFTable</span><span class="params">(VF_PTR pTable[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; pTable[i] != <span class="number">0</span>; ++i) <span class="comment">//!=nullptr也可以</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;vftabel[%d]:%p-&gt;&quot;</span>, i, pTable[i]);</span><br><span class="line">VF_PTR f = pTable[i];</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">base b;</span><br><span class="line">derive d;</span><br><span class="line"></span><br><span class="line"><span class="comment">//base的虚表</span></span><br><span class="line"><span class="built_in">PrintVFTable</span>((VF_PTR*)(*(<span class="type">long</span> <span class="type">long</span>*)&amp;b));</span><br><span class="line"><span class="built_in">PrintVFTable</span>((VF_PTR*)(*(<span class="type">void</span>**)&amp;b));</span><br><span class="line"></span><br><span class="line"><span class="comment">//derive的虚表</span></span><br><span class="line"><span class="comment">//而监视窗口只有继承下来的fun1和fun2</span></span><br><span class="line"><span class="built_in">PrintVFTable</span>((VF_PTR*)(*(<span class="type">long</span> <span class="type">long</span>*)&amp;d));</span><br><span class="line"><span class="built_in">PrintVFTable</span>((VF_PTR*)(*(<span class="type">void</span>**)&amp;d));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/3.6.png" alt="在这里插入图片描述"></p><hr><h2 id="2-多继承展现虚表"><a href="#2-多继承展现虚表" class="headerlink" title="2.多继承展现虚表"></a>2.多继承展现虚表</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;base::fun1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;base::fun2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> b1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;base::fun1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;base::fun2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> b2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">public</span> base1,<span class="keyword">public</span> base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;derive::fun1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;derive::fun3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef void (*VF_PTR)();</span></span><br><span class="line"><span class="keyword">using</span> VF_PTR = <span class="built_in">void</span>(*)(); </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVFTable</span><span class="params">(VF_PTR pTable[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; pTable[i] != <span class="literal">nullptr</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;vftabel[%d]:%p-&gt;&quot;</span>, i, pTable[i]);</span><br><span class="line">VF_PTR f = pTable[i];</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">derive d;</span><br><span class="line"><span class="comment">//base1 //监视窗口中只有fun1和fun2</span></span><br><span class="line"><span class="built_in">PrintVFTable</span>(( VF_PTR*)(*(<span class="type">void</span>**)&amp;d));</span><br><span class="line"><span class="comment">//我们发现derive的fun3存在于base1的虚表中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//base2 //监视窗口也有fun1和fun2</span></span><br><span class="line"><span class="built_in">PrintVFTable</span>((VF_PTR*)(*(<span class="type">void</span>**)((<span class="type">char</span>*)&amp;d + <span class="built_in">sizeof</span>(base1))));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/img/3.7.png" alt="在这里插入图片描述"></p><blockquote><p>子类独有的函数，存在第一个虚表中</p></blockquote><p>关于函数指针数组指针的用法</p><blockquote><p>第一种 typedef void(<em>PFUNC)();<br>第二种 using VF_PTR &#x3D; void(</em>)();</p></blockquote><p>留下了一个问题</p><blockquote><p>在64位平台下base1 和 base2的函数内部只要操作不同,就会导致 base2无法依次访问时遇见nullptr停止,但是从虚表开头开始遍历却没有问题<br>32位平台下并没有这种问题</p></blockquote><hr><h1 id="六、继承和多态"><a href="#六、继承和多态" class="headerlink" title="六、继承和多态"></a>六、继承和多态</h1><hr><h2 id="1-几个关于继承和多态的点"><a href="#1-几个关于继承和多态的点" class="headerlink" title="1.几个关于继承和多态的点"></a>1.几个关于继承和多态的点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">inline</span>函数不可以是虚函数,<span class="keyword">inline</span>函数没有地址,无法把地址放到虚函数表中</span><br><span class="line"><span class="number">2.</span>静态成员不可以是虚函数,静态成员函数没有<span class="keyword">this</span>指针,使用 类型::成员函数 的调用方式无法访问虚表,所以静态成员函数无法放进虚函数表</span><br><span class="line"><span class="number">3.</span>构造函数不可以是虚函数,对象中的虚函数表指针是在构造函数初始化列表阶段才初始化的</span><br><span class="line"><span class="number">4.</span>对象访问普通函数快还是虚函数快?</span><br><span class="line">如果是普通对象一样快;  如果是指针对象或者是引用对象,普通函数快,构成多态,运行时调用虚函数需要需要到虚表中去查找;</span><br></pre></td></tr></table></figure><hr><h2 id="2-继承多态的大小"><a href="#2-继承多态的大小" class="headerlink" title="2.继承多态的大小"></a>2.继承多态的大小</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> x = <span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;aa&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Aa</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>(<span class="type">int</span> x = <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bb&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Aa</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b;</span><br><span class="line">A a;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;A::Aa);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;B::Aa); <span class="comment">//两个地址不一样,触发了重写</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虚继承算出来大小是24 : virtual两个指针 8+8, 虚表+8 = 24</span></span><br><span class="line"><span class="comment">//不用虚继承大小是  8 :  virtual算指针8字节</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-一道题"><a href="#3-一道题" class="headerlink" title="3.一道题"></a>3.一道题</h2><p>计算输出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> <span class="type">char</span>* s) </span><br><span class="line">    &#123; </span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2)</span><br><span class="line">        :<span class="built_in">A</span>(s1) </span><br><span class="line">    &#123; </span><br><span class="line">        cout &lt;&lt; s2 &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2) </span><br><span class="line">        :<span class="built_in">A</span>(s1) </span><br><span class="line">    &#123; </span><br><span class="line">        cout &lt;&lt; s2 &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> :<span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>(<span class="type">const</span> <span class="type">char</span>* s1,<span class="type">const</span> <span class="type">char</span>* s2,<span class="type">const</span> <span class="type">char</span>* s3,<span class="type">const</span> <span class="type">char</span>* s4) </span><br><span class="line">        :<span class="built_in">B</span>(s1, s2), <span class="built_in">C</span>(s1, s3), <span class="built_in">A</span>(s1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; s4 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D* p = <span class="keyword">new</span> <span class="built_in">D</span>(<span class="string">&quot;class A&quot;</span>, <span class="string">&quot;class B&quot;</span>, <span class="string">&quot;class C&quot;</span>, <span class="string">&quot;class D&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.A只有一个，所以A只构造一次,优先A构造<br>2.初始化列表优先于函数体，D最后<br>3.构造按继承顺序，即使先C(s1，s3)，B(s1，s2) 也是B先输出，C再输出<br>所以结果为ABCD</p><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>priority_queue</title>
      <link href="/2023/10/21/cpp-priority-queue/"/>
      <url>/2023/10/21/cpp-priority-queue/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、priority-queue简介"><a href="#一、priority-queue简介" class="headerlink" title="一、priority_queue简介"></a>一、priority_queue简介</h1><hr><blockquote><p>priority_queue也是适配出来的<br>其与queue不同点在于能够排序,因为底层是由heap实现的,并且</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functionnal&gt;</span> <span class="comment">//默认仿函数 greater / less</span></span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq; <span class="comment">//此时输出默认顺序是降序的,大堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br></pre></td></tr></table></figure><hr><h1 id="二、模拟实现"><a href="#二、模拟实现" class="headerlink" title="二、模拟实现"></a>二、模拟实现</h1><hr><blockquote><p>仿函数的使用,向上向下调整算法</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="number">9</span>TSe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Container</span> = vector&lt;T&gt;,<span class="keyword">class</span> Compare = less&lt;T&gt;&gt; </span><br><span class="line"><span class="keyword">class</span> priority_queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">AdjustUp</span>(<span class="type">int</span> child)</span><br><span class="line">&#123;</span><br><span class="line">Compare com;</span><br><span class="line"><span class="type">int</span> parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (child &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//if (_con[child] &gt; _con[parent])</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">com</span>(_con[parent],_con[child]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(_con[child], _con[parent]);</span><br><span class="line">child = parent;</span><br><span class="line">parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Compare com;</span><br><span class="line"><span class="type">int</span> parent = root;</span><br><span class="line"><span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (child &lt; _con.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//选出较大的孩子</span></span><br><span class="line"><span class="comment">//if ( child + 1 &lt; _con.size() &amp;&amp; _con[child + 1] &gt; _con[child] )</span></span><br><span class="line"><span class="keyword">if</span> ( child + <span class="number">1</span> &lt; _con.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">com</span>(_con[child], _con[child + <span class="number">1</span>]))</span><br><span class="line">&#123;</span><br><span class="line">child++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if (_con[child] &gt; _con[parent])</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">com</span>(_con[parent],_con[child]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(_con[child], _con[parent]);</span><br><span class="line">parent = child;</span><br><span class="line">child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_con.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="built_in">AdjustUp</span>(_con.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">swap</span>(_con[<span class="number">0</span>], _con[_con.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">_con.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">AdjustDown</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Container _con;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仿函数(函数对象)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x1, <span class="type">const</span> T&amp; x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x1 &lt; x2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">greater</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x1, <span class="type">const</span> T&amp; x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x1 &gt; x2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="三、仿函数-lambda表达式-sort-priority-queue"><a href="#三、仿函数-lambda表达式-sort-priority-queue" class="headerlink" title="三、仿函数,lambda表达式,sort,priority_queue"></a>三、仿函数,lambda表达式,sort,priority_queue</h1><hr><p>可以通过仿函数和lambda表达式实现<br>sort的升序降序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>()) <span class="comment">//升序</span></span><br><span class="line"><span class="built_in">sort</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)&#123;<span class="keyword">return</span> a &gt; b; &#125;); <span class="comment">//变为降序</span></span><br><span class="line"><span class="built_in">sort</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());  <span class="comment">//降序</span></span><br></pre></td></tr></table></figure><p>那么priority_queue</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq; <span class="comment">//降序</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; pq; <span class="comment">//升序</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,<span class="keyword">decltype</span>([](<span class="keyword">auto</span> x,<span class="keyword">auto</span> y)&#123;<span class="keyword">return</span> x &gt; y;&#125;)&gt;pq;</span><br><span class="line"> <span class="comment">//这段代码只有C++20才支持,C++20之前不支持在priority内传入lambda表达式的类</span></span><br></pre></td></tr></table></figure><p>值得注意的是,sort和priority_queue的第三个参数并不相同<br>sort传的是对象(函数,仿函数中的结构体对象,注意有括号)<br>priority_queue传入的是类,仿函数后面没括号,是一个类型名</p><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟实现 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stack,queue,deque</title>
      <link href="/2023/10/21/cpp-stack-queue-deque/"/>
      <url>/2023/10/21/cpp-stack-queue-deque/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、适配器和迭代器"><a href="#一、适配器和迭代器" class="headerlink" title="一、适配器和迭代器"></a>一、适配器和迭代器</h1><hr><blockquote><p>迭代器模式 是STL中的迭代器在封装后不暴露内部细节，使得上层使用时达到一种统一的方法访问<br>适配器模式 是通过原内容封装转换出形式</p></blockquote><p>stack 和 queue 通过容器适配转换出来的,不是原生实现的</p><hr><h1 id="二、stack"><a href="#二、stack" class="headerlink" title="二、stack"></a>二、stack</h1><hr><p><code>stack没有迭代器</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> bsy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span> , <span class="keyword">class</span> <span class="title class_">Container</span>&gt; <span class="comment">//stack类模拟实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_con.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_con.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Container _con;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_stack1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//stack底层可以是链表也可以是vector</span></span><br><span class="line"><span class="comment">//stack&lt;int, vector&lt;int&gt; &gt; st;</span></span><br><span class="line">stack&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt; &gt; st;</span><br><span class="line">st.<span class="built_in">push</span>(<span class="number">1</span>); <span class="comment">//stack没有push_back</span></span><br><span class="line">st.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">st.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">st.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">st.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="三、queue"><a href="#三、queue" class="headerlink" title="三、queue"></a>三、queue</h1><hr><h2 id="queue没有迭代器"><a href="#queue没有迭代器" class="headerlink" title="queue没有迭代器"></a><code>queue没有迭代器</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="number">9</span>TSe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Container</span> = deque&lt;T&gt;&gt;  <span class="comment">//vector无法实现,vector没有前插前删操作,效率太低,一般是list作为底层</span></span><br><span class="line"><span class="keyword">class</span> queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">void</span> <span class="built_in">push</span>(<span class="type">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">_con.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_con.<span class="built_in">pop_front</span>();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Container _con;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_queue1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt; &gt; que;</span><br><span class="line">que.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">que.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">que.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">que.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; que.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="四、deque"><a href="#四、deque" class="headerlink" title="四、deque"></a>四、deque</h1><hr><blockquote><p>vector不支持前删前插,list不支持随机访问,但是有deque(双端队列)是其优点的集合<br>deque有迭代器</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_deque1</span><span class="params">()</span> <span class="comment">//基本使用方法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">0</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">-1</span>);</span><br><span class="line">d.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//deque既可以支持头插头删,也可以支持下标随机访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//那为什么集大成者却没有完全替代上述两种容器呢?</span></span><br><span class="line"><span class="comment">//效率上还是不如vector 和 list</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_deque2</span><span class="params">()</span> <span class="comment">//测试效率差距</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">1000000</span>;</span><br><span class="line"><span class="type">int</span>* a1 = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="type">int</span>* a2 = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"></span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">rand</span>();</span><br><span class="line">d.<span class="built_in">push_back</span>(x);</span><br><span class="line">v.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> begin1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">size_t</span> end1 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> begin2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">size_t</span> end2 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt;<span class="string">&quot;deque : &quot;</span> &lt;&lt; end1 - begin1 &lt;&lt; endl; <span class="comment">//250</span></span><br><span class="line">cout &lt;&lt;<span class="string">&quot;vector : &quot;</span> &lt;&lt; end2 - begin2 &lt;&lt; endl; <span class="comment">//50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//约有五倍的效率差</span></span><br><span class="line"><span class="comment">//随机访问的效率无法替代vector(sort底层用下标访问)</span></span><br><span class="line"><span class="comment">//头尾插入删除的效率还可以,stack和queue没有使用到它的随机访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>deque的原理是一小段数组一小段数组组成的,形状可以理解为list&lt; vector &gt; 但不是,list不支持随机访问<br>由中控管理的指针数组,存储每一个小数组的地址,且该指针数组会增容,所以数据量大的话,效率就低了<br>迭代器由四个部分组成 cur(当前位置),first(当前小数组的头位),last(当前小数组的末尾),node(中控管理的指针数组的当前访问数组的指针)<br>总之,一般来说deque不行</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟实现 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 适配器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>list</title>
      <link href="/2023/10/21/cpp-list/"/>
      <url>/2023/10/21/cpp-list/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、list要注意事项"><a href="#一、list要注意事项" class="headerlink" title="一、list要注意事项"></a>一、list要注意事项</h1><hr><h2 id="1-迭代器失效"><a href="#1-迭代器失效" class="headerlink" title="1.迭代器失效"></a>1.迭代器失效</h2><hr><blockquote><p>list没有增容销毁空间这一说,因此insert等插入不会导致失效<br>erase也是返回下一个位置的迭代器</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">it = l.<span class="built_in">erase</span>(it); <span class="comment">//erase 会导致迭代器失效</span></span><br><span class="line">                  <span class="comment">//空间被erase后不能再进行操作,即++,*;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">++it;</span><br></pre></td></tr></table></figure><hr><h2 id="2-splic-连接两个链表"><a href="#2-splic-连接两个链表" class="headerlink" title="2.splic(连接两个链表)"></a>2.splic(连接两个链表)</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; l;</span><br><span class="line">l.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">l.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">l.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">l.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt; lt;</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator pos = l.<span class="built_in">begin</span>();</span><br><span class="line">++pos;</span><br><span class="line"></span><br><span class="line">l.<span class="built_in">splice</span>(pos, lt); <span class="comment">//在 l 链表中的pos位置插入lt链表</span></span><br><span class="line"><span class="built_in">Print_list</span>(l); <span class="comment">//1 10 20 30 40 2 3 4</span></span><br><span class="line"><span class="built_in">Print_list</span>(lt); <span class="comment">//lt插入过去就没了,成了l的一部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="二、模拟实现list"><a href="#二、模拟实现list" class="headerlink" title="二、模拟实现list"></a>二、模拟实现list</h1><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="number">9</span>TSe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  <span class="comment">//一个节点的类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_node</span></span><br><span class="line">&#123;</span><br><span class="line">T _data;</span><br><span class="line">__list_node* _next;</span><br><span class="line">__list_node* _prev;</span><br><span class="line"></span><br><span class="line">__list_node(<span class="type">const</span> T&amp; x = <span class="built_in">T</span>())</span><br><span class="line">:_data(x)</span><br><span class="line">,_next(<span class="literal">nullptr</span>)</span><br><span class="line">,_prev(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt; <span class="comment">//迭代器的类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> __list_node&lt;T&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; Self;</span><br><span class="line"></span><br><span class="line">Node* _node; <span class="comment">//创建一个新节点</span></span><br><span class="line"></span><br><span class="line">__list_iterator(Node* node) <span class="comment">//构造节点</span></span><br><span class="line">:_node(node)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Ref <span class="keyword">operator</span>*()  <span class="comment">//应该还有一个const类型的此函数,但要再写一个就要再创建一个const_iterator类其他都赋值,这两个加个const</span></span><br><span class="line">&#123;             <span class="comment">//会导致代码冗余  T&amp;</span></span><br><span class="line"><span class="keyword">return</span> _node-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ptr <span class="keyword">operator</span>-&gt;()  <span class="comment">//同上,套用模板可以简写  T*</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;(_node-&gt;_data); <span class="comment">//&amp;取其地址以-&gt;,所以实际上使用应为 dit-&gt;-&gt;_year,只不过被编译器特殊处理优化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Self&amp; <span class="keyword">operator</span>++() <span class="comment">//前置++,做到能像vector一样++就访问下一个数据</span></span><br><span class="line">&#123;</span><br><span class="line">_node = _node-&gt;_next;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Self&amp; <span class="keyword">operator</span>++(<span class="type">int</span>) <span class="comment">//后置++</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//__list_iterator tmp(*this);  </span></span><br><span class="line">Self tmp = *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//_node = _node-&gt;_next;</span></span><br><span class="line">++(*<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Self&amp; <span class="keyword">operator</span>--() <span class="comment">//前置--</span></span><br><span class="line">&#123;</span><br><span class="line">_node = _node-&gt;_prev;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Self&amp; <span class="keyword">operator</span>--(<span class="type">int</span>) <span class="comment">//后置--</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Self <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="comment">//_node = _node-&gt;_prev;</span></span><br><span class="line">--(*<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Self&amp; it) <span class="comment">//迭代器循环时需要!=  记得加上const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node != it._node; <span class="comment">//迭代器(两个指针)不相同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Self&amp; it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node == it._node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">//链表的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> __list_node&lt;T&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T,T&amp;,T*&gt; iterator;</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T,<span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(_head-&gt;_next); <span class="comment">//哨兵的下一位才是数据的第一位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(_head);  <span class="comment">//哨兵就是最后一位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">const_iterator</span>(_head-&gt;_next); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">const_iterator</span>(_head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>()</span><br><span class="line">&#123;</span><br><span class="line">_head = <span class="keyword">new</span> Node;</span><br><span class="line">_head-&gt;_next = _head;</span><br><span class="line">_head-&gt;_prev = _head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="type">const</span> list&lt;T&gt;&amp; lt)</span><br><span class="line">&#123;</span><br><span class="line">_head = <span class="keyword">new</span> Node;</span><br><span class="line">_head-&gt;_next = _head;</span><br><span class="line">_head-&gt;_prev = _head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*const_iterator it = lt.begin();</span></span><br><span class="line"><span class="comment">while (it != end())</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">push_back(*it);</span></span><br><span class="line"><span class="comment">++it;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : lt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">push_back</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*list&lt;T&gt;&amp; operator=(const list&lt;T&gt;&amp; lt)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if (*this != &amp;lt)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">clear();</span></span><br><span class="line"><span class="comment">for (auto&amp; e : lt)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">push_back(e);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">return *this;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line">list&lt;T&gt;&amp; <span class="keyword">operator</span>=(list&lt;T&gt; lt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(_head, lt._head); <span class="comment">//交换指针指向的方向,即哨兵</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~<span class="built_in">list</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">clear</span>(); <span class="comment">//清楚除哨兵外的数据</span></span><br><span class="line"><span class="keyword">delete</span> _head;</span><br><span class="line">_head = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iterator it = <span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != <span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">erase</span>(it++); <span class="comment">//迭代器失效是因为,it被销毁后访问++或*,先调用重载++,后erase</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Node* tail = _head-&gt;_prev;</span></span><br><span class="line"><span class="comment">//Node* newnode = new Node(x); //括号这里讲过</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//tail-&gt;_next = newnode;</span></span><br><span class="line"><span class="comment">//newnode-&gt;_prev = tail;</span></span><br><span class="line"><span class="comment">//newnode-&gt;_next = _head;</span></span><br><span class="line"><span class="comment">//_head-&gt;_prev = newnode;</span></span><br><span class="line"><span class="built_in">insert</span>(<span class="built_in">end</span>(), x); <span class="comment">//插在哨兵前,哨兵前就是尾</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//erase(iterator(_head-&gt;_prev));</span></span><br><span class="line"><span class="built_in">erase</span>(--<span class="built_in">end</span>()); <span class="comment">//哨兵前就是最后一个数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">insert</span>(<span class="built_in">begin</span>(), x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">erase</span>(<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; x)</span> <span class="comment">//pos位置前插入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(x); <span class="comment">//这里一定要初始值x</span></span><br><span class="line">Node* cur = pos._node;</span><br><span class="line">Node* prev = cur-&gt;_prev;</span><br><span class="line">cur-&gt;_prev = newnode;</span><br><span class="line">newnode-&gt;_next = cur; <span class="comment">//1 2 3 3 4</span></span><br><span class="line">newnode-&gt;_prev = prev;</span><br><span class="line">prev-&gt;_next = newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos != <span class="built_in">end</span>()); <span class="comment">//不能删哨兵  1 2 3 3 4</span></span><br><span class="line">Node* cur = pos._node;</span><br><span class="line">Node* next = cur-&gt;_next;</span><br><span class="line">Node* prev = cur-&gt;_prev;</span><br><span class="line"><span class="keyword">delete</span> cur; <span class="comment">//可以不置空,出作用域自动销毁</span></span><br><span class="line"></span><br><span class="line">next-&gt;_prev = prev;</span><br><span class="line">prev-&gt;_next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_list1</span><span class="params">()</span> <span class="comment">//基本的遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lt;</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator lit = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (lit != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *lit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">++lit;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> _year = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> _month = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> _day = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_list2</span><span class="params">()</span> <span class="comment">//cout类的数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;Date&gt; dlt;</span><br><span class="line">dlt.<span class="built_in">push_back</span>(<span class="built_in">Date</span>());</span><br><span class="line">dlt.<span class="built_in">push_back</span>(<span class="built_in">Date</span>());</span><br><span class="line"></span><br><span class="line">list&lt;Date&gt;::iterator dit = dlt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (dit != dlt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; *dit &lt;&lt; &quot; &quot;; //此时无法输出,一个类解引用怎么得不出想要的结果</span></span><br><span class="line">cout &lt;&lt; dit-&gt;_year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; dit-&gt;_month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; dit-&gt;_day &lt;&lt; endl; <span class="comment">//这里-&gt;需要重载</span></span><br><span class="line">      <span class="comment">//  dit-&gt;  返回 Date*</span></span><br><span class="line">      <span class="comment">//所以实际上应写为 dit-&gt;-&gt;_year 为了可读性,编译器将其优化了,这样写反而会出错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt;(*dit)._year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; (*dit)._month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; (*dit)._day &lt;&lt; endl; <span class="comment">//这样写也可以</span></span><br><span class="line">      <span class="comment">//但是推荐-&gt;写法</span></span><br><span class="line"></span><br><span class="line">dit++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_list</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; lt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::const_iterator lit = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (lit != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//*lit = 1; //在修饰了lt为const,这一步却不报错且可以执行,不符合我们的要求</span></span><br><span class="line">            <span class="comment">//此时加入const_iterator begin,end,重载*和&amp;的修改</span></span><br><span class="line">cout &lt;&lt; *lit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">++lit;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_list3</span><span class="params">()</span> <span class="comment">//测试部分操作接口</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lt;</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print_list</span>(lt);</span><br><span class="line"></span><br><span class="line">lt.<span class="built_in">pop_back</span>();</span><br><span class="line">lt.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="built_in">print_list</span>(lt);</span><br><span class="line"></span><br><span class="line">lt.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">print_list</span>(lt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_list4</span><span class="params">()</span> <span class="comment">//测试默认函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lt1;</span><br><span class="line">lt1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lt1.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">lt1.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lt1.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lt2</span><span class="params">(lt1)</span></span>; <span class="comment">//之所以在重载++地方报错是因为,clear时调用++,浅拷贝释放后无法++</span></span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt; lt3;</span><br><span class="line">lt3 = lt2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print_list</span>(lt2);</span><br><span class="line"><span class="built_in">print_list</span>(lt3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Node* cur  和  iterator it   的区别</span></span><br><span class="line"><span class="comment">//他们都指向同一个节点,在物理内存中他们都是存的这个节点的地址</span></span><br><span class="line"><span class="comment">//但是他们类型不一样,他们的意义就不一样了</span></span><br><span class="line"><span class="comment">//*cur表示的是指针的解引用       ,取到的值是节点</span></span><br><span class="line"><span class="comment">//*it 表示去调用这个迭代器重载的*,返回的是节点中的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟实现 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 迭代器失效 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector</title>
      <link href="/2023/10/21/cpp-vector/"/>
      <url>/2023/10/21/cpp-vector/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、vector的注意事项"><a href="#一、vector的注意事项" class="headerlink" title="一、vector的注意事项"></a>一、vector的注意事项</h1><hr><h2 id="1-和-at-的越界访问"><a href="#1-和-at-的越界访问" class="headerlink" title="1. [] 和 at() 的越界访问"></a>1. [] 和 at() 的越界访问</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//v1[4] = 5; //越界直接结束,assert判断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">at</span>(<span class="number">4</span>) = <span class="number">5</span>; <span class="comment">//抛异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;beyond&quot;</span> &lt;&lt; endl;  <span class="comment">//输出beyond</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-迭代器失效问题"><a href="#2-迭代器失效问题" class="headerlink" title="2.迭代器失效问题"></a>2.迭代器失效问题</h2><hr><blockquote><p>简单来说就是在迭代器创建后<br>使用了reverse,resize,insert,push_back等导致的增容<br>导致迭代器仍然指向已经被释放的旧空间</p></blockquote><p><code>一个应对迭代器失效的过程</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//删除容器中所有的偶数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">erase</span>(it); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后该怎么++it?</span></span><br><span class="line"></span><br><span class="line">++it;  <span class="comment">//此时会报错,为什么?</span></span><br><span class="line">        <span class="comment">//erase删除一个数据后,其他数据向前移动,移动后其实it已经指向我们想要遍历的下一个元素</span></span><br><span class="line">        <span class="comment">//此时再++it就会导致错过部分数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">++it;  <span class="comment">//那么这样处理可以么?</span></span><br><span class="line">       <span class="comment">//Linux环境下这样可以达到目的,但是vs编译环境自动检查且较为严格,仍然报错</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//正确做法</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it2 = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it2 != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it2 % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">it2 = v.<span class="built_in">erase</span>(it2); <span class="comment">//正确做法 erase会返回删除的it的下一个位置的迭代器</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">++it2;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="二、vector的模拟实现"><a href="#二、vector的模拟实现" class="headerlink" title="二、vector的模拟实现"></a>二、vector的模拟实现</h1><hr><p>有以下要点: </p><blockquote><p>reserve中浅拷贝memmove问题<br>新型拷贝构造和重载赋值符写法<br>insert时的迭代器失效</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="number">9</span>TSe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> T* iterator; </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> T* const_iterator;</span><br><span class="line"><span class="built_in">vector</span>()</span><br><span class="line">:_start(<span class="literal">nullptr</span>)</span><br><span class="line">,_finish(<span class="literal">nullptr</span>)</span><br><span class="line">,_endofstorage(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//v2(v1)</span></span><br><span class="line"><span class="comment">//vector(const vector&lt;T&gt;&amp; v)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//_start = new T[v.capacity()];     //开辟新空间</span></span><br><span class="line"><span class="comment">//_finish = _start;</span></span><br><span class="line"><span class="comment">//_endofstorage = _start + capacity();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for (size_t i = 0; i &lt; v.size(); ++i)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//*_finish = v[i];</span></span><br><span class="line"><span class="comment">//++_finish;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造的另一种方法</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; v)</span><br><span class="line">:_start(<span class="literal">nullptr</span>)</span><br><span class="line">,_finish(<span class="literal">nullptr</span>)</span><br><span class="line">,_endofstorage(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">reserve</span>(v.<span class="built_in">capacity</span>());</span><br><span class="line"><span class="built_in">push_back</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector&lt;T&gt;&amp; operator=(const vector&lt;T&gt;&amp; v)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//if (*this != &amp;v) //防止自己赋值给自己</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//delete[] _start; //s1 = s2 s1有自己的空间,先释放</span></span><br><span class="line"><span class="comment">//_start = new T[v.capacity()];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//memcpy(_start, v._start, sizeof(T) * v.size());</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//return *this;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重载赋值运算符简便写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;T&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">::<span class="built_in">swap</span>(_start, v._start); </span><br><span class="line">::<span class="built_in">swap</span>(_finish, v._finish);</span><br><span class="line">::<span class="built_in">swap</span>(_endofstorage, v._endofstorage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(vector&lt;T&gt; v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*<span class="keyword">this</span> != &amp;v)</span><br><span class="line"><span class="built_in">swap</span>(v);<span class="comment">//这里不用库内自带的swap是因为,其会生成三个深拷贝,有很大的代价</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">vector</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] _start;</span><br><span class="line">_start = _finish = _endofstorage = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="built_in">capacity</span>()) <span class="comment">//增大容量时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> sz = <span class="built_in">size</span>();</span><br><span class="line">T* tmp = <span class="keyword">new</span> T[n];</span><br><span class="line"><span class="keyword">if</span> (_start) <span class="comment">//这里的用意是防止_start为空指针时扩容,会导致memcpy出错(memcpy内不能存在空指针)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//memcpy(tmp, _start, sizeof(T) * size()); //这个memcpy是浅拷贝,当T为string时,会导致指针指向同一位置,释放两次同一空间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">&#123;</span><br><span class="line">tmp[i] = _start[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] _start; </span><br><span class="line">&#125;</span><br><span class="line">_start = tmp;</span><br><span class="line">_finish = tmp + sz; <span class="comment">//如果这里赋予 tmp + size() 会出错 </span></span><br><span class="line">    <span class="comment">//sz的计算方式是_finish-_start</span></span><br><span class="line"><span class="comment">//_start已经指向新空间了,finish还指向旧空间</span></span><br><span class="line">_endofstorage = tmp + n;<span class="comment">//这里如果赋予tmp + capacity() 也会出错,与上同理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> n, <span class="type">const</span> T&amp; v = T())</span> <span class="comment">//这里的T()为T类型的默认缺省值,有int() double() 等都有</span></span></span><br><span class="line"><span class="function">   <span class="comment">//int() double()等内置类型,只是专门创建了此形式的东西</span></span></span><br><span class="line"><span class="function">   <span class="comment">//string ,vector 是调用构造函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="built_in">size</span>()) <span class="comment">//缩容</span></span><br><span class="line">&#123;</span><br><span class="line">_finish = _start + n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="built_in">capacity</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">reserve</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (_finish &lt; _start + n)</span><br><span class="line">&#123;</span><br><span class="line">*_finish = v;</span><br><span class="line">++_finish;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_finish == _endofstorage) <span class="comment">//扩容</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> newcapacity = <span class="built_in">capacity</span>() == <span class="number">0</span> ? <span class="number">2</span> : <span class="built_in">capacity</span>() * <span class="number">2</span>;</span><br><span class="line"><span class="built_in">reserve</span>(newcapacity);</span><br><span class="line">&#125;</span><br><span class="line">*_finish = x;</span><br><span class="line">++_finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; v)</span> <span class="comment">//这里会有迭代器失效问题</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt;= _finish);</span><br><span class="line"><span class="keyword">if</span> (_finish == _endofstorage)<span class="comment">//pos会扩容后失效</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> n = pos - _start; <span class="comment">//因此要记录之间的距离,以明确新pos指针指向的位置</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> newcapacity = <span class="built_in">capacity</span>() == <span class="number">0</span> ? <span class="number">2</span> : <span class="built_in">capacity</span>() * <span class="number">2</span>;</span><br><span class="line"><span class="built_in">reserve</span>(newcapacity);</span><br><span class="line"></span><br><span class="line">pos = _start + n; <span class="comment">//设置新pos</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iterator end = _finish - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt;= pos)   <span class="comment">//移动数据</span></span><br><span class="line">&#123;</span><br><span class="line">*(end + <span class="number">1</span>) = *end;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">*pos = v;</span><br><span class="line">++_finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt; _finish&amp;&amp; _start != _finish);</span><br><span class="line">iterator it = pos;</span><br><span class="line"><span class="keyword">while</span> (it &lt; _finish)</span><br><span class="line">&#123;</span><br><span class="line">*it = *(it + <span class="number">1</span>);</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line">_finish--;</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _finish - _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _endofstorage - _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(i &lt; <span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">return</span> *(_start + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> i)<span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(i &lt; <span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">return</span> *(_start + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(_start &lt; _finish);</span><br><span class="line">_finish--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">iterator _start;</span><br><span class="line">iterator _finish; <span class="comment">//这个指针指向的是最后一个数据的下一个数据的位置</span></span><br><span class="line">iterator _endofstorage;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟实现 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 迭代器失效 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string</title>
      <link href="/2023/10/21/cpp-string/"/>
      <url>/2023/10/21/cpp-string/</url>
      
        <content type="html"><![CDATA[<h1 id="一、关于string常用的接口"><a href="#一、关于string常用的接口" class="headerlink" title="一、关于string常用的接口"></a>一、关于string常用的接口</h1><hr><h2 id="1-string类对象的创建"><a href="#1-string类对象的创建" class="headerlink" title="1.string类对象的创建"></a>1.string类对象的创建</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关于string类对象的创建</span></span><br><span class="line">string s1;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>;  <span class="comment">//这三个是常用且重点的,以下是了解一下</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="number">2</span>)</span></span>;         <span class="comment">//输出前两个字符</span></span><br><span class="line">cout &lt;&lt; s4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s5</span><span class="params">(s2, <span class="number">2</span>, <span class="number">1</span>)</span></span>;           <span class="comment">//输出s2内,第2个开始输出,输出1个字符</span></span><br><span class="line">cout &lt;&lt; s5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s6</span><span class="params">(s2, <span class="number">2</span>)</span></span>;              <span class="comment">//输出s2内,第2个开始输出,输出至结束</span></span><br><span class="line">cout &lt;&lt; s6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s7</span><span class="params">(s2, <span class="number">2</span>,string::npos)</span></span>; <span class="comment">//输出s2内,第2个开始输出,输出至结束</span></span><br><span class="line">cout &lt;&lt; s7 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s8</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;            <span class="comment">//10个字符a</span></span><br><span class="line">cout &lt;&lt; s8 &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="2-reserve和resize"><a href="#2-reserve和resize" class="headerlink" title="2.reserve和resize"></a>2.reserve和resize</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//reverse</span></span><br><span class="line">s1.<span class="built_in">reserve</span>(<span class="number">100</span>);  <span class="comment">//改变capacity</span></span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">capacity</span>() &lt;&lt; endl; </span><br><span class="line"> <span class="comment">//capacity有对齐,所以不一定为自己所指定改变的capacity</span></span><br><span class="line"> <span class="comment">//capacity比实际输出多1,为了放 &#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//resize</span></span><br><span class="line">s1.<span class="built_in">resize</span>(<span class="number">3</span>);         <span class="comment">//改变size大小</span></span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;   <span class="comment">//当size小于内容时,  输出  hel</span></span><br><span class="line">s1.<span class="built_in">resize</span>(<span class="number">20</span>);        <span class="comment">//size变大</span></span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">s1.<span class="built_in">resize</span>(<span class="number">20</span>, <span class="string">&#x27;0&#x27;</span>);   <span class="comment">//此时不需要初始化,因为没有扩大</span></span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">s2.<span class="built_in">resize</span>(<span class="number">40</span>, <span class="string">&#x27;0&#x27;</span>);   <span class="comment">//size大于内容时,扩大了,扩大的空间初始化&#x27;0&#x27;;</span></span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><hr><h2 id="3-insert和erase"><a href="#3-insert和erase" class="headerlink" title="3.insert和erase"></a>3.insert和erase</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//insert</span></span><br><span class="line">s1.<span class="built_in">insert</span>(s1.<span class="built_in">begin</span>(), <span class="string">&#x27;0&#x27;</span>); <span class="comment">//在begin位置添加字符&#x27;0&#x27;</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">2</span>, <span class="string">&quot;3&quot;</span>);         <span class="comment">//在下标为2的位置添加字符&quot;3&quot;</span></span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//erase</span></span><br><span class="line">s1.<span class="built_in">erase</span>(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//下标位置2的数据开始删除三个数据</span></span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">s2.<span class="built_in">erase</span>(<span class="number">4</span>); <span class="comment">//下标位置4的数据开始删除所有数据</span></span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">s2.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">100</span>); <span class="comment">//如果超过了不会报错,会删除所有数据</span></span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><hr><h2 id="4-c-str"><a href="#4-c-str" class="headerlink" title="4.c_str"></a>4.c_str</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c_str  ,获取字符数组首地址,返回const char*指针</span></span><br><span class="line"><span class="comment">//通过 c_str() 实现遍历</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = s1.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="keyword">while</span> (*str)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *str &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">++str;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出数组数据内容的方式</span></span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;          <span class="comment">//调用string的重载 operator&lt;&lt;</span></span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">c_str</span>() &lt;&lt; endl;  <span class="comment">//直接输出const char*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//那么以上两者有什么区别呢 ??</span></span><br><span class="line">s1 += <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">s1 += <span class="string">&quot; world&quot;</span>; <span class="comment">//s1 == hello(/0)world</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;        <span class="comment">//这种方式将整个数组内所有内容全部输出</span></span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">c_str</span>() &lt;&lt; endl;<span class="comment">//这种方式遍历,遇见&#x27;\0&#x27;就停止</span></span><br></pre></td></tr></table></figure><hr><h2 id="5-find-非算法中的find"><a href="#5-find-非算法中的find" class="headerlink" title="5.find(非算法中的find)"></a>5.find(非算法中的find)</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由find可以分解URL : 协议  域名  资源名称</span></span><br><span class="line"><span class="comment">//也可以将一下部分整理为函数接口</span></span><br><span class="line"><span class="function">string <span class="title">url</span><span class="params">(<span class="string">&quot;https://www.icourse163.org/home.htm?userId=1531618954#/home/course&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">size_t</span> i1 = url.<span class="built_in">find</span>(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (i1 != string::npos)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; url.<span class="built_in">substr</span>(<span class="number">0</span>, i1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="type">size_t</span> i2 = url.<span class="built_in">find</span>(<span class="string">&#x27;/&#x27;</span>,i1 + <span class="number">3</span>); <span class="comment">//从i1+3坐标开始寻找&#x27;/&#x27;,之所以+3,跳过&quot;://&quot;</span></span><br><span class="line"><span class="keyword">if</span> (i2 != string::npos)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; url.<span class="built_in">substr</span>(i1 + <span class="number">3</span>, i2 - (i1 + <span class="number">3</span>)) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; url.<span class="built_in">substr</span>(i2 + <span class="number">1</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><hr><h2 id="6-geline"><a href="#6-geline" class="headerlink" title="6.geline"></a>6.geline</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求最后一个英文单词长度</span></span><br><span class="line">string s;</span><br><span class="line"><span class="comment">//cin &gt;&gt; s; //当想在一串字符串输入空格,自动结束</span></span><br><span class="line"><span class="built_in">getline</span>(cin, s); <span class="comment">//通过getline可以输入空格</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> pos = s.<span class="built_in">rfind</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != string::npos)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">size</span>() - (pos + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="二、string的模拟实现"><a href="#二、string的模拟实现" class="headerlink" title="二、string的模拟实现"></a>二、string的模拟实现</h1><hr><h2 id="1-模拟实现"><a href="#1-模拟实现" class="headerlink" title="1.模拟实现"></a>1.模拟实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="number">9</span>TSe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">string</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, string&amp; s);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;&quot;</span>)</span><br><span class="line">:_str(<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_str, str);</span><br><span class="line">_size = <span class="built_in">strlen</span>(str);</span><br><span class="line">_capacity = _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; s)</span><br><span class="line">:_str(<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s._str) + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_str, s._str);</span><br><span class="line">_capacity = s._capacity;</span><br><span class="line">_size = s._size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">string</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] _str;</span><br><span class="line">_str = <span class="literal">nullptr</span>;</span><br><span class="line">_size = _capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* iterator; <span class="comment">//迭代器的仿实现</span></span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _str + _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(i &lt; _size);</span><br><span class="line"><span class="keyword">return</span> _str[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> i)<span class="type">const</span> <span class="comment">//两种取下标值的方法,以方便使用</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(i &lt; _size);</span><br><span class="line"><span class="keyword">return</span> _str[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//增:</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> newcapacity = i;</span><br><span class="line"><span class="type">char</span>* tmp = <span class="keyword">new</span> <span class="type">char</span>[newcapacity + <span class="number">1</span>]; <span class="comment">//+1 为\0开辟空间</span></span><br><span class="line"><span class="built_in">strcpy</span>(tmp, _str);</span><br><span class="line"><span class="keyword">delete</span>[] _str;</span><br><span class="line">_str = tmp;</span><br><span class="line">_capacity = newcapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">char</span> ch)</span> <span class="comment">//增加字符</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">////增容</span></span><br><span class="line"><span class="comment">//if (_size == _capacity)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//size_t newcapacity = _capacity == 0 ? 4 : _capacity * 2;</span></span><br><span class="line"><span class="comment">//reserve(newcapacity);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//_str[_size] = ch;</span></span><br><span class="line"><span class="comment">//_size++;</span></span><br><span class="line"><span class="comment">//_str[_size] = &#x27;\0&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>(_size,ch); <span class="comment">//可以调用insert减少步骤</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span> <span class="comment">//增加字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//size_t len = strlen(str);</span></span><br><span class="line"><span class="comment">//if (len + _size &gt; _capacity) //增容</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//size_t newcapacity = len + _size;</span></span><br><span class="line"><span class="comment">//reserve(newcapacity);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//strcpy(_str + _size, str);</span></span><br><span class="line"><span class="comment">//_size += len;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>(_size,str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">char</span> ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">push_back</span>(ch);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">append</span>(str);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt;= _size);</span><br><span class="line"><span class="keyword">if</span> (_size == _capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> newcapacity = _capacity == <span class="number">0</span> ? <span class="number">4</span> : _capacity * <span class="number">2</span>;</span><br><span class="line"><span class="built_in">reserve</span>(newcapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> end = _size;<span class="comment">//end 类型不能给size_t 否则在pos为0时,end在0--后将变为npos的值,将无限循环</span></span><br><span class="line"><span class="keyword">while</span> (end &gt;= (<span class="type">int</span>)pos) <span class="comment">//类型不同形式比大小,隐式类型转换int -&gt; size_t,强转pos为int可进行比较,可以阻止隐式类型转换</span></span><br><span class="line">&#123;                       <span class="comment">//int -1 &gt;= size_t 0 ??  ==&gt;&gt; size_t -1 &gt;= size_t 0;</span></span><br><span class="line">_str[end + <span class="number">1</span>] = _str[end];</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">_str[pos] = ch;</span><br><span class="line">++_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt;= _size);</span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">if</span> (len + _size &gt; _capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">reserve</span>(len + _size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> end = _size; </span><br><span class="line"><span class="keyword">while</span> (end &gt;= (<span class="type">int</span>)pos)</span><br><span class="line">&#123;</span><br><span class="line">_str[end + len] = _str[end];</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strncpy</span>(_str+pos, str, len);</span><br><span class="line">_size += len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> n,<span class="type">char</span> ch)</span>    <span class="comment">//1 2 3 4 5</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt; _size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt; _capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">reserve</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = _size; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">_str[i] = ch;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">_str[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">_size = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len = npos)</span>  <span class="comment">//1 2 3 4 5</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt; _size);</span><br><span class="line"><span class="keyword">if</span> (len + pos &gt;= _size)</span><br><span class="line">&#123;</span><br><span class="line">_str[pos] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">_size = pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> end = pos;</span><br><span class="line"><span class="keyword">while</span> (end &lt;= pos + len)</span><br><span class="line">&#123;</span><br><span class="line">_str[end] = _str[end + len];</span><br><span class="line">end++;</span><br><span class="line">&#125;</span><br><span class="line">_size -= len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">char</span> ch, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="comment">//wdnmd</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = pos; i &lt; _size; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_str[i] == ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> npos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">size_t</span> pos = npos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* ret = <span class="built_in">strstr</span>(_str + pos, str);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ret - _str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> npos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重载</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">const</span> string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s) <span class="comment">//防止同对象自己赋值给自己</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* tmp = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s._str) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(tmp, s._str);</span><br><span class="line"><span class="keyword">delete</span>[] _str;</span><br><span class="line">_str = tmp;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> string&amp; s1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> ret = <span class="built_in">strcmp</span>(_str, s1._str);</span><br><span class="line"><span class="keyword">return</span> ret &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> string&amp; s1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; s1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> string&amp; s1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> ret = <span class="built_in">strcmp</span>(_str, s1._str);</span><br><span class="line"><span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> string&amp; s1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span> == s1 || *<span class="keyword">this</span> &gt; s1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> string&amp; s1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> &gt; s1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> string&amp; s1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> == s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span><span class="params">(istream&amp; in, string&amp; s)</span> <span class="comment">//和operator&gt;&gt;二者本质没有区别,只是判断条件少了一个&#x27; &#x27;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="comment">//in &gt;&gt; ch; //这样写会导致当输入&#x27; &#x27; 或 &#x27;\n&#x27; 时被解读为开始读取下一个字符,直接被跳过</span></span><br><span class="line">  <span class="comment">//导致无法读取&#x27; &#x27; 和&#x27;\n&#x27;</span></span><br><span class="line">ch = in.<span class="built_in">get</span>(); <span class="comment">//使用这种方法可以读取任意字符,包括回车和空格</span></span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">s += ch;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* _str;</span><br><span class="line"><span class="type">size_t</span> _size;</span><br><span class="line"><span class="type">size_t</span> _capacity;   <span class="comment">//\0不是有效字符,不算在capacity和size内部</span></span><br><span class="line">                   <span class="comment">//但在实际创建空间时需要多创建一个空间,存放\0</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> npos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> string::npos = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="comment">//in &gt;&gt; ch; //这样写会导致当输入&#x27; &#x27; 或 &#x27;\n&#x27; 时被解读为开始读取下一个字符,直接被跳过</span></span><br><span class="line">  <span class="comment">//导致无法读取&#x27; &#x27; 和&#x27;\n&#x27;</span></span><br><span class="line">ch = in.<span class="built_in">get</span>(); <span class="comment">//使用这种方法可以读取任意字符,包括回车和空格</span></span><br><span class="line"><span class="keyword">if</span> (ch==<span class="string">&#x27; &#x27;</span>||ch == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">s += ch;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> string&amp; s) <span class="comment">//由于运算符参数数量问题,和使用方便,重载写在外面</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; s[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-string中构造-拷贝构造-赋值重载的简洁写法"><a href="#2-string中构造-拷贝构造-赋值重载的简洁写法" class="headerlink" title="2.string中构造,拷贝构造,赋值重载的简洁写法"></a>2.string中构造,拷贝构造,赋值重载的简洁写法</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现一个有基本功能的string类:构造,析构,拷贝,operator=  ,,  深拷贝的现代写法 -- 简洁</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="number">9</span>TSe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">string</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;\0&quot;</span>) <span class="comment">//&quot;\0&quot; 或者&quot;&quot;都可以</span></span><br><span class="line">:_str(<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str)+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_str,str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////拷贝构造的传统写法</span></span><br><span class="line"><span class="comment">//string(const string&amp; s)</span></span><br><span class="line"><span class="comment">//:_str(new char[strlen(s._str) + 1])</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//strcpy(_str, s._str);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造的现代写法</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; s)</span><br><span class="line">:_str(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">string <span class="title">tmp</span><span class="params">(s._str)</span></span>;   <span class="comment">//调用构造函数</span></span><br><span class="line"><span class="built_in">swap</span>(_str, tmp._str); <span class="comment">//如果不初始化_str为nullptr,tmp在析构随即地址时会崩溃</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////operator=的传统写法</span></span><br><span class="line"><span class="comment">//string&amp; operator=(const string&amp; s)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//if (this != &amp;s)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//char* tmp = new char[strlen(s._str) + 1];</span></span><br><span class="line"><span class="comment">//strcpy(tmp, s._str);</span></span><br><span class="line"><span class="comment">//delete[] _str;</span></span><br><span class="line"><span class="comment">//_str = tmp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//return *this;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////operator=的现代写法</span></span><br><span class="line"><span class="comment">//string&amp; operator=(const string&amp; s)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//if (this != &amp;s)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//string tmp(s);</span></span><br><span class="line"><span class="comment">//swap(_str, tmp._str);  //交换后,tmp还会再次调用析构,将_str交换过来的随机值释放空间</span></span><br><span class="line"><span class="comment">//&#125;                          //可谓狸猫换太子</span></span><br><span class="line"><span class="comment">//return *this;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//operator=的更简单的写法,传值操作</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>=(string s) <span class="comment">//相当于直接调用拷贝构造 // new: 口 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(_str, s._str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* _str;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="number">9</span>TSe <span class="comment">//现代化方法,有时成员较多,库中的swap无法一次交换多个数据,以下为解决方式</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">string</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">_size = <span class="built_in">strlen</span>(str);</span><br><span class="line">_capacity = _size;</span><br><span class="line">_str = <span class="keyword">new</span> <span class="type">char</span>[_capacity + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(_str, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; s)</span><br><span class="line">:_str(<span class="literal">nullptr</span>)</span><br><span class="line">,_size(<span class="number">0</span>)</span><br><span class="line">,_capacity(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">string <span class="title">tmp</span><span class="params">(s._str)</span></span>;</span><br><span class="line"><span class="comment">//this-&gt;swap(tmp);</span></span><br><span class="line"><span class="built_in">swap</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">::<span class="built_in">swap</span>(_str, s._str);  <span class="comment">//由于参数相同,swap会优先调用自己,导致循环</span></span><br><span class="line">::<span class="built_in">swap</span>(_size,s._size); <span class="comment">//前面加入 :: 表示调用全局的swap</span></span><br><span class="line">::<span class="built_in">swap</span>(_capacity, s._capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string&amp; <span class="keyword">operator</span>=(string s) <span class="comment">//这里不初始化_str是因为它交换于栈区,函数结束自动释放</span></span><br><span class="line">&#123;</span><br><span class="line">_str = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//this-&gt;swap(s);</span></span><br><span class="line"><span class="built_in">swap</span>(s);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* _str;</span><br><span class="line"><span class="type">size_t</span> _size;</span><br><span class="line"><span class="type">size_t</span> _capacity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟实现 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tips</title>
      <link href="/2023/10/21/cpp-tips/"/>
      <url>/2023/10/21/cpp-tips/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、函数重载"><a href="#一、函数重载" class="headerlink" title="一、函数重载"></a>一、函数重载</h1><hr><blockquote><p>在程序编译时分为四步:预编译 编译 汇编 链接<br>而C++的函数重载与C的区别就在于<code>链接</code>生成符号表时</p></blockquote><blockquote><p>C :  0x000000 :<br> Add  C语言中, .o文件符号表中地址对应的函数名为 自己创建的函数名,所以不能创建同名函数</p></blockquote><blockquote><p>C++:  0x000000 : _Z3Adddd 和 _Z3Addii<br>  <code>_Z为标志符,3为函数字符数,Add为函数名,ii为两个参数类型</code></p></blockquote><p>由以上分析,我们可以知道函数重载的实现的重点为<code>参数</code></p><p> <code>数量or顺序or类型</code>不同时就能构成重载</p><p> 注意,如果构建两个函数名相同的函数,若只有返回值类型的不同无法构成重载<br>因为其与参数无任何关系</p><hr><h1 id="二、缺省函数"><a href="#二、缺省函数" class="headerlink" title="二、缺省函数"></a>二、缺省函数</h1><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Func1</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">20</span>,<span class="type">int</span> c = <span class="number">30</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Func2</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b = <span class="number">20</span>, <span class="type">int</span> c = <span class="number">30</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Func1</span>();</span><br><span class="line"><span class="built_in">Func1</span>(<span class="number">3</span>);       <span class="comment">//加入不完整的参数默认为从左到右,此时函数内a==3,b==20,c==30;</span></span><br><span class="line"><span class="built_in">Func1</span>(<span class="number">3</span>, <span class="number">4</span>);    <span class="comment">//此时函数内a==3,b==4,c==30</span></span><br><span class="line"><span class="built_in">Func1</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">//此时函数内a==3,b==4,c==5</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>缺省函数有以下注意要点</p><blockquote><p>1.填补缺省参数时,填补只能 <code>从右向左</code> 并且 <code>连续</code>才行<br>2.如果构建两个函数名称相同,参数相同,唯有参数的缺省值不同,此时并<code>不构成重载</code>,反而还会报错</p></blockquote><hr><h1 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用 &amp;"></a>三、引用 &amp;</h1><hr><h2 id="1-引用的基本定义"><a href="#1-引用的基本定义" class="headerlink" title="1.引用的基本定义"></a>1.引用的基本定义</h2><hr><p><code>引用必须在定义时就进行初始化</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; e;  <span class="comment">//这样一写九成要爆炸</span></span><br></pre></td></tr></table></figure><hr><p><code>关于const修饰的引用(权限的扩大和缩小)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> f = <span class="number">4</span>; <span class="comment">//f创建时的权限为只读</span></span><br><span class="line"><span class="type">int</span>&amp; g = f;   <span class="comment">//此时f的引用g,可读可写,权限被放大,直接爆炸</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> f = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; h = f; <span class="comment">//此时权限没有放大,可行</span></span><br></pre></td></tr></table></figure><blockquote><p>在引用前一定要注意要引用的对象权限,只能缩小和不变,不能扩大权限</p></blockquote><hr><p><code>临时变量具有常性</code>,<code>隐式类型转换</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k = <span class="number">6</span>;</span><br><span class="line"><span class="type">double</span> l = k;  <span class="comment">//可行</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span>&amp; m = k; <span class="comment">//报错</span></span><br><span class="line"><span class="type">double</span>&amp; n = k;<span class="comment">//报错</span></span><br><span class="line"><span class="comment">//此时为什么两者都不行呢?</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">float</span>&amp; o = k;  <span class="comment">//可行</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span>&amp; p = k; <span class="comment">//可行</span></span><br><span class="line"><span class="comment">//加上const不让权限放大即可</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; r = q;</span><br><span class="line">q = <span class="number">20</span>; <span class="comment">//无措且成功修改</span></span><br><span class="line">cout &lt;&lt; r &lt;&lt; endl; <span class="comment">//r变为20</span></span><br><span class="line">r = <span class="number">30</span>; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>隐式类型转换发生在上述 double l &#x3D; k; 时(隐式类型转换)</p><blockquote><p>赋值前会先创建一个临时的double变量,k先将值赋值给这个临时的double变量,再将临时变量赋值给l</p></blockquote><p>引用时报错的原因是(临时变量具有常性)</p><blockquote><p>因为临时创建的临时变量具有 常性(即只读性),即访问权限放大了</p></blockquote><hr><h2 id="2-引用作为函数参数和返回类型-浅提static-函数返回值的过程"><a href="#2-引用作为函数参数和返回类型-浅提static-函数返回值的过程" class="headerlink" title="2.引用作为函数参数和返回类型(浅提static,函数返回值的过程)"></a>2.引用作为函数参数和返回类型(浅提static,函数返回值的过程)</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">Count1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> n = <span class="number">0</span>;  <span class="comment">//static 在程序运行后只执行一次,因此程序只执行一次 static int n = 0;</span></span><br><span class="line">n++;</span><br><span class="line"><span class="keyword">return</span> n; <span class="comment">//返回时,引用一个临时名称代表n (int&amp; tmp = n;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Count2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">n++;</span><br><span class="line"><span class="keyword">return</span> n; <span class="comment">//在返回时,n将值赋给一个临时变量 (int tmp = n;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>&amp; ret1 = <span class="built_in">Count1</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ret2 = <span class="built_in">Count2</span>(); <span class="comment">//返回的临时变量具有常性,因此加上 const 才可以通过编译</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于引用作为函数返回值有最大的优点就是<code>提升效率</code></p><blockquote><p>由于不需要再创建额外变量,只要引用作为返回类型或者参数,提高程序运行的效率</p></blockquote><hr><p><code>引用中的不慎会导致的错误</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> c = a + b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方式</span></span><br><span class="line"><span class="comment">//static int c = a + b;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>&amp; ret = <span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Add(1,2) is : &quot;</span> &lt;&lt; ret &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>为什么前面一有其他函数就会使得值变化呢?</code></p><blockquote><p>问题就在Add函数在栈区每调用完这个栈就会销毁(下次使用这块栈区可能会直接覆盖),但是c的值还在<br>当有函数在此栈区运行时会使得c的别名变为随机值</p></blockquote><p>所以要static修饰将其转移至静态区即可解决</p><hr><p><strong>引用和指针的区别</strong></p><blockquote><p>1.引用在初始化时引用一个实体后就不能再引用其他实体,而指针在没有const修饰时可以指向任何一个实体<br>2.没有空引用,但有空指针(NULL)<br>3.有多级指针,没有多级引用<br>4.访问实体时,指针需要解引用,引用编译器自己处理<br>5.引用相对于指针更安全<br>6.实际上在转换为汇编中指针和引用没有过大区别,效率几乎一样</p></blockquote><hr><h1 id="四、内联函数"><a href="#四、内联函数" class="headerlink" title="四、内联函数"></a>四、内联函数</h1><hr><p><code>inline</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;                               </span><br><span class="line"><span class="type">int</span> tmp = a;                </span><br><span class="line">a = b;                       </span><br><span class="line">b = tmp;                    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">Swap</span>(a, b);</span><br><span class="line"><span class="built_in">Swap</span>(a, b);</span><br><span class="line"><span class="built_in">Swap</span>(a, b);</span><br><span class="line"><span class="built_in">Swap</span>(a, b);</span><br><span class="line"><span class="built_in">Swap</span>(a, b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内联函数的主要作用是<code>代替宏</code><br><em>汇编中直接将 main中的 call _Z4swapii 取代为swap函数内的算法</em></p><p>但是内联函数有以下要点</p><blockquote><p>1.频繁调用Swap是有消耗的<br>2.inline只是对编译器进行建议,如果函数内行数过多(多于20行左右),那么内联函数就不会使用</p></blockquote><hr><h1 id="五、类和对象"><a href="#五、类和对象" class="headerlink" title="五、类和对象"></a>五、类和对象</h1><hr><h2 id="1-类的大小如何计算"><a href="#1-类的大小如何计算" class="headerlink" title="1.类的大小如何计算?"></a>1.类的大小如何计算?</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack1</span><span class="comment">//类中有成员函数和成员变量</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:       </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span>* _a;</span><br><span class="line"><span class="type">int</span> _size;</span><br><span class="line"><span class="type">int</span> _capacity; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack2</span> <span class="comment">//类中只有成员函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack3</span> <span class="comment">//类中只有成员变量</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>* _a;</span><br><span class="line"><span class="type">int</span> _size;</span><br><span class="line"><span class="type">int</span> _capacity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack4</span> <span class="comment">//类中什么也没有--空类</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Stack1) &lt;&lt; endl; <span class="comment">//16</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Stack2) &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Stack3) &lt;&lt; endl; <span class="comment">//16</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Stack4) &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据输出,我们有以下问题</p><blockquote><p><strong>为什么对象中只存储成员变量,不存储成员函数?</strong><br> 一个类实例化出多个对象,他们的成员变量可以存储不同的值<br>  但是他们调用的成员函数是同一个,若每个对象都存储成员函数,那么将会浪费空间</p></blockquote><blockquote><p><strong>对于空类和只有成员函数的类,大小是1?</strong><br>开1字节不是为了存数据,而是占位,以表示该对象存在</p></blockquote><p>而且要注意<br><code>计算成员变量的和,并且要考虑对齐</code></p><hr><blockquote><p>const Date* p1;    const修饰指针指向的对象<br>Date const * p2;   const修饰指针指向的对象<br>Date* const p3;    const修饰指针本身</p></blockquote><hr><h2 id="2-初始化列表"><a href="#2-初始化列表" class="headerlink" title="2.初始化列表"></a>2.初始化列表</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year = <span class="number">0</span>, <span class="type">int</span> month = <span class="number">1</span>, <span class="type">int</span> day = <span class="number">1</span>)</span><br><span class="line">:_year(year)</span><br><span class="line">,_month(month)</span><br><span class="line">,_day(day)</span><br><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//函数体内赋值</span></span><br><span class="line"><span class="comment">/*_year = year;  </span></span><br><span class="line"><span class="comment">_month = month;</span></span><br><span class="line"><span class="comment">_day = day;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么初始化列表有什么用呢?</p><p>初始化列表的初始化是分先后的,而不是一起同时初始化的,但其初始化顺序是<br><code>定义成员变量的顺序</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> a = <span class="number">10</span>) <span class="comment">//是构造函数,但不是无参数默认构造函数</span></span><br><span class="line">:_a(a)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>(<span class="type">int</span> a, <span class="type">int</span> ref)</span><br><span class="line">:_aobj()</span><br><span class="line">,_ref(ref)</span><br><span class="line">,_n(<span class="number">10</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//成员变量的声明</span></span><br><span class="line">A _aobj;     <span class="comment">//没有默认构造函数</span></span><br><span class="line"><span class="type">int</span>&amp; _ref;   <span class="comment">//引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> _n; <span class="comment">//const</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以理解为初始化列表是对象的成员变量定义的地方</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; _b;</span><br><span class="line">A _a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> _c;</span><br><span class="line"><span class="comment">//这些类型都需要初始化</span></span><br><span class="line"><span class="comment">//所以这些成员的初始化必须使用初始化列表</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-计算一个类产生了多少个对象-小实例"><a href="#3-计算一个类产生了多少个对象-小实例" class="headerlink" title="3.计算一个类产生了多少个对象(小实例)"></a>3.计算一个类产生了多少个对象(小实例)</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//static成员</span></span><br><span class="line"><span class="comment">//设计出一个类,计算这个类总共产生了多少对象</span></span><br><span class="line"><span class="comment">//如果仅仅只有一个全局变量来统计,那么将没有封装性,因此我们引入static成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetN</span><span class="params">()</span> <span class="comment">//没有this指针,函数中不能访问非静态的成员</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _a;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> n; <span class="comment">//声明 不是属于某个对象,是属于类的所有对象,属于这个类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::n = <span class="number">0</span>; <span class="comment">//进行定义</span></span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">f1</span><span class="params">(A&amp; a)</span></span></span><br><span class="line"><span class="function"><span class="comment">//A f1(A&amp; a)</span></span></span><br><span class="line"><span class="function"><span class="comment">//A f1(A a)  这三种因为引用的原因,所进行的调用次数不一样,可以影响n,会有不一样的结果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a1;</span><br><span class="line">A a2;</span><br><span class="line"><span class="built_in">f1</span>(a1);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a1.<span class="built_in">GetN</span>() &lt;&lt; endl;</span><br><span class="line">A a3;</span><br><span class="line">A a4;</span><br><span class="line"><span class="built_in">f1</span>(a2);</span><br><span class="line">cout &lt;&lt; a1.<span class="built_in">GetN</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="①static的理解"><a href="#①static的理解" class="headerlink" title="①static的理解"></a>①static的理解</h3><p>上述代码有一关键点:突破类域<br>有两种方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A a1;</span><br><span class="line"><span class="comment">//突破类域的两种方式</span></span><br><span class="line">a1.f4;</span><br><span class="line">A::f4;</span><br></pre></td></tr></table></figure><hr><p>以下是static的函数调用理解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">f2</span>(); <span class="comment">//this-&gt;f2();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f4</span><span class="params">()</span> <span class="comment">//static 成员函数内部没有this指针,因此无法调用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">f3</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>在C++11中也有一点关于static</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//非静态成员变量可以声明时给缺省值</span></span><br><span class="line"><span class="type">int</span> _year = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> _month = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> _day = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span>); <span class="comment">//指针也可以在这里开辟空间</span></span><br><span class="line">A aa = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//static int n = 0;  static类型并不行</span></span><br></pre></td></tr></table></figure><blockquote><p>C++11中可以在声明时给<code>非静态</code>变量缺省值</p></blockquote><hr><h2 id="4-匿名对象"><a href="#4-匿名对象" class="headerlink" title="4.匿名对象"></a>4.匿名对象</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Date&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Date</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~Date&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Date d1; <span class="comment">//声明周期持续到main结束</span></span><br><span class="line">d1.<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Date(); //匿名对象 生命周期只有一行</span></span><br><span class="line"><span class="built_in">Date</span>().<span class="built_in">Print</span>(); <span class="comment">//只有这一行使用这个创建的对象,别人不需要使用,这一行开始自动调用构造,结束调用析构</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>匿名对象的生命周期只有一行,结束调用析构函数</p></blockquote><hr><h2 id="5-全局变量-静态成员变量-调用构造和析构的顺序"><a href="#5-全局变量-静态成员变量-调用构造和析构的顺序" class="headerlink" title="5.全局变量,静态成员变量,调用构造和析构的顺序"></a>5.全局变量,静态成员变量,调用构造和析构的顺序</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;<span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>()&#123;cout &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">~<span class="built_in">A</span>()&#123;cout &lt;&lt; <span class="string">&quot;~A&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;<span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>()&#123;cout &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">~<span class="built_in">B</span>()&#123;cout &lt;&lt; <span class="string">&quot;~B&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;<span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">C</span>()&#123;cout &lt;&lt; <span class="string">&quot;C&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">~<span class="built_in">C</span>()&#123;cout &lt;&lt; <span class="string">&quot;~C&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span></span><br><span class="line">&#123;<span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">D</span>()&#123;cout &lt;&lt; <span class="string">&quot;D&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">~<span class="built_in">D</span>()&#123;cout &lt;&lt; <span class="string">&quot;~D&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b;</span><br><span class="line"><span class="type">static</span> D d;</span><br><span class="line">C c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// A  B  D  C</span></span><br><span class="line"><span class="comment">//~C ~B ~D ~A</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>先构造全局,静态构造无优先级,和局部对象无区别<br>先照常析构局部对象,再释放静态,最后释放全局</p></blockquote><hr><h2 id="6-Cpp-C-的内存分布"><a href="#6-Cpp-C-的内存分布" class="headerlink" title="6. Cpp&#x2F;C 的内存分布"></a>6. Cpp&#x2F;C 的内存分布</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> globalval = <span class="number">1</span>;  </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> staticglobalval = <span class="number">1</span>;<span class="comment">//以上两种位于数据段(静态区),main函数之前就初始化,在哪里都能用,作用域是全局的</span></span><br><span class="line">                               <span class="comment">//区别,前者所有文件可用,后者只有当前&quot;8process.cpp&quot;可以用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> staticval = <span class="number">1</span>;  <span class="comment">//位于数据段,运行到这里再初始化,作用域在main中,只能在main中使用</span></span><br><span class="line"><span class="type">int</span> val = <span class="number">1</span>;               <span class="comment">//局部变量,位于栈内</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;; <span class="comment">//栈内</span></span><br><span class="line"><span class="type">char</span> char2[] = <span class="string">&quot;abcd&quot;</span>;     <span class="comment">//栈内</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* pchar3 = <span class="string">&quot;abcd&quot;</span>; <span class="comment">//指针位于栈内,指针指向的内容位于代码段(常量区)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* ptr1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">4</span>); <span class="comment">//指针位于栈内,指向的内容位于堆</span></span><br><span class="line"><span class="type">int</span>* ptr2 = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">4</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span>* ptr3 = (<span class="type">int</span>*)<span class="built_in">realloc</span>(ptr2,<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">8</span>);</span><br><span class="line"><span class="built_in">free</span>(ptr1);</span><br><span class="line"><span class="built_in">free</span>(ptr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据段(静态区)存储全局数据,静态数据</span></span><br><span class="line"><span class="comment">//代码段(常量区)存储可执行代码/只读常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="六、new和delete"><a href="#六、new和delete" class="headerlink" title="六、new和delete"></a>六、new和delete</h1><hr><h2 id="1-malloc-、free-和-new-、delete"><a href="#1-malloc-、free-和-new-、delete" class="headerlink" title="1. malloc 、free 和 new 、delete"></a>1. malloc 、free 和 new 、delete</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~A&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//C 函数</span></span><br><span class="line"><span class="type">int</span>* p1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));   <span class="comment">//申请一个int4个字节的空间</span></span><br><span class="line"><span class="type">int</span>* p2 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>);<span class="comment">//为指向数组的指针开辟内存</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++  操作符</span></span><br><span class="line"><span class="type">int</span>* p3 = <span class="keyword">new</span> <span class="type">int</span>;     <span class="comment">//申请一个int4个字节的空间</span></span><br><span class="line"><span class="type">int</span>* p4 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">//为指向数组的指针开辟内存</span></span><br><span class="line"><span class="type">int</span>* p5 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>); <span class="comment">//申请一个int4个字节的空间,初始化为10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p3;</span><br><span class="line"><span class="keyword">delete</span>[] p4;</span><br><span class="line"><span class="keyword">delete</span> p5;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样看来功能几乎类似,那么new和delete存在的意义是什么?</span></span><br><span class="line">A* p6 = (A*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(A));</span><br><span class="line">A* p7 = <span class="keyword">new</span> A; <span class="comment">//申请空间+构造函数初始化</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p6);</span><br><span class="line"><span class="keyword">delete</span> p7;  <span class="comment">//析构函数+销毁空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>对于内置类型和malloc,free作用相同<br>对于自定义类型就有其他作用<br>new申请空间后对于自定义类型还会调用构造函数初始化<br>delete在销毁空间前还会调用自定义类型的析构函数</p></blockquote><hr><h2 id="2-operator-new-和-operator-delete"><a href="#2-operator-new-和-operator-delete" class="headerlink" title="2.operator new 和 operator delete"></a>2.operator new 和 operator delete</h2><hr><p><code>在使用方法上</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A* p1 = (A*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(A));</span><br><span class="line">A* p2 = (A*)<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(A));</span><br></pre></td></tr></table></figure><p><strong>operator new和malloc使用方法一样</strong></p><hr><p><code>和new的区别</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A* p1 = (A*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(A));</span><br><span class="line">A* p2 = (A*)<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(A)); <span class="comment">//operator new 的用法和malloc一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//malloc申请出错时</span></span><br><span class="line"><span class="type">size_t</span> size = <span class="number">3</span>;</span><br><span class="line"><span class="type">void</span>* p4 = <span class="built_in">malloc</span>(size * <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>); <span class="comment">//申请3G内存,32位平台下申请绝对失败,观察失败后运行结果</span></span><br><span class="line">cout &lt;&lt; p4 &lt;&lt; endl; <span class="comment">//输出p4地址的结果是000000,失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//operator new 申请出错时</span></span><br><span class="line"><span class="comment">//这部分语法暂时了解</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* p5 = <span class="keyword">operator</span> <span class="built_in">new</span>(size * <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">cout &lt;&lt; p5 &lt;&lt; endl;<span class="comment">//失败抛异常</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p5)</span></span>; <span class="comment">//operator delete 和  free 没有区别,只是为了对应operator new</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl; <span class="comment">//输出bad allocation</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在观察operator new 和 operator delete内部,发现内部是用malloc和free实现的,在operator new内部多了一个申请出错输出bad allocation</p></blockquote><p>总结</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">malloc</span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span> -&gt; malloc + 失败抛异常</span><br><span class="line"><span class="keyword">new</span>          -&gt;<span class="keyword">operator</span> <span class="keyword">new</span> + 构造函数</span><br><span class="line"></span><br><span class="line">free</span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">delete</span> -&gt; 和free没有区别</span><br><span class="line"><span class="keyword">delete</span>          -&gt; free + 析构函数</span><br></pre></td></tr></table></figure><hr><h2 id="3-定位new和delete"><a href="#3-定位new和delete" class="headerlink" title="3.定位new和delete"></a>3.定位new和delete</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">List* p1 = <span class="keyword">new</span> List;</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟上面的行为,即,创建对象后调用构造,销毁对象后调用析构</span></span><br><span class="line"><span class="comment">//显式调用构造函数和析构函数</span></span><br><span class="line"></span><br><span class="line">List* p2 = (List*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(List));</span><br><span class="line"><span class="keyword">new</span>(p2)<span class="built_in">List</span>(<span class="number">1</span>);<span class="comment">//调用构造函数,new(空间指针)类型(参数)</span></span><br><span class="line"></span><br><span class="line">p2-&gt;~<span class="built_in">List</span>(); <span class="comment">//调用析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>调用构造函数为 new(空间指针)类型(参数)<br>调用析构函数为 空间指针-&gt;析构函数名()</p></blockquote><hr><h2 id="4-总结new-malloc…"><a href="#4-总结new-malloc…" class="headerlink" title="4.总结new,malloc…"></a>4.总结new,malloc…</h2><blockquote><p>使用效果上: new会调用构造函数,失败了抛异常,malloc失败返回0<br>概念性质上: new是一个操作符,malloc是一个函数<br>使用方法上: new后面跟申请对象的类型,返回的是类型的指针;malloc参数传字节数,返回值为void*</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态内存分配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见多种排序方式和实现</title>
      <link href="/2023/10/21/c-%E5%B8%B8%E8%A7%81%E5%A4%9A%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/10/21/c-%E5%B8%B8%E8%A7%81%E5%A4%9A%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="头文件-Sort-h"><a href="#头文件-Sort-h" class="headerlink" title="头文件(Sort.h)"></a>头文件(Sort.h)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintArray</span><span class="params">(<span class="type">int</span>* arr,<span class="type">int</span> n)</span>; <span class="comment">//打印数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span>; <span class="comment">//交换数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认全部实现升序排列</span></span><br><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span>* arr,<span class="type">int</span> n)</span>; <span class="comment">//插入排序 : 稳定 最坏O( N^2 )  最好O( N )</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span>; <span class="comment">//希尔排序 : 不稳定 最坏O( N^2 )  最好O( N^1.3)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span>; <span class="comment">//选择排序 : 不稳定 O( N^2 )  </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span>; <span class="comment">//堆排序 : 稳定 O( N*logN )</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AdjustDown</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n,<span class="type">int</span> root)</span>; <span class="comment">//堆排序所需要的向下调整接口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span>; <span class="comment">//冒泡排序 : 稳定 O(N^2)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>* arr,<span class="type">int</span> left,<span class="type">int</span> right)</span>; <span class="comment">//快排 : 不稳定 三数取中、区间非快排优化后O( N*LogN )  空间复杂度 O(logN)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span>;  <span class="comment">//归并排序 : 稳定 O( N*logN ) 空间复杂度 O(N) </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSortFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file)</span>; <span class="comment">//对文件进行排序,适用于大量数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//计数排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CountSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//以下为非递归快排所需要的栈头文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> StackData;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">StackData* _a;  <span class="comment">//存放数据</span></span><br><span class="line"><span class="type">int</span> _top;       <span class="comment">//顶标</span></span><br><span class="line"><span class="type">int</span> _capacity;  <span class="comment">//存放数量</span></span><br><span class="line">&#125;Sta;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackInit</span><span class="params">(Sta* pst)</span>;     <span class="comment">//初始化堆栈</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackDestroy</span><span class="params">(Sta* pst)</span>;  <span class="comment">//销毁堆栈</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPush</span><span class="params">(Sta* pst, StackData x)</span>;  <span class="comment">//插入数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPop</span><span class="params">(Sta* pst)</span>;  <span class="comment">//删除数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackSize</span><span class="params">(Sta* pst)</span>;  <span class="comment">//堆栈数据个数</span></span><br><span class="line"><span class="comment">// int StackSize(Sta st);  不传入指针也可以,但为了接口函数的一致性传入指针也可以</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackEmpty</span><span class="params">(Sta* pst)</span>;  <span class="comment">//判断堆栈是否为空</span></span><br><span class="line"></span><br><span class="line">StackData <span class="title function_">StackTop</span><span class="params">(Sta* pst)</span>;  <span class="comment">//取出堆栈头的数据</span></span><br></pre></td></tr></table></figure><hr><h1 id="函数接口部分-Sort-c"><a href="#函数接口部分-Sort-c" class="headerlink" title="函数接口部分(Sort.c)"></a>函数接口部分(Sort.c)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sort.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintArray</span><span class="params">(<span class="type">int</span>* arr,<span class="type">int</span> n)</span>  <span class="comment">//打印数组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span> <span class="comment">//插入排序</span></span><br><span class="line">&#123;                                </span><br><span class="line">assert(arr);                 </span><br><span class="line">                                 </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//以下为一趟,即只排序一个数字</span></span><br><span class="line"><span class="type">int</span> end = i;</span><br><span class="line"><span class="type">int</span> tmp = arr[end + <span class="number">1</span>];  <span class="comment">//竖线后的值赋给tmp</span></span><br><span class="line"><span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[end] &gt; tmp)</span><br><span class="line">&#123;</span><br><span class="line">arr[end + <span class="number">1</span>] = arr[end];  <span class="comment">//使大于该排序的数整体后移</span></span><br><span class="line">--end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[end + <span class="number">1</span>] = tmp;    <span class="comment">//最后将值赋给后移部分数组的头</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3 6 7 | 2 </span></span><br><span class="line"><span class="comment">// 3 6 7 | 7 </span></span><br><span class="line"><span class="comment">// 3 6 6 | 7 </span></span><br><span class="line"><span class="comment">// 3 3 6 | 7 </span></span><br><span class="line"><span class="comment">// 2 3 6 | 7 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span> <span class="comment">//插入排序的优化 希尔排序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> gap = n;</span><br><span class="line"><span class="keyword">while</span> (gap &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">gap = gap / <span class="number">3</span> + <span class="number">1</span>; <span class="comment">//+1确保最后一次循环为gap为1的循环,即插入排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - gap; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> end = i;</span><br><span class="line"><span class="type">int</span> tmp = arr[end + gap];</span><br><span class="line"><span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tmp &lt; arr[end])</span><br><span class="line">&#123;</span><br><span class="line">arr[end + gap] = arr[end];</span><br><span class="line">end -= gap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[end + gap] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//间隔gap之间进行插入排序</span></span><br><span class="line"><span class="comment">//9 1 3 6 7 2 5 4 10 8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span> <span class="comment">//选择排序  即选择最小的数排在前面,为了提高效率,同时选择最大和最小</span></span><br><span class="line">&#123;</span><br><span class="line">assert(arr);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> maxi = right;</span><br><span class="line"><span class="type">int</span> mini = left;</span><br><span class="line"><span class="type">int</span> tmp = left;</span><br><span class="line"><span class="keyword">while</span> (tmp &lt;= right)        <span class="comment">//9 1 3 6 7 2 5 4 10 8</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[tmp] &lt; arr[mini])  <span class="comment">//当找到更小的,记录坐标</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//Swap(&amp;arr[tmp], &amp;arr[mini]);  //swap使用太频繁,效率略低</span></span><br><span class="line">mini = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[tmp] &gt; arr[maxi])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//Swap(&amp;arr[tmp], &amp;arr[maxi]);</span></span><br><span class="line">maxi = tmp;</span><br><span class="line">&#125;</span><br><span class="line">tmp++;</span><br><span class="line">&#125;</span><br><span class="line">Swap(&amp;arr[left], &amp;arr[mini]);</span><br><span class="line"><span class="keyword">if</span> (left== maxi) <span class="comment">//如果left上就是最大值,那么第一次交换会使得第二次交换失效</span></span><br><span class="line">&#123;</span><br><span class="line">maxi = mini;</span><br><span class="line">&#125;</span><br><span class="line">Swap(&amp;arr[right], &amp;arr[maxi]);</span><br><span class="line">left++;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AdjustDown</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n, <span class="type">int</span> root)</span> <span class="comment">//向下调整算法  使最大位于顶</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> parent = root;</span><br><span class="line"><span class="type">int</span> child = root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (child &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[child + <span class="number">1</span>] &gt; arr[child] &amp;&amp; child + <span class="number">1</span> &lt; n) <span class="comment">//是child为最大的孩子,并且不越数组</span></span><br><span class="line">&#123;</span><br><span class="line">child++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[child] &gt; arr[parent])</span><br><span class="line">&#123;</span><br><span class="line">Swap(&amp;arr[child], &amp;arr[parent]);</span><br><span class="line">parent = child;</span><br><span class="line">child = child * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span> <span class="comment">//堆排序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//要排升序,建立大堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = (n<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">AdjustDown(arr, n, i);  <span class="comment">//n为结束的标志,虽然开始数据很少,但是i初始赋值很大</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> end = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Swap(&amp;arr[end], &amp;arr[<span class="number">0</span>]);</span><br><span class="line">AdjustDown(arr, end, <span class="number">0</span>);</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span> <span class="comment">//冒泡排序法   9 1 3 6 7 2 5 4 10 8</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> end = n;</span><br><span class="line"><span class="keyword">while</span> (end &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> exchange = <span class="number">0</span>;  <span class="comment">//当一趟冒泡排序中没有发生交换,则已经有序,不需要再排</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; end; i++) <span class="comment">//一趟</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i<span class="number">-1</span>] &gt; arr[i])</span><br><span class="line">&#123;</span><br><span class="line">Swap(&amp;arr[i<span class="number">-1</span>], &amp;arr[i]);</span><br><span class="line">exchange = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">end--;</span><br><span class="line"><span class="keyword">if</span> (exchange == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _Find_Mid(<span class="type">int</span>* arr,<span class="type">int</span> left,<span class="type">int</span> right) <span class="comment">//以防每次快排都是最差的情况(选择出最大或最小的数字作为key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[left] &lt; arr[mid])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt; arr[right])  <span class="comment">// 3 5 7</span></span><br><span class="line">&#123;</span><br><span class="line">Swap(&amp;arr[mid], &amp;arr[right]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[right] &lt; arr[left])</span><br><span class="line">&#123;</span><br><span class="line">Swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[left] &gt; arr[mid])  <span class="comment">//  5  3  1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; arr[right])</span><br><span class="line">&#123;</span><br><span class="line">Swap(&amp;arr[mid], &amp;arr[right]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[right] &gt; arr[left])</span><br><span class="line">&#123;</span><br><span class="line">Swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _Left_right_point_Part_Sort(<span class="type">int</span>* arr,<span class="type">int</span> left,<span class="type">int</span> right)  <span class="comment">//左右指针法</span></span><br><span class="line">&#123;</span><br><span class="line">_Find_Mid(arr,left,right); <span class="comment">//优化</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> keyindex = right;</span><br><span class="line"><span class="type">int</span> key = arr[right]; <span class="comment">//将key默认设置为最后一个数</span></span><br><span class="line"><span class="comment">//左大右小 进行交换  9 1 3 6 7 2 5 4 10 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (arr[left] &lt;= key &amp;&amp; left &lt; right)  <span class="comment">//这里第二次判断left &gt; right 画图测试</span></span><br><span class="line">&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (arr[right] &gt;= key &amp;&amp; left &lt; right)  </span><br><span class="line">&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">Swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">&#125;</span><br><span class="line">Swap(&amp;arr[left], &amp;arr[keyindex]);</span><br><span class="line"><span class="keyword">return</span> left;  <span class="comment">//返回key值所在下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _Dig_Blank_Part_Sort(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)  <span class="comment">//挖坑法 本质上与左右指针法类似</span></span><br><span class="line">&#123;</span><br><span class="line">_Find_Mid(arr,left,right);</span><br><span class="line"><span class="comment">// 9 1 3 6 7 2 5 4 10 8</span></span><br><span class="line"><span class="comment">//最右挖坑 从左开始  同样两个指针一起填坑  替换坑位  左大换,右小换</span></span><br><span class="line"><span class="type">int</span> key = arr[right];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt; key) <span class="comment">//左边小于右边时,向后继续搜索直到找到大的</span></span><br><span class="line">&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">arr[right] = arr[left];</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; key)</span><br><span class="line">&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">arr[left] = arr[right];</span><br><span class="line">&#125;</span><br><span class="line">arr[left] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _Prev_Back_point_Part_Sort(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right) <span class="comment">//前后指针法  类似于将大数翻在前面,小数留在后面</span></span><br><span class="line">&#123;</span><br><span class="line">_Find_Mid(arr, left, right);</span><br><span class="line"><span class="type">int</span> prev = left;</span><br><span class="line"><span class="type">int</span> back = left - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (prev &lt; right)  <span class="comment">// 9 1 3 6 7 2 5 4 10 8  前指针小于key(代码中right)就交换前后指针数值</span></span><br><span class="line">&#123;                                           </span><br><span class="line"><span class="keyword">if</span>( arr[prev] &lt; arr[right] &amp;&amp; ++back != prev)<span class="comment">//前指针大于key,if条件中(由于&amp;&amp;)不执行++back</span></span><br><span class="line">&#123;                                            <span class="comment">//前指针小于key,prev不动,先让back动</span></span><br><span class="line">Swap(&amp;arr[prev], &amp;arr[back]);            <span class="comment">//有时在开始时都小于,back++后,prev == back</span></span><br><span class="line">&#125;                                            <span class="comment">//交换不交换一样,所以直接跳出if提升效率</span></span><br><span class="line">prev++;</span><br><span class="line">&#125;</span><br><span class="line">Swap(&amp;arr[++back], &amp;arr[right]); <span class="comment">//此时在back前面一定是大于key的,所以++,使key为div</span></span><br><span class="line"><span class="keyword">return</span> back;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归改非递归一般两种方法 1.简单的递归可以使用普通的循环处理 2.较为困难的需要使用栈</span></span><br><span class="line"><span class="comment">//非递归的方法具有两个缺点</span></span><br><span class="line"><span class="comment">// 1.提高效率,递归需要建立栈帧(每个未运行完的函数都有一个栈帧,栈帧保存了函数的返回地址和局部变量)</span></span><br><span class="line"><span class="comment">//   会有消耗,但对于现代计算机,消耗可以忽略不计</span></span><br><span class="line"><span class="comment">// 2.最大的缺陷是,如果栈帧太深,会导致栈溢出,栈的空间不大,只有10M左右</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _Without_Recursion_Part_Sort(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">assert(arr);         <span class="comment">// 9 1 3 6 7 2 5 4 10 8 将数据坐标入栈</span></span><br><span class="line">Sta <span class="built_in">stack</span>;</span><br><span class="line">StackInit(&amp;<span class="built_in">stack</span>);</span><br><span class="line">StackPush(&amp;<span class="built_in">stack</span>, right);   <span class="comment">//输入坐标</span></span><br><span class="line">StackPush(&amp;<span class="built_in">stack</span>, left);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!StackEmpty(&amp;<span class="built_in">stack</span>)) <span class="comment">//当栈内不为空时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> begin = StackTop(&amp;<span class="built_in">stack</span>);</span><br><span class="line">StackPop(&amp;<span class="built_in">stack</span>);   <span class="comment">//使用完删除</span></span><br><span class="line"><span class="type">int</span> end = StackTop(&amp;<span class="built_in">stack</span>);</span><br><span class="line">StackPop(&amp;<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> div = _Prev_Back_point_Part_Sort(arr, begin, end);</span><br><span class="line"><span class="keyword">if</span> (div + <span class="number">1</span> &lt; end)</span><br><span class="line">&#123;</span><br><span class="line">StackPush(&amp;<span class="built_in">stack</span>, end);</span><br><span class="line">StackPush(&amp;<span class="built_in">stack</span>, div + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (begin &lt; div - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">StackPush(&amp;<span class="built_in">stack</span>,div - <span class="number">1</span>);</span><br><span class="line">StackPush(&amp;<span class="built_in">stack</span>, begin);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">StackDestroy(&amp;<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>  <span class="comment">//快速排序  本质使用递归</span></span><br><span class="line">&#123;</span><br><span class="line">assert(arr);</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int div = _Left_right_point_Part_Sort(arr, left, right); </span></span><br><span class="line"><span class="comment">//int div = _Dig_Blank_Part_Sort(arr, left, right);</span></span><br><span class="line"><span class="type">int</span> div = _Prev_Back_point_Part_Sort(arr, left, right);</span><br><span class="line"><span class="comment">//_Without_Recursion_Part_Sort(arr, left, right);  //单独一个函数就可完成排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对key值左右进行处理</span></span><br><span class="line"><span class="comment">//当每个递归后剩余的数字小于15时可以不使用递归,增高效率,此时排序最优解为插入排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (right - left &gt; <span class="number">15</span>)</span><br><span class="line">&#123;</span><br><span class="line">QuickSort(arr, left, div - <span class="number">1</span>);</span><br><span class="line">QuickSort(arr, div + <span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">InsertSort(arr, right - left + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*QuickSort(arr, left, div - 1);</span></span><br><span class="line"><span class="comment">QuickSort(arr, div + 1, right);*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge_Sort_Arr_Part</span><span class="params">( <span class="type">int</span>* arr, <span class="type">int</span>* tmp,<span class="type">int</span> begin1,<span class="type">int</span> end1,<span class="type">int</span> begin2,<span class="type">int</span> end2)</span> <span class="comment">//合并的过程</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> left = begin1, right = end2;  <span class="comment">//为后面赋值arr做准备</span></span><br><span class="line"><span class="type">int</span> index = begin1;</span><br><span class="line"><span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[begin1] &lt;= arr[begin2])</span><br><span class="line">&#123;</span><br><span class="line">tmp[index++] = arr[begin1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp[index++] = arr[begin2++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (begin1 &lt;= end1)</span><br><span class="line">&#123;</span><br><span class="line">tmp[index++] = arr[begin1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (begin2 &lt;= end2)</span><br><span class="line">&#123;</span><br><span class="line">tmp[index++] = arr[begin2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将tmp内的值赋给arr</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge_Sort_Part</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span>* tmp,<span class="type">int</span> left, <span class="type">int</span> right)</span>  <span class="comment">//归并排序,将两段有序的数组归并为一段有序的数组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right) <span class="comment">//分割停止标志</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mid = (left + right) / <span class="number">2</span>;     <span class="comment">// 9 1 3 6 7 2 5 4 10 8</span></span><br><span class="line"><span class="comment">//当两边无序,即左右两段数组数据个数大于1</span></span><br><span class="line"><span class="comment">//开始分割</span></span><br><span class="line">Merge_Sort_Part(arr, tmp, left, mid);</span><br><span class="line">Merge_Sort_Part(arr, tmp, mid+<span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当两边有序,左右两端数组数据个数为1</span></span><br><span class="line"><span class="comment">//开始合并</span></span><br><span class="line">Merge_Sort_Arr_Part(arr,tmp,left,mid,mid+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge_No_Recursion_Sort_Part</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span>* tmp, <span class="type">int</span> n)</span> <span class="comment">//使用非递归的方式归并</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//逐渐增长的gap之间归并</span></span><br><span class="line"><span class="type">int</span> gap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (gap &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i+=<span class="number">2</span>*gap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> begin1 = i, end1 = i + gap - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> begin2 = i+gap, end2 = i + <span class="number">2</span>*gap - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (begin2 &gt;= n) <span class="comment">//此时被分割的第二组已经超过整个数组,即不存在</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (end2 &gt;= n) <span class="comment">//此时第二组不能被整分,需要调整end2</span></span><br><span class="line">&#123;</span><br><span class="line">end2 = n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整之后开始归并</span></span><br><span class="line">Merge_Sort_Arr_Part(arr, tmp, begin1, end1, begin2, end2);</span><br><span class="line">&#125;</span><br><span class="line">gap *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span> <span class="comment">//归并排序法</span></span><br><span class="line">&#123;</span><br><span class="line">assert(arr);</span><br><span class="line"><span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Merge_Sort_Part(arr,tmp,0,n-1);  //递归法</span></span><br><span class="line">Merge_No_Recursion_Sort_Part(arr, tmp,n);  <span class="comment">//非递归法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file1,<span class="type">const</span> <span class="type">char</span>* file2,<span class="type">const</span> <span class="type">char</span>* mfile)</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* fout1 = fopen(file1, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fout1==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fout1 error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FILE* fout2 = fopen(file2, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fout2 == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fout2 error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FILE* fin = fopen(mfile, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fin == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fin error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num1, num2;</span><br><span class="line"><span class="type">int</span> ret1 = <span class="built_in">fscanf</span>(fout1, <span class="string">&quot;%d\n&quot;</span>, &amp;num1); <span class="comment">//文件内数据赋予num</span></span><br><span class="line"><span class="type">int</span> ret2 = <span class="built_in">fscanf</span>(fout2, <span class="string">&quot;%d\n&quot;</span>, &amp;num2);</span><br><span class="line"><span class="keyword">while</span> (ret1 != EOF &amp;&amp; ret2 != EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num1 &lt; num2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(fin, <span class="string">&quot;%d\n&quot;</span>, num1);</span><br><span class="line">ret1 = <span class="built_in">fscanf</span>(fout1, <span class="string">&quot;%d\n&quot;</span>, &amp;num1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(fin, <span class="string">&quot;%d\n&quot;</span>, num2);</span><br><span class="line">ret2 = <span class="built_in">fscanf</span>(fout2, <span class="string">&quot;%d\n&quot;</span>, &amp;num2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ret1 != EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(fin, <span class="string">&quot;%d\n&quot;</span>, num1);</span><br><span class="line">ret1 = <span class="built_in">fscanf</span>(fout1, <span class="string">&quot;%d\n&quot;</span>, &amp;num1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (ret2 != EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(fin, <span class="string">&quot;%d\n&quot;</span>, num2);</span><br><span class="line">ret2 = <span class="built_in">fscanf</span>(fout2, <span class="string">&quot;%d\n&quot;</span>, &amp;num2);</span><br><span class="line">&#125;</span><br><span class="line">fclose(fout1);</span><br><span class="line">fclose(fout2);</span><br><span class="line">fclose(fin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSortFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file)</span> <span class="comment">//对文件进行排序</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* fout = fopen(file, <span class="string">&quot;r&quot;</span>); <span class="comment">//打开待排序文件</span></span><br><span class="line"><span class="keyword">if</span> (fout == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fout error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将文件内数据分割为小文件,对小文件内可放置入内存的数据进行快排</span></span><br><span class="line"><span class="comment">//最后将小文件归并</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = <span class="number">10</span>; <span class="comment">//一个小文件内存放的数据个数</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];  <span class="comment">//文件内即将快排的数据放入此数组</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> subfile[<span class="number">20</span>];<span class="comment">//文件名字符串</span></span><br><span class="line"><span class="type">int</span> filei = <span class="number">1</span>;<span class="comment">//储存第filei组内排序后的数据的文件的文件名</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fscanf</span>(fout, <span class="string">&quot;%d\n&quot;</span>, &amp;num) != EOF) <span class="comment">//将fout内数据读入num</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; n - <span class="number">1</span>)<span class="comment">//读取前n-1个数据</span></span><br><span class="line">&#123;</span><br><span class="line">a[i++] = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">a[i] = num;<span class="comment">//读取第n个数据</span></span><br><span class="line">QuickSort(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(subfile, <span class="string">&quot;%d&quot;</span>, filei++);<span class="comment">//将储存第filei组内排序后的数据的文件的文件名命名为filei</span></span><br><span class="line">FILE* fin = fopen(subfile, <span class="string">&quot;w&quot;</span>);<span class="comment">//创建一个以字符串subfile[20]为名字的文件并打开</span></span><br><span class="line"><span class="keyword">if</span> (fin == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;first fin error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//将内排序排好的数据写入到subfile文件中</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(fin, <span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line">fclose(fin);</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相互排序归并至文件,实现整体有序</span></span><br><span class="line"><span class="type">char</span> mfile[<span class="number">100</span>] = <span class="string">&quot;12&quot;</span>;</span><br><span class="line"><span class="type">char</span> file1[<span class="number">100</span>] = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="type">char</span> file2[<span class="number">100</span>] = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">MergeFile(file1, file2, mfile);<span class="comment">//将file1文件和file2文件中的数据归并到mfile文件中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(file1, mfile);<span class="comment">//下一次待归并的第一个文件就是上一次归并好的文件</span></span><br><span class="line"><span class="built_in">sprintf</span>(file2, <span class="string">&quot;%d&quot;</span>, i + <span class="number">1</span>);<span class="comment">//上一次待归并的第二个文件的文件名加一，就是下一次待归并的第二个文件的文件名</span></span><br><span class="line"><span class="built_in">sprintf</span>(mfile, <span class="string">&quot;%s%d&quot;</span>, mfile, i + <span class="number">1</span>);<span class="comment">//下一次归并后文件的文件名</span></span><br><span class="line">&#125;</span><br><span class="line">fclose(fout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CountSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span> <span class="comment">//数据范围内创建数组,遍历后遇见数组下标有关的数据,数组内容++</span></span><br><span class="line">&#123;</span><br><span class="line">assert(arr);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> min = arr[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//创建数组,范围确定</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; max)</span><br><span class="line">&#123;</span><br><span class="line">max = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; min)</span><br><span class="line">&#123;</span><br><span class="line">min = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * range); <span class="comment">//创建数组</span></span><br><span class="line"><span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * range); <span class="comment">//数组初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp[arr[i] - min]++; <span class="comment">//每遇见下标对应的数据,和数组数据相同时是,下标内容++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (tmp[i]--) <span class="comment">//下标数据为0时停止赋值,进入下一个下标</span></span><br><span class="line">&#123;</span><br><span class="line">arr[index++] = i + min; <span class="comment">//i可看作tmp的下标,进行赋值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="非递归方式实现快排的栈接口函数-Stack-c"><a href="#非递归方式实现快排的栈接口函数-Stack-c" class="headerlink" title="非递归方式实现快排的栈接口函数(Stack.c)"></a>非递归方式实现快排的栈接口函数(Stack.c)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sort.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackInit</span><span class="params">(Sta* pst)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pst);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*pst-&gt;_a = NULL;</span></span><br><span class="line"><span class="comment">    pst-&gt;_capacity = 0;</span></span><br><span class="line"><span class="comment">    pst-&gt;_top = 0;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化之后还需再分配,可写为  以简洁</span></span><br><span class="line"></span><br><span class="line">    pst-&gt;_a = <span class="literal">NULL</span>;</span><br><span class="line">    pst-&gt;_top = <span class="number">0</span>;</span><br><span class="line">    pst-&gt;_capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackDestroy</span><span class="params">(Sta* pst)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pst);</span><br><span class="line">    <span class="built_in">free</span>(pst-&gt;_a);</span><br><span class="line">    pst-&gt;_a = <span class="literal">NULL</span>;</span><br><span class="line">    pst-&gt;_top = <span class="number">0</span>;</span><br><span class="line">    pst-&gt;_capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPush</span><span class="params">(Sta* pst, StackData x)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pst);</span><br><span class="line">    <span class="comment">//判断空间是否足够,增容</span></span><br><span class="line">    <span class="keyword">if</span> (pst-&gt;_top == pst-&gt;_capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> capacity = pst-&gt;_capacity == <span class="number">0</span> ? <span class="number">4</span> : pst-&gt;_capacity * <span class="number">2</span>;</span><br><span class="line">        StackData* tmp = (StackData*)<span class="built_in">realloc</span>(pst-&gt;_a, <span class="keyword">sizeof</span>(StackData) * capacity);</span><br><span class="line">        <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pst-&gt;_a = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;realloc error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pst-&gt;_capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pst-&gt;_a[pst-&gt;_top] = x;</span><br><span class="line">    pst-&gt;_top += <span class="number">1</span>;        <span class="comment">//top标内没有数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPop</span><span class="params">(Sta* pst)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pst);</span><br><span class="line">    assert(pst-&gt;_top &gt; <span class="number">0</span>); <span class="comment">//当堆栈满时不再进行删除</span></span><br><span class="line">    pst-&gt;_top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackSize</span><span class="params">(Sta* pst)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pst);</span><br><span class="line">    <span class="keyword">return</span> pst-&gt;_top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackEmpty</span><span class="params">(Sta* pst)</span>  <span class="comment">//为空返回1,否则返回0</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pst);</span><br><span class="line">    <span class="keyword">return</span> pst-&gt;_top &gt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">StackData <span class="title function_">StackTop</span><span class="params">(Sta* pst)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pst);</span><br><span class="line">    assert(pst-&gt;_top &gt; <span class="number">0</span>);         <span class="comment">//堆栈内不能为空</span></span><br><span class="line">    <span class="keyword">return</span> pst-&gt;_a[pst-&gt;_top - <span class="number">1</span>];  <span class="comment">//减1的原因看 push</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="测试用例-test-c"><a href="#测试用例-test-c" class="headerlink" title="测试用例(test.c)"></a>测试用例(test.c)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TestInsertSort</span><span class="params">()</span> <span class="comment">//插入排序用例</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">9</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">8</span> &#125;;</span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">PrintArray(arr, sz);</span><br><span class="line">InsertSort(arr, sz);</span><br><span class="line">PrintArray(arr, sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TestShellSort</span><span class="params">()</span> <span class="comment">//希尔排序用例</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">9</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">8</span> &#125;;</span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">PrintArray(arr, sz);</span><br><span class="line">ShellSort(arr, sz);</span><br><span class="line">PrintArray(arr, sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TestSelectSort</span><span class="params">()</span> <span class="comment">//选择排序用例</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">10</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span> &#125;;</span><br><span class="line"><span class="comment">//int arr[] = &#123; 3,1,4,1,7,9,8,2,0,5&#125;;</span></span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">PrintArray(arr, sz);</span><br><span class="line">SelectSort(arr, sz);</span><br><span class="line">PrintArray(arr, sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TestHeapSort</span><span class="params">()</span> <span class="comment">//堆排序用例</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">9</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">8</span> &#125;;</span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">PrintArray(arr, sz);</span><br><span class="line">HeapSort(arr, sz);</span><br><span class="line">PrintArray(arr, sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TestBubbleSort</span><span class="params">()</span> <span class="comment">//冒泡排序用例</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">9</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">8</span> &#125;;</span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">PrintArray(arr, sz);</span><br><span class="line">BubbleSort(arr, sz);</span><br><span class="line">PrintArray(arr, sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TestQuickSort</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">9</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">8</span> &#125;;</span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">PrintArray(arr, sz);</span><br><span class="line">QuickSort(arr,<span class="number">0</span>,sz<span class="number">-1</span>);</span><br><span class="line">PrintArray(arr, sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TestMergeSort</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">9</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">8</span> &#125;;</span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">PrintArray(arr, sz);</span><br><span class="line">MergeSort(arr, sz);</span><br><span class="line">PrintArray(arr, sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TestMergeFileSort()</span><br><span class="line">&#123;</span><br><span class="line">MergeSortFile(<span class="string">&quot;Sort.txt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TestCountSort()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">9</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">8</span> &#125;;</span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">PrintArray(arr, sz);</span><br><span class="line">CountSort(arr, sz);</span><br><span class="line">PrintArray(arr, sz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TestDiffernt</span><span class="params">()</span>  <span class="comment">//测试不同函数处理方式的效率</span></span><br><span class="line">&#123;</span><br><span class="line">srand(time(<span class="literal">NULL</span>));  <span class="comment">//time中没有负数,仅用于测试</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100000</span>;</span><br><span class="line"><span class="type">int</span>* a1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * N);</span><br><span class="line"><span class="type">int</span>* a2 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * N);</span><br><span class="line"><span class="type">int</span>* a3 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * N);</span><br><span class="line"><span class="type">int</span>* a4 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * N);</span><br><span class="line"><span class="type">int</span>* a5 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * N);</span><br><span class="line"><span class="type">int</span>* a6 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * N);</span><br><span class="line"><span class="type">int</span>* a7 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * N);</span><br><span class="line"><span class="type">int</span>* a8 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * N);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line">a1[i] = rand();</span><br><span class="line">a2[i] = a1[i];</span><br><span class="line">a3[i] = a1[i];</span><br><span class="line">a4[i] = a1[i];</span><br><span class="line">a5[i] = a1[i];</span><br><span class="line">a6[i] = a1[i];</span><br><span class="line">a7[i] = a1[i];</span><br><span class="line">a8[i] = a1[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin1 = clock();</span><br><span class="line">InsertSort(a1, N);</span><br><span class="line"><span class="type">int</span> end1 = clock();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin2 = clock();</span><br><span class="line">ShellSort(a2, N);</span><br><span class="line"><span class="type">int</span> end2 = clock();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin3 = clock();</span><br><span class="line">SelectSort(a3, N);</span><br><span class="line"><span class="type">int</span> end3 = clock();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin4 = clock();</span><br><span class="line">HeapSort(a4, N);</span><br><span class="line"><span class="type">int</span> end4 = clock();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin5 = clock();</span><br><span class="line">BubbleSort(a5, N);</span><br><span class="line"><span class="type">int</span> end5 = clock();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin6 = clock();</span><br><span class="line">QuickSort(a6, <span class="number">0</span>,N);</span><br><span class="line"><span class="type">int</span> end6 = clock();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin7 = clock();</span><br><span class="line">MergeSort(a7, N);</span><br><span class="line"><span class="type">int</span> end7 = clock();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin8 = clock();</span><br><span class="line">CountSort(a8, N);</span><br><span class="line"><span class="type">int</span> end8 = clock();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;InsertSort time:%d\n&quot;</span>, end1 - begin1); <span class="comment">//5000</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ShellSort time:%d\n&quot;</span>, end2 - begin2);  <span class="comment">//20</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SelectSort time:%d\n&quot;</span>, end3 - begin3); <span class="comment">//5000</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;HeapSort time:%d\n&quot;</span>, end4 - begin4);   <span class="comment">//20</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;BubbleSort time:%d\n&quot;</span>, end5 - begin5); <span class="comment">//30000</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;QuickSort time:%d\n&quot;</span>, end6 - begin6); <span class="comment">//20</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;MergeSort time:%d\n&quot;</span>, end7 - begin7);<span class="comment">//20</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;CountSort time:%d\n&quot;</span>, end8 - begin8);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(a1);</span><br><span class="line"><span class="built_in">free</span>(a2);</span><br><span class="line"><span class="built_in">free</span>(a3);</span><br><span class="line"><span class="built_in">free</span>(a4);</span><br><span class="line"><span class="built_in">free</span>(a5);</span><br><span class="line"><span class="built_in">free</span>(a6);</span><br><span class="line"><span class="built_in">free</span>(a7);</span><br><span class="line"><span class="built_in">free</span>(a8);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TestInsertSort();</span></span><br><span class="line"><span class="comment">//TestShellSort();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//TestSelectSort();</span></span><br><span class="line"><span class="comment">//TestHeapSort();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//TestBubbleSort();</span></span><br><span class="line"><span class="comment">//TestQuickSort();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//TestMergeSort();</span></span><br><span class="line"><span class="comment">//TestMergeFileSort();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//TestCountSort();</span></span><br><span class="line"></span><br><span class="line">TestDiffernt();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构常见类型的搭建</title>
      <link href="/2023/10/21/c-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/10/21/c-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h1><hr><h2 id="头文件-Stack-h"><a href="#头文件-Stack-h" class="headerlink" title="头文件(Stack.h)"></a>头文件(Stack.h)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> StackData;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">StackData* _a;  <span class="comment">//存放数据</span></span><br><span class="line"><span class="type">int</span> _top;       <span class="comment">//顶标</span></span><br><span class="line"><span class="type">int</span> _capacity;  <span class="comment">//存放数量</span></span><br><span class="line">&#125;Sta;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackInit</span><span class="params">(Sta* pst)</span>;     <span class="comment">//初始化堆栈</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackDestroy</span><span class="params">(Sta* pst)</span>;  <span class="comment">//销毁堆栈</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPush</span><span class="params">(Sta* pst,StackData x)</span>;  <span class="comment">//插入数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPop</span><span class="params">(Sta* pst)</span>;  <span class="comment">//删除数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackSize</span><span class="params">(Sta* pst)</span>;  <span class="comment">//堆栈数据个数</span></span><br><span class="line"><span class="comment">// int StackSize(Sta st);  不传入指针也可以,但为了接口函数的一致性传入指针也可以</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackEmpty</span><span class="params">(Sta* pst)</span>;  <span class="comment">//判断堆栈是否为空</span></span><br><span class="line"></span><br><span class="line">StackData <span class="title function_">StackTop</span><span class="params">(Sta* pst)</span>;  <span class="comment">//取出堆栈头的数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="函数接口部分-Stack-c"><a href="#函数接口部分-Stack-c" class="headerlink" title="函数接口部分(Stack.c)"></a>函数接口部分(Stack.c)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Stack.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackInit</span><span class="params">(Sta* pst)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pst);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*pst-&gt;_a = NULL;</span></span><br><span class="line"><span class="comment">    pst-&gt;_capacity = 0;</span></span><br><span class="line"><span class="comment">    pst-&gt;_top = 0;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化之后还需再分配,可写为  以简洁</span></span><br><span class="line"></span><br><span class="line">    pst-&gt;_a = <span class="literal">NULL</span>;</span><br><span class="line">    pst-&gt;_top = <span class="number">0</span>;</span><br><span class="line">    pst-&gt;_capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackDestroy</span><span class="params">(Sta* pst)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pst);</span><br><span class="line">    <span class="built_in">free</span>(pst-&gt;_a);</span><br><span class="line">    pst-&gt;_a = <span class="literal">NULL</span>;</span><br><span class="line">    pst-&gt;_top = <span class="number">0</span>;</span><br><span class="line">    pst-&gt;_capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPush</span><span class="params">(Sta* pst,StackData x)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pst);</span><br><span class="line">    <span class="comment">//判断空间是否足够,增容</span></span><br><span class="line">    <span class="keyword">if</span> (pst-&gt;_top == pst-&gt;_capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> capacity = pst-&gt;_capacity == <span class="number">0</span> ? <span class="number">4</span> : pst-&gt;_capacity * <span class="number">2</span>;</span><br><span class="line">        StackData* tmp = (StackData*)<span class="built_in">realloc</span>(pst-&gt;_a,<span class="keyword">sizeof</span>(StackData)*capacity);</span><br><span class="line">        <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pst-&gt;_a = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;realloc error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pst-&gt;_capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pst-&gt;_a[pst-&gt;_top] = x;</span><br><span class="line">    pst-&gt;_top += <span class="number">1</span>;        <span class="comment">//top标内没有数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPop</span><span class="params">(Sta* pst)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pst);</span><br><span class="line">    assert(pst-&gt;_top &gt; <span class="number">0</span>); <span class="comment">//当堆栈满时不再进行删除</span></span><br><span class="line">    pst-&gt;_top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackSize</span><span class="params">(Sta* pst)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pst);</span><br><span class="line">    <span class="keyword">return</span> pst-&gt;_top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackEmpty</span><span class="params">(Sta* pst)</span>  <span class="comment">//为空返回1,否则返回0</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pst);</span><br><span class="line">    <span class="keyword">return</span> pst-&gt;_top &gt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">StackData <span class="title function_">StackTop</span><span class="params">(Sta* pst)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pst);</span><br><span class="line">    assert(pst-&gt;_top &gt; <span class="number">0</span>);         <span class="comment">//堆栈内不能为空</span></span><br><span class="line">    <span class="keyword">return</span> pst-&gt;_a[pst-&gt;_top <span class="number">-1</span>];  <span class="comment">//减1的原因看 push</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="测试用例-test-c"><a href="#测试用例-test-c" class="headerlink" title="测试用例(test.c)"></a>测试用例(test.c)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Stack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Sta <span class="built_in">stack</span>;</span><br><span class="line">StackInit(&amp;<span class="built_in">stack</span>);</span><br><span class="line">StackPush(&amp;<span class="built_in">stack</span>, <span class="number">1</span>);</span><br><span class="line">StackPush(&amp;<span class="built_in">stack</span>, <span class="number">2</span>);</span><br><span class="line">StackPush(&amp;<span class="built_in">stack</span>, <span class="number">3</span>);</span><br><span class="line">StackPush(&amp;<span class="built_in">stack</span>, <span class="number">4</span>);</span><br><span class="line">StackPush(&amp;<span class="built_in">stack</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">StackPop(&amp;<span class="built_in">stack</span>);</span><br><span class="line">StackPop(&amp;<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (StackEmpty(&amp;<span class="built_in">stack</span>) != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, StackTop(&amp;<span class="built_in">stack</span>));</span><br><span class="line">StackPop(&amp;<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StackDestroy(&amp;<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h1><hr><h2 id="头文件-Queue-h"><a href="#头文件-Queue-h" class="headerlink" title="头文件(Queue.h)"></a>头文件(Queue.h)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span>  <span class="comment">//布尔值,当然也可以用int代替,但布尔值较为方便,具体实现看函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QueDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">Next</span>;</span></span><br><span class="line">QueDataType data;</span><br><span class="line">&#125;QueNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QueNode* _head;</span><br><span class="line">QueNode* _tail;</span><br><span class="line">&#125;Que;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueInit</span><span class="params">(Que* pq)</span>;   <span class="comment">//初始化队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueDestroy</span><span class="params">(Que* pq)</span>; <span class="comment">//销毁队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePush</span><span class="params">(Que* pq, QueDataType x)</span>;  <span class="comment">//插入数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePop</span><span class="params">(Que* pq)</span>;  <span class="comment">//删除数据</span></span><br><span class="line"></span><br><span class="line">QueDataType <span class="title function_">QueueFront</span><span class="params">(Que* pq)</span>;  <span class="comment">//取头数据</span></span><br><span class="line"></span><br><span class="line">QueDataType <span class="title function_">QueueBack</span><span class="params">(Que* pq)</span>;   <span class="comment">//取尾数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueSize</span><span class="params">(Que* pq)</span>;  <span class="comment">//得到队列数据个数</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(Que* qp)</span>;  <span class="comment">//判断队列是否为空</span></span><br></pre></td></tr></table></figure><hr><h2 id="函数接口部分-Queue-c"><a href="#函数接口部分-Queue-c" class="headerlink" title="函数接口部分(Queue.c)"></a>函数接口部分(Queue.c)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueInit</span><span class="params">(Que* pq)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">pq-&gt;_tail = pq-&gt;_head = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueDestroy</span><span class="params">(Que* pq)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">QueNode* cur = pq-&gt;_head;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">QueNode* next = cur-&gt;Next;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line">pq-&gt;_head = pq-&gt;_tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePush</span><span class="params">(Que* pq, QueDataType x)</span>  <span class="comment">//数据放在tail部</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">QueNode* newNode = (QueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueNode));</span><br><span class="line"><span class="keyword">if</span> (newNode != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">newNode-&gt;data = x;</span><br><span class="line">newNode-&gt;Next = <span class="literal">NULL</span>;   <span class="comment">//没有这一步,后面的 pop 和 Empty 就难以实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当队列为空时</span></span><br><span class="line"><span class="keyword">if</span> (QueueEmpty(pq))</span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;_tail = pq-&gt;_head = newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//QueNode* tail = pq-&gt;_tail;</span></span><br><span class="line">pq-&gt;_tail-&gt;Next = newNode;</span><br><span class="line">pq-&gt;_tail = newNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePop</span><span class="params">(Que* pq)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pq);</span><br><span class="line"><span class="comment">//判断队列不为空</span></span><br><span class="line">assert(!(QueueEmpty(pq)));</span><br><span class="line"><span class="comment">//assert(pq-&gt;_head != pq-&gt;_tail);</span></span><br><span class="line"></span><br><span class="line">QueNode* headnext = pq-&gt;_head-&gt;Next;</span><br><span class="line"><span class="built_in">free</span>(pq-&gt;_head);</span><br><span class="line">pq-&gt;_head = headnext;</span><br><span class="line"><span class="keyword">if</span> (pq-&gt;_head == <span class="literal">NULL</span>)  <span class="comment">//防止把tail释放后却不为空指针仍然可以调用</span></span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;_tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(Que* pq)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pq);</span><br><span class="line"><span class="keyword">return</span> pq-&gt;_head == <span class="literal">NULL</span>;  <span class="comment">//为真返回ture(非0),为假返回false(0)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QueDataType <span class="title function_">QueueBack</span><span class="params">(Que* pq)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">assert(!(QueueEmpty(pq)));</span><br><span class="line"><span class="keyword">return</span> pq-&gt;_tail-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QueDataType <span class="title function_">QueueFront</span><span class="params">(Que* pq)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">assert(!(QueueEmpty(pq)));</span><br><span class="line"><span class="keyword">return</span> pq-&gt;_head-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueSize</span><span class="params">(Que* pq)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pq);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">QueNode* cur = pq-&gt;_head;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;Next;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="测试用例-test-c-1"><a href="#测试用例-test-c-1" class="headerlink" title="测试用例(test.c)"></a>测试用例(test.c)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Que <span class="built_in">queue</span>;</span><br><span class="line">QueueInit(&amp;<span class="built_in">queue</span>);</span><br><span class="line">QueuePush(&amp;<span class="built_in">queue</span>, <span class="number">1</span>);</span><br><span class="line">QueuePush(&amp;<span class="built_in">queue</span>, <span class="number">2</span>);</span><br><span class="line">QueuePush(&amp;<span class="built_in">queue</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">QueuePop(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!QueueEmpty(&amp;<span class="built_in">queue</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, QueueFront(&amp;<span class="built_in">queue</span>));</span><br><span class="line">QueuePop(&amp;<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">QueueDestroy(&amp;<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="三、无头单向非循环链表"><a href="#三、无头单向非循环链表" class="headerlink" title="三、无头单向非循环链表"></a>三、无头单向非循环链表</h1><hr><h2 id="头文件-SL-h"><a href="#头文件-SL-h" class="headerlink" title="头文件(SL.h)"></a>头文件(SL.h)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> typeSL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">typeSL data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;SLNode;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListpushfront</span><span class="params">(SLNode ** pphead,typeSL x)</span>; <span class="comment">//头插  实现过程中要改变指针的内容,所以传二级指针  end</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListpopfront</span><span class="params">(SLNode** pphead)</span>; <span class="comment">//头删  end</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListpushback</span><span class="params">(SLNode** pphead,typeSL x)</span>; <span class="comment">//尾插  end</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListpopback</span><span class="params">(SLNode** pphead)</span>; <span class="comment">//尾删  end</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListInsertAfter</span><span class="params">(SLNode* pos,typeSL x)</span>; <span class="comment">//后插  不前插,因为查找后返回的地址想要得到上一个链书写量过大 end</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListEraseAfter</span><span class="params">(SLNode* phead)</span>; <span class="comment">//后删</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListInsert</span><span class="params">(SLNode**pphead,SLNode*pos,typeSL x)</span>;    <span class="comment">//前插;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListErase</span><span class="params">(SLNode**pphead,SLNode*pos)</span>;     <span class="comment">//删除pos数据</span></span><br><span class="line"></span><br><span class="line">SLNode* <span class="title function_">SListFind</span><span class="params">(SLNode* phead , typeSL x)</span>;<span class="comment">//查找  end</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListprint</span><span class="params">(SLNode* phead)</span>; <span class="comment">//打印  end</span></span><br><span class="line"></span><br><span class="line">SLNode* <span class="title function_">BuySListNode</span><span class="params">(typeSL x)</span>; <span class="comment">//创建新节点  end</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListDestory</span><span class="params">(SLNode** pphead)</span>; <span class="comment">//销毁链表</span></span><br></pre></td></tr></table></figure><hr><h2 id="函数接口部分-SL-c"><a href="#函数接口部分-SL-c" class="headerlink" title="函数接口部分(SL.c)"></a>函数接口部分(SL.c)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SL.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SLNode* <span class="title function_">BuySListNode</span><span class="params">(typeSL x)</span> <span class="comment">//创建结点并赋值</span></span><br><span class="line">&#123;</span><br><span class="line">SLNode* newNode = (SLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode));</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;Buy malloc&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">newNode-&gt;data = x;</span><br><span class="line">newNode-&gt;next = <span class="literal">NULL</span>; <span class="comment">//至空</span></span><br><span class="line"><span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListpushback</span><span class="params">(SLNode** pphead,typeSL x)</span> <span class="comment">//尾插</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pphead);  <span class="comment">//即使*pphead为NULL , pphead不可能为空,assert可以方便我们更快的找出错误</span></span><br><span class="line">                 <span class="comment">//并且当pphead为NULL时,会使*pphead访问冲突</span></span><br><span class="line"></span><br><span class="line">SLNode* newNode = BuySListNode(x); <span class="comment">//创建节点</span></span><br><span class="line"><span class="keyword">if</span> (*pphead == <span class="literal">NULL</span>) <span class="comment">//如果没有结点,直接赋</span></span><br><span class="line">&#123;</span><br><span class="line">*pphead = newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找尾</span></span><br><span class="line">SLNode* tail = *pphead;</span><br><span class="line"><span class="keyword">while</span> (tail-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">tail = tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">tail-&gt;next = newNode;  <span class="comment">//对地址上的数据进行改变</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListpopback</span><span class="params">(SLNode** pphead)</span> <span class="comment">//尾删</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pphead);</span><br><span class="line"><span class="keyword">if</span> (*pphead == <span class="literal">NULL</span>) <span class="comment">//1.没有结点  assert(*pphead);</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((*pphead)-&gt;next == <span class="literal">NULL</span>) <span class="comment">//2.只有一个节点  注意括号的作用</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(*pphead);</span><br><span class="line">*pphead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>                              <span class="comment">//3.一个以上的节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找尾</span></span><br><span class="line">SLNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">SLNode* tail = *pphead;</span><br><span class="line"><span class="keyword">while</span> (tail-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">prev = tail;</span><br><span class="line">tail = tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(tail);</span><br><span class="line">prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListprint</span><span class="params">(SLNode* phead)</span> <span class="comment">//打印链表</span></span><br><span class="line">&#123;</span><br><span class="line">SLNode* cur = phead;</span><br><span class="line"><span class="keyword">while</span> (cur) <span class="comment">//处理当前位置,不用cur-&gt;next</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>,cur-&gt;data );</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListpushfront</span><span class="params">(SLNode** pphead, typeSL x)</span> <span class="comment">//头插</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pphead);</span><br><span class="line">SLNode* newNode = BuySListNode(x);</span><br><span class="line">newNode-&gt;next = *pphead;</span><br><span class="line">*pphead = newNode; <span class="comment">//head是头,这一步使头变成插入的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListpopfront</span><span class="params">(SLNode** pphead)</span> <span class="comment">//头删</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pphead);</span><br><span class="line"><span class="comment">//1.没有结点</span></span><br><span class="line"><span class="comment">//2.有一个或一个以上的结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*pphead == <span class="literal">NULL</span>) <span class="comment">//没有结点时   assert(*pphead);</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>                 <span class="comment">//有一个或一个以上,实现方法一样,故而写在一起</span></span><br><span class="line">&#123;</span><br><span class="line">SLNode* Next = (*pphead)-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(*pphead);</span><br><span class="line">*pphead = Next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SLNode* <span class="title function_">SListFind</span><span class="params">(SLNode* phead, typeSL x)</span> <span class="comment">//查找目标数值,返回地址</span></span><br><span class="line">&#123;</span><br><span class="line">SLNode* pos = phead;</span><br><span class="line"><span class="keyword">while</span> (pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pos-&gt;data == x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line">pos = pos-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListInsertAfter</span><span class="params">( SLNode* pos, typeSL x)</span>  <span class="comment">//根据返回地址之后进行插入</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pos);</span><br><span class="line"></span><br><span class="line">SLNode* newNode = BuySListNode(x);</span><br><span class="line">newNode-&gt;next = pos-&gt;next;</span><br><span class="line">pos-&gt;next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListEraseAfter</span><span class="params">(SLNode* pos)</span> <span class="comment">//后删</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pos);</span><br><span class="line"><span class="comment">//assert(pos-&gt;next);  可以加上,使得后删时pos后面必须有数字</span></span><br><span class="line"><span class="keyword">if</span> (pos-&gt;next)  <span class="comment">//如果pos后面有元素</span></span><br><span class="line">&#123;</span><br><span class="line">SLNode* posnext = pos-&gt;next;</span><br><span class="line">SLNode* posnextnext = posnext-&gt;next; <span class="comment">//pos-&gt;next = posnext-&gt;next;</span></span><br><span class="line">pos-&gt;next = posnextnext;             <span class="comment">//可以代替这两行</span></span><br><span class="line"><span class="built_in">free</span>(posnext);</span><br><span class="line"><span class="comment">//posnext-&gt;next = NULL;  由于函数运行后会自动释放内存,所以置空指针可以省去</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListDestory</span><span class="params">(SLNode** pphead)</span>   <span class="comment">//销毁链表</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pphead);</span><br><span class="line"></span><br><span class="line">SLNode* cur = *pphead;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">SLNode* next = cur-&gt;next;   <span class="comment">//每次额外创建一个存储cur的下一个</span></span><br><span class="line"><span class="built_in">free</span>(cur);                  <span class="comment">//释放指针指向的内存后</span></span><br><span class="line">cur = next;                 <span class="comment">//cur在变为额外创建的指针</span></span><br><span class="line">&#125;</span><br><span class="line">*pphead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListInsert</span><span class="params">(SLNode** pphead,SLNode*pos,typeSL x)</span>  <span class="comment">//前插</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pphead);</span><br><span class="line">assert(pos);</span><br><span class="line"></span><br><span class="line">SLNode* newNode = BuySListNode(x);</span><br><span class="line"><span class="keyword">if</span> (*pphead == pos)    <span class="comment">//当pphead就是所要寻找数字的位置</span></span><br><span class="line">&#123;</span><br><span class="line">newNode-&gt;next = pos;</span><br><span class="line">*pphead = newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">SLNode* pospre = *pphead;   <span class="comment">//找到pos前的位置</span></span><br><span class="line"><span class="keyword">while</span> (pospre-&gt;next != pos)</span><br><span class="line">&#123;</span><br><span class="line">pospre = pospre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">pospre-&gt;next = newNode;</span><br><span class="line">newNode-&gt;next = pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListErase</span><span class="params">(SLNode** pphead, SLNode* pos)</span>   <span class="comment">//删除pos数据</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pphead);</span><br><span class="line">assert(pos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pos == *pphead)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//直接调用头删函数</span></span><br><span class="line">SListpopfront(pphead);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找到pos前的位置</span></span><br><span class="line">SLNode* pospre = *pphead;   <span class="comment">//找到pos前的位置</span></span><br><span class="line"><span class="keyword">while</span> (pospre-&gt;next != pos)</span><br><span class="line">&#123;</span><br><span class="line">pospre = pospre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">pospre-&gt;next = pos-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(pos);</span><br><span class="line"><span class="comment">//pos = NULL;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试用例-test-c-2"><a href="#测试用例-test-c-2" class="headerlink" title="测试用例(test.c)"></a>测试用例(test.c)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SL.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">SLNode* phead =<span class="literal">NULL</span>; <span class="comment">//初始化</span></span><br><span class="line">SListpushfront(&amp;phead, <span class="number">1</span>);</span><br><span class="line">SListpushfront(&amp;phead, <span class="number">2</span>);</span><br><span class="line">SListpushfront(&amp;phead, <span class="number">3</span>);</span><br><span class="line">SListpushfront(&amp;phead, <span class="number">4</span>);</span><br><span class="line">SListprint(phead);  <span class="comment">//4321N</span></span><br><span class="line"></span><br><span class="line">SListpopfront(&amp;phead);</span><br><span class="line">SListpopfront(&amp;phead);</span><br><span class="line">SListpopfront(&amp;phead);</span><br><span class="line">SListprint(phead);  <span class="comment">//1N</span></span><br><span class="line"></span><br><span class="line">SListpushback(&amp;phead, <span class="number">2</span>);</span><br><span class="line">SListpushback(&amp;phead, <span class="number">3</span>);</span><br><span class="line">SListpushback(&amp;phead, <span class="number">4</span>);</span><br><span class="line">SListpushback(&amp;phead, <span class="number">5</span>);</span><br><span class="line">SListprint(phead); <span class="comment">//12345N</span></span><br><span class="line"></span><br><span class="line">SListpopback(&amp;phead);</span><br><span class="line">SListpopback(&amp;phead);</span><br><span class="line">SListpopback(&amp;phead);</span><br><span class="line">SListprint(phead); <span class="comment">//12N</span></span><br><span class="line"></span><br><span class="line">SListInsertAfter(SListFind(phead, <span class="number">1</span>), <span class="number">3</span>);</span><br><span class="line">SListprint(phead);    <span class="comment">//132N</span></span><br><span class="line">SListEraseAfter(SListFind(phead, <span class="number">3</span>));</span><br><span class="line">SListprint(phead);    <span class="comment">//13N </span></span><br><span class="line"></span><br><span class="line">SListDestory(&amp;phead);</span><br><span class="line">SListprint(phead); <span class="comment">//N</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">SLNode* phead = <span class="literal">NULL</span>; <span class="comment">//初始化</span></span><br><span class="line">SListpushfront(&amp;phead, <span class="number">1</span>);</span><br><span class="line">SListpushfront(&amp;phead, <span class="number">2</span>);</span><br><span class="line">SListpushfront(&amp;phead, <span class="number">3</span>);</span><br><span class="line">SListpushfront(&amp;phead, <span class="number">4</span>);</span><br><span class="line">SListprint(phead);  <span class="comment">//4321N</span></span><br><span class="line"></span><br><span class="line">SListInsert(phead, SListFind(phead, <span class="number">3</span>), <span class="number">1</span>);</span><br><span class="line">SListprint(phead);  <span class="comment">//41321N</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line"><span class="comment">//test2();</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="四、有头双向循环链表"><a href="#四、有头双向循环链表" class="headerlink" title="四、有头双向循环链表"></a>四、有头双向循环链表</h1><hr><h2 id="头文件-ListNode-h"><a href="#头文件-ListNode-h" class="headerlink" title="头文件(ListNode.h)"></a>头文件(ListNode.h)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ListNode data;</span><br><span class="line">ListNode* next;</span><br><span class="line">ListNode* prev;</span><br><span class="line">&#125;LNode;</span><br><span class="line"></span><br><span class="line">LNode* <span class="title function_">ListNodeInit</span><span class="params">()</span>; <span class="comment">//初始化双链表</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListNodepushback</span><span class="params">(LNode* phead,ListNode x)</span>; <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListNodepopback</span><span class="params">(LNode* phead)</span>;  <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListNodepushfront</span><span class="params">(LNode* phead,ListNode x)</span>;  <span class="comment">//头插</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListNodepopfront</span><span class="params">(LNode* phead)</span>; <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListNodeDestroy</span><span class="params">(LNode* phead)</span>; <span class="comment">//销毁链表</span></span><br><span class="line"></span><br><span class="line">LNode* <span class="title function_">ListNodeFind</span><span class="params">(LNode* phead,ListNode x)</span>;   <span class="comment">//寻找</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListNodepop</span><span class="params">(LNode* pos)</span>;    <span class="comment">//位删</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListNodepush</span><span class="params">(LNode* pos,ListNode x)</span>;   <span class="comment">//位前插</span></span><br><span class="line"></span><br><span class="line">LNode* <span class="title function_">BuyListNode</span><span class="params">(ListNode x)</span>;   <span class="comment">//补充数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListNodePrint</span><span class="params">(LNode* phead)</span>;  <span class="comment">//打印链表</span></span><br></pre></td></tr></table></figure><hr><h2 id="函数接口部分-ListNode-c"><a href="#函数接口部分-ListNode-c" class="headerlink" title="函数接口部分(ListNode.c)"></a>函数接口部分(ListNode.c)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ListNode.h&quot;</span></span></span><br><span class="line">LNode* <span class="title function_">BuyListNode</span><span class="params">(ListNode x)</span>    <span class="comment">//创建新链表</span></span><br><span class="line">&#123;</span><br><span class="line">LNode* newNode = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"><span class="keyword">if</span> (newNode != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">newNode-&gt;data = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;newNode创建失败&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LNode* <span class="title function_">ListNodeInit</span><span class="params">()</span> <span class="comment">//也可以创建二级指针,使返回类型为void   初始化</span></span><br><span class="line">&#123;</span><br><span class="line">LNode*phead = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"><span class="keyword">if</span> (phead != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">phead-&gt;next = phead;</span><br><span class="line">phead-&gt;prev = phead;</span><br><span class="line"><span class="keyword">return</span> phead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;init error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListNodePrint</span><span class="params">(LNode* phead)</span>        <span class="comment">//打印链表</span></span><br><span class="line">&#123;</span><br><span class="line">assert(phead);</span><br><span class="line">LNode* cur = phead-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (cur != phead)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, cur-&gt;data);</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListNodepushback</span><span class="params">(LNode* phead, ListNode x)</span>  <span class="comment">//尾插</span></span><br><span class="line">&#123;</span><br><span class="line">assert(phead);</span><br><span class="line"><span class="comment">/*LNode* newNode = BuyListNode(x);</span></span><br><span class="line"><span class="comment">LNode* tail = phead-&gt;prev;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">newNode-&gt;prev = tail;</span></span><br><span class="line"><span class="comment">newNode-&gt;next = phead;</span></span><br><span class="line"><span class="comment">tail-&gt;next = newNode;</span></span><br><span class="line"><span class="comment">phead-&gt;prev = newNode;    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于在phead位置前插</span></span><br><span class="line">    <span class="comment">//所以断言之后可以写为</span></span><br><span class="line"><span class="comment">// ListNodepush(phead,x);</span></span><br><span class="line">ListNodepush(phead, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListNodepopback</span><span class="params">(LNode* phead)</span>   <span class="comment">//尾删</span></span><br><span class="line">&#123;</span><br><span class="line">assert(phead);</span><br><span class="line">LNode* tail = phead-&gt;prev;</span><br><span class="line">assert(tail != phead);   <span class="comment">//当只有哨兵时不进入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//phead-&gt;prev = tail-&gt;prev;</span></span><br><span class="line"><span class="comment">//tail = tail-&gt;prev;</span></span><br><span class="line"><span class="comment">//free(tail-&gt;next);   </span></span><br><span class="line"><span class="comment">//tail-&gt;next = phead;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ListNodepop(tail);</span></span><br><span class="line">ListNodepop(tail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListNodepushfront</span><span class="params">(LNode* phead, ListNode x)</span>  <span class="comment">//头插</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*assert(phead);</span></span><br><span class="line"><span class="comment">LNode* newNode = BuyListNode(x);</span></span><br><span class="line"><span class="comment">LNode* Next = phead-&gt;next;</span></span><br><span class="line"><span class="comment">phead-&gt;next = newNode;</span></span><br><span class="line"><span class="comment">newNode-&gt;next = Next;</span></span><br><span class="line"><span class="comment">newNode-&gt;prev = phead;</span></span><br><span class="line"><span class="comment">Next-&gt;prev = newNode;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同尾插几乎一样</span></span><br><span class="line"><span class="comment">//可以写为</span></span><br><span class="line"><span class="comment">//ListNodepush(phead-&gt;next,x);</span></span><br><span class="line">ListNodepush(phead-&gt;next, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListNodepopfront</span><span class="params">(LNode* phead)</span>  <span class="comment">//头删</span></span><br><span class="line">&#123;</span><br><span class="line">assert(phead);</span><br><span class="line">assert(phead-&gt;next != phead);</span><br><span class="line"><span class="comment">/*LNode* Next = phead-&gt;next;</span></span><br><span class="line"><span class="comment">LNode* Nextnext = Next-&gt;next;</span></span><br><span class="line"><span class="comment">phead-&gt;next = Nextnext;</span></span><br><span class="line"><span class="comment">Nextnext-&gt;prev = phead;</span></span><br><span class="line"><span class="comment">free(Next);*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ListNodepop(phead-&gt;next);</span></span><br><span class="line">ListNodepop(phead-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListNodeDestroy</span><span class="params">(LNode* phead)</span> <span class="comment">//销毁链表</span></span><br><span class="line">&#123;</span><br><span class="line">assert(phead);</span><br><span class="line">LNode* cur = phead-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (cur != phead)</span><br><span class="line">&#123;</span><br><span class="line">LNode* curnext = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line">cur = curnext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(phead);</span><br><span class="line">phead = <span class="literal">NULL</span>;   <span class="comment">//函数结束自动释放内存 可加可不加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LNode* <span class="title function_">ListNodeFind</span><span class="params">(LNode* phead, ListNode x)</span>  <span class="comment">//寻找数据</span></span><br><span class="line">&#123;</span><br><span class="line">LNode* cur = phead-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (cur != phead)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;data == x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListNodepop</span><span class="params">(LNode* pos)</span>   <span class="comment">//位删,phead被删了怎么办   可以加入哨兵位参数实现防止删除哨兵位</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pos);</span><br><span class="line">LNode* posnext = pos-&gt;next;</span><br><span class="line">LNode* posprev = pos-&gt;prev;</span><br><span class="line"></span><br><span class="line">posnext-&gt;prev = posprev;</span><br><span class="line">posprev-&gt;next = posnext;</span><br><span class="line"><span class="built_in">free</span>(pos);</span><br><span class="line">pos = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListNodepush</span><span class="params">(LNode* pos, ListNode x)</span>  <span class="comment">//位前插</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pos);</span><br><span class="line">LNode* newNode = BuyListNode(x);</span><br><span class="line">LNode* posprev = pos-&gt;prev;</span><br><span class="line"></span><br><span class="line">newNode-&gt;prev = posprev;</span><br><span class="line">newNode-&gt;next = pos;</span><br><span class="line">posprev-&gt;next = newNode;</span><br><span class="line">pos-&gt;prev = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="测试用例-test-c-3"><a href="#测试用例-test-c-3" class="headerlink" title="测试用例(test.c)"></a>测试用例(test.c)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ListNode.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">LNode* phead = ListNodeInit();</span><br><span class="line">ListNodepushback(phead, <span class="number">1</span>);</span><br><span class="line">ListNodepushback(phead, <span class="number">2</span>);</span><br><span class="line">ListNodepushback(phead, <span class="number">3</span>);</span><br><span class="line">ListNodepopback(phead);</span><br><span class="line">ListNodepopback(phead);</span><br><span class="line">ListNodepopback(phead);</span><br><span class="line">ListNodepushfront(phead, <span class="number">1</span>);</span><br><span class="line">ListNodepushfront(phead, <span class="number">2</span>);</span><br><span class="line">ListNodepushfront(phead, <span class="number">3</span>);</span><br><span class="line">ListNodepopfront(phead);</span><br><span class="line">ListNodepush(ListNodeFind(phead, <span class="number">2</span>), <span class="number">4</span>);</span><br><span class="line">ListNodepush(ListNodeFind(phead, <span class="number">2</span>), <span class="number">3</span>);</span><br><span class="line">ListNodepush(ListNodeFind(phead, <span class="number">2</span>), <span class="number">3</span>);</span><br><span class="line">ListNodepop(ListNodeFind(phead, <span class="number">4</span>));</span><br><span class="line">ListNodepop(ListNodeFind(phead, <span class="number">1</span>));</span><br><span class="line">ListNodepop(ListNodeFind(phead, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">ListNodePrint(phead);</span><br><span class="line"></span><br><span class="line">ListNodeDestroy(phead);</span><br><span class="line">phead = <span class="literal">NULL</span>;  <span class="comment">//手动置空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">LNode* phead = ListNodeInit();</span><br><span class="line">ListNodepushback(phead, <span class="number">1</span>);</span><br><span class="line">ListNodepushback(phead, <span class="number">2</span>);</span><br><span class="line">ListNodepushback(phead, <span class="number">3</span>);</span><br><span class="line">ListNodepopback(phead);</span><br><span class="line">ListNodepopback(phead);</span><br><span class="line">ListNodepopback(phead);</span><br><span class="line">ListNodepushfront(phead, <span class="number">1</span>);</span><br><span class="line">ListNodepushfront(phead, <span class="number">2</span>);</span><br><span class="line">ListNodepushfront(phead, <span class="number">3</span>);</span><br><span class="line">ListNodepopfront(phead);</span><br><span class="line">ListNodepopfront(phead);</span><br><span class="line">ListNodepopfront(phead);</span><br><span class="line">ListNodepopfront(phead);</span><br><span class="line">ListNodePrint(phead);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//test1();</span></span><br><span class="line">test2();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="五、堆"><a href="#五、堆" class="headerlink" title="五、堆"></a>五、堆</h1><hr><h2 id="头文件-Heap-h"><a href="#头文件-Heap-h" class="headerlink" title="头文件(Heap.h)"></a>头文件(Heap.h)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//只对根两边都为小堆情况下使用</span></span><br><span class="line"><span class="comment">//当然可以自行将其处理为根两边都是小堆</span></span><br><span class="line"><span class="comment">//小堆即父都小于子</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对AdjustDown进行处理也可以将顺序表变为大堆,父子大小对比符号改变即可</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Hpdatatype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Heap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Hpdatatype* _a;</span><br><span class="line"><span class="type">int</span> _size;</span><br><span class="line"><span class="type">int</span> _capacity;</span><br><span class="line">&#125;Heap;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapInit</span><span class="params">(Heap* php, Hpdatatype* x, <span class="type">int</span> n)</span>;  <span class="comment">//初始化堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AdjustDown</span><span class="params">(Hpdatatype* a, <span class="type">int</span> n, <span class="type">int</span> root)</span>; <span class="comment">//向下调整算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(Hpdatatype* a, Hpdatatype* b)</span>;   <span class="comment">//交换两数据函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapDestroy</span><span class="params">(Heap* php)</span>;  <span class="comment">//销毁堆</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapPush</span><span class="params">(Heap* php, Hpdatatype x)</span>;   <span class="comment">//添加数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapPop</span><span class="params">(Heap*php)</span>;   <span class="comment">//删除一个数据</span></span><br><span class="line"></span><br><span class="line">Hpdatatype <span class="title function_">Heaptop</span><span class="params">(Heap* php)</span>;  <span class="comment">//取root</span></span><br></pre></td></tr></table></figure><hr><h2 id="函数接口的实现-Heap-c"><a href="#函数接口的实现-Heap-c" class="headerlink" title="函数接口的实现(Heap.c)"></a>函数接口的实现(Heap.c)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Heap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(Hpdatatype * a,Hpdatatype *b)</span>  <span class="comment">//AjustDown 内部的交换函数,接下的函数也会经常调用, 因此创建</span></span><br><span class="line">&#123;</span><br><span class="line">Hpdatatype* tmp = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AdjustDown</span><span class="params">(Hpdatatype *a,<span class="type">int</span> n ,<span class="type">int</span> root)</span>  <span class="comment">//原顺序表,数量,根</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> parant = root;</span><br><span class="line"><span class="type">int</span> child = parant * <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">//创建坐标  默认较小的孩子为左孩子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (child &lt; n)  <span class="comment">//当孩子坐标超过创建数组大小,停止向下调整算法</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; a[child + <span class="number">1</span>] &lt; a[child]) <span class="comment">//判断child+1 &lt; n 防止越界, 如果 &gt;n 说明只有一个孩子</span></span><br><span class="line">&#123;</span><br><span class="line">child = child + <span class="number">1</span>;    <span class="comment">//通过计算将较小孩子的坐标变为child</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a[parant] &gt; a[child]) <span class="comment">//当父亲大于子,开始交换</span></span><br><span class="line">&#123;</span><br><span class="line">swap(&amp;a[parant], &amp;a[child]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换后改变坐标 继续下次循环</span></span><br><span class="line">parant = child;</span><br><span class="line">child = child * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//当父亲本来就比子小</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;   <span class="comment">//因为默认两边为小堆,所以直接break跳出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapInit</span><span class="params">(Heap* php, Hpdatatype* x, <span class="type">int</span> n)</span>  <span class="comment">//n为总结点</span></span><br><span class="line">&#123;</span><br><span class="line">php-&gt;_a = (Hpdatatype*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Heap) * n); <span class="comment">//先创建空间供给于 php</span></span><br><span class="line"><span class="keyword">if</span> (php-&gt;_a != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(php-&gt;_a, x, <span class="keyword">sizeof</span>(Hpdatatype) * n);<span class="comment">//将函数外部创建的数组复制到 php内,以完成初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">php-&gt;_size = n;</span><br><span class="line">php-&gt;_capacity = n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上只是构建出了一个数组</span></span><br><span class="line"><span class="comment">//以下为构建堆</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从坐标最后的 叶的父,开始使用向下调整算法,使其变为小堆</span></span><br><span class="line"><span class="comment">//最后一个数据坐标为 n-1  , 那么推出其父坐标为 (坐标 -1) /2</span></span><br><span class="line"><span class="comment">//所以得(n-1-1)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = (n - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">AdjustDown(php-&gt;_a,php-&gt;_size,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapDestroy</span><span class="params">(Heap* php)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(php);</span><br><span class="line"><span class="built_in">free</span>(php-&gt;_a);</span><br><span class="line">php-&gt;_a = <span class="literal">NULL</span>;</span><br><span class="line">php-&gt;_size = <span class="number">0</span>;</span><br><span class="line">php-&gt;_capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AdjustUp</span><span class="params">(Hpdatatype* a, <span class="type">int</span> n, <span class="type">int</span> child)</span> <span class="comment">//数组,数量,最后一个孩子</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//while (parent &gt;= 0)  parent的判断条件不允许其为负数  -1 / 2 = 0;</span></span><br><span class="line"><span class="keyword">while</span> (child &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[child] &gt;= a[parent])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">swap(&amp;a[child], &amp;a[parent]);</span><br><span class="line">child = parent;</span><br><span class="line">parent = (parent - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapPush</span><span class="params">(Heap* php, Hpdatatype x)</span>  <span class="comment">//添加数据后 考虑扩容  关系的改变</span></span><br><span class="line">&#123;</span><br><span class="line">assert(php);</span><br><span class="line"><span class="keyword">if</span> (php-&gt;_size == php-&gt;_capacity)</span><br><span class="line">&#123;</span><br><span class="line">php-&gt;_capacity *= <span class="number">2</span>;</span><br><span class="line">Hpdatatype* tmp = (Hpdatatype*)<span class="built_in">realloc</span>(php-&gt;_a, <span class="keyword">sizeof</span>(Hpdatatype) * php-&gt;_capacity); <span class="comment">//扩容</span></span><br><span class="line"><span class="keyword">if</span> (tmp != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">php-&gt;_a = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;realloc error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">php-&gt;_a[php-&gt;_size] = x;</span><br><span class="line">++php-&gt;_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加完开始处理关系</span></span><br><span class="line"><span class="comment">//观察可发现并不是需要调整整个树,而是一条线的关系,即向上调整算法</span></span><br><span class="line"></span><br><span class="line">AdjustUp(php-&gt;_a, php-&gt;_size, php-&gt;_size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapPop</span><span class="params">(Heap* php)</span>  <span class="comment">//删除堆顶数据  普通删除方式删除后还需要移动整个顺序表,这里采用头尾交换后除尾</span></span><br><span class="line">&#123;</span><br><span class="line">assert(php);</span><br><span class="line">assert(php-&gt;_size &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">swap(&amp;php-&gt;_a[<span class="number">0</span>], &amp;php-&gt;_a[php-&gt;_size - <span class="number">1</span>]);</span><br><span class="line">--php-&gt;_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换后对除去尾的顺序表再Adjust 使头变为次小数 </span></span><br><span class="line"><span class="comment">//调整树之间的关系</span></span><br><span class="line">AdjustDown(php-&gt;_a,php-&gt;_size,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hpdatatype <span class="title function_">Heaptop</span><span class="params">(Heap* php)</span>  <span class="comment">//取根数据 , 即当前树 最小/最大 的数据</span></span><br><span class="line">&#123;</span><br><span class="line">assert(php);</span><br><span class="line">assert(php-&gt;_size &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> php-&gt;_a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="测试用例-test-c-4"><a href="#测试用例-test-c-4" class="headerlink" title="测试用例(test.c)"></a>测试用例(test.c)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Heap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>  <span class="comment">//a为数组,n为数组元素个数  这里测试降序排序  降序创建小堆  升序创建大堆</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = (n - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)  <span class="comment">//先将数组变为小堆</span></span><br><span class="line">&#123;</span><br><span class="line">AdjustDown(a,n,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始通过交换首尾的方式进行排序</span></span><br><span class="line"><span class="comment">//首在小堆中绝对是最小的数,将它放在最后</span></span><br><span class="line"><span class="comment">//再暂时排除最后一个数,进行Adjust</span></span><br><span class="line"><span class="comment">//首即为次小的数</span></span><br><span class="line"><span class="comment">//以此类推便可得到降序排列的数据 </span></span><br><span class="line"><span class="type">int</span> end = n - <span class="number">1</span>;  <span class="comment">//end 为最后一个数据的坐标</span></span><br><span class="line"><span class="keyword">while</span> (end &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">swap(&amp;a[<span class="number">0</span>], &amp;a[end]);</span><br><span class="line">AdjustDown(a, end, <span class="number">0</span>);</span><br><span class="line">--end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">27</span>,<span class="number">15</span>,<span class="number">19</span>,<span class="number">18</span>,<span class="number">28</span>,<span class="number">34</span>,<span class="number">65</span>,<span class="number">49</span>,<span class="number">25</span>,<span class="number">37</span> &#125;;</span><br><span class="line">HeapSort(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(Hpdatatype));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">27</span>,<span class="number">15</span>,<span class="number">19</span>,<span class="number">18</span>,<span class="number">28</span>,<span class="number">34</span>,<span class="number">65</span>,<span class="number">49</span>,<span class="number">25</span>,<span class="number">37</span> &#125;;</span><br><span class="line">Heap hp;</span><br><span class="line">HeapInit(&amp;hp, arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(Hpdatatype)); <span class="comment">//arr整个大小除一个Hpdata大小得出arr内数据个数</span></span><br><span class="line">HeapPush(&amp;hp, <span class="number">3</span>);</span><br><span class="line">HeapPush(&amp;hp, <span class="number">66</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">test1();  <span class="comment">//接口测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//test2(); //通过堆排序</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="六、完全二叉树"><a href="#六、完全二叉树" class="headerlink" title="六、完全二叉树"></a>六、完全二叉树</h1><hr><h2 id="头文件-BinaryTree-h"><a href="#头文件-BinaryTree-h" class="headerlink" title="头文件(BinaryTree.h)"></a>头文件(BinaryTree.h)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树本质上也是递归出来的树</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span> <span class="comment">//布尔值的头文件包含</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> BTDataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">BTDataType _data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span>* _<span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span>* _<span class="title">right</span>;</span></span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line">BTNode* <span class="title function_">CreatBTNode</span><span class="params">(BTDataType x)</span>;  <span class="comment">//创建一个树结点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BTSize</span><span class="params">(BTNode* root)</span>;  <span class="comment">//求出树的节点个数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BTLeafSize</span><span class="params">(BTNode* root)</span>; <span class="comment">//求出树叶的个数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BTDeepSize</span><span class="params">(BTNode* root)</span>; <span class="comment">//求出树的深度</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintPrevOrder</span><span class="params">(BTNode* root)</span>; <span class="comment">//按前序打印树</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintInOrder</span><span class="params">(BTNode* root)</span>; <span class="comment">//按中序打印树</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintBackOrder</span><span class="params">(BTNode* root)</span>; <span class="comment">//按后序打印树</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BTLevelKSize</span><span class="params">(BTNode* root,<span class="type">int</span> k)</span>; <span class="comment">//树的第K层结点个数</span></span><br><span class="line"></span><br><span class="line">BTNode* <span class="title function_">BTFindX</span><span class="params">(BTNode* root, BTDataType x)</span>; <span class="comment">//寻找结点数据为x的结点</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BTDestroy</span><span class="params">(BTNode* root)</span>;  <span class="comment">//销毁树</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintLevelOrder</span><span class="params">(BTNode* root)</span>; <span class="comment">//层序打印树  此时需要使用队列方便打印</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BTComplete</span><span class="params">(BTNode* root)</span>;  <span class="comment">//判断树是否为完全二叉树</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//以下为队列的声明</span></span><br><span class="line"><span class="comment">//此时队列内部数据应为 树</span></span><br><span class="line"><span class="comment">//以调用树的孩子 来进行算法的实现</span></span><br><span class="line"><span class="comment">//放入队列第一个根的左右孩子,同时将队列第一个根移除</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> BTNode* QueDataType;  <span class="comment">//队列类型为树,以便接口实现</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">Next</span>;</span></span><br><span class="line">QueDataType data;</span><br><span class="line">&#125;QueNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QueNode* _head;</span><br><span class="line">QueNode* _tail;</span><br><span class="line">&#125;Que;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueInit</span><span class="params">(Que* pq)</span>;   <span class="comment">//初始化队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueDestroy</span><span class="params">(Que* pq)</span>; <span class="comment">//销毁队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePush</span><span class="params">(Que* pq, QueDataType x)</span>;  <span class="comment">//插入数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePop</span><span class="params">(Que* pq)</span>;  <span class="comment">//删除数据</span></span><br><span class="line"></span><br><span class="line">QueDataType <span class="title function_">QueueFront</span><span class="params">(Que* pq)</span>;  <span class="comment">//取头数据</span></span><br><span class="line"></span><br><span class="line">QueDataType <span class="title function_">QueueBack</span><span class="params">(Que* pq)</span>;   <span class="comment">//取尾数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueSize</span><span class="params">(Que* pq)</span>;  <span class="comment">//得到队列数据个数</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(Que* qp)</span>;  <span class="comment">//判断队列是否为空</span></span><br></pre></td></tr></table></figure><hr><h2 id="函数接口的实现-BinaryTree-c"><a href="#函数接口的实现-BinaryTree-c" class="headerlink" title="函数接口的实现(BinaryTree.c)"></a>函数接口的实现(BinaryTree.c)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BinaryTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintPrevOrder</span><span class="params">(BTNode* root)</span>  <span class="comment">//以递归为主</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL &quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,root-&gt;_data);</span><br><span class="line">PrintPrevOrder(root-&gt;_left);</span><br><span class="line">PrintPrevOrder(root-&gt;_right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintInOrder</span><span class="params">(BTNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL &quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">PrintInOrder(root-&gt;_left);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;_data);</span><br><span class="line">PrintInOrder(root-&gt;_right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintBackOrder</span><span class="params">(BTNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL &quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">PrintBackOrder(root-&gt;_left);</span><br><span class="line">PrintBackOrder(root-&gt;_right);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BTNode* <span class="title function_">CreatBTNode</span><span class="params">(BTDataType x)</span>   <span class="comment">//创建一个树结点</span></span><br><span class="line">&#123;</span><br><span class="line">BTNode* node = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line"><span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">node-&gt;_left = node-&gt;_right = <span class="literal">NULL</span>;</span><br><span class="line">node-&gt;_data = x;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Creat malloc error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//求出节点个数,int*以防止数据重复或丢失,但并不为最优解</span></span><br><span class="line"><span class="comment">//int BTSize(BTNode* root,int* size) </span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//if (root == NULL)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//else</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//(*size)++;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//BTSize(root-&gt;_left,size);</span></span><br><span class="line"><span class="comment">//BTSize(root-&gt;_right,size);</span></span><br><span class="line"><span class="comment">//return *size;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BTSize</span><span class="params">(BTNode* root)</span>  <span class="comment">//求出树结点个数优解</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + BTSize(root-&gt;_left) + BTSize(root-&gt;_right);  <span class="comment">//递归思想</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BTLeafSize</span><span class="params">(BTNode* root)</span>  <span class="comment">//求出树叶个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;_left == <span class="literal">NULL</span> &amp;&amp; root-&gt;_right == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> BTLeafSize(root-&gt;_left) + BTLeafSize(root-&gt;_right);  <span class="comment">//递归思想</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BTDeepSize</span><span class="params">(BTNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return BTDeepSize(root-&gt;_left) &gt; BTDeepSize(root-&gt;_right) ? 1+BTDeepSize(root-&gt;_left) : 1+BTDeepSize(root-&gt;_right);</span></span><br><span class="line"><span class="comment">//这样写虽然不错,但是效率太低,递归重复</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> leftdepth = BTDeepSize(root-&gt;_left);</span><br><span class="line"><span class="type">int</span> rightdepth = BTDeepSize(root-&gt;_right);</span><br><span class="line"><span class="keyword">return</span> leftdepth &gt; rightdepth ? leftdepth + <span class="number">1</span> : rightdepth + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BTLevelKSize</span><span class="params">(BTNode* root,<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>)  <span class="comment">//第一层只有根,因此只有一个</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> BTLevelKSize(root-&gt;_left, k - <span class="number">1</span>) + BTLevelKSize(root-&gt;_right, k - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//每当进入左或右子树,此时所求的第K层变为相对于新根的K-1层</span></span><br><span class="line"><span class="comment">//当到所求的K层时, k==1 成立, +1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BTNode* <span class="title function_">BTFindX</span><span class="params">(BTNode* root, BTDataType x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_data == x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BTNode* node = BTFindX(root-&gt;_left,x);  <span class="comment">//以下递归可以直接求出结果</span></span><br><span class="line"><span class="keyword">if</span> (node)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node = BTFindX(root-&gt;_left, x);</span><br><span class="line"><span class="keyword">if</span> (node)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BTDestroy</span><span class="params">(BTNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BTDestroy(root-&gt;_left);</span><br><span class="line">BTDestroy(root-&gt;_right);</span><br><span class="line"><span class="built_in">free</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintLevelOrder</span><span class="params">(BTNode* root)</span> <span class="comment">//调用队列</span></span><br><span class="line">&#123;</span><br><span class="line">Que que;</span><br><span class="line">QueueInit(&amp;que);</span><br><span class="line">QueuePush(&amp;que, root);  <span class="comment">//传入树根</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!(QueueEmpty(&amp;que)))</span><br><span class="line">&#123;</span><br><span class="line">BTNode* front = QueueFront(&amp;que);  <span class="comment">//取出队列头结点,并删除</span></span><br><span class="line">QueuePop(&amp;que);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, front-&gt;_data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (front-&gt;_left)   <span class="comment">//当结点孩子不为空时,就放入其孩子于队列</span></span><br><span class="line">&#123;</span><br><span class="line">QueuePush(&amp;que, front-&gt;_left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (front-&gt;_right)</span><br><span class="line">&#123;</span><br><span class="line">QueuePush(&amp;que, front-&gt;_right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">QueueDestroy(&amp;que);  <span class="comment">//销毁队列释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BTComplete</span><span class="params">(BTNode* root)</span>  <span class="comment">//若为完全二叉树,则在队列中如果出现NULL,则后面全是NULL</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Que que;</span><br><span class="line">QueueInit(&amp;que);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!QueueEmpty(&amp;que))</span><br><span class="line">&#123;</span><br><span class="line">BTNode* front = QueueFront(&amp;que);</span><br><span class="line">QueuePop(&amp;que);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (front == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QueuePush(&amp;que, front-&gt;_left); <span class="comment">//放在if后,防止break前Push空指针的左右孩子</span></span><br><span class="line">QueuePush(&amp;que, front-&gt;_right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!QueueEmpty(&amp;que))</span><br><span class="line">&#123;</span><br><span class="line">BTNode* front = QueueFront(&amp;que);</span><br><span class="line"><span class="keyword">if</span> (front != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">QueueDestroy(&amp;que);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">QueuePop(&amp;que);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">QueueDestroy(&amp;que);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="队列的引用接口实现部分-Queue-c"><a href="#队列的引用接口实现部分-Queue-c" class="headerlink" title="队列的引用接口实现部分(Queue.c)"></a>队列的引用接口实现部分(Queue.c)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BinaryTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueInit</span><span class="params">(Que* pq)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">pq-&gt;_tail = pq-&gt;_head = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueDestroy</span><span class="params">(Que* pq)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">QueNode* cur = pq-&gt;_head;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">QueNode* next = cur-&gt;Next;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line">pq-&gt;_head = pq-&gt;_tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePush</span><span class="params">(Que* pq, QueDataType x)</span>  <span class="comment">//数据放在tail部</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">QueNode* newNode = (QueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueNode));</span><br><span class="line"><span class="keyword">if</span> (newNode != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">newNode-&gt;data = x;</span><br><span class="line">newNode-&gt;Next = <span class="literal">NULL</span>;   <span class="comment">//没有这一步,后面的 pop 和 Empty 就难以实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当队列为空时</span></span><br><span class="line"><span class="keyword">if</span> (QueueEmpty(pq))</span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;_tail = pq-&gt;_head = newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//QueNode* tail = pq-&gt;_tail;</span></span><br><span class="line">pq-&gt;_tail-&gt;Next = newNode;</span><br><span class="line">pq-&gt;_tail = newNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePop</span><span class="params">(Que* pq)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pq);</span><br><span class="line"><span class="comment">//判断队列不为空</span></span><br><span class="line">assert(!(QueueEmpty(pq)));</span><br><span class="line"><span class="comment">//assert(pq-&gt;_head != pq-&gt;_tail);</span></span><br><span class="line"></span><br><span class="line">QueNode* headnext = pq-&gt;_head-&gt;Next;</span><br><span class="line"><span class="built_in">free</span>(pq-&gt;_head);</span><br><span class="line">pq-&gt;_head = headnext;</span><br><span class="line"><span class="keyword">if</span> (pq-&gt;_head == <span class="literal">NULL</span>)  <span class="comment">//防止把tail释放后却不为空指针仍然可以调用</span></span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;_tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(Que* pq)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pq);</span><br><span class="line"><span class="keyword">return</span> pq-&gt;_head == <span class="literal">NULL</span>;  <span class="comment">//为真返回ture(非0),为假返回false(0)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QueDataType <span class="title function_">QueueBack</span><span class="params">(Que* pq)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">assert(!(QueueEmpty(pq)));</span><br><span class="line"><span class="keyword">return</span> pq-&gt;_tail-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QueDataType <span class="title function_">QueueFront</span><span class="params">(Que* pq)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">assert(!(QueueEmpty(pq)));</span><br><span class="line"><span class="keyword">return</span> pq-&gt;_head-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueSize</span><span class="params">(Que* pq)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(pq);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">QueNode* cur = pq-&gt;_head;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;Next;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="测试用例-test-c-5"><a href="#测试用例-test-c-5" class="headerlink" title="测试用例(test.c)"></a>测试用例(test.c)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BinaryTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">BTNode* A = CreatBTNode(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">BTNode* B = CreatBTNode(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">BTNode* C = CreatBTNode(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">BTNode* D = CreatBTNode(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">BTNode* E = CreatBTNode(<span class="string">&#x27;E&#x27;</span>);</span><br><span class="line"><span class="comment">//    A</span></span><br><span class="line"><span class="comment">//  B   C</span></span><br><span class="line"><span class="comment">// D E </span></span><br><span class="line"></span><br><span class="line">A-&gt;_left = B;  </span><br><span class="line">A-&gt;_right = C; </span><br><span class="line">B-&gt;_left = D;  </span><br><span class="line">B-&gt;_right = E; </span><br><span class="line"></span><br><span class="line">PrintPrevOrder(A);  <span class="comment">//前序打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">PrintInOrder(A);    <span class="comment">//中序打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">PrintBackOrder(A);  <span class="comment">//后序打印  以上三种为顺序</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">PrintLevelOrder(A); <span class="comment">//层序打印  层序</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下注释非最优解的处理方式</span></span><br><span class="line"><span class="comment">/*int sizea = 0;</span></span><br><span class="line"><span class="comment">sizea = BTSize(A);</span></span><br><span class="line"><span class="comment">printf(&quot;ATree&#x27;s Size is %d&quot;,sizea);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int sizeb = 0;</span></span><br><span class="line"><span class="comment">sizeb = BTSize(B);</span></span><br><span class="line"><span class="comment">printf(&quot;BTree&#x27;s Size is %d&quot;, sizeb);*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    A</span></span><br><span class="line"><span class="comment">//  B   C</span></span><br><span class="line"><span class="comment">// D E </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ATree %d\n&quot;</span>, BTSize(A)); <span class="comment">//5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;BTree %d\n&quot;</span>, BTSize(B)); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ATree leaf %d\n&quot;</span>, BTLeafSize(A)); <span class="comment">//3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;BTree leaf %d\n&quot;</span>, BTLeafSize(B)); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ATree Deep %d\n&quot;</span>, BTDeepSize(A)); <span class="comment">//3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ATree Deep %d\n&quot;</span>, BTDeepSize(A)); <span class="comment">//3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;BTree Deep %d\n&quot;</span>, BTDeepSize(B)); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (BTComplete(A))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;complete&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;uncomplete&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通讯录</title>
      <link href="/2023/10/21/c-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%80%9A%E8%AE%AF%E5%BD%95/"/>
      <url>/2023/10/21/c-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%80%9A%E8%AE%AF%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一、项目头文件-project-h"><a href="#一、项目头文件-project-h" class="headerlink" title="一、项目头文件(project.h)"></a>一、项目头文件(project.h)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">inputnum</span> //输入数字</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Exit,</span><br><span class="line">Add,</span><br><span class="line">Del,</span><br><span class="line">Query,</span><br><span class="line">Modify,</span><br><span class="line">Sort,</span><br><span class="line">Display,</span><br><span class="line">Reset</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MAX</span>            //字符串的最大大小</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Name_MAX = <span class="number">20</span>,</span><br><span class="line">Sex_MAX = <span class="number">5</span>,</span><br><span class="line">Adress_MAX = <span class="number">30</span>,</span><br><span class="line">Tel_MAX = <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Peopleinfo</span>   //一个人的信息</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> name[Name_MAX];</span><br><span class="line"><span class="type">char</span> sex[Sex_MAX];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> tel[Tel_MAX];</span><br><span class="line"><span class="type">char</span> adress[Adress_MAX];</span><br><span class="line">&#125;Ppinfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Connect</span>      //信息组</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Ppinfo* data;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> capacity;</span><br><span class="line">&#125;Con;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>;               <span class="comment">//菜单  end</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Init</span><span class="params">(Con* con)</span>;    <span class="comment">//初始化  end</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Add</span><span class="params">(Con* con)</span>;     <span class="comment">//增加信息  end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Del</span><span class="params">(Con* con)</span>;     <span class="comment">//删除信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Delask</span><span class="params">(Con* con, <span class="type">int</span> jud, <span class="type">int</span>(*(*Cmp)[<span class="number">5</span>])(Con*, <span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>))</span>;   <span class="comment">//删除信息中的函数分支，用于判断多个重复查找对象的删除</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Query</span><span class="params">(Con* con)</span>;   <span class="comment">//查找</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_goal</span><span class="params">(Con* con, <span class="type">int</span> jud, <span class="type">int</span>(*(*Cmp)[<span class="number">5</span>])(Con*, <span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>))</span>;  <span class="comment">//通过选择方式打印出需要查找的内容函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Modify</span><span class="params">(Con* con)</span>;  <span class="comment">//更改</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Modifyask</span><span class="params">(Con* con, <span class="type">int</span> jud, <span class="type">int</span>(*(*Cmp)[<span class="number">5</span>])(Con*, <span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>))</span>; <span class="comment">//更改选择函数分支</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Sort</span><span class="params">(Con* con)</span>;    <span class="comment">//排列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Display</span><span class="params">(Con* con)</span>; <span class="comment">//展现出通讯录</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Reset</span><span class="params">(Con* con)</span>;   <span class="comment">//销毁通讯录</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_expand</span><span class="params">(Con* con)</span>;     <span class="comment">//增加通信录容量  end</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">Pp_Save</span><span class="params">(Con* con)</span>;   <span class="comment">//保存通讯录至硬盘      </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_alloc</span><span class="params">(Con* con)</span>;      <span class="comment">//释放动态内存 </span></span><br></pre></td></tr></table></figure><hr><h1 id="二、项目主干部分-test-c"><a href="#二、项目主干部分-test-c" class="headerlink" title="二、项目主干部分(test.c)"></a>二、项目主干部分(test.c)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;project.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">Con con = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">Pp_Init(&amp;con);    <span class="comment">//初始化结构体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">menu();<span class="comment">//打印菜单</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line"><span class="keyword">switch</span> (input)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> Add:</span><br><span class="line">Pp_Add(&amp;con);  </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Del:</span><br><span class="line">Pp_Del(&amp;con); </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Query:</span><br><span class="line">Pp_Query(&amp;con); </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Modify:</span><br><span class="line">Pp_Modify(&amp;con); </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Sort:</span><br><span class="line">Pp_Sort(&amp;con); </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Reset:</span><br><span class="line">Pp_Reset(&amp;con); </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Display:</span><br><span class="line">Pp_Display(&amp;con);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Exit:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;正在存储信息中...\n&quot;</span>);</span><br><span class="line">Pp_Save(&amp;con); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;存储成功\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入格式错误，请再次输入\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (input);</span><br><span class="line"></span><br><span class="line">free_alloc(&amp;con);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;退出成功\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="三、函数实现部分-contact-c"><a href="#三、函数实现部分-contact-c" class="headerlink" title="三、函数实现部分(contact.c)"></a>三、函数实现部分(contact.c)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;project.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> judgee = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span> <span class="comment">//菜单  end</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;     ---------------------------------------------- \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    |       请根据您所需要的功能选择数字           |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;     ---------------------------------------------- \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    |      0:Exit   |    1:Add     |  2:Delete     |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;     ---------------------------------------------- \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    |      3:Query  |    4:Modify  |  5:Sort       |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;     ---------------------------------------------- \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    |           6:Display  |   7:Reset             |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;     ---------------------------------------------- \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_expand</span><span class="params">(Con* con)</span>   <span class="comment">//扩展空间为原来的二倍   </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (con-&gt;size == con-&gt;capacity)</span><br><span class="line">&#123;</span><br><span class="line">Ppinfo* str = (Ppinfo*)<span class="built_in">realloc</span>(con-&gt;data, (con-&gt;capacity * <span class="number">2</span>) * (<span class="keyword">sizeof</span>(Ppinfo)));</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;expand&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">con-&gt;data = str;</span><br><span class="line">con-&gt;capacity *= <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;扩容成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Add</span><span class="params">(Con* con)</span> <span class="comment">//增加个人信息   end</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断内存是否够用</span></span><br><span class="line">check_expand(con);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请按,姓名,性别,年龄,电话,地址,的顺序输入信息\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s %s %d %s %s&quot;</span>, &amp;con-&gt;data[con-&gt;size].name, &amp;con-&gt;data[con-&gt;size].sex, &amp;con-&gt;data[con-&gt;size].age, &amp;con-&gt;data[con-&gt;size].tel, &amp;con-&gt;data[con-&gt;size].adress);</span><br><span class="line">con-&gt;size++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入成功...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">File_load</span><span class="params">(Con* con)</span>  <span class="comment">//初始化时加载之前保存文件至当前通讯录  end</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* pf = fopen(<span class="string">&quot;contact.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;Load fopen&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">Ppinfo tmp = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (fread(&amp;tmp, <span class="keyword">sizeof</span>(Ppinfo), <span class="number">1</span>, pf))</span><br><span class="line">&#123;</span><br><span class="line">check_expand(con);</span><br><span class="line">con-&gt;data[con-&gt;size] = tmp;</span><br><span class="line">con-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line">fclose(pf);</span><br><span class="line">pf = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Init</span><span class="params">(Con* con)</span>  <span class="comment">//初始化  end</span></span><br><span class="line">&#123;</span><br><span class="line">assert(con);</span><br><span class="line">con-&gt;size = <span class="number">0</span>;</span><br><span class="line">con-&gt;capacity = <span class="number">8</span>;</span><br><span class="line">con-&gt;data = (Ppinfo*)<span class="built_in">malloc</span>(con-&gt;capacity * (<span class="keyword">sizeof</span>(Ppinfo)));</span><br><span class="line"></span><br><span class="line">File_load(con);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_alloc</span><span class="params">(Con* con)</span>  <span class="comment">//释放动态内存分配过的空间  end</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(con-&gt;data);</span><br><span class="line">con-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*Cmp)</span><span class="params">(Con*, <span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>)</span>; <span class="comment">//声明一个函数指针类型 int为这个函数指针所指向函数的返回类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Cmp_name</span><span class="params">(Con* con, <span class="type">const</span> <span class="type">char</span>* str, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(str, con-&gt;data[i].name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Cmp_sex</span><span class="params">(Con* con, <span class="type">const</span> <span class="type">char</span>* str, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(str, con-&gt;data[i].sex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Cmp_age</span><span class="params">(Con* con, <span class="type">const</span> <span class="type">char</span>* str, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> atoi(str) - con-&gt;data[i].age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Cmp_tel</span><span class="params">(Con* con, <span class="type">const</span> <span class="type">char</span>* str, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(str, con-&gt;data[i].tel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Cmp_adress</span><span class="params">(Con* con, <span class="type">const</span> <span class="type">char</span>* str, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(str, con-&gt;data[i].adress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Delask</span><span class="params">(Con* con, <span class="type">int</span> jud, Cmp* ptr)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要删除联系人的信息\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;str);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; con-&gt;size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ptr[jud - <span class="number">1</span>](con, str, i) == <span class="number">0</span>)   <span class="comment">//函数指针数组的调用</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s %d %s %s\n&quot;</span>, con-&gt;data[i].name, con-&gt;data[i].sex, con-&gt;data[i].age, con-&gt;data[i].tel, con-&gt;data[i].adress);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;该联系人是否为您要删除的对象(Y/N)\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> judge = <span class="number">0</span>;</span><br><span class="line">flag:</span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">judge = getchar();</span><br><span class="line"><span class="keyword">switch</span> (judge)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;Y&#x27;</span>:</span><br><span class="line"><span class="keyword">for</span> (; i &lt; con-&gt;size - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">con-&gt;data[i] = con-&gt;data[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">con-&gt;size--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除成功\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入Y或N分别表示是或不是\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> flag;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找结束，您所要删除的对象不存在\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//void Pp_Del(Con* con)  //指定性删除信息   end</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//judgee = 0;</span></span><br><span class="line"><span class="comment">//int(*Cmp[5])(Con*, const char*, int) = &#123; Cmp_name,Cmp_sex ,Cmp_age,Cmp_tel,Cmp_adress &#125;; //创建函数指针数组</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//printf(&quot;请输入数字选择查找要删除联系人的方式\n&quot;);</span></span><br><span class="line"><span class="comment">//printf(&quot;1：姓名 2：性别 3：年龄 4：电话 5：地址\n&quot;);</span></span><br><span class="line"><span class="comment">//flag:</span></span><br><span class="line"><span class="comment">//scanf(&quot;%d&quot;, &amp;judgee);</span></span><br><span class="line"><span class="comment">//if (judgee == 1 || judgee == 2 || judgee == 3 || judgee == 4 || judgee == 5)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//Pp_Delask(con, judgee, &amp;Cmp); //第三个参数为函数指针数组的地址</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//else</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//printf(&quot;输入格式错误请重新输入:\n&quot;);</span></span><br><span class="line"><span class="comment">//goto flag;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Del</span><span class="params">(Con* con)</span>  <span class="comment">//指定性删除信息   end</span></span><br><span class="line">&#123;</span><br><span class="line">judgee = <span class="number">0</span>;</span><br><span class="line">Cmp ptr[<span class="number">5</span>] = &#123;Cmp_name,Cmp_sex ,Cmp_age,Cmp_tel,Cmp_adress&#125;; <span class="comment">//创建函数指针数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数字选择查找要删除联系人的方式\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1：姓名 2：性别 3：年龄 4：电话 5：地址\n&quot;</span>);</span><br><span class="line">flag:</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;judgee);</span><br><span class="line"><span class="keyword">if</span> (judgee == <span class="number">1</span> || judgee == <span class="number">2</span> || judgee == <span class="number">3</span> || judgee == <span class="number">4</span> || judgee == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">Pp_Delask(con, judgee, &amp;ptr); <span class="comment">//第三个参数为函数指针数组的地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入格式错误请重新输入:\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_goal</span><span class="params">(Con* con, <span class="type">int</span> jud, <span class="type">int</span>(*(*Cmp)[<span class="number">5</span>])(Con*, <span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>))</span>  <span class="comment">//查找选择后开始选择打印</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要查找联系人的信息\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;str);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> exist = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; con-&gt;size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Cmp[<span class="number">0</span>][jud - <span class="number">1</span>](con, str, i) == <span class="number">0</span>)   <span class="comment">//替换函数</span></span><br><span class="line">&#123;</span><br><span class="line">exist = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s %d %s %s\n&quot;</span>, con-&gt;data[i].name, con-&gt;data[i].sex, con-&gt;data[i].age, con-&gt;data[i].tel, con-&gt;data[i].adress);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (exist)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;以上是为您查找到的数据\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;您所要查找的对象不存在\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Query</span><span class="params">(Con* con)</span>    <span class="comment">//指定行查找信息  wait</span></span><br><span class="line">&#123;</span><br><span class="line">judgee = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数字选择查找联系人的方式\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1：姓名 2：性别 3：年龄 4：电话 5：地址\n&quot;</span>);</span><br><span class="line"><span class="type">int</span>(*Cmp[<span class="number">5</span>])(Con*, <span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>) = &#123; Cmp_name,Cmp_sex ,Cmp_age,Cmp_tel,Cmp_adress &#125;; <span class="comment">//创建函数指针数组</span></span><br><span class="line">flag:</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;judgee);</span><br><span class="line"><span class="keyword">if</span> (judgee == <span class="number">1</span> || judgee == <span class="number">2</span> || judgee == <span class="number">3</span> || judgee == <span class="number">4</span> || judgee == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">print_goal(con, judgee, &amp;Cmp);   <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入格式错误请重新输入:\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Display</span><span class="params">(Con* con)</span>  <span class="comment">//展现通讯录  end</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; -------------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-15s\t%-5s\t%-5s\t%-12s\t%-30s\n&quot;</span>, <span class="string">&quot;姓名&quot;</span>, <span class="string">&quot;性别&quot;</span>, <span class="string">&quot;年龄&quot;</span>, <span class="string">&quot;电话&quot;</span>, <span class="string">&quot;地址&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; con-&gt;size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-15s\t%-5s\t%-5d\t%-12s\t%-30s\n&quot;</span>, con-&gt;data[i].name, con-&gt;data[i].sex, con-&gt;data[i].age, con-&gt;data[i].tel, con-&gt;data[i].adress);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; -------------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Modifyask</span><span class="params">(Con* con, <span class="type">int</span> jud, <span class="type">int</span>(*(*Cmp)[<span class="number">5</span>])(Con*, <span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>))</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要查找联系人的信息\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;str);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; con-&gt;size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Cmp[<span class="number">0</span>][jud - <span class="number">1</span>](con, str, i) == <span class="number">0</span>)   <span class="comment">//函数指针数组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s %d %s %s\n&quot;</span>, con-&gt;data[i].name, con-&gt;data[i].sex, con-&gt;data[i].age, con-&gt;data[i].tel, con-&gt;data[i].adress);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;该联系人是否为您要修改的对象(Y/N)\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> judge = <span class="number">0</span>;</span><br><span class="line">flag2:</span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">judge = getchar();</span><br><span class="line"><span class="keyword">switch</span> (judge)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;Y&#x27;</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;选择你要修改的信息所对应的数字\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1:姓名  2：性别  3：年龄  4：电话  5：地址 6：全部\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> jjud = <span class="number">0</span>;</span><br><span class="line">flag1:</span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">jjud = getchar();</span><br><span class="line"><span class="keyword">switch</span> (jjud)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入修改后的姓名&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, con-&gt;data[i].name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;修改姓名成功\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入修改后的性别&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, con-&gt;data[i].sex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;修改性别成功\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入修改后的年龄&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;con-&gt;data[i].age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;修改年龄成功\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入修改后的电话&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, con-&gt;data[i].tel);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;修改电话成功\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入修改后的地址&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, con-&gt;data[i].adress);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;修改地址成功\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入修改后的信息&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, con-&gt;data[i].name);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, con-&gt;data[i].sex);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;con-&gt;data[i].age);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, con-&gt;data[i].tel);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, con-&gt;data[i].adress);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;修改信息成功\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入格式错误，请再次输入&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> flag1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入Y或N分别表示是或不是\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> flag2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找结束，您所要修改的对象不存在\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Modify</span><span class="params">(Con* con)</span> <span class="comment">//更改通讯录内的内容</span></span><br><span class="line">&#123;</span><br><span class="line">judgee = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>(*Cmp[<span class="number">5</span>])(Con*, <span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>) = &#123; Cmp_name,Cmp_sex ,Cmp_age,Cmp_tel,Cmp_adress &#125;; <span class="comment">//创建函数指针数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数字选择查找要更改联系人的方式\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1：姓名 2：性别 3：年龄 4：电话 5：地址\n&quot;</span>);</span><br><span class="line">flag:</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;judgee);</span><br><span class="line"><span class="keyword">if</span> (judgee == <span class="number">1</span> || judgee == <span class="number">2</span> || judgee == <span class="number">3</span> || judgee == <span class="number">4</span> || judgee == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">Pp_Modifyask(con, judgee, &amp;Cmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入格式错误请重新输入:\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Strcmp_byname</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* e1, <span class="type">const</span> <span class="type">void</span>* e2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(((Ppinfo*)e1)-&gt;name, ((Ppinfo*)e2)-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Strcmp_bysex</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* e1, <span class="type">const</span> <span class="type">void</span>* e2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(((Ppinfo*)e1)-&gt;sex, ((Ppinfo*)e2)-&gt;sex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Strcmp_byage</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* e1, <span class="type">const</span> <span class="type">void</span>* e2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ((Ppinfo*)e1)-&gt;age - ((Ppinfo*)e2)-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Strcmp_bytel</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* e1, <span class="type">const</span> <span class="type">void</span>* e2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(((Ppinfo*)e1)-&gt;tel, ((Ppinfo*)e2)-&gt;tel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Strcmp_byadress</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* e1, <span class="type">const</span> <span class="type">void</span>* e2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(((Ppinfo*)e1)-&gt;adress, ((Ppinfo*)e2)-&gt;adress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Sort</span><span class="params">(Con* con)</span>  <span class="comment">//排列通讯录内的内容</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> jud = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数字选择排列方式\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1：姓名 2：性别 3：年龄 4：电话 5：地址\n&quot;</span>);</span><br><span class="line">flag:</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;jud);</span><br><span class="line"><span class="keyword">switch</span> (jud)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">qsort(con-&gt;data, con-&gt;size, <span class="keyword">sizeof</span>(con-&gt;data[<span class="number">0</span>]), Strcmp_byname);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">qsort(con-&gt;data, con-&gt;size, <span class="keyword">sizeof</span>(con-&gt;data[<span class="number">0</span>]), Strcmp_bysex);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">qsort(con-&gt;data, con-&gt;size, <span class="keyword">sizeof</span>(con-&gt;data[<span class="number">0</span>]), Strcmp_byage);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">qsort(con-&gt;data, con-&gt;size, <span class="keyword">sizeof</span>(con-&gt;data[<span class="number">0</span>]), Strcmp_bytel);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">qsort(con-&gt;data, con-&gt;size, <span class="keyword">sizeof</span>(con-&gt;data[<span class="number">0</span>]), Strcmp_byadress);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;选择格式错误，请重新输入&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;已排序成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pp_Reset</span><span class="params">(Con* con)</span>  <span class="comment">//初始化通讯录所有内容</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;确定要初始化所有内容么？(Y/N)&quot;</span>);</span><br><span class="line"><span class="type">int</span> judge = <span class="number">0</span>;</span><br><span class="line">flag:</span><br><span class="line">getchar();</span><br><span class="line">judge = getchar();</span><br><span class="line"><span class="keyword">switch</span> (judge)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;Y&#x27;</span>:</span><br><span class="line">con-&gt;size = <span class="number">0</span>;</span><br><span class="line">Pp_Save(con);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化成功\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;选择格式错误，请重新输入&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;已取消初始化\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">Pp_Save</span><span class="params">(Con* con)</span>  <span class="comment">//保存当前通讯录至文件内</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* pf = fopen(<span class="string">&quot;contact.dat&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;Save fopen&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; con-&gt;size; i++)</span><br><span class="line">&#123;</span><br><span class="line">fwrite(con-&gt;data + i, <span class="keyword">sizeof</span>(Ppinfo), <span class="number">1</span>, pf);</span><br><span class="line">&#125;</span><br><span class="line">fclose(pf);</span><br><span class="line">pf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序环境和预处理</title>
      <link href="/2023/10/21/c-%E7%A8%8B%E5%BA%8F%E7%8E%AF%E5%A2%83%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86/"/>
      <url>/2023/10/21/c-%E7%A8%8B%E5%BA%8F%E7%8E%AF%E5%A2%83%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、翻译环境和执行环境"><a href="#一、翻译环境和执行环境" class="headerlink" title="一、翻译环境和执行环境"></a>一、翻译环境和执行环境</h1><blockquote><p>翻译环境:在这个环境中源代码被转换为可执行的机器指令<br>执行环境:用于实际执行代码</p></blockquote><p>具体什么意思我们通过画图来解释</p><p><img src="/img/7.1.png" alt="在这里插入图片描述"></p><hr><h2 id="1-翻译环境"><a href="#1-翻译环境" class="headerlink" title="1.翻译环境"></a>1.翻译环境</h2><hr><p>翻译环境分为两步,编译和链接<br><img src="/img/7.2.png" alt="在这里插入图片描述"></p><hr><p>那么编译和链接是什么呢,同样以图来说明<br><img src="/img/7.3.png" alt="在这里插入图片描述"></p><hr><p>那么问题又来了,编译和链接的过程中发生了什么</p><p><code>由于编译和链接内部需要Linux环境深入了解,这里直接上定义</code></p><p><img src="/img/7.4.png" alt="在这里插入图片描述"></p><hr><h2 id="2-执行环境"><a href="#2-执行环境" class="headerlink" title="2.执行环境"></a>2.执行环境</h2><p>简述一下程序执行的过程</p><blockquote><p>1.程序必须载入内存中.<br>在有操作系统的环境中:一般由操作系统完成<br>在独立的环境中:程序的载入必须由手工安排,也可能是通过可执行代码置入只读内存完成<br>2.程序执行便开始,调用main函数<br>3.开始执行程序代码.这个时候程序将使用一个运行的堆栈(stack)(堆栈就是栈),存储函数的局部变量和返回地址.<br>程序同时也可以使用静态(static)内存,存储于静态内存中的变量在程序的整个执行过程一直保留他们的值.<br>4.终止程序.正常终止main函数,也可能是意外终止.</p></blockquote><p>以上</p><hr><h1 id="二、预处理详解"><a href="#二、预处理详解" class="headerlink" title="二、预处理详解"></a>二、预处理详解</h1><hr><h2 id="1-预定义符号"><a href="#1-预定义符号" class="headerlink" title="1.预定义符号"></a>1.预定义符号</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__FILE__ <span class="comment">//进行编译的源文件  %s</span></span><br><span class="line">__LINE__ <span class="comment">//文件当前的行号    %d</span></span><br><span class="line">__DATE__ <span class="comment">//文件被编译的日期  %s</span></span><br><span class="line">__TIME__ <span class="comment">//文件被编译的时间  %s</span></span><br><span class="line">__STDC__ <span class="comment">//如果编译器遵循ANSI C,其值为1,否则未定义  %d</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-define定义宏"><a href="#2-define定义宏" class="headerlink" title="2.#define定义宏"></a>2.#define定义宏</h2><blockquote><p>#define允许把参数替换到文本中<br>勤加()</p></blockquote><h2 id="3-和"><a href="#3-和" class="headerlink" title="3.#和##"></a>3.#和##</h2><h3 id="①"><a href="#①" class="headerlink" title="①#"></a>①#</h3><blockquote><p>#可以把参数替换到字符串中</p></blockquote><p>引出一下常见情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;??的结果是%d\n&quot;</span>,x); <span class="comment">// ?? 里面到底放什么呢</span></span><br><span class="line">                               <span class="comment">//显然函数并不能做到这个功能</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">//打印出: a的结果是10</span></span><br><span class="line">  print(a);</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="comment">//打印出: b的结果是20</span></span><br><span class="line">  print(b);</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">  <span class="comment">//打印出: c的结果是30</span></span><br><span class="line">  print(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>所以我们使用宏</p><p>首先我们要知道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;halo&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ha&quot;</span><span class="string">&quot;lo&quot;</span>);</span><br><span class="line"><span class="comment">//这两个代码的结果是一样的,由此</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> print(X) printf(#X <span class="string">&quot;的结果是%d&quot;</span>,X)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">//打印出: a的结果是10</span></span><br><span class="line">  print(a);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//本质上来讲,替换后</span></span><br><span class="line">  <span class="built_in">printf</span>(#X <span class="string">&quot;的结果是%d&quot;</span>,X);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;a&quot;</span> <span class="string">&quot;的结果是%d&quot;</span>,X);</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="comment">//打印出: b的结果是20</span></span><br><span class="line">  print(b);</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">  <span class="comment">//打印出: c的结果是30</span></span><br><span class="line">  print(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/7.5.png" alt="在这里插入图片描述"></p><hr><p>有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式不同的处理</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> print(X,FORMATE) printf(#X <span class="string">&quot;的结果是&quot;</span>FORMATE,X)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//打印出: a的结果是20</span></span><br><span class="line">print(a, <span class="string">&quot;%d\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> b = <span class="number">5.5</span>;</span><br><span class="line"><span class="comment">//打印出: b的结果是5.5</span></span><br><span class="line">print(b, <span class="string">&quot;%f\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/7.6.png" alt="在这里插入图片描述"></p><hr><p><code>注意:#不能直接用在printf中,只能在宏内使用</code></p><hr><h3 id="②"><a href="#②" class="headerlink" title="②##"></a>②##</h3><p>直接举个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CAT(X,Y) X##Y##Z</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> class1011 = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,CAT(class,<span class="number">10</span>,<span class="number">11</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,class1011);</span><br><span class="line">  <span class="comment">//两者打印结果相同,可以将##看作是一个连接符号</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-宏和函数的取舍"><a href="#4-宏和函数的取舍" class="headerlink" title="4.宏和函数的取舍"></a>4.宏和函数的取舍</h2><table><thead><tr><th>属性</th><th>#define定义宏</th><th>函数</th></tr></thead><tbody><tr><td>代码长度</td><td>每次使用时,宏代码都会被插入程序中.除了非常小的宏除外,程序的长度会大幅提升</td><td>函数代码只出现于一个地方,每次调用这个函数时,都调用那个地方的同一份代码</td></tr><tr><td>执行速度</td><td>更快</td><td>存在函数的调用和返回的额外开销,所以相对较慢</td></tr><tr><td>操作符优先级</td><td>宏参数的求值是在所有周围表达式的上下文环境里,除非加上括号,否则邻近操作符的优先级可能会产生不可预料的后果,所以建议宏在书写时多些括号</td><td>函数参数只在函数调用的时候求值一次,它的结果值传递给函数.表达式的求值结果更容易预测</td></tr><tr><td>带有副作用的参数</td><td>参数可能被替换到宏体中的多个位置,所以带有副作用的参数求值可能会产生不可预料的结果</td><td>函数传参只在传参的时候求值一次,结果更容易控制</td></tr><tr><td>参数类型</td><td>宏的参数与类型无关,只要对参数的操作时合法的,它就可以使用于任何参数类型</td><td>函数的参数与类型有关,如果参数的类型不同,就需要不同的函数</td></tr><tr><td>调试</td><td>宏是不方便调试的</td><td>函数是可以逐语句调试的</td></tr><tr><td>递归</td><td>宏不能递归</td><td>函数可以递归</td></tr></tbody></table><hr><p>以上</p><hr><h2 id="5-undef"><a href="#5-undef" class="headerlink" title="5.undef"></a>5.undef</h2><p>该指令可以移除一条宏定义<br>比如说<br><img src="/img/7.7.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">undef</span> NAME</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-条件编译"><a href="#6-条件编译" class="headerlink" title="6.条件编译"></a>6.条件编译</h2><hr><p>先上一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> ADD       <span class="comment">//如果定义了ADD宏,那么endif前就可以运行,反之则会在预处理时被略过</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> 1            <span class="comment">//非零则进入,否则在预处理时被略过</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>#ifdef 后跟宏名称<br>#if  后跟常量表达式<br>同样都是以#endif作为结尾</p></blockquote><hr><p>同样的还有#else 、#elif<br><code>其后面跟的都是常量表达式</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> 1==1            <span class="comment">//常量表达式</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;666&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="keyword">elif</span> 2==2          <span class="comment">//常量表达式</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;999&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="keyword">else</span> 3==3          <span class="comment">//常量表达式</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;114514&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//同if else 一样,这三条语句只能进入一个,不能同时进入</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>也有</p><blockquote><p>#ifndef  作用与 #ifdef相反<br>#if defined()   括号内加入宏名,作用与 #ifdef相同<br>也可以#if !defined(),作用与 #ifdef相反</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 预处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件</title>
      <link href="/2023/10/21/c-%E6%96%87%E4%BB%B6/"/>
      <url>/2023/10/21/c-%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是文件"><a href="#一、什么是文件" class="headerlink" title="一、什么是文件"></a>一、什么是文件</h1><hr><blockquote><p>磁盘上的文件就是文件<br>但在程序设计中,我们一般谈的文件有两种:程序文件、数据文件(功能角度分类)</p></blockquote><hr><h2 id="1-程序文件"><a href="#1-程序文件" class="headerlink" title="1.程序文件"></a>1.程序文件</h2><blockquote><p>包括源文件(后缀为.c),目标文件(windows环境后缀为.obj),可执行程序(windows环境后缀为.exe)</p></blockquote><hr><h2 id="2-数据文件"><a href="#2-数据文件" class="headerlink" title="2.数据文件"></a>2.数据文件</h2><blockquote><p>文件的内容不一定是程序,而是程序运行时读写的数据,比如程序运行需要从中读取数据的文件<br>或者输出内容的文件</p></blockquote><p><code>本文主要以数据文件为中心进行简介</code></p><hr><h2 id="3-文件名"><a href="#3-文件名" class="headerlink" title="3.文件名"></a>3.文件名</h2><p>文件名包含三个部分</p><blockquote><p>文件路径+文件主干+文件后缀<br>eg: C:\code\test.txt<br>路径: C:\code<br>文件名主干: test<br>文件后缀: .txt</p></blockquote><hr><h1 id="二、文件的打开和关闭"><a href="#二、文件的打开和关闭" class="headerlink" title="二、文件的打开和关闭"></a>二、文件的打开和关闭</h1><hr><h2 id="1-文件指针"><a href="#1-文件指针" class="headerlink" title="1.文件指针"></a>1.文件指针</h2><blockquote><p>每个被使用的文件都在内存开辟了一个相应的文件信息区<br>用来存放文件的相关信息(文件名,文件状态,文件当前位置等).<br>这些信息是保存在一个结构体变量中的.<br>该结构体系统声明取名为 FILE<br>即 FILE 是一个结构体类型</p></blockquote><p>具体内部实现如下(不同环境下,结构成员会有所差异))</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">//文件相关信息</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span> <span class="title">FILE</span>;</span></span><br></pre></td></tr></table></figure><hr><p><img src="/img/6.1.png"></p><hr><p>比如创建一个FILE*的指针变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE * pf; <span class="comment">//pf即文件指针变量</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-文件的打开和关闭"><a href="#2-文件的打开和关闭" class="headerlink" title="2.文件的打开和关闭"></a>2.文件的打开和关闭</h2><hr><h3 id="①fopen"><a href="#①fopen" class="headerlink" title="①fopen"></a>①fopen</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line">FILE*<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename,<span class="type">const</span> <span class="type">char</span>* mode)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>以mode的形式打开filename文件</p></blockquote><p>其中mode主要分为以下几种</p><table><thead><tr><th>文件使用方式</th><th>含义</th><th>如果指定文件不存在</th></tr></thead><tbody><tr><td>“r”(只读)</td><td>为了输入数据,打开一个已经存在的文本文件</td><td>出错</td></tr><tr><td>“w”(只写)</td><td>为了输出数据,打开一个文本文件</td><td>建立一个新的文件</td></tr><tr><td>“a”(追加)</td><td>向文本文件尾添加数据</td><td>建立一个新的文件</td></tr><tr><td>“rb” (只读)</td><td>为了输入数据,打开一个二进制文件</td><td>出错</td></tr><tr><td>“wb”(只写)</td><td>为了输出数据,打开一个二进制文件</td><td>建立一个新的文件</td></tr><tr><td>“ab” (追加)</td><td>向一个二进制文件尾添加数据</td><td>出错</td></tr><tr><td>“r+”(读写)</td><td>为了读和写,打开一个文本文件</td><td>出错</td></tr><tr><td>“w+”(读写)</td><td>为了读和写,建立一个新文件</td><td>建立一个新的文件</td></tr><tr><td>“a+”(读写)</td><td>打开一个文件,在文件尾进行读写</td><td>建立一个新的文件</td></tr><tr><td>“rb+”(读写)</td><td>为了读和写,打开一个二进制文件</td><td>出错</td></tr><tr><td>“wb+”(读写)</td><td>为了读和写,建立一个二进制文件</td><td>建立一个新的文件</td></tr><tr><td>“ab+”(读写)</td><td>打开一个二进制文件,在文件尾进行读和写</td><td>建立一个新的文件</td></tr></tbody></table><hr><p>以一段代码介绍fopen实际使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FILE * pf = fopen(<span class="string">&quot;test.dat&quot;</span>,<span class="string">&quot;r&quot;</span>);<span class="comment">//test.dat 位于该项目同一文件内可以被打开,或创建于同一文件</span></span><br><span class="line">                                  <span class="comment">//但是并不代表只能打开同项目文件</span></span><br><span class="line">FILE * pf = fopen(<span class="string">&quot;D:\\2023_code\\class\\test.dat&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">                                  <span class="comment">//注意是\\而不是\</span></span><br><span class="line"><span class="comment">                                  //给定一块指定的空间也可以打开或创建</span></span><br><span class="line">                                  </span><br><span class="line"><span class="keyword">if</span>(pf == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  perror(<span class="string">&quot;fopen&quot;</span>);  <span class="comment">//如果打开失败返回错误信息</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">fclose(pf);</span><br><span class="line">pf = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="②fclose"><a href="#②fclose" class="headerlink" title="②fclose"></a>②fclose</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE* stream)</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="三、文件的顺序读写"><a href="#三、文件的顺序读写" class="headerlink" title="三、文件的顺序读写"></a>三、文件的顺序读写</h1><hr><h2 id="1-读写函数表"><a href="#1-读写函数表" class="headerlink" title="1.读写函数表"></a>1.读写函数表</h2><table><thead><tr><th>功能</th><th>函数名</th><th>适用于</th></tr></thead><tbody><tr><td>字符输入函数</td><td>fgetc</td><td>所有输入流</td></tr><tr><td>字符输出函数</td><td>fputc</td><td>所有输出流</td></tr><tr><td>文本行输入函数</td><td>fgets</td><td>所有输入流</td></tr><tr><td>文本行输出函数</td><td>fputs</td><td>所有输出流</td></tr><tr><td>格式化输入函数</td><td>fscanf</td><td>所有输入流</td></tr><tr><td>格式化输出函数</td><td>fprintf</td><td>所有输出流</td></tr><tr><td>二进制输入</td><td>fread</td><td>文件</td></tr><tr><td>二进制输出</td><td>fwrite</td><td>文件</td></tr></tbody></table><hr><h2 id="2-”输入”-”输出”是什么"><a href="#2-”输入”-”输出”是什么" class="headerlink" title="2.”输入”,”输出”是什么"></a>2.”输入”,”输出”是什么</h2><p><img src="/img/6.2.png"></p><hr><h2 id="3-流"><a href="#3-流" class="headerlink" title="3.流"></a>3.流</h2><blockquote><p>流是一个高度抽象的概念</p></blockquote><p>同样的我们以图的形式展现流</p><p><img src="/img/6.3.png"></p><p>具体理解可能略微生硬<br>在fputc中我们可以在逐渐深入了解</p><hr><h2 id="4-fputc"><a href="#4-fputc" class="headerlink" title="4.fputc"></a>4.fputc</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c,FILE*stream)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>将一个字符c,输出到 stream(输出流) 中</p></blockquote><hr><p>举一个实例</p><p><img src="/img/6.4.png"></p><p>函数运行后观察该项目文件夹</p><p><img src="/img/6.n.png"></p><p><strong>文件夹内创建了我们输入的文件名,并向文件内输出了我们想要的结果</strong></p><hr><p><strong>当然输出流可以改变,比如stdout(标准输出流–屏幕)</strong></p><p><img src="/img/6.5.png"></p><hr><h2 id="5-fgetc"><a href="#5-fgetc" class="headerlink" title="5.fgetc"></a>5.fgetc</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE * stream)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>从流中读取单字符<br>每使用一次向后偏移一次<br>若读取失败则返回EOF( -1 )</p></blockquote><hr><p>举个例子<br><img src="/img/6.6.png"><br>先将要读取的文件加入字符</p><p>运行程序后</p><p><img src="/img/6.7.png"></p><hr><p><strong>同样的,输入流也可以不仅仅是文件,也可以是stdin(标准输入流—键盘)</strong></p><p><img src="/img/6.8.png"><br><em><strong>输入后再打印</strong></em></p><hr><h2 id="6-fputs"><a href="#6-fputs" class="headerlink" title="6.fputs"></a>6.fputs</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * <span class="built_in">string</span>, FILE * stream)</span>;</span><br></pre></td></tr></table></figure><p><img src="/img/6.9.png"></p><hr><h2 id="7-fgets"><a href="#7-fgets" class="headerlink" title="7.fgets"></a>7.fgets</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">char</span> * <span class="title function_">fgets</span><span class="params">(<span class="type">char</span> * <span class="built_in">string</span> , <span class="type">int</span> n ,FILE * stream)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>从流中读取最多n个字符到string<br>返回string的地址</p></blockquote><hr><p>举个例子</p><p><img src="/img/6.10.png"></p><p>在文件中提前放入字符串</p><p>然后读取打印</p><p><img src="/img/6.11.png"></p><p>可以看到打印成功</p><p>但是之所以只打印了三个字符</p><p><code>是因为需要预留一字节空间存储&#39;\0&#39;</code></p><hr><h2 id="8-fprintf"><a href="#8-fprintf" class="headerlink" title="8.fprintf"></a>8.fprintf</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE * stream , <span class="type">const</span> <span class="type">char</span> * format [,argument]....)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> arr[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="type">float</span> sc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;<span class="string">&quot;abcdef&quot;</span>,<span class="number">10</span>,<span class="number">5.5f</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对格式化数据进行写文件</span></span><br><span class="line">  FILE*pf = fopen(<span class="string">&quot;test.dat&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(pf == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//写文件</span></span><br><span class="line">  <span class="built_in">fprintf</span>(pf,<span class="string">&quot;%s %d %f&quot;</span>,s.arr,s.num,s.sc); <span class="comment">//可以理解为fprintf为输出函数</span></span><br><span class="line">                                           <span class="comment">//在pf文件内输出这几组数据</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//关闭文件</span></span><br><span class="line">  fclose(pf);</span><br><span class="line">  pf = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fprintf也可以适用于其他输出流</p><hr><h2 id="9-fscanf"><a href="#9-fscanf" class="headerlink" title="9.fscanf"></a>9.fscanf</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE*stream, <span class="type">const</span> <span class="type">char</span> * format[,argument]....)</span>;</span><br></pre></td></tr></table></figure><p>继上一段代码将结构中的数据存储于文件中<br>我们也可以读取文件中的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> arr[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="type">float</span> sc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> arr[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="type">float</span> sc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   </span><br><span class="line">  <span class="comment">//对格式化数据进行读文件</span></span><br><span class="line">  FILE*pf = fopen(<span class="string">&quot;test.dat&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(pf == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//读文件</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">fscanf</span>(pf,<span class="string">&quot;%s %d %f&quot;</span>,s.arr,s.num,s.sc);  <span class="comment">//从pf中读取结构,再放到已之前输出的结构中</span></span><br><span class="line">  <span class="built_in">fscanf</span>(pf,<span class="string">&quot;%s %d %f&quot;</span>,a.arr,a.num,a.sc);  <span class="comment">//同类型的结构不能放入,报错</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//打印</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s %d %f&quot;</span>,s.arr,s.num,s.sc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//关闭文件</span></span><br><span class="line">  fclose(pf);</span><br><span class="line">  pf = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可使用于其他流</p><hr><h2 id="10-fwrite"><a href="#10-fwrite" class="headerlink" title="10.fwrite"></a>10.fwrite</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*buffer,<span class="type">size_t</span> isze,<span class="type">size_t</span> count,FILE* stream)</span>;</span><br></pre></td></tr></table></figure><p>该函数作用是</p><blockquote><p>再stream流中写入大小为size,个数为count的二进制buffer数据</p></blockquote><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> arr[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="type">float</span> sc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   </span><br><span class="line">  <span class="comment">//对格式化数据进行写文件</span></span><br><span class="line">  FILE*pf = fopen(<span class="string">&quot;test.dat&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(pf == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//写文件</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123; <span class="string">&quot;abcde&quot;</span>,<span class="number">10</span>,<span class="number">5.5f</span> &#125;;</span><br><span class="line">  fwrite(&amp;s,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> S),<span class="number">1</span>,pf);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//关闭文件</span></span><br><span class="line">  fclose(pf);</span><br><span class="line">  pf = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/6.12.png"><br>二进制数据<br>引出fread函数</p><hr><h2 id="11-fread"><a href="#11-fread" class="headerlink" title="11.fread"></a>11.fread</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> * buffer,<span class="type">size_t</span> size,<span class="type">size_t</span> count,FILE*stream)</span>;</span><br></pre></td></tr></table></figure><p>该函数作用为</p><blockquote><p>从stream流中读取count个大小为size的数据放入buffer内</p></blockquote><hr><p>我们以上述代码带入的结果测试一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> arr[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="type">float</span> sc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   </span><br><span class="line">  <span class="comment">//对格式化数据进行读文件</span></span><br><span class="line">  FILE*pf = fopen(<span class="string">&quot;test.dat&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(pf == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//读文件</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  fread(&amp;s,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> S),<span class="number">1</span>,pf);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印观察结果</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s %d %f&quot;</span>,s.arr,s.num,s.sc);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//关闭文件</span></span><br><span class="line">  fclose(pf);</span><br><span class="line">  pf = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/6.13.png"></p><p>二进制数据可以被读取为我们可以读懂的数据</p><hr><h2 id="12-sscanf、sprintf"><a href="#12-sscanf、sprintf" class="headerlink" title="12.sscanf、sprintf"></a>12.sscanf、sprintf</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * buffer,<span class="type">const</span> <span class="type">char</span>*format[,argument]...)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>从一段被格式化转换为字符串的数据<br>还原出原本的格式化数据</p></blockquote><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio,h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span>*buffer,<span class="type">const</span> <span class="type">char</span>*format[,argumen]...)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>把一个格式化的数据(包含各种类型)<br>转化为字符串存储至buffer</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> arr[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;<span class="string">&quot;hello&quot;</span>,<span class="number">20</span>,<span class="number">5.5f</span>&#125;;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%s %d %f&quot;</span>,s.arr,s.age,s.f);</span><br><span class="line">  <span class="comment">//将s的格式化数据全部转换为字符串存入到buf内</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/6.14.png"></p><p>打印结果如上</p><p>我们还可以将这段字符串通过fscanf还原出结构中的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> arr[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;<span class="string">&quot;hello&quot;</span>,<span class="number">20</span>,<span class="number">5.5f</span>&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">tmp</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">char</span> buf[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%s %d %f&quot;</span>,s.arr,s.age,s.f);</span><br><span class="line">  <span class="comment">//将s的格式化数据全部转换为字符串存入到buf内</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//从buf数据中还原出一个结构体数据</span></span><br><span class="line">  <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %d %f&quot;</span>,tmp.arr,&amp;(tmp.age),&amp;(tmp.f));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s %d %f\n&quot;</span>,tmp.arr,tmp.age,tmp.f);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/6.15.png"></p><hr><h1 id="四、文件的随机读写"><a href="#四、文件的随机读写" class="headerlink" title="四、文件的随机读写"></a>四、文件的随机读写</h1><hr><p>在文件顺序读写中,我们发现以fgetc为例</p><p>总是从第一个字符开始,并向后逐一递增</p><p>怎样可以自定义读写方式呢</p><p>这里就要用到文件随机读写的知识</p><hr><h2 id="1-fseek"><a href="#1-fseek" class="headerlink" title="1.fseek"></a>1.fseek</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE * stream,<span class="type">long</span> <span class="type">int</span> offset,<span class="type">int</span> origin)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>将指针定位至与起始位置 origin 偏移 offset 的位置<br>origin分为三种情况<br>SEEK_CUR  — 当前文件指针的位置<br>SEEK_END — 文件末尾<br>SEEK_SET — 文件的起始位置</p></blockquote><hr><p>测试一下实际情况</p><p><img src="/img/6.16.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE* pf = fopen(<span class="string">&quot;test.dat&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(pf == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读取文件</span></span><br><span class="line">  <span class="type">int</span> ch = fgetc(pf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,ch); <span class="comment">//a</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//调整文件指针</span></span><br><span class="line">  fseek(pf,<span class="number">1</span>,SEEK_CUR);  <span class="comment">//将指针向回偏移1,从a到c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ch = fgetc(pf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,ch); <span class="comment">//c</span></span><br><span class="line">  ch = fgetc(pf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,ch);<span class="comment">//d</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//关闭文件</span></span><br><span class="line">  fclose(pf);</span><br><span class="line">  pf=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/6.17.png"></p><hr><h2 id="2-ftell"><a href="#2-ftell" class="headerlink" title="2.ftell"></a>2.ftell</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">ftell</span><span class="params">(FILE * stream)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>返回文件指针相对于起始位置的偏移量</p></blockquote><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE* pf = fopen(<span class="string">&quot;test.dat&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(pf == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读取文件</span></span><br><span class="line">  <span class="type">int</span> ch = fgetc(pf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,ch); <span class="comment">//a</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//调整文件指针</span></span><br><span class="line">  fseek(pf,<span class="number">1</span>,SEEK_CUR);  <span class="comment">//将指针向回偏移1,从a到c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ch = fgetc(pf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,ch); <span class="comment">//c</span></span><br><span class="line">  ch = fgetc(pf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,ch);<span class="comment">//d</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ret = ftell(pf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ret); <span class="comment">//打印结果为4</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//关闭文件</span></span><br><span class="line">  fclose(pf);</span><br><span class="line">  pf=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-rewind"><a href="#3-rewind" class="headerlink" title="3.rewind"></a>3.rewind</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE*stream)</span>; </span><br></pre></td></tr></table></figure><blockquote><p>让文件指针回到起始的位置</p></blockquote><hr><p>还以上述举例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* pf = fopen(<span class="string">&quot;test.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//调整文件指针</span></span><br><span class="line">    fseek(pf, <span class="number">3</span>, SEEK_CUR);  <span class="comment">//将指针向回偏移3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ch = fgetc(pf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, ch); <span class="comment">//d</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = ftell(pf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret); <span class="comment">//打印结果为4</span></span><br><span class="line"></span><br><span class="line">    rewind(pf);  <span class="comment">//使文件指针回到起始位置</span></span><br><span class="line"></span><br><span class="line">    ret = ftell(pf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret); <span class="comment">//观察偏移量</span></span><br><span class="line"></span><br><span class="line">    ch = fgetc(pf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, ch);<span class="comment">//a </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    fclose(pf);</span><br><span class="line">    pf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/6.18.png"></p><hr><h1 id="五、文件读取结束的判定-feof"><a href="#五、文件读取结束的判定-feof" class="headerlink" title="五、文件读取结束的判定(feof)"></a>五、文件读取结束的判定(feof)</h1><hr><p>feof的作用使</p><blockquote><p>判断文件是读取失败结束的,还是遇到文件尾结束的</p></blockquote><hr><p>对于文本文件:</p><blockquote><p>通过判定返回值来确定<br>判断返回值是否尾EOF(fgetc),或者NULL(fgets)</p></blockquote><p><strong>fgetc函数在读取结束后返回的是EOF<br>正常读取时返回的是读取到的字符的ASCII值</strong></p><p><strong>fgets函数在读取结束时返回的是NULL<br>正常读取时返回的是,存放字符串空间的起始地址</strong></p><hr><p>对于二进制文件:</p><blockquote><p>判断返回值是否小于实际要读的个数</p></blockquote><p><strong>fread函数在读取的时候,返回的是实际读取到的完整元素的个数<br>如果发现读取到完整的元素个数小于 指定元素个数,这就是最后一次读取</strong></p><hr><p>举个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE * pread = fopen(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(pread == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;pread&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  FILE * pwrite = fopen(<span class="string">&quot;test.txt2&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(pwrite == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//如果失败直接返回,文件没有关闭,会出问题</span></span><br><span class="line">    fclose(pread);</span><br><span class="line">    pread = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//开始拷贝</span></span><br><span class="line">  <span class="type">int</span> ch = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>( ch = fgetc(fread) != EOF)</span><br><span class="line">  &#123;</span><br><span class="line">    fputc(ch,fwrite);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断文件怎样结束</span></span><br><span class="line">  <span class="keyword">if</span>(feof(pread)) <span class="comment">//如果读取成功返回非0</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;遇到文件结束标志,文件正常结束&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ferror(pread)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件读取失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//关闭文件</span></span><br><span class="line">  fclose(pread);</span><br><span class="line">  pread = <span class="literal">NULL</span>;</span><br><span class="line">  fclose(pwrite);</span><br><span class="line">  pwrite = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="六、文件缓冲区"><a href="#六、文件缓冲区" class="headerlink" title="六、文件缓冲区"></a>六、文件缓冲区</h1><blockquote><p>简而言之就是<br>从程序到文件、从文件到程序<br>必须塞够足够的数据或者刷新( fflush (pf) )(高版本无法使用刷新)<br>数据才会完全输送到目的地</p></blockquote><hr><h1 id="七、文本文件和二进制文件"><a href="#七、文本文件和二进制文件" class="headerlink" title="七、文本文件和二进制文件"></a>七、文本文件和二进制文件</h1><blockquote><p>1.数据在内存中以二进制的形式存储,如果不加以转换输出到外存,就是二进制文件<br>2.如果要求在外存以ASCII的形式存储,则需要在存储前转换<br>以ASCII字符的形式存储的文件就是文本文件</p></blockquote><p>一个数据在内存中是怎么存储的呢</p><blockquote><p>字符一律以ASCII形式存储<br>数值即可以ASCII存储也可以二进制形式存储</p></blockquote><hr><p>假设整数10000<br>ASCII存储需要5个字符 –五字节<br>而二进制只需要占4字节 –转换为二进制再转换为16进制计算</p><hr>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态内存分配</title>
      <link href="/2023/10/21/c-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>/2023/10/21/c-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="一、栈区-堆区-静态区-数据段"><a href="#一、栈区-堆区-静态区-数据段" class="headerlink" title="一、栈区,堆区,静态区(数据段)"></a>一、栈区,堆区,静态区(数据段)</h1><hr><p><img src="/img/5.1.png"></p><hr><h1 id="二、malloc"><a href="#二、malloc" class="headerlink" title="二、malloc"></a>二、malloc</h1><hr><p>该函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">void</span> * <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>该函数作用为</p><blockquote><p>在堆区开辟size个字节的空间<br>开辟成功返回开辟的地址<br>开辟失败返回空指针</p></blockquote><hr><p>实际应用如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//开辟十个整形空间,强制转换位int* 类型方便接收和处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果开辟失败</span></span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  perror(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p[i]); <span class="comment">//p[i] == *(p+i)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回收空间</span></span><br><span class="line"><span class="built_in">free</span>(p);  <span class="comment">//若不回收,会导致内存泄漏</span></span><br><span class="line">p = <span class="literal">NULL</span>; <span class="comment">//手动把p指针置为空指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="三、free"><a href="#三、free" class="headerlink" title="三、free"></a>三、free</h1><hr><p>该函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> * ptr)</span></span><br></pre></td></tr></table></figure><blockquote><p>free函数用来释放动态开辟的内存<br>如果参数ptr指向的空间不是动态开辟的,free函数的行为是未定义的<br>如果参数ptr指向的是NULL指针,则函数什么也不做</p></blockquote><p>比如当ptr指向的空间不是动态开辟的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> * p = &amp;a;</span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">//error</span></span><br></pre></td></tr></table></figure><p><code>注意:动态开辟一块空间必须释放,但是同一块空间不能释放两次,否则会报错.</code></p><p><strong>动态开辟的空间只有两种回收方式</strong></p><blockquote><p>手动free释放<br>程序结束时释放</p></blockquote><hr><h1 id="四、realloc"><a href="#四、realloc" class="headerlink" title="四、realloc"></a>四、realloc</h1><hr><p>该函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">void</span> * <span class="title function_">realloc</span><span class="params">(<span class="type">void</span> * memblock,<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>该函数的作用是</p><blockquote><p>在memblock地点重新开辟size字节的空间<br>但开辟有三种情况<br>所以返回的地址不一定是原本memblock的地址</p></blockquote><p>以一张图来解释一下</p><p><img src="/img/5.2.png"></p><hr><p>看一下realloc实际使用情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//开辟十个整形空间,强制转换位int* 类型方便接收和处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果开辟失败</span></span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  perror(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新开辟为20字节的空间</span></span><br><span class="line"><span class="type">int</span> * ptr = <span class="built_in">realloc</span>(p,<span class="number">20</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">//拿新指针接收</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ptr != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  p = ptr       <span class="comment">//如果开辟成功则将ptr的地址交给p.使p指向的空间更大</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回收空间</span></span><br><span class="line"><span class="built_in">free</span>(p);  <span class="comment">//若不回收,会导致内存泄漏</span></span><br><span class="line">p = <span class="literal">NULL</span>; <span class="comment">//手动把p指针置为空指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><hr><p>与malloc相似<br>当出现以下情况时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * p = (<span class="type">int</span>*)<span class="built_in">realloc</span>(<span class="literal">NULL</span>,<span class="number">40</span>); </span><br><span class="line"><span class="comment">//功能类似于malloc,直接在堆区开辟40字节</span></span><br></pre></td></tr></table></figure><hr><h1 id="五、calloc"><a href="#五、calloc" class="headerlink" title="五、calloc"></a>五、calloc</h1><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">void</span> * <span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> num , <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>该函数的功能是</p><blockquote><p>为num个大小为size的元素开辟一块空间,并把空间的每个字节初始化为0.<br>与malloc的区别在于calloc会在返回地址之前把申请的空间的每个字节初始化为0</p></blockquote><p>上一段代码看看和malloc的区别</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pm = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//malloc不会初始化每个字节</span></span><br><span class="line">                                        <span class="comment">//即存储随机值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * pc = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">10</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">                              <span class="comment">//calloc会顺便初始化每个字节为0</span></span><br></pre></td></tr></table></figure><hr><h1 id="六、柔性数组"><a href="#六、柔性数组" class="headerlink" title="六、柔性数组"></a>六、柔性数组</h1><hr><blockquote><p>结构中的最后一个元素允许是未知大小的数组<br>这就叫做柔性数组的成员</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> arr[];  <span class="comment">//大小未知</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">0</span>];  <span class="comment">//大小未知</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>柔性数组的特点</p><blockquote><p>1.结构中柔性数组成员前必须至少有一个其他成员<br>2.sizeof 返回这种结构大小,不包括柔性数组<br>3. 包含柔性数组的结构用malloc进行内存的动态分配,分配的空间应大于结构的大小,以适应柔性数组的预期大小</p></blockquote><p>柔性数组的应用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//期望arr大小为十个整形</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">S</span> *<span class="title">ps</span> =</span> (<span class="keyword">struct</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> S) + <span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">                                            <span class="comment">//为柔性数组预留十个整形</span></span><br><span class="line">  ps-&gt;n = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ps-&gt;arr[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">//增加</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">S</span> *<span class="title">p</span>=</span>(<span class="keyword">struct</span> S*)<span class="built_in">realloc</span>(ps,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> S)+<span class="number">20</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   ps = p;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//使用</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//释放</span></span><br><span class="line"> <span class="built_in">free</span>(ps);</span><br><span class="line"> ps = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>指针也可以<br>创建可改变的空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> *arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//为结构开辟空间</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">S</span> *<span class="title">ps</span> =</span> (<span class="keyword">struct</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> S));</span><br><span class="line">  <span class="keyword">if</span>(ps == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//为arr指向的空间开辟空间</span></span><br><span class="line">  ps-&gt;arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="keyword">if</span>(ps-&gt;arr == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用</span></span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ps-&gt;arr[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//增加</span></span><br><span class="line">  <span class="type">int</span> * ptr = (<span class="type">int</span> *)<span class="built_in">realloc</span>(ps-&gt;arr,<span class="number">20</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="keyword">if</span>(ptr != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ps-&gt;arr = ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//释放</span></span><br><span class="line">  <span class="built_in">free</span>(ps-&gt;arr);</span><br><span class="line">  ps-&gt;arr = <span class="literal">NULL</span>; <span class="comment">//必须先释放ps-&gt;arr , 否则在释放完ps后找不到 ps-&gt;arr</span></span><br><span class="line">  <span class="built_in">free</span>(ps);</span><br><span class="line">  ps = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><hr><p><strong>指针的方法用了两次malloc,两次free</strong></p><p><strong>多次使用malloc会使内存碎片变多,内存的利用率会下降</strong></p><p>此时柔性数组的优势就会体现出来</p><hr>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态内存分配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义类型</title>
      <link href="/2023/10/21/c-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/10/21/c-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、结构体"><a href="#一、结构体" class="headerlink" title="一、结构体"></a>一、结构体</h1><hr><h2 id="1-匿名结构体类型"><a href="#1-匿名结构体类型" class="headerlink" title="1.匿名结构体类型"></a>1.匿名结构体类型</h2><p>我们来举个例子介绍匿名结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  //创建时只有关键字,即为匿名结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">double</span> d;</span><br><span class="line">&#125;s;         </span><br></pre></td></tr></table></figure><hr><p>再来列举一个匿名结构体常见的错误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">double</span> d;</span><br><span class="line">&#125;s;        </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">double</span> d;</span><br><span class="line">&#125;*p;        <span class="comment">//用p指向这个匿名结构体</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  p = &amp;s;  <span class="comment">//观察两个匿名结构体发现组成成分一样,是不是就可以通过这种方式使 p 指针存储 s 呢?</span></span><br><span class="line">           <span class="comment">//error  虽然类型一样,但是在编译器看来这是两个不同的匿名结构体,非法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-结构体的自引用"><a href="#2-结构体的自引用" class="headerlink" title="2.结构体的自引用"></a>2.结构体的自引用</h2><p>举个例子来看看结构体如何相互引用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">sa</span>;</span>  <span class="comment">//结构体类型 struct B 中含有结构体类型 struct A;</span></span><br><span class="line">  <span class="type">double</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么结构体自引用是否为以下这种方式呢</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">N</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> d;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">N</span> <span class="title">n</span>;</span> <span class="comment">//error 无限套娃 ,如果计算大小就直接爆炸</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>正确方法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">N</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> d;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">N</span>* <span class="title">next</span>;</span> <span class="comment">//通过指针找到同类型的下一节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-结构体的大小计算"><a href="#3-结构体的大小计算" class="headerlink" title="3.结构体的大小计算"></a>3.结构体的大小计算</h2><p>结构体的对齐规则</p><blockquote><p>1.第一个成员在与结构体偏移量为0的地址处<br>2.其他成员变量要对齐到(对齐数)的整数倍的地址处<br>.<br>对齐数 &#x3D; 编译器默认的对齐数 与 该成员大小的较小值<br>VS默认为8(并且该默认值可以通过编码修改)<br>.<br>3.结构体总大小为最大对齐数(每个成员变量都有一个对齐数)的整数倍<br>4.如果该结构体嵌套了另一个结构体,嵌套的结构体对齐到自己的最大对齐数的整数倍处<br> 结构体整体大小就是所有最大对齐数(含嵌套结构体的对齐数)的整数倍</p></blockquote><hr><p>我们以一张图来整明白这些话<br><img src="/img/4.1.png"></p><hr><p>前面提到过可以修改默认对齐数</p><p>以下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()  <span class="comment">//括号内的数字即是你要的默认对齐数</span></span></span><br><span class="line">/</span><br><span class="line">/</span><br><span class="line"><span class="comment">//使用完结构体后再恢复默认对齐数为8=</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()  <span class="comment">//括号内不放数字</span></span></span><br></pre></td></tr></table></figure><hr><p>举个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> A));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="二、位段"><a href="#二、位段" class="headerlink" title="二、位段"></a>二、位段</h1><h2 id="1-位段的介绍"><a href="#1-位段的介绍" class="headerlink" title="1.位段的介绍"></a>1.位段的介绍</h2><blockquote><p>位段的声明和结构体是类似的,但有两个不同<br>1.位段的成员必须是int、unsigned int 或 signed int<br>2.位段的成员后边有一个冒号和一个数字</p></blockquote><p>例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> a:<span class="number">2</span>;  <span class="comment">//a成员占2bit位</span></span><br><span class="line">  <span class="type">int</span> b:<span class="number">5</span>;  <span class="comment">//b成员占5bit位</span></span><br><span class="line">  <span class="type">int</span> c:<span class="number">10</span>; <span class="comment">//c成员占10bit位</span></span><br><span class="line">  <span class="type">int</span> d:<span class="number">30</span>; <span class="comment">//d成员占30bit位</span></span><br><span class="line">&#125;           <span class="comment">//此时A就是一个位段类型</span></span><br></pre></td></tr></table></figure><hr><p><code>为什么好好的一个整形,偏要把它硬塞进2bit呢?</code><br><strong>节省空间!!</strong></p><p>比如说表示性别,2个字节就足矣</p><table><thead><tr><th>00</th><th>保密</th></tr></thead><tbody><tr><td>01</td><td>女</td></tr><tr><td>11</td><td>男</td></tr></tbody></table><hr><h2 id="2-位段的大小"><a href="#2-位段的大小" class="headerlink" title="2.位段的大小"></a>2.位段的大小</h2><p>还是以上述代码举例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2+5+10+30=47</span></span><br><span class="line"><span class="comment">//识别出int,创建一个int的大小,即32bit</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">//创建4字节----32bit</span></span><br><span class="line">  <span class="type">int</span> a:<span class="number">2</span>;  <span class="comment">//a成员占2bit位</span></span><br><span class="line">  <span class="type">int</span> b:<span class="number">5</span>;  <span class="comment">//b成员占5bit位</span></span><br><span class="line">  <span class="type">int</span> c:<span class="number">10</span>; <span class="comment">//c成员占10bit位</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//还留下15bit</span></span><br><span class="line">  <span class="comment">//d塞不进去了 再创建4字节 ---32bit</span></span><br><span class="line">  <span class="type">int</span> d:<span class="number">30</span>; <span class="comment">//d成员占30bit位</span></span><br><span class="line">&#125;           </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> A)); <span class="comment">//结果为4+4 = 8字节</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但其实,在不同的环境下结果可能是不同的</p><p>比如在上述代码中,d塞不进去后,是继续用上一次留下的15bit,还是直接塞进新创建的呢?</p><p>所以说</p><blockquote><p>位段涉及到很多不确定因素,位段是不跨平台的<br>注重可移植的程序应该避免位段</p></blockquote><hr><h2 id="3-位段的实际使用情况"><a href="#3-位段的实际使用情况" class="headerlink" title="3.位段的实际使用情况"></a>3.位段的实际使用情况</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> a:<span class="number">3</span>;</span><br><span class="line">  <span class="type">char</span> b:<span class="number">4</span>;</span><br><span class="line">  <span class="type">char</span> c:<span class="number">5</span>;</span><br><span class="line">  <span class="type">char</span> d:<span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">s.a = <span class="number">10</span>;</span><br><span class="line">s.b = <span class="number">12</span>;</span><br><span class="line">s.c = <span class="number">3</span>;</span><br><span class="line">s.d = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p><img src="/img/4.2.png"></p><p><img src="/img/4.3.png"><br>以上</p><hr><h2 id="4-位段跨平台问题"><a href="#4-位段跨平台问题" class="headerlink" title="4.位段跨平台问题"></a>4.位段跨平台问题</h2><blockquote><p>1.int位段被当成有符号数还是无符号数是不确定的<br>2.位段中的最大位的数目不能确定(16位机器最大16,32位最大32,若写成大于16的数再16位机器就会出问题)<br>3.位段中的成员在内存中从左向右分配,还是从右向左分配标准尚未定义<br>4.当一个结构体包含两个位段,第二个位段成员比较大,无法容纳于第一个位段剩余的位时<br>—是舍弃剩余的位还是利用,这是不确定的</p></blockquote><hr><h1 id="三、联合-共用体"><a href="#三、联合-共用体" class="headerlink" title="三、联合(共用体)"></a>三、联合(共用体)</h1><hr><h2 id="1-联合类型的定义"><a href="#1-联合类型的定义" class="headerlink" title="1.联合类型的定义"></a>1.联合类型的定义</h2><blockquote><p>联合也是一种特殊的自定义类型<br>这种类型定义的变量也包含一系列的成员<br>特征是这些成员共用一块空间(所以联合也叫共用体)<br>.<br>所以联合体的大小最小是最大成员的大小</p></blockquote><hr><h2 id="2-利用联合特征判断机器大小端字节序"><a href="#2-利用联合特征判断机器大小端字节序" class="headerlink" title="2.利用联合特征判断机器大小端字节序"></a>2.利用联合特征判断机器大小端字节序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">check_sys</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">U</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">  &#125;u;</span><br><span class="line">  u.i = <span class="number">1</span>;  <span class="comment">// 00 00 00 01</span></span><br><span class="line">            <span class="comment">// 01 00 00 00</span></span><br><span class="line">  <span class="keyword">return</span> u.c;</span><br><span class="line">  <span class="comment">//返回1是小端</span></span><br><span class="line">  <span class="comment">//返回0是大端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-联合大小的计算"><a href="#3-联合大小的计算" class="headerlink" title="3.联合大小的计算"></a>3.联合大小的计算</h2><blockquote><p>联合大小最小是最大成员的大小<br>当最大成员大小不是最大对齐数的整数倍的时候,就要对齐到最大对齐数的整数倍</p></blockquote><p>比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> arr[<span class="number">5</span>]; <span class="comment">//对齐数为1   </span></span><br><span class="line">  <span class="type">int</span> b;       <span class="comment">//对齐数为4</span></span><br><span class="line">               <span class="comment">//又因为至少为5(arr为最大成员)</span></span><br><span class="line">               <span class="comment">//所以对齐至8</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自定义类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见函数和模拟实现</title>
      <link href="/2023/10/21/c-%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/10/21/c-%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><code>     前言: 学习C语言的过程中模拟实现各种库函数可以让我们了解更加底层的原理,在这里我整理了部分函数的模拟实现和注意事项.</code></p><h1 id="一、strlen"><a href="#一、strlen" class="headerlink" title="一、strlen"></a>一、strlen</h1><h2 id="1-函数介绍"><a href="#1-函数介绍" class="headerlink" title="1.函数介绍"></a>1.函数介绍</h2><p>strlen的原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">int</span> <span class="title function_">strlen</span><span class="params">(<span class="type">char</span> *str)</span>;</span><br></pre></td></tr></table></figure><p>.</p><p>其作用和原理是</p><blockquote><p>  传入要统计字符串的地址<br>  统计该字符串’\0’(字符串结束标志)前的字符个数</p></blockquote><hr><h2 id="2-模拟实现"><a href="#2-模拟实现" class="headerlink" title="2.模拟实现"></a>2.模拟实现</h2><h3 id="①-指针计数器方式"><a href="#①-指针计数器方式" class="headerlink" title="①  指针计数器方式"></a>①  指针计数器方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(str); <span class="comment">//判定不为空指针再运行</span></span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">//count作为计数器</span></span><br><span class="line">  <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//若str解引用不为字符串中的&#x27;\0&#x27; 则停止</span></span><br><span class="line">  &#123;</span><br><span class="line">    count++;</span><br><span class="line">    str++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="②-函数递归方式"><a href="#②-函数递归方式" class="headerlink" title="② 函数递归方式"></a>② 函数递归方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(str);</span><br><span class="line">  <span class="keyword">if</span>(*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> + my_strlen(str + <span class="number">1</span>) );</span><br><span class="line">    <span class="comment">//注意 这里由一种易错的写法,如下&quot;</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//return (1 + my_strlen(++str) );</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//此时会改变递归进行中str的值,导致计算中途出现错误</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="③-指针减指针方法"><a href="#③-指针减指针方法" class="headerlink" title="③ 指针减指针方法"></a>③ 指针减指针方法</h3><p>我们要知道</p><blockquote><p>同类型的指针减指针得到的结果为两个指针间的元素个数</p></blockquote><p>所以我们可以通过指针减指针的方法来模拟实现strlen</p><p>具体实现方法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * str)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(str);</span><br><span class="line">  <span class="type">char</span> * mem = str; <span class="comment">//通过 mem 记录 str 的起始位置</span></span><br><span class="line">  <span class="keyword">while</span>( *str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    str++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str - mem; <span class="comment">//指针减指针得到中间元素的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="二、strcpy"><a href="#二、strcpy" class="headerlink" title="二、strcpy"></a>二、strcpy</h1><h2 id="1-函数介绍-1"><a href="#1-函数介绍-1" class="headerlink" title="1.函数介绍"></a>1.函数介绍</h2><p>strcpy的原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br></pre></td></tr></table></figure><p>.<br>strcpy的作用和原理是 </p><blockquote><p>先后传入空间的目标空间的起始地址和源空间的起始地址<br>将源空间的内容拷贝至目标空间</p></blockquote><p>该函数的脾气</p><blockquote><p>如果目标空间不够,会越界访问,导致报错<br>所以目标空间必须足够大,确保能放进去;<br>源空间的’\0’也会被拷贝过去;<br>目标空间必须可以改变(const,指针指向字符串常量字符串就不行)</p></blockquote><hr><h2 id="2-模拟实现-1"><a href="#2-模拟实现-1" class="headerlink" title="2.模拟实现"></a>2.模拟实现</h2><p>具体实现方法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_strcpy</span><span class="params">(<span class="type">char</span> *destination,<span class="type">const</span> <span class="type">char</span> * source)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert( destination &amp;&amp; source); <span class="comment">//断言一下两者都不为空指针</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>( *source != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    *destination = *source;</span><br><span class="line">     destination++;</span><br><span class="line">     source++;</span><br><span class="line">  &#125;</span><br><span class="line">  *destination = *source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>略微观察一下这个代码,我们可以写出更简洁的版本,如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_strcpy</span><span class="params">(<span class="type">char</span> *destination,<span class="type">const</span> <span class="type">char</span> * source)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert( destination &amp;&amp; source);</span><br><span class="line">  <span class="keyword">while</span>( *destination++ = *source) <span class="comment">//当碰到&#x27;\0&#x27;(即为0,判定为假)</span></span><br><span class="line">  &#123;</span><br><span class="line">     ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我一开始有疑问,当source字符串里面有0这个函数功能是不是就失效了呢?</p><p>原来,判断的根据是ASCII码值为0 ,我所想的’0’ ASCII值为48<br>而ASCII值为0的就是 ‘\0’ (空字符)</p><p>以上</p><hr><h1 id="三、qsort"><a href="#三、qsort" class="headerlink" title="三、qsort"></a>三、qsort</h1><h2 id="1-函数介绍-2"><a href="#1-函数介绍-2" class="headerlink" title="1.函数介绍"></a>1.函数介绍</h2><p>qsort函数的原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(</span></span><br><span class="line"><span class="params">           <span class="type">void</span>*base,   <span class="comment">//要被排序的第一个元素的地址</span></span></span><br><span class="line"><span class="params">           <span class="type">size_t</span> num,  <span class="comment">//排序数据元素的个数</span></span></span><br><span class="line"><span class="params">           <span class="type">size_t</span> size, <span class="comment">//排序数据中一个元素的大小</span></span></span><br><span class="line"><span class="params">           <span class="type">int</span>(*compar)(<span class="type">const</span> <span class="type">void</span>* e1, <span class="type">const</span> <span class="type">void</span>* e2)</span></span><br><span class="line"><span class="params">                        <span class="comment">//用来比较待排序数据中的两个元素 的函数</span></span></span><br><span class="line"><span class="params">          )</span>;</span><br></pre></td></tr></table></figure><hr><p>我们以整形排序实例来看一下qsort的使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Cmp_int</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*e1,<span class="type">const</span> <span class="type">void</span>*e2)</span> <span class="comment">//比较两个元素大小的函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">int</span>*)e1 - *(<span class="type">int</span>*)e2; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> arr[] = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">  <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  qsort(arr,sz,<span class="keyword">sizeof</span>(<span class="type">int</span>),Cmp_int);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印出的结果为</span></span><br><span class="line">  <span class="comment">// 1,2,3,4,5,6,7,8,9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>通过qsort排序结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sortby_age</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*e1,<span class="type">const</span> <span class="type">void</span>*e2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">struct</span> stu *)e1 -&gt; age - (<span class="keyword">struct</span> stu *)e2 -&gt; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sortby_name</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*e1,<span class="type">const</span> <span class="type">void</span>*e2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>((<span class="keyword">struct</span> stu *)e1 -&gt; name, (<span class="keyword">struct</span> stu *)e2 -&gt; name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若想改变排序的升序或降序,改变一下 e1 和 e2 的位置即可</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span>[3] =</span> &#123;&#123;<span class="string">&quot;zhang&quot;</span>,<span class="number">30</span>&#125;,&#123;<span class="string">&quot;lisi&quot;</span>,<span class="number">34</span>&#125;,&#123;<span class="string">&quot;wang&quot;</span>,<span class="number">20</span>&#125;&#125;;</span><br><span class="line">  <span class="type">int</span> sz = <span class="keyword">sizeof</span>(s) / <span class="keyword">sizeof</span>(s[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">//年龄排序</span></span><br><span class="line">  qsort(s,sz,<span class="keyword">sizeof</span>(s[<span class="number">0</span>]),sortby_age);</span><br><span class="line">  <span class="comment">//结果为  20,30,34 方式排列出结构体</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//名字排序</span></span><br><span class="line">  qsort(s,sz,<span class="keyword">sizeof</span>(s[<span class="number">0</span>],sortby_name);</span><br><span class="line">  <span class="comment">//结果为   lisi,wang,zhang 方式排列出结构体</span></span><br></pre></td></tr></table></figure><hr><p>.</p><h2 id="2-模拟实现-2"><a href="#2-模拟实现-2" class="headerlink" title="2.模拟实现"></a>2.模拟实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>* buf1, <span class="type">char</span> * buf2 , <span class="type">int</span> width)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; width ; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">char</span> tem = *buf1;</span><br><span class="line">    *buf1 = *buf2;</span><br><span class="line">    *buf2 = tem;</span><br><span class="line">    buf1++;</span><br><span class="line">    buf2++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_qsort</span><span class="params">(</span></span><br><span class="line"><span class="params">                 <span class="type">void</span>*base,   </span></span><br><span class="line"><span class="params">                 <span class="type">size_t</span> sz,  </span></span><br><span class="line"><span class="params">                 <span class="type">size_t</span> width, </span></span><br><span class="line"><span class="params">                 <span class="type">int</span>(*cmp)(<span class="type">const</span> <span class="type">void</span>* e1, <span class="type">const</span> <span class="type">void</span>* e2)</span></span><br><span class="line"><span class="params">               )</span></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//趟数</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz<span class="number">-1</span> ; i++)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">//每一趟的排序</span></span><br><span class="line">     <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; sz - <span class="number">1</span> - i ; j++)</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="comment">//开始比较两个元素</span></span><br><span class="line">      <span class="keyword">if</span>( cmp( (<span class="type">char</span>*)base + j*width , (<span class="type">char</span>*)base + (j+<span class="number">1</span>)*width)&gt;<span class="number">0</span>)</span><br><span class="line">         <span class="comment">//一个字节一个字节进行比较和交换</span></span><br><span class="line">       &#123;</span><br><span class="line">         <span class="comment">//交换</span></span><br><span class="line">         swap( (<span class="type">char</span>*)base + j*width , (<span class="type">char</span>*)base + (j+<span class="number">1</span>)*width)</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="四、strcat"><a href="#四、strcat" class="headerlink" title="四、strcat"></a>四、strcat</h1><h2 id="1-函数介绍-3"><a href="#1-函数介绍-3" class="headerlink" title="1.函数介绍"></a>1.函数介绍</h2><p>strcat原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *des, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br></pre></td></tr></table></figure><p>strcat的作用</p><blockquote><p>将源空间中的内容追加到目标空间后<br>目标空间中的 ‘\0’ 被替换为源空间中第一个元素</p></blockquote><p><code>注意:strcat不能自己追加自己,会使&#39;\0&#39;被覆盖,导致无法终止</code></p><hr><h2 id="2-模拟实现-3"><a href="#2-模拟实现-3" class="headerlink" title="2.模拟实现"></a>2.模拟实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">my_strcat</span><span class="params">(<span class="type">char</span> * dest, <span class="type">const</span> <span class="type">char</span> * src)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(dest &amp;&amp; src);</span><br><span class="line">  <span class="type">char</span> * ret = dest;</span><br><span class="line">  <span class="comment">//寻找目标空间中的&#x27;\0&#x27;</span></span><br><span class="line">  <span class="keyword">while</span>(*dest)</span><br><span class="line">  &#123;</span><br><span class="line">    dest++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//开始追加</span></span><br><span class="line">  <span class="keyword">while</span>( *dest++ = *src++);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="五、strcmp"><a href="#五、strcmp" class="headerlink" title="五、strcmp"></a>五、strcmp</h1><h2 id="1-函数介绍-4"><a href="#1-函数介绍-4" class="headerlink" title="1.函数介绍"></a>1.函数介绍</h2><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str1)</span>;</span><br></pre></td></tr></table></figure><p>函数的作用</p><blockquote><p>我们知道,两个字符串无法直接用大于小于号来进行比较<br>因此就存在了strcmp这个函数<br>.<br>对字符串逐一比较字符ASCII大小<br>一旦有大于或小于便停止,返回结果,若都相等则返回0<br>若前面都相等,则较长的win</p></blockquote><hr><h2 id="2-模拟实现-4"><a href="#2-模拟实现-4" class="headerlink" title="2.模拟实现"></a>2.模拟实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s1,<span class="type">const</span> <span class="type">char</span>* s2)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(s1 &amp;&amp; s2);</span><br><span class="line">  <span class="keyword">while</span>(*s1 == *s2)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(*s1 == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s1++;</span><br><span class="line">    s2++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *s1 - *s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="六、strncpy"><a href="#六、strncpy" class="headerlink" title="六、strncpy"></a>六、strncpy</h1><h2 id="1-函数介绍-5"><a href="#1-函数介绍-5" class="headerlink" title="1.函数介绍"></a>1.函数介绍</h2><p>该函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">char</span>* <span class="title function_">strncpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">size_t</span> num)</span>;</span><br></pre></td></tr></table></figure><p>该函数作用和原理为</p><blockquote><p>选择一定数量的字符拷贝至目标空间<br>.<br>若传递数量超过源空间含有的数量,并且空间足够<br>那么就会先将源空间内所有字符传进去后,按照规定数量补’\0’</p></blockquote><hr><h2 id="2-模拟实现-5"><a href="#2-模拟实现-5" class="headerlink" title="2.模拟实现"></a>2.模拟实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">my_strncpy</span><span class="params">(<span class="type">char</span> * dest,<span class="type">const</span> <span class="type">char</span> * src,<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span>* ret = dest;</span><br><span class="line">  <span class="keyword">while</span>(num &amp;&amp; (*dest++ = *src++) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    num--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(num)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(--num)</span><br><span class="line">    &#123;</span><br><span class="line">      *dest++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="七、strncat"><a href="#七、strncat" class="headerlink" title="七、strncat"></a>七、strncat</h1><h2 id="1-函数介绍-6"><a href="#1-函数介绍-6" class="headerlink" title="1.函数介绍"></a>1.函数介绍</h2><p>函数的原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> num)</span>;</span><br></pre></td></tr></table></figure><p>函数作用为</p><blockquote><p>选择固定数量的字符从源空间中追加到目标空间内</p></blockquote><hr><h2 id="2-模拟实现-6"><a href="#2-模拟实现-6" class="headerlink" title="2.模拟实现"></a>2.模拟实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *ret = dest;</span><br><span class="line">  <span class="keyword">while</span>(*dest++)</span><br><span class="line">  &#123;</span><br><span class="line">    dest--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(num--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>((*dest++ == *src++)==<span class="number">0</span>) <span class="comment">//发现&#x27;\0&#x27;直接结束,不再继续进行循环</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *dest=<span class="string">&#x27;\0&#x27;</span>;   <span class="comment">//提前结束</span></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="八、strncmp"><a href="#八、strncmp" class="headerlink" title="八、strncmp"></a>八、strncmp</h1><h2 id="1-函数介绍-7"><a href="#1-函数介绍-7" class="headerlink" title="1.函数介绍"></a>1.函数介绍</h2><p>strncmp的原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2, <span class="type">size_t</span> num)</span>;</span><br></pre></td></tr></table></figure><p>strncmp的作用为</p><blockquote><p>固定一个数量<br>使两个字符串的前几个数量的字符进行比较</p></blockquote><hr><h2 id="2-模拟实现-7"><a href="#2-模拟实现-7" class="headerlink" title="2.模拟实现"></a>2.模拟实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">My_strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (n-- &amp;&amp; *str1 != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *str1 == *str2)</span><br><span class="line">&#123;</span><br><span class="line">str1++;</span><br><span class="line">str2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *str1 - *str2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="九、strstr"><a href="#九、strstr" class="headerlink" title="九、strstr"></a>九、strstr</h1><h2 id="1-函数介绍-8"><a href="#1-函数介绍-8" class="headerlink" title="1.函数介绍"></a>1.函数介绍</h2><p>strstr函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string,h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">char</span>*<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1,<span class="type">const</span> <span class="type">char</span>* str2)</span>;</span><br></pre></td></tr></table></figure><p>该函数作用为</p><blockquote><p>在str1中寻找str2<br>返回str1中出现str2首元素的地址<br>若找不到则返回空指针</p></blockquote><hr><h2 id="2-模拟实现-8"><a href="#2-模拟实现-8" class="headerlink" title="2.模拟实现"></a>2.模拟实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">my_strstr</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str1, <span class="type">const</span> <span class="type">char</span> * str2)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(str1 &amp;&amp; str2);</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> * s1 = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> * s2 = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> * cp = str1;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(*str2 == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>*)str1;</span><br><span class="line">  <span class="keyword">while</span>(*cp)</span><br><span class="line">  &#123;</span><br><span class="line">    s1 = cp;</span><br><span class="line">    s2 = str2;</span><br><span class="line">    <span class="keyword">while</span>(*s1 &amp;&amp; *s2 &amp;&amp;(*s1 == *s2) )</span><br><span class="line">    &#123;</span><br><span class="line">      s1++;</span><br><span class="line">      s2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(*S2 == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="type">char</span>*)cp;</span><br><span class="line">    &#125;</span><br><span class="line">    cp++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="十、strtok"><a href="#十、strtok" class="headerlink" title="十、strtok"></a>十、strtok</h1><h2 id="1-函数介绍-9"><a href="#1-函数介绍-9" class="headerlink" title="1.函数介绍"></a>1.函数介绍</h2><p>该函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">char</span>* <span class="title function_">strtok</span><span class="params">(<span class="type">char</span> * str, <span class="type">const</span> <span class="type">char</span> * sep)</span>;</span><br></pre></td></tr></table></figure><p>该函数的介绍</p><blockquote><p>在str中  以sep中的字符分割str<br>sep中可以有一个或多个分隔符标记<br>.<br>strtok函数找到str中的下一个标记,并将其用’\0’结尾,返回一个指向这个标记的指针<br>所以该函数会改变被操作的字符串,所以在使用时一般面向对象都是临时拷贝的内容<br>.<br>strtok函数第一个参数不为空指针,函数将找到str中第一个标记,strtok会保存它在字符串中的位置<br>strtok函数第一个参数为空指针,函数将在同一字符串中被保存的位置开始,查找下一个标记<br>如果字符串中不存在标记则会返回空指针</p></blockquote><hr><p>我们以一个实例来加深理解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[<span class="number">30</span>] = <span class="string">&quot;9TSe@qq.com&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = <span class="string">&quot;@.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> tmp[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//创建临时拷贝份</span></span><br><span class="line"><span class="built_in">strcpy</span>(tmp,arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//9TSe@qq.com\0</span></span><br><span class="line">strtok(tmp,p); <span class="comment">//返回9TSe   9TSe\0qq.com\0</span></span><br><span class="line">strtok(<span class="literal">NULL</span>,p);<span class="comment">//返回qq     9TSe\0qq\0com\0</span></span><br><span class="line">strtok(<span class="literal">NULL</span>,p);<span class="comment">//返回com    9TSe\0qq\0com\0</span></span><br></pre></td></tr></table></figure><hr><p>那么实际上使用该函数的用法为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[<span class="number">30</span>] = <span class="string">&quot;9TSe@qq.com&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = <span class="string">&quot;@.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> tmp[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line"><span class="built_in">strcpy</span>(tmp,arr);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * ret = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(ret = strtok(tmp,p); ret != <span class="literal">NULL</span> ; ret = strtok(<span class="literal">NULL</span>,p) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>该函数由于使用情况不多,暂且不做模拟实现</strong></p><hr><h1 id="十一、strerror"><a href="#十一、strerror" class="headerlink" title="十一、strerror"></a>十一、strerror</h1><h2 id="1-函数介绍-10"><a href="#1-函数介绍-10" class="headerlink" title="1.函数介绍"></a>1.函数介绍</h2><p>该函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">char</span> * <span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span>;</span><br></pre></td></tr></table></figure><p>该函数的作用为</p><blockquote><p>返回错误码所对应的错误信息</p></blockquote><hr><p>使用情况一般如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,strerror(errno)); <span class="comment">//errno是库函数里本有的全局变量,加入头文件就不用再创建</span></span><br></pre></td></tr></table></figure><hr><p><strong>模拟暂不实现</strong></p><hr><h1 id="十二、perror"><a href="#十二、perror" class="headerlink" title="十二、perror"></a>十二、perror</h1><h2 id="1-函数介绍-11"><a href="#1-函数介绍-11" class="headerlink" title="1.函数介绍"></a>1.函数介绍</h2><p>该函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * str)</span>;</span><br></pre></td></tr></table></figure><p>该函数的作用为</p><blockquote><p>perror可以直接转换错误信息并且打印<br>比如<br>perror(“fopen”) ;<br>fopen: No such file or directory </p></blockquote><hr><p><strong>该函数暂不模拟实现</strong></p><hr><h1 id="十三、字符分类函数和字符转换函数"><a href="#十三、字符分类函数和字符转换函数" class="headerlink" title="十三、字符分类函数和字符转换函数"></a>十三、字符分类函数和字符转换函数</h1><h2 id="1-函数介绍-12"><a href="#1-函数介绍-12" class="headerlink" title="1.函数介绍"></a>1.函数介绍</h2><p>他们公用原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">int</span> <span class="title function_">xxx</span><span class="params">(<span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure><p>函数功能为</p><blockquote><p>为真返回非0<br>为假返回0</p></blockquote><hr><table><thead><tr><th>函数</th><th>如果符合以下条件返回真</th></tr></thead><tbody><tr><td>iscntrl</td><td>任何控制字符</td></tr><tr><td>isspace</td><td>空白字符:空格’ ‘ ,换页’\f’,换行’\n’,回车’\r’,制表符’\t’,垂直制表符’\v’</td></tr><tr><td>isdigit</td><td>十进制数字 0 ~ 9</td></tr><tr><td>isxdigit</td><td>十六进制数字,包括所有十进制数字和大小写字母 a<del>f 、A</del>F</td></tr><tr><td>islower</td><td>小写字母 a ~ z</td></tr><tr><td>isuper</td><td>大写字母 A ~ Z</td></tr><tr><td>isalpha</td><td>字母 a ~ z 和 A ~ Z</td></tr><tr><td>isalnum</td><td>字母或数字 a ~ z , A ~ Z , 0 ~ 9</td></tr><tr><td>ispunct</td><td>标点符号,任何不属于数字或字母的图形字符(可打印)</td></tr><tr><td>isgraph</td><td>任何图形字符</td></tr><tr><td>isprint</td><td>任何可打印字符,包括图形字符和空白字符</td></tr></tbody></table><hr><table><thead><tr><th>字符转换函数</th><th>功能</th></tr></thead><tbody><tr><td>tolower</td><td>将字符大写转换为小写</td></tr><tr><td>toupper</td><td>将字符小写转换为大写</td></tr></tbody></table><hr><h1 id="十四、memcpy"><a href="#十四、memcpy" class="headerlink" title="十四、memcpy"></a>十四、memcpy</h1><h2 id="1-函数介绍-13"><a href="#1-函数介绍-13" class="headerlink" title="1.函数介绍"></a>1.函数介绍</h2><p>该函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">void</span> * <span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> * dest , <span class="type">const</span> <span class="type">void</span> * src , <span class="type">size_t</span> num)</span>;</span><br></pre></td></tr></table></figure><p>该函数的功能</p><blockquote><p>memcpy为内存拷贝,将src中的内容拷贝至dest<br>num中存放的为拷贝的<strong>字节大小</strong></p></blockquote><hr><h2 id="2-模拟实现-9"><a href="#2-模拟实现-9" class="headerlink" title="2.模拟实现"></a>2.模拟实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">my_memcpy</span><span class="params">(<span class="type">void</span> * dest , <span class="type">const</span> <span class="type">void</span> * src , <span class="type">size_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(dest &amp;&amp; src);</span><br><span class="line">  <span class="type">void</span> * ret = dest;</span><br><span class="line">  <span class="keyword">while</span>(num--)</span><br><span class="line">  &#123;</span><br><span class="line">    *(<span class="type">char</span>*)dest = *(<span class="type">char</span>*)src; <span class="comment">//一个字节一个字节拷贝,所以强制转换为char*再解引用</span></span><br><span class="line">    dest = (<span class="type">char</span>*)dest + <span class="number">1</span>;</span><br><span class="line">    src  = (<span class="type">char</span>*)src + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//那能不能写如下的更加简便呢</span></span><br><span class="line">    <span class="comment">//*(char*)dest++ = *(char*)src++;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//很遗憾并不可以 ++在生效时dest和src还是void*类型,不能++;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>注意:memcpy不能拷贝重叠的内存</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">memcpy</span>(arr+<span class="number">2</span>,arr,<span class="number">20</span>);</span><br><span class="line"><span class="comment">//结果并不为 &#123;1,2,1,2,3,4,5,8,9,10&#125;</span></span><br><span class="line"><span class="comment">//而是为     &#123;1,2,1,2,1,2,1,8,9,10&#125;</span></span><br></pre></td></tr></table></figure><p>但是memmove却可以做到</p><hr><h1 id="十五、memmove"><a href="#十五、memmove" class="headerlink" title="十五、memmove"></a>十五、memmove</h1><h2 id="1-函数介绍-14"><a href="#1-函数介绍-14" class="headerlink" title="1.函数介绍"></a>1.函数介绍</h2><p>该函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">void</span> * <span class="title function_">memmove</span><span class="params">( <span class="type">void</span> * dest, <span class="type">const</span> <span class="type">void</span> * src , <span class="type">size_t</span> num)</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="2-模拟实现-10"><a href="#2-模拟实现-10" class="headerlink" title="2.模拟实现"></a>2.模拟实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">memmove</span><span class="params">( <span class="type">void</span> * dest, <span class="type">const</span> <span class="type">void</span> * src , <span class="type">size_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(dest &amp;&amp; src);</span><br><span class="line">  <span class="type">void</span> * ret = dest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dest&lt;src)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//前-&gt;后</span></span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">    &#123;</span><br><span class="line">      *(<span class="type">char</span>*)dest = *(<span class="type">char</span>*)src;</span><br><span class="line">      dest = (<span class="type">char</span>*)dest + <span class="number">1</span>;</span><br><span class="line">      src  = (<span class="type">char</span>*)src + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//后-&gt;前</span></span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">    &#123;</span><br><span class="line">      *((<span class="type">char</span>*)dest+num) = *((<span class="type">char</span>*)src+num);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p><img src="/img/3.1.png"><br>如图为分情况讨论理解图</p><hr><h1 id="十六、memcmp"><a href="#十六、memcmp" class="headerlink" title="十六、memcmp"></a>十六、memcmp</h1><h2 id="1-函数介绍-15"><a href="#1-函数介绍-15" class="headerlink" title="1.函数介绍"></a>1.函数介绍</h2><p>该函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * str1 , <span class="type">const</span> <span class="type">void</span> * str2 , <span class="type">size_t</span> num)</span>;</span><br></pre></td></tr></table></figure><p>该函数作用</p><blockquote><p>对比str1和str2中前 num 字节的内容</p></blockquote><p>该函数较strcmp较相似,不再模拟实现</p><hr><h1 id="十七、memset"><a href="#十七、memset" class="headerlink" title="十七、memset"></a>十七、memset</h1><h2 id="1-函数介绍-16"><a href="#1-函数介绍-16" class="headerlink" title="1.函数介绍"></a>1.函数介绍</h2><p>该函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">.</span><br><span class="line"><span class="type">void</span> * <span class="title function_">memset</span><span class="params">(<span class="type">void</span> * ptr , <span class="type">int</span> value , <span class="type">size_t</span> num)</span>;</span><br></pre></td></tr></table></figure><p>该函数作用为</p><blockquote><p>设置ptr内前num字节 全部初始化为 value</p></blockquote><hr><p><strong>该函数不进行模拟实现</strong></p><hr>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针</title>
      <link href="/2023/10/21/c-%E6%8C%87%E9%92%88/"/>
      <url>/2023/10/21/c-%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="一、-指针指向字符常量"><a href="#一、-指针指向字符常量" class="headerlink" title="一、 指针指向字符常量"></a>一、 指针指向字符常量</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *pc1 = <span class="string">&quot;9TSe&quot;</span>;</span><br><span class="line"><span class="type">char</span> *pc2 = <span class="string">&quot;9TSe&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pc1和pc2指向的地址是相同的(相同字符串,系统为了节省空间就没有再开辟空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有些编译器在写以上代码时会报错</span></span><br><span class="line"><span class="comment">//以下是解决方式</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *pc1 = <span class="string">&quot;9TSe&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *pc2 = <span class="string">&quot;9TSe&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为 指针指向的是字符常量,不可修改,编译器认为其不安全,故报错</span></span><br><span class="line"><span class="comment">//加上const修饰即可</span></span><br></pre></td></tr></table></figure><hr><h1 id="二、-指针、数组"><a href="#二、-指针、数组" class="headerlink" title="二、 指针、数组"></a>二、 指针、数组</h1><hr><h2 id="1-指针数组"><a href="#1-指针数组" class="headerlink" title="1. 指针数组"></a>1. 指针数组</h2><hr><blockquote><p>指针数组是一个数组<br>数组里面存放着指针</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[<span class="number">3</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> c[<span class="number">3</span>] = &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* arr[<span class="number">3</span>] = &#123;a,b,c&#125;; </span><br><span class="line"><span class="comment">//数组名即为数组首元素地址</span></span><br><span class="line"><span class="comment">//arr就为有三个元素,每个元素是一个指针的数组</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-数组指针"><a href="#2-数组指针" class="headerlink" title="2. 数组指针"></a>2. 数组指针</h2><hr><blockquote><p>数组指针是一个指针<br>指向数组的指针</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *parr = arr;<span class="comment">//error arr是数组首元素的地址,而不是数组的地址</span></span><br><span class="line">          <span class="comment">//虽然数组的地址指向的也是数组首元素的地址,但二者本质却不相同</span></span><br><span class="line">           </span><br><span class="line"><span class="type">int</span> *parr = &amp;arr;     <span class="comment">//error 虽然确实指向了数组arr的地址,但是类型不对</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *parr[<span class="number">5</span>] = &amp;arr;  <span class="comment">//error parr先和[5]结合,表示的就是一个指针数组了</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*parr)[<span class="number">5</span>] = &amp;arr;<span class="comment">//bingo</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写出 double* arr[5] 的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> * (*pd)[<span class="number">5</span>] = &amp;arr; <span class="comment">//pd就是一个数组指针</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-数组参数-指针参数传参"><a href="#3-数组参数-指针参数传参" class="headerlink" title="3. 数组参数,指针参数传参"></a>3. 数组参数,指针参数传参</h2><hr><h3 id="①一维数组传参"><a href="#①一维数组传参" class="headerlink" title="①一维数组传参"></a>①一维数组传参</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> arr[])</span> <span class="comment">//传过来的是数组,拿数组接收,可行</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> arr[<span class="number">10</span>])</span> <span class="comment">//10是没有任何意义的,但也可行</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> *arr)</span> <span class="comment">//即为地址,可行</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> *arr[<span class="number">20</span>])</span> <span class="comment">//拿指针数组接收,可行</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> **arr)</span> <span class="comment">// 即为地址,可行</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> arr1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> *arr2[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  test1(arr1); <span class="comment">//传过去的是数组首元素地址</span></span><br><span class="line">  test2(arr2); <span class="comment">//传过去指针数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="②二维数组的传参"><a href="#②二维数组的传参" class="headerlink" title="②二维数组的传参"></a>②二维数组的传参</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>])</span>; <span class="comment">// 二维数组接受,可行</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[][])</span>;   <span class="comment">// 不能省略列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[][<span class="number">5</span>])</span>;  <span class="comment">// 可行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组传参,函数形参的设计只能省略第一个[]中的数字</span></span><br><span class="line"><span class="comment">//因为对于一个二维数组,可以不知道有多少行,但必须知道一行有多少元素</span></span><br><span class="line"><span class="comment">//以方便运算</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> *arr)</span>;     <span class="comment">//传过来数组的地址,不能拿单元素接收,不可行 </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> *arr[<span class="number">5</span>])</span>;  <span class="comment">//这是指针数组,不可行 </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> (*arr)[<span class="number">5</span>])</span>;<span class="comment">//接受二维数组的第一行,即二维数组首元素可行 </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> **arr)</span>;    <span class="comment">//二级指针,不匹配,不可行</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  test(arr);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h2 id="4-一维数组-二维数组-指针大小判断例题"><a href="#4-一维数组-二维数组-指针大小判断例题" class="headerlink" title="4. 一维数组,二维数组,指针大小判断例题"></a>4. 一维数组,二维数组,指针大小判断例题</h2><hr><h3 id="①整形数组"><a href="#①整形数组" class="headerlink" title="①整形数组"></a>①整形数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a));   <span class="comment">// 16 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a+<span class="number">0</span>)); <span class="comment">// 4/8 a+0 是数组第一个元素的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*a));  <span class="comment">// 4   *a  是数组的第一个元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a+<span class="number">1</span>)); <span class="comment">// 4/8 a+1 是第二个元素的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">1</span>]));<span class="comment">// 4      第二个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a));     <span class="comment">//数组的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*&amp;a));    <span class="comment">//数组的大小</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a+<span class="number">1</span>));   <span class="comment">//跳过整个数组后面的空间的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>]));  <span class="comment">//第一个元素的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>]+<span class="number">1</span>));<span class="comment">//第二个元素的地址</span></span><br></pre></td></tr></table></figure><hr><h3 id="②字符数组"><a href="#②字符数组" class="headerlink" title="②字符数组"></a>②字符数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(arr));      <span class="comment">//6    整个数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(arr+<span class="number">0</span>));    <span class="comment">//4/8  首元素地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*arr));     <span class="comment">//1    首元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(arr[<span class="number">1</span>]));   <span class="comment">//1    第二个元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;arr));     <span class="comment">//4/8  整个数组地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;arr+<span class="number">1</span>));   <span class="comment">//4/8  跳过一个数组后的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>));<span class="comment">//4/8  第二个元素的地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(arr));       <span class="comment">//随机值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(arr+<span class="number">0</span>));     <span class="comment">//随机值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(*arr));      <span class="comment">//报错    首元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(arr[<span class="number">1</span>]));    <span class="comment">//报错    第二个元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(&amp;arr));      <span class="comment">//随机值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(&amp;arr+<span class="number">1</span>));    <span class="comment">//随机值-6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>)); <span class="comment">//随机值-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;abcdef&quot;</span>;           <span class="comment">//&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;\0&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(arr));      <span class="comment">//7    数组内所有元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(arr+<span class="number">0</span>));    <span class="comment">//4/8  首元素地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*arr));     <span class="comment">//1    第一个元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(arr[<span class="number">1</span>]));   <span class="comment">//1    第二个元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;arr));     <span class="comment">//4/8  数组的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;arr+<span class="number">1</span>));   <span class="comment">//4/8  跳过整个数组后的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>));<span class="comment">//4/8  第二个元素的地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(arr));       <span class="comment">//6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(arr+<span class="number">0</span>));     <span class="comment">//6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(*arr));      <span class="comment">//报错</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(arr[<span class="number">1</span>]));    <span class="comment">//报错</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(&amp;arr));      <span class="comment">//6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(&amp;arr+<span class="number">1</span>));    <span class="comment">//随机值  数组后的&#x27;\0&#x27;不知道在哪里</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>)); <span class="comment">//5</span></span><br></pre></td></tr></table></figure><hr><h3 id="③指针指向字符串"><a href="#③指针指向字符串" class="headerlink" title="③指针指向字符串"></a>③指针指向字符串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(p));       <span class="comment">//4/8   一个指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(p+<span class="number">1</span>));     <span class="comment">//4/8   b的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*p));      <span class="comment">//1     即第一个元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(p[<span class="number">0</span>]));    <span class="comment">//1     p[0] == *(p+0)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;p));      <span class="comment">//4/8   二级指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;p+<span class="number">1</span>));    <span class="comment">//4/8   二级指针+1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;p[<span class="number">0</span>]+<span class="number">1</span>)); <span class="comment">//4/8   b的地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(p));       <span class="comment">//6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(p+<span class="number">1</span>));     <span class="comment">//5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(*p));      <span class="comment">//报错</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(p[<span class="number">0</span>]));    <span class="comment">//报错</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(&amp;p));      <span class="comment">//随机值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(&amp;p+<span class="number">1</span>));    <span class="comment">//另一个随机值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(&amp;p[<span class="number">0</span>]+<span class="number">1</span>)); <span class="comment">//5</span></span><br></pre></td></tr></table></figure><hr><h3 id="④二维数组"><a href="#④二维数组" class="headerlink" title="④二维数组"></a>④二维数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a));            <span class="comment">//48</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]));      <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>]));         <span class="comment">//16  可以理解为第一行数组的数组名</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>]+<span class="number">1</span>));       <span class="comment">//4/8  a[0]作为数组名并没有单独放在sizeof内部</span></span><br><span class="line">                                     <span class="comment">//     也没有取地址,即a[0]就是第一行第一个元素的地址</span></span><br><span class="line">                                     <span class="comment">//     a[0]就是第一行第二个元素的地址</span></span><br><span class="line">                                     </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*(a[<span class="number">0</span>]+<span class="number">1</span>)) );   <span class="comment">//4    第一行第二个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a+<span class="number">1</span>));          <span class="comment">//4/8  a是数组名.并没有单独存放在sizeof内部</span></span><br><span class="line">                                     <span class="comment">//     也没有取地址,即a就是第一行的地址</span></span><br><span class="line">                                     <span class="comment">//     所以a+1为第二行的地址</span></span><br><span class="line">                                     </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*(a+<span class="number">1</span>)));       <span class="comment">//16   == a[1] 即第二行所有元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>]+<span class="number">1</span>));      <span class="comment">//4/8  第二行的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*(&amp;a[<span class="number">0</span>]+<span class="number">1</span>)));   <span class="comment">//16   第二行所有元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*a));           <span class="comment">//16   == *(a+0) == a[0] 即第一行元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">3</span>]));         <span class="comment">//16   计算的是第四行的数组名,计算的是类型大小,即 int[4] 类型</span></span><br></pre></td></tr></table></figure><hr><h1 id="三、函数指针"><a href="#三、函数指针" class="headerlink" title="三、函数指针"></a>三、函数指针</h1><h2 id="1-函数指针的介绍"><a href="#1-函数指针的介绍" class="headerlink" title="1.函数指针的介绍"></a>1.函数指针的介绍</h2><hr><p>函数指针即</p><blockquote><p>指向函数的指针<br> 存放函数地址的指针</p></blockquote><p>前面我们知道,在数组当中<br><code>&amp;(数组名) !=  数组名</code></p><p>但是在函数指针中</p><p><code>&amp;(函数名) == 函数名</code></p><hr><p><strong>函数指针的创建和使用方式:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> (*pf)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Add; </span><br><span class="line">  <span class="type">int</span> (*pf)(<span class="type">int</span>, <span class="type">int</span>) = Add; <span class="comment">//以上两种方式均可</span></span><br><span class="line">  <span class="comment">//pf即为函数指针</span></span><br><span class="line">  <span class="comment">//int 代表Add的返回类型</span></span><br><span class="line">  <span class="comment">//(*pf)代表声明pf为一个指针</span></span><br><span class="line">  <span class="comment">//(int,int)即为Add 的参数类型</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ret = (*pf)(a,b);  <span class="comment">//*并无意义,这样写只是更方便理解</span></span><br><span class="line">  <span class="type">int</span> ret = (******pf)(a,b);<span class="comment">//这种方式计算出的结果也并无差错</span></span><br><span class="line">  <span class="type">int</span> ret = pf(a,b);</span><br><span class="line">  <span class="type">int</span> ret = Add(a,b);</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> ret = * pf(a,b);<span class="comment">//这样写时就会出错,相当于 *(pf(a,b)) == *3</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-函数指针数组"><a href="#2-函数指针数组" class="headerlink" title="2.函数指针数组"></a>2.函数指针数组</h2><p>我们以一段代码来展示以下函数指针数组的创建和使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> (*pA)(<span class="type">int</span> ,<span class="type">int</span>) = Add;</span><br><span class="line">  <span class="type">int</span> (*pS)(<span class="type">int</span> ,<span class="type">int</span>) = Sub;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> (*parr[<span class="number">2</span>])(<span class="type">int</span> ,<span class="type">int</span>) = &#123;Add,Sub&#125;; </span><br><span class="line">  <span class="comment">//parr即为函数指针数组</span></span><br></pre></td></tr></table></figure><hr><h1 id="四、回调函数"><a href="#四、回调函数" class="headerlink" title="四、回调函数"></a>四、回调函数</h1><hr><blockquote><p>回调函数就是<br>一个通过函数指针调用的函数</p></blockquote><p>举一个简单的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">all</span><span class="params">( <span class="type">int</span>(*pf)(<span class="type">int</span>,<span class="type">int</span>) )</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">  <span class="keyword">return</span> pf(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据的存储</title>
      <link href="/2023/10/21/c-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/"/>
      <url>/2023/10/21/c-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-整形在内存中的存储和整形提升"><a href="#1-整形在内存中的存储和整形提升" class="headerlink" title="1. 整形在内存中的存储和整形提升"></a>1. 整形在内存中的存储和整形提升</h1><hr><p><img src="/img/2.1.png"></p><blockquote><p>整数在内存中存储的是补码</p></blockquote><hr><p><code>那为什么在内存中偏要存储补码呢?</code></p><p>比如 (1-1)</p><p><img src="/img/2.2.png"></p><p>这里我们要解释</p><blockquote><p>补码可以将符号位和数值域统一处理<br>同时加法和减法也可以统一处理 (CPU只有加法处理器)<br>还有 补码和原码,原码和补码转化的方式是一样的(都是取反+1),不需要额外的电路</p></blockquote><p>因此在内存中存储补码可以方便运算</p><hr><p>简述一下<strong>整形提升</strong> </p><p><em><strong>一、</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-1 的补码为</span></span><br><span class="line"><span class="comment">//11111111111111111111111111111111</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//因为 a 为 char 类型,所以只能存一个字节(8bit) 即为</span></span><br><span class="line"><span class="comment">//11111111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//又因为打印的方式为 %d 即为整形方式打印 所以要整形提升</span></span><br><span class="line"><span class="comment">//(因为为有符号类型,所以前面补1) 即为</span></span><br><span class="line"><span class="comment">// 11111111111111111111111111111111 (补码)</span></span><br><span class="line"><span class="comment">//转换为原码则为 10000000000000000000000000000001 (即为-1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> b = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b为有符号字符类型,计算方式与a相同</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//11111111(存储内容)</span></span><br><span class="line"><span class="comment">//因为为无符号类型,且需要整形提升 所以前面补0 即为</span></span><br><span class="line"><span class="comment">//00000000000000000000000011111111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为其为无符号类型 所以原反补码相同</span></span><br><span class="line"><span class="comment">//即不需要转化.直接打印出来</span></span><br><span class="line"><span class="comment">//即为255</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c); <span class="comment">//-1 -1 255</span></span><br></pre></td></tr></table></figure><blockquote><p>有符号位的整形提升前面补1<br>无符号位的整形提升前面补0</p></blockquote><hr><p><em><strong>二、</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="number">-128</span>;</span><br><span class="line"><span class="comment">//-128 的补码为 11111111111111111111111110000000</span></span><br><span class="line"><span class="comment">//所以在a中存储的为后8bit位即为</span></span><br><span class="line"><span class="comment">//10000000</span></span><br><span class="line"><span class="comment">//又因为要以无符号整形打印 所以要整形提升,又因为char为有符号类型所以补1</span></span><br><span class="line"><span class="comment">//11111111111111111111111110000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//又因为数据要以 %u解读 即为无符号类型,即原反补相同,所以直接打印</span></span><br><span class="line"><span class="comment">//即为4294967168</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u&quot;</span>,a); <span class="comment">//4294967168</span></span><br></pre></td></tr></table></figure><blockquote><p>char默认为 signed char 还是 unsigned char 并没有标准规定,取决于编译器<br>但 int 默认为 signed int<br>short 默认为 signed short</p></blockquote><hr><h1 id="2-大小端存储的介绍"><a href="#2-大小端存储的介绍" class="headerlink" title="2. 大小端存储的介绍"></a>2. 大小端存储的介绍</h1><p>在整形存储方式中我们注意到<br><img src="/img/2.3.png"><br>我们运算出的 内存存储数据 在内存是反着来的</p><hr><p>大小字节端的内存处理方式</p><blockquote><p><strong>大端存储模式(大端字节序) : 数据的低位字节序保存在内存的高地址处,数据的高位字节序保存在内存的低地址处</strong><br>.<br><strong>小端存储模式(小端字节序) : 数据的高位字节序保存在内存的高地址处,数据的低位字节序保存在内存的低地址处</strong></p></blockquote><p>什么是低位字节序和高位字节序呢</p><p>我们举一个很简单的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0x11223344</span>;</span><br></pre></td></tr></table></figure><p>就以这个a为例子</p><p>在a中, 11 就是最高位字节序,44就为最低位字节序</p><hr><p><code>写出一个程序,判断当前机器的字节序</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>; </span><br><span class="line">  <span class="comment">//可以知道 a 的16进制补码为 00 00 00 01</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">char</span> *p = (<span class="type">char</span>*) &amp;a; </span><br><span class="line">  <span class="comment">//取出a的地址并强制转换为char* 并将地址交付给 p</span></span><br><span class="line">  <span class="comment">//从而转换为存储a最低地址的一个字节即 01 或 00 </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//再进行判断</span></span><br><span class="line">  <span class="keyword">if</span> (*p == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;小端&quot;</span>); <span class="comment">//即低字节序存储在低地址处</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(*p == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;大端&quot;</span>); <span class="comment">//即高字节序存储在低地址处</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="3-浮点型在内存中的存储"><a href="#3-浮点型在内存中的存储" class="headerlink" title="3. 浮点型在内存中的存储"></a>3. 浮点型在内存中的存储</h1><p><code> 浮点数的存储为IEE 754规定,任意一个浮点数可以表示为下面的形式:</code></p><blockquote><p>(-1) ^S * M * 2 ^E<br>(-1) ^S 表示符号位, S &#x3D;&#x3D; 0为正 , S &#x3D;&#x3D; 1为负<br> M表示有效数字, 1 &lt;&#x3D; M &lt; 2<br>2^E表示指数位</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">浮点数: <span class="number">5.5</span> (十进制)</span><br><span class="line">二进制: <span class="number">101.1</span> --&gt; <span class="number">1.011</span> * <span class="number">2</span>^<span class="number">2</span> --&gt; (<span class="number">-1</span>)^<span class="number">0</span> * <span class="number">1.011</span> * <span class="number">2</span>^<span class="number">2</span></span><br><span class="line">                                S == <span class="number">0</span>   M = <span class="number">1.011</span>  E = <span class="number">2</span></span><br></pre></td></tr></table></figure><hr><p>每个值该分配多少空间,IEE 754 也有规定</p><p>float:</p><p><img src="/img/2.4.png"><br>.<br>.<br>.</p><p>double:</p><p><img src="/img/2.5.png"></p><hr><p><code>关于M:</code><br>前面提到了M总是为1-2之间,因此M的表达式总是为<br>1.xxxxxxx<br>所以为了拥有更大的存储上限,IEE规定这个1可以省去<br><strong>M内只存入小数点后几位</strong></p><hr><p><code>关于指数E:</code><br>首先,<strong>E是一个无符号整数</strong><br>所以E为8位时,其取值范围为 0<del>255<br>E为11位时,其取值范围为 0</del>2047</p><p>但是我们都知道指数在科学计数法中是可以为负数的<br>所以规定</p><blockquote><p>存入内存时E的真实值必须加入一个中间数<br> 8位时这个中间数为127<br> 11位时这个中间数为1023</p></blockquote><hr><p>指数存入就是以上这些<br>指数取出就又可以分为三种情况了</p><table><thead><tr><th>情况</th><th>处理方式</th></tr></thead><tbody><tr><td>E不为全0并且不为全1</td><td>对指数减去127得到真实值,再将有效数字M前加上一位1</td></tr><tr><td>E为全0</td><td>此时E的真实值即为 1-127 或 1-1023,有效数字M前不再加1,而是还原为 0.xxxxx的小数,这样做表示±0,以及接近于0的很小数字</td></tr><tr><td>E为全1</td><td>表示±无穷大(正负取决于S)</td></tr></tbody></table><hr><p>内存中怎么装这些东西?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a = <span class="number">5.5f</span>;</span><br><span class="line"><span class="comment">//转化为二进制为 101.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (-1) ^0 * 1.011 * 2 ^2</span></span><br><span class="line"><span class="comment">// s === 0  M===011  E=2+127</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 10000001 01100000000000000000000</span></span><br><span class="line"><span class="comment">// 01000000101100000000000000000000</span></span><br><span class="line"><span class="comment">// 0100 0000 1011 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">// 40 b0 00 00</span></span><br><span class="line"><span class="comment">// 以上十六进制数列即为内存中存放的数据</span></span><br></pre></td></tr></table></figure><p>我们可以验证一下<br><img src="/img/2.6.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据的存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tips</title>
      <link href="/2023/10/21/tips/"/>
      <url>/2023/10/21/tips/</url>
      
        <content type="html"><![CDATA[<h1 id="1-全局变量的作用域"><a href="#1-全局变量的作用域" class="headerlink" title="1. 全局变量的作用域"></a>1. 全局变量的作用域</h1><hr><blockquote><p><em><strong>全局变量的作用域就是整个工程</strong></em></p></blockquote><p>我们在<strong>同一工程</strong>但在<strong>不同的源文件</strong>这句话是否有误呢?</p><p>比如在源文件 test2.c 中我们创建一个全局变量  a &#x3D; 10<br><img src="/img/1.1.png"></p><p>但在<strong>不做声名</strong>的情况下我们却发现在test1.c中   a    并没有被创建<br><img src="/img/1.2.png"></p><p>但是全局变量的作用域是整个工程这句话并没有错误</p><p>我们只需要在 test2.c 中声明即可</p><p>此时我们需要一个函数 extern  使用方法如下<br><img src="/img/1.3.png"></p><hr><h1 id="2-什么是常量"><a href="#2-什么是常量" class="headerlink" title="2. 什么是常量"></a>2. 什么是常量</h1><hr><p>创建数组时我们需要为数组提供 创建量(必须为常量)<br><img src="/img/1.4.png"></p><hr><h2 id="2-1-const"><a href="#2-1-const" class="headerlink" title="2.1 const"></a>2.1 const</h2><hr><blockquote><p>const在 * 前 , 修饰的是 *p<br>const在 * 后 , 修饰的是  p </p></blockquote><p><img src="/img/1.5.png"></p><p><strong><code>const 只是将 a 从变量修饰成了常量,让其拥有了常属性,但其本质上还是一个变量  </code></strong></p><p><img src="/img/1.6.png"></p><hr><h2 id="2-2-枚举常量"><a href="#2-2-枚举常量" class="headerlink" title="2.2 枚举常量"></a>2.2 枚举常量</h2><blockquote><p>枚举常量即是可以一一列举的量</p></blockquote><p>创建方法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">xxx</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   a,       <span class="comment">//若不赋值默认为0</span></span><br><span class="line">   b,       <span class="comment">//向下逐一递增,b即默认为1</span></span><br><span class="line">   c = <span class="number">100</span>, <span class="comment">//赋值之后即为100</span></span><br><span class="line">   d        <span class="comment">//逐一递增,默认为101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/1.7.png"></p><p>可以看到 d 并不能改变</p><hr><h1 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3. 字符串"></a>3. 字符串</h1><hr><h2 id="3-1-常见字符串的创建"><a href="#3-1-常见字符串的创建" class="headerlink" title="3.1 常见字符串的创建"></a>3.1 常见字符串的创建</h2><hr><p>常见的字符串创建有以下几种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr1[] = <span class="string">&quot;abc&quot;</span>;              <span class="comment">//实际上该字符串共有4个元素,其末尾会自动补上&#x27;\0&#x27;作为终止标志</span></span><br><span class="line"><span class="type">char</span> arr2[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">//以这种方式创建时必须手动补上 &#x27;\0&#x27;作为结束标志</span></span><br><span class="line"><span class="type">char</span> arr3[<span class="number">4</span>] = <span class="string">&quot;abc&quot;</span>              <span class="comment">//之所以要标有四个元素个数,是要为 &#x27;\0&#x27; 留有空间</span></span><br><span class="line"><span class="type">char</span> arr4[<span class="number">4</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;</span><br><span class="line"><span class="type">char</span> arr5[<span class="number">4</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;      <span class="comment">//此时不加&#x27;\0&#x27;也没有关系,剩下的元素自动默认为&#x27;\0&#x27;</span></span><br></pre></td></tr></table></figure><p>那么,加入没有手动加入  <strong>‘\0’</strong>   arr2 是否会出问题呢,我们来使用 <strong>strlen</strong> 这个函数来验证一下</p><hr><h2 id="3-2-strlen简介"><a href="#3-2-strlen简介" class="headerlink" title="3.2 strlen简介"></a>3.2 strlen简介</h2><hr><blockquote><p>求长度方式就是计算出字符串 ‘\0’ 前的字符个数(不包括’\0’)</p></blockquote><p><img src="/img/1.8.png"><br>可见没有手动加入 ‘\0’ 之后该字符串的长度是42(随机值)</p><hr><h1 id="4-转义字符"><a href="#4-转义字符" class="headerlink" title="4. 转义字符"></a>4. 转义字符</h1><p><strong>前言</strong>:当我们想要打印一个字符 ‘ 时会发现如下错误</p><p><img src="/img/1.9.png"><br>那么究竟该如何做才能打印出一些貌似有功能作用的字符呢<br>在此我们引出<strong>转义字符</strong></p><table><thead><tr><th>转义字符</th><th>作用</th></tr></thead><tbody><tr><td>&#x2F;‘</td><td>用于表示字符常量 ‘</td></tr><tr><td>&#x2F;“</td><td>用于表示一个字符串内的双引号</td></tr><tr><td>&#x2F;&#x2F;</td><td>用于表示一个反斜杠,防止被解释为一个 转义序列符(即 &#x2F;n , &#x2F;r 等解释方向)</td></tr><tr><td>&#x2F;a</td><td>警告字符,打印可发出蜂鸣声</td></tr><tr><td>&#x2F;b</td><td>退格符</td></tr><tr><td>&#x2F;f</td><td>进纸符</td></tr><tr><td>&#x2F;n</td><td>换行</td></tr><tr><td>&#x2F;r</td><td>回车</td></tr><tr><td>&#x2F;t</td><td>水平制表符</td></tr><tr><td>&#x2F;t</td><td>水平制表符</td></tr><tr><td>&#x2F;v</td><td>垂直制表符</td></tr><tr><td>&#x2F;ddd</td><td>(d表示随机数字)表示1~3个八进制数字(系统可以将他解读为十进制 比如 &#x2F;130 系统可以将他解释为十进制的 88</td></tr><tr><td>&#x2F;xdd</td><td>(&#x2F;x是头,d是随机数字)表示1~2个十六进制数字</td></tr></tbody></table><hr><h1 id="5-关键字"><a href="#5-关键字" class="headerlink" title="5. 关键字"></a>5. 关键字</h1><hr><p><code>注意: define 和 include 并不是关键字 而是预处理指令</code></p><hr><h2 id="5-1-static"><a href="#5-1-static" class="headerlink" title="5.1 static"></a>5.1 static</h2><hr><blockquote><p><strong>static修饰局部变量,改变了局部变量的生命周期 ,本质上是改变了变量的存储类型(由栈区变为静态区)</strong><br><strong>static也会使其修饰的全局变量只能在自己所在的源文件内使用,其他源文件不能使用</strong></p></blockquote><p>如下:<br><img src="/img/1.10.png"></p><blockquote><p>全局变量在其他源文件内可以使用的原因是其具有<strong>外部链接属性</strong><br>但被static修饰后,就变成了<strong>内部链接属性</strong>,其他源文件就不能链接到这个静态的全局变量了<br><strong>static修饰函数</strong>时,也会使得函数只能在自己所在的源文件内部使用</p></blockquote><hr><h2 id="5-2-goto"><a href="#5-2-goto" class="headerlink" title="5.2 goto"></a>5.2 goto</h2><hr><blockquote><p>goto语句不能够跨越函数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   flag:</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">goto</span> flag; <span class="comment">//此时的flag会报错出&quot;未定义flag&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><hr><h1 id="6-随机数-时间戳-的生成"><a href="#6-随机数-时间戳-的生成" class="headerlink" title="6. 随机数(时间戳)的生成"></a>6. 随机数(时间戳)的生成</h1><hr><h2 id="6-1-rand-函数"><a href="#6-1-rand-函数" class="headerlink" title="6.1 rand 函数"></a>6.1 rand 函数</h2><p>rand函数的模型为</p><blockquote><p>#include&lt;stdilb.h&gt;<br>.<br> int rand(void);</p></blockquote><p>该函数可以生成 0~32767 的整形数</p><p><strong>但是,调用该数组生成的虽然确实是一个随机数,但是当你运行第二次时,这个随机数并没有发生变化</strong></p><p>第一次调用:<br><img src="/img/1.11.png"></p><p>第二次调用:<br><img src="/img/1.12.png"></p><p>我们引入另外一个函数</p><hr><h2 id="6-2-srand-函数"><a href="#6-2-srand-函数" class="headerlink" title="6.2 srand 函数"></a>6.2 srand 函数</h2><hr><blockquote><p>调用rand之前,我们需要调用srand来设置这个随机数的生成器</p></blockquote><p>其模型为</p><blockquote><p>#include&lt;stdlib.h&gt;<br>.<br>void srand(unsigned int seed);</p></blockquote><p>但是当我们调用这个函数后并放入一个 unsigned int 整形数后却发现</p><p><img src="/img/1.13.png"></p><p>较上次不一样了<br>调用第二次却发现,数字还是没有变化</p><p>再引入一个库函数</p><hr><h2 id="6-3-time函数"><a href="#6-3-time函数" class="headerlink" title="6.3 time函数"></a>6.3 time函数</h2><hr><blockquote><p>time函数会返回一个时间戳,返回的时间戳是:<br>调用这个函数的那个时间点和计算机的起始时间之间的时间戳</p></blockquote><p>其模型为:</p><blockquote><p>#include&lt;time.h&gt;<br>.<br>time_t time(time_t *timer);    &#x2F;&#x2F;time_t 本质上是一个整形</p></blockquote><p>而srand需要的类型是 unsigned int 类型,那么强制转换一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">  <span class="type">int</span> ret = rand(); <span class="comment">//ret 即是我们需要的随机数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="7-栈区存储习惯先高地址后低地址"><a href="#7-栈区存储习惯先高地址后低地址" class="headerlink" title="7. 栈区存储习惯先高地址后低地址"></a>7. 栈区存储习惯先高地址后低地址</h1><blockquote><p>栈区的存储习惯为<br>先使用高地址再使用低地址</p></blockquote><hr><h1 id="8-位操作符"><a href="#8-位操作符" class="headerlink" title="8. 位操作符"></a>8. 位操作符</h1><hr><h2 id="8-1-、-右移操作符和左移操作符"><a href="#8-1-、-右移操作符和左移操作符" class="headerlink" title="8.1 &gt;&gt;  、&lt;&lt;   (右移操作符和左移操作符)"></a>8.1 &gt;&gt;  、&lt;&lt;   (右移操作符和左移操作符)</h2><hr><blockquote><p> .&gt;&gt; 是数字向低位移动<br>.&lt;&lt; 是数字向高位移动</p></blockquote><p>注意:以下写法为错误且编译器无法处理的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = a &gt;&gt; <span class="number">-3</span> ; <span class="comment">//error</span></span><br></pre></td></tr></table></figure><hr><h2 id="8-2-按位与"><a href="#8-2-按位与" class="headerlink" title="8.2 &amp; (按位与)"></a>8.2 &amp; (按位与)</h2><hr><blockquote><p>有0为0<br>全1为1</p></blockquote><hr><h2 id="8-3-按位或"><a href="#8-3-按位或" class="headerlink" title="8.3 |  (按位或)"></a>8.3 |  (按位或)</h2><hr><blockquote><p>有1为1<br>全0为0</p></blockquote><hr><h2 id="8-4-按位异或"><a href="#8-4-按位异或" class="headerlink" title="8.4 ^ (按位异或)"></a>8.4 ^ (按位异或)</h2><hr><p>按位异或的规则是</p><blockquote><p>相同为0<br>相异为1</p></blockquote><hr><h2 id="8-5-按位取反"><a href="#8-5-按位取反" class="headerlink" title="8.5 ~ (按位取反)"></a>8.5 ~ (按位取反)</h2><blockquote><p>按位取反是对其补码进行处理</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
